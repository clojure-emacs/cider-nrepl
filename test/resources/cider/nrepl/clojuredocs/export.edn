{:clojure.test/do-report {:added "1.2", :ns "clojure.test", :name "do-report", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 351, :examples nil, :notes nil, :arglists ["m"], :doc "Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/do-report"}, :clojure.core/ns-unalias {:added "1.0", :ns "clojure.core", :name "ns-unalias", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/alias :clojure.core/ns-aliases :clojure.core/ns-unmap], :line 4247, :examples [";; You are having a problem loading a redefined namespace:\nuser=> (load \"src/clj/com/tizra/layout_expander.clj\")\n#<IllegalStateException java.lang.IllegalStateException: Alias xml already exists in namespace com.tizra.layout-expander, aliasing com.tizra.xml-match>\n\n;; ns-unalias to the rescue!\nuser=> (ns-unalias (find-ns 'com.tizra.layout-expander) 'xml)\nnil\n\nuser=> (load \"src/clj/com/tizra/layout_expander.clj\")\n#'com.tizra.layout-expander/junk\n" "user=> (ns-aliases *ns*)\n{}\nuser=> (alias 'string 'clojure.string)\nnil\nuser=> (ns-aliases *ns*)\n{string #<Namespace clojure.string>}\nuser=> (ns-unalias *ns* 'string)\nnil\nuser=> (ns-aliases *ns*)\n{}" ";; To wipe aliases of current namespace:\n*my-ns*=> (map (partial ns-unalias *ns*) (keys (ns-aliases *ns*)))"], :notes nil, :arglists ["ns sym"], :doc "Removes the alias for the symbol from the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-unalias"}, :clojure.core/number? {:added "1.0", :ns "clojure.core", :name "number?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/num :clojure.core/integer?], :line 3551, :examples ["user=> (number? 1)\ntrue\nuser=> (number? 1.0)\ntrue\nuser=> (number? :a)\nfalse\nuser=> (number? nil)\nfalse\nuser=> (number? \"23\")\nfalse\n\n" ";; map number? over the vector\n(map number? [1 0.44 3e6 0xFF])\n;;=> (true true true true)\n\n;; map number? over the vector created by converting a list into a vector \n;; with the function \"into\"\n(map number? (into [] '(1 0.44 3e6 0xFF)))\n;;=> (true true true true)\n\n"], :notes nil, :arglists ["x"], :doc "Returns true if x is a Number", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/number_q"}, :clojure.core/set? {:added "1.0", :ns "clojure.core", :name "set?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/set :clojure.core/map? :clojure.core/vector?], :line 4065, :examples ["user> (set? #{1 2 3})\ntrue\n\nuser> (set? (hash-set 1 2 3))\ntrue\n\nuser> (set? (sorted-set 1 2 3))\ntrue\n\nuser> (set? [1 2 3])\nfalse\n\nuser> (set? {:a 1 :b 2})\nfalse"], :notes nil, :arglists ["x"], :doc "Returns true if x implements IPersistentSet", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set_q"}, :clojure.reflect/flag-descriptors {:ns "clojure.reflect", :name "flag-descriptors", :file "clojure/reflect/java.clj", :type "var", :column 1, :see-alsos nil, :line 71, :examples ["(use 'clojure.reflect)\n\n(pprint clojure.reflect/flag-descriptors)\n;;=> [{:name :public, :flag 1, :contexts #{:method :field :class}}\n;;    {:name :private, :flag 2, :contexts #{:method :field :class}}\n;;    {:name :protected, :flag 4, :contexts #{:method :field :class}}\n;;    {:name :static, :flag 8, :contexts #{:method :field}}\n;;    {:name :final, :flag 16, :contexts #{:method :field :class}}\n;;    {:name :synchronized, :flag 32, :contexts #{:method}}\n;;    {:name :volatile, :flag 64, :contexts #{:field}}\n;;    {:name :bridge, :flag 64, :contexts #{:method}}\n;;    {:name :varargs, :flag 128, :contexts #{:method}}\n;;    {:name :transient, :flag 128, :contexts #{:field}}\n;;    {:name :native, :flag 256, :contexts #{:method}}\n;;    {:name :interface, :flag 512, :contexts #{:class}}\n;;    {:name :abstract, :flag 1024, :contexts #{:method :class}}\n;;    {:name :strict, :flag 2048, :contexts #{:method}}\n;;    {:name :synthetic, :flag 4096, :contexts #{:method :field :class}}\n;;    {:name :annotation, :flag 8192, :contexts #{:class}}\n;;    {:name :enum, :flag 16384, :contexts #{:field :inner :class}}]"], :notes ["The value of the `:flag` field for each modifier is identical to the value of the constant representing the modifier in [`java.lang.reflect.Modifier`](https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Modifier.html#field.summary), which in turn is taken from [Table 4.1-A](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1-200-E.1), [Table 4.5-A](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5-200-A.1), [Table 4.6-A](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6-200-A.1) and [Table 4.7.6-A](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6-300-D.1-D.1) of *The Java™ Virtual Machine Specification.*\n"], :arglists [], :doc "The Java access bitflags, along with their friendly names and\nthe kinds of objects to which they can apply.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/flag-descriptors"}, :clojure.core/reduced? {:added "1.5", :ns "clojure.core", :name "reduced?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduced :clojure.core/reduce :clojure.core/unreduced :clojure.core/ensure-reduced], :line 2834, :examples ["(reduced? :foo)\n;;=> false\n\n(reduced? (reduced :foo))\n;;=> true\n\n(reduced? (clojure.lang.Reduced. :foo))\n;;=> true"], :notes nil, :arglists ["x"], :doc "Returns true if x is the result of a call to reduced", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reduced_q"}, :clojure.core/int-array {:added "1.0", :ns "clojure.core", :name "int-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ints :clojure.core/aget :clojure.core/aset :clojure.core/aset-int], :line 5272, :examples [";; if you have a sequence, perhaps lazy, int-array will figure out the size\n(aget (int-array [1 2 3]) 0)\n;;=> 1\n(int-array [1 2 3])\n;;=> <int[] [i@263c8db9]>\n\n;; if you need a certain size, with a constant initial value\n(aget (int-array 5 1) 4)\n;;=> 1\n(alength (int-array 5))\n;;=> 5\n\n;; finally, you can specify a size + a sequence, which will initialize the array \n;; by taking size from the sequence\n(alength (int-array 5 (range 10)))\n;;=> 5\n;; which is equivalent to\n(alength (int-array (take 5 (range 10)))\n;;=> 5\n"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of ints", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/int-array"}, :clojure.core.async/do-alt {:ns "clojure.core.async", :name "do-alt", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 302, :examples nil, :notes nil, :arglists ["alts clauses"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/do-alt"}, :clojure.core/nthnext {:added "1.0", :ns "clojure.core", :name "nthnext", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/nth :clojure.core/drop :clojure.core/nthrest], :line 3156, :examples ["(nthnext (range 10) 3)\n;;=> (3 4 5 6 7 8 9)\n\n(nthnext [] 3)\n;;=> nil\n\n(nthnext [1 2 3 4 5 6 7] 4)\n;;=> (5 6 7)\n\n" ";; drop is also similar, but different \n(nthnext (range 10) 5)   ;;=> (5 6 7 8 9)\n(drop    5 (range 10))   ;;=> (5 6 7 8 9)\n\n;; here is a case where the results differ\n(nthnext [] 3)  ;;=> nil\n(drop    3 [])  ;;=> ()   ; a lazy sequence"], :notes ["`nthnext` is similar to `drop`.\r\nBut `nthnext` is <i>eager</i>, while `drop` is <i>lazy</i>.<p>\r\nAlso parameters are in opposite order."], :arglists ["coll n"], :doc "Returns the nth next of coll, (seq coll) when n is 0.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nthnext"}, :clojure.core.logic/copy-term {:ns "clojure.core.logic", :name "copy-term", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1439, :examples nil, :notes nil, :arglists ["u v"], :doc "Copies a term u into v. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/copy-term"}, :clojure.spec.alpha/map-of {:ns "clojure.spec.alpha", :name "map-of", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 571, :examples nil, :macro true, :notes nil, :arglists ["kpred vpred & opts"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/map-of"}, :clojure.core/create-struct {:added "1.0", :ns "clojure.core", :name "create-struct", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/struct :clojure.core/defstruct :clojure.core/defrecord], :line 4004, :examples [";;Creates a person structure\n(def person (create-struct :name :age))\n\n;;Creates a structure with the given values associated with the structure keys\n(struct person \"Brad Cypert\" 23)\n{:name \"Brad Cypert\", :age 23}"], :notes ["Structs are becoming obsolete. Use records instead. See defrecord."], :arglists ["& keys"], :doc "Returns a structure basis object.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/create-struct"}, :clojure.core.logic/nilo {:ns "clojure.core.logic", :name "nilo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1649, :examples nil, :notes nil, :arglists ["a"], :doc "A relation where a is nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/nilo"}, :clojure.core.logic/rem-dom {:ns "clojure.core.logic", :name "rem-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 494, :examples nil, :notes nil, :arglists ["s x dom" "s x dom seenset"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/rem-dom"}, :clojure.core/assoc {:added "1.0", :ns "clojure.core", :name "assoc", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc-in :clojure.core/dissoc :clojure.core/merge], :line 181, :examples ["(assoc {} :key1 \"value\" :key2 \"another value\")\n;;=> {:key2 \"another value\", :key1 \"value\"}\n\n;; Here we see an overwrite by a second entry with the same key\n(assoc {:key1 \"old value1\" :key2 \"value2\"} \n        :key1 \"value1\" :key3 \"value3\")\n;;=> {:key3 \"value3\", :key2 \"value2\", :key1 \"value1\"}\n\n;; We see a nil being treated as an empty map\n(assoc nil :key1 4)\n;;=> {:key1 4}\n\n;; 'assoc' can be used on a vector (but not a list), in this way: \n(assoc vec index replacement)\n\n(assoc [1 2 3] 0 10)     ;;=> [10 2 3]\n(assoc [1 2 3] 3 10)     ;;=> [1 2 3 10]\n(assoc [1 2 3] 2 '(4 6)) ;;=> [1 2 (4 6)]\n;; but if the index does not exist, it is not added automagically\n(assoc [1 2 3] 4 10)\n;; java.lang.IndexOutOfBoundsException (NO_SOURCE_FILE:0)\n\n;; From http://clojure-examples.appspot.com/clojure.core/assoc" ";; here is an example of updating a field in a map.\n(def test-map {:account-no 12345678 :lname \"Jones\" :fnam \"Fred\"})\n(assoc test-map :fnam \"Sue\")\n;;=> {:account-no 12345678, :lname \"Jones\", :fnam \"Sue\"}\n\n;; notice that test-map is unchanged\ntest-map\n;;=> {:account-no 12345678 :lname \"Jones\" :fnam \"Fred\"})" ";; beware of this\n(assoc {} nil nil)\n;;=> {nil nil}" ";;transform a map´s values using reduce and assoc\n\n(defn transform\n  [coll]\n  (reduce (fn [ncoll [k v]]\n            (assoc ncoll k (* 10 v)))\n          {}\n          coll))\n\n(transform {:a 1 :b 2 :c 3})\n;;{:a 10 :b 20 :c 30}\n" ";;assoc applied to a vector\n\n(def my-vec [1 2 5 6 8 9])\n\n(assoc my-vec 0 77)\n;;[77 2 5 6 8 9]\n" ";; convert a vector into a set with assoc\n\n(def book-city  {:awards [\"Hugo\" \"World Fantasy Award\" \"Arthur C. Clarke Award\"\n            \"British Science Fiction Award\"]\n   :title \"The City and the City\"\n   :authors [{:birth-year 1972, :name \"China Miéville\"}]})\n\n(assoc book-city :authors (set (:authors book-city)))\n\n;; {:awards [\"Hugo\" \"World Fantasy Award\" \"Arthur C. Clarke Award\" \"British Science Fiction Award\"], :title \"The City and the City\", :authors #{{:birth-year 1972, :name \"China Miéville\"}}}"], :notes ["Here is a version that will create a vector when the key is numerical.\r\nThis may be useful instead of throwing an IndexOutOfBoundsException.\r\n\r\n<pre>\r\n(defn assoc-in-idx [m [k & ks] v]\r\n  (let [value (get m k (when (number? (first ks)) []))\r\n\tm (if (and (vector? m) (number? k) (-> m count (< k)))\r\n\t    (reduce (fn [m _] (conj m nil)) m (range (count m) k))\r\n\t    m)\r\n\tv (if ks\r\n\t    (assoc-in-idx value ks v)\r\n\t    v)]\r\n    (assoc m k v)))\r\n</pre>\r\n" "the API is blurry When applied to a vector\r\n\r\n<pre>\r\n;; should indicate following\r\n(assoc vector index val) </pre>"], :arglists ["map key val" "map key val & kvs"], :doc "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/assoc"}, :clojure.core/comment {:added "1.0", :ns "clojure.core", :name "comment", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 4677, :examples [";; The commented forms do not get executed\nuser=> (comment\n         (functioncall-1)\n         (functioncall-2))\nnil" ";; What is inside the (comment ...) form is not completely ignored.  Clojure\n;; still tries to use the normal reader to read it, so it must consist of\n;; a sequence of readable forms with balanced parens, braces, square brackets,\n;; with no unreadable elements.\n\n;; If you want lines to be completely ignored, you must use a ; to comment from\n;; the ; until the end of the line.  If you want to quickly comment or uncomment\n;; a range of consecutive lines, most text editors have special commands\n;; specifically for that.  e.g. Emacs has comment-region\n;; http://www.gnu.org/software/emacs/manual/html_node/emacs/Comment-Commands.html\n;; Vim has visual commands to do this, and probably many other text editors.\n;; (Feel free to edit this text to add links to docs for other editors).\n\n;; What is inside the (commment ...) is readable, so no error for this,\n;; and no code will be generated by the compiler.\n(comment\n(defn foo [x]\n  (inc x))\n)\n\n;; What is inside the (comment ...) is NOT readable, so this will give an error\n(comment\na : b\n)" ";; Another thing to watch out for: the comment form IS a form, and is usually\n;; the wrong way to comment out code.  For example, let's say that you want to\n;; try out a new \"then\" form in an \"if\":\n(if true (comment :old-then) :new-then)  ;;=> nil (Oops, :new-then was desired.)\n\n;; Instead, use the \"ignore next form\" reader macro #_:\n(if true #_(:old-then) :new-then)  ;;=> :new-then\n\n;; Note that #_ also allows non-readable code:\n#_(a : b) 1  ;;=> 1 (contrast to (comment a : b) which doesn't compile.)\n"], :macro true, :notes ["it doesn't 100% ignore the body. If your comment has a map in it, for example, and that map isn't 100% correct it will fail to compile in some environments. I found that using Light Table. I am certain it would fail on other platforms that won't know to exclude it before parsing.\r\n\r\nExample:\r\n(comment\r\n here is some TeX: \\frac{\\sum_{m=1}^{m}x_{m}}{x_{s}}\r\n)\r\n\r\nThat will produce an error."], :arglists ["& body"], :doc "Ignores body, yields nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/comment"}, :clojure.core/*compile-files* {:added "1.0", :ns "clojure.core", :name "*compile-files*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "Set to true when compiling files, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*compile-files*"}, :clojure.repl/root-cause {:added "1.3", :ns "clojure.repl", :name "root-cause", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 215, :examples nil, :notes nil, :arglists ["t"], :doc "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/root-cause"}, :clojure.core.logic.pldb/rel-key {:ns "clojure.core.logic.pldb", :name "rel-key", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 23, :examples nil, :notes nil, :arglists ["rel"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/rel-key"}, :clojure.spec.alpha/with-gen* {:ns "clojure.spec.alpha", :name "with-gen*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec gfn"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/with-gen*"}, :clojure.core/unchecked-multiply {:added "1.0", :ns "clojure.core", :name "unchecked-multiply", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/* :clojure.core/*'], :line 1218, :examples [";; the unchecked-multiply function silently overflows\n\nuser=> (* 1000000000000 10)\n10000000000000\nuser=> (unchecked-multiply 1000000000000 10)\n10000000000000\n\nuser=> (* 3037000500 3037000500)\nArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1424)\nuser=> (unchecked-multiply 3037000500 3037000500)\n-9223372036709301616\n\n"], :notes nil, :arglists ["x y"], :doc "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-multiply"}, :clojure.core/chunk-next {:ns "clojure.core", :name "chunk-next", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-first :clojure.core/chunk-rest :clojure.core/chunk-cons :clojure.core/chunk-buffer :clojure.core/chunk :clojure.core/chunk-append :clojure.core/chunked-seq?], :line 699, :examples ["(let [chunked-cons (seq (range 1 42))]\n\n  (class chunked-cons)\n  ;; => clojure.lang.ChunkedCons\n\n  ;; Returns the next chunk when there are more than 32 elements\n  ;; in the ChunkedCons.\n  (chunk-next chunked-cons)\n  ;; => (33 34 35 36 37 38 39 40 41)\n\n)"], :notes nil, :tag "clojure.lang.ISeq", :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-next"}, :clojure.core.async/put! {:ns "clojure.core.async", :name "put!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/take! :clojure.core.async/>! :clojure.core.async/>!!], :line 157, :examples ["user=> (def c (chan 1))\n#'user/c\n\nuser=> (take! c\n              (fn [x]\n                (println \"Clojure callback value \" x)))\nnil\n\nuser=> (put! c \"XYZ\") ; return true unless the channel is closed.\nClojure callback value  XYZ\ntrue\n\nuser=> (put! c \"XYZ\")\ntrue\n"], :notes ["The documentation here is somewhat out of date, the real documentation for more recent versions of core.async (0.1.346.0-17112a-alpha, at the time of this note) removes the bit about throwing when the channel is closed.  \n\nInstead, put! returns true unless the port is already closed, in which case false is returned.\n\nAn exception *is* thrown is you attempt to put! nil."], :arglists ["port val" "port val fn1" "port val fn1 on-caller?"], :doc "Asynchronously puts a val into port, calling fn1 (if supplied) when\n   complete, passing false iff port is already closed. nil values are\n   not allowed. If on-caller? (default true) is true, and the put is\n   immediately accepted, will call fn1 on calling thread.  Returns\n   true unless port is already closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/put!"}, :clojure.core/deftype {:added "1.2", :ns "clojure.core", :name "deftype", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/definterface :clojure.core/defprotocol :clojure.core/defrecord], :line 422, :examples ["user=> (import (java.awt.datatransfer Transferable DataFlavor)\n               javax.swing.ImageIcon)\n\n;; create a Transferable Image from an array of bytes\nuser=> (deftype ImageSelection [data]\n         Transferable\n         (getTransferDataFlavors\n          [this]\n          (into-array DataFlavor [DataFlavor/imageFlavor]))\n        \n         (isDataFlavorSupported\n          [this flavor]\n          (= DataFlavor/imageFlavor flavor))\n\n         (getTransferData\n          [this flavor]\n          (when (= DataFlavor/imageFlavor flavor)\n            (.getImage (ImageIcon. data)))))\n\n;; create a new image selection:\nuser=> (def *selection* (ImageSelection. somedata))" ";; define a couple of shape types\n(deftype Circle [radius])\n(deftype Square [length width])\n\n;; multimethod to calculate the area of a shape\n(defmulti area class)\n(defmethod area Circle [c]\n    (* Math/PI (* (.radius c) (.radius c))))\n(defmethod area Square [s]\n    (* (.length s) (.width s)))\n\n;; create a couple shapes and get their area\n(def myCircle (Circle. 10))\n(def mySquare (Square. 5 11))\n\n(area myCircle)\n(area mySquare)" "(deftype Person [first-name last-name])\n\n;; use the factory function instead of the constructor, \"Person.\",\n;; to create a Person\n(->Person \"John\" \"Smith\")" ";; How :load-ns works.\n;; deftype can be used for AOT generation of classes (with gen-class that would be\n;; the only option). For example:\n\n(spit \"foo.clj\"\n  \"(ns foo)\n   (defn bar [] :bar)\n   (defprotocol P (foo [p]))\n   (deftype Foo [] :load-ns true P\n     (foo [this] (bar)))\")\n\n(binding [*compile-path* \".\"] (compile 'foo))\n\n;; Now close and re-open the REPL to import the newly created class. Note that the\n;; call to (.foo p) doesn't throw exception here because we used \":load-ns true\"\n;; option in deftype. This makes sure that the namespace 'foo is also loaded \n;; forcing the evaluation of the \"bar\" function. This makes especially sense\n;; if Foo is used from a Java application:\n\n(import 'foo.Foo)\n(def p (Foo.))\n(.foo p)\n;; \"bar\""], :macro true, :notes ["There's also some undocumented support for annotations:\r\n\r\n<https://groups.google.com/group/clojure/browse_thread/thread/d2128e1505c0c117?pli=1>"], :arglists ["name [& fields] & opts+specs"], :doc "(deftype name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the type class will cause the\n             namespace in which the type was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta, __extmap, __hash and __hasheq are currently\n  reserved and should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/deftype"}, :clojure.core/some->> {:added "1.5", :ns "clojure.core", :name "some->>", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/->> :clojure.core/some->], :line 7518, :examples [";; an example of looking up a value from a\n;; map and performing an operation(addition)\n;; on it if it exists\nuser=> (some->> {:y 3 :x 5}\n                 (:y)\n                 (- 2))\n\n-1\n\n\n;; if we were to look up a value which\n;; doesn't exist, it will safely short-circuit\nuser=> (some->> {:y 3 :x 5}\n                (:z)\n                (- 2))\n\nnil\n"], :macro true, :notes nil, :arglists ["expr & forms"], :doc "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/some->>"}, :clojure.core.logic/defnm {:ns "clojure.core.logic", :name "defnm", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1639, :examples nil, :macro true, :notes nil, :arglists ["t n & rest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/defnm"}, :clojure.core/error-mode {:added "1.2", :ns "clojure.core", :name "error-mode", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 2221, :examples nil, :notes nil, :arglists ["a"], :doc "Returns the error-mode of agent a.  See set-error-mode!", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/error-mode"}, :clojure.core.logic/add-dom {:ns "clojure.core.logic", :name "add-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 467, :examples nil, :notes nil, :arglists ["s x dom domv" "s x dom domv seenset"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/add-dom"}, :clojure.core.logic/update-eset {:ns "clojure.core.logic", :name "update-eset", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 572, :examples nil, :notes nil, :arglists ["s doms eset"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/update-eset"}, :clojure.core/completing {:added "1.7", :ns "clojure.core", :name "completing", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/transduce], :line 6778, :examples [";; Fix apparently inconsistent behaviour of - with transduce:\n(transduce (map inc) - 0 (range 10))\n;; 55\n(transduce (map inc) (completing -) 0 (range 10))\n;; -55" ";; the reducing fn arity-1 executes the last transformation in transduce.\n;; completing defaults to \"identity\" but you can change it.\n;; Use this fact for example with transients and go back to persistent once done.\n(require '[clojure.string :refer [lower-case]])\n(transduce\n (comp\n  (remove nil?)\n  (map lower-case))\n (completing #(assoc! %1 %2 (inc (get %1 %2 0))) persistent!)\n (transient {})\n [\"hi\" \"ho\" \"Hello\" \"hoi\" \"Hi\" \"Ha\" \"ha\" \"hello\"])\n;; {\"hi\" 2, \"ho\" 1, \"hello\" 2, \"hoi\" 1, \"ha\" 2}"], :notes nil, :arglists ["f" "f cf"], :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/completing"}, :clojure.core/rseq {:added "1.0", :ns "clojure.core", :name "rseq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/reverse], :line 1573, :examples ["user=> (vec (range 10))\n[0 1 2 3 4 5 6 7 8 9]\n\nuser=> (rseq (vec (range 10)))\n(9 8 7 6 5 4 3 2 1 0)\n" "(rseq (into (sorted-map) {:a 1 :b 2}))\n;; => ([:b 2] [:a 1])"], :notes nil, :arglists ["rev"], :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rseq"}, :clojure.core/supers {:added "1.0", :ns "clojure.core", :name "supers", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/type :clojure.core/instance? :clojure.core/bases :clojure.core/ancestors], :line 5493, :examples [";;find superclasses and interfaces of Java objects...\nuser> (supers Object)\nnil\n\nuser> (supers String)\n#{java.lang.Comparable java.lang.CharSequence java.io.Serializable java.lang.Object}\n\n;;...or Java interfaces\nuser> (supers javax.naming.Name)\n#{java.lang.Cloneable java.lang.Comparable java.io.Serializable}\n\n;;Also with clojure types...\nuser> (defrecord MyThing [a b c])\nuser.MyThing\n\nuser> (supers MyThing)\n#{clojure.lang.Counted java.lang.Iterable clojure.lang.IKeywordLookup clojure.lang.IObj clojure.lang.IPersistentMap clojure.lang.Associative clojure.lang.Seqable java.util.Map clojure.lang.IMeta java.io.Serializable java.lang.Object clojure.lang.IPersistentCollection clojure.lang.ILookup}\n"], :notes nil, :arglists ["class"], :doc "Returns the immediate and indirect superclasses and interfaces of c, if any", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/supers"}, :clojure.core.logic/disunify {:ns "clojure.core.logic", :name "disunify", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2290, :examples nil, :notes nil, :arglists ["s u v" "s u v cs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/disunify"}, :clojure.spec.alpha/spec? {:ns "clojure.spec.alpha", :name "spec?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 72, :examples nil, :notes nil, :arglists ["x"], :doc "returns x if x is a spec object, else logical false", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/spec_q"}, :clojure.core.logic/conso {:ns "clojure.core.logic", :name "conso", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1659, :examples nil, :notes nil, :arglists ["a d l"], :doc "A relation where l is a collection, such that a is the first of l\n  and d is the rest of l. If ground d must be bound to a proper tail.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/conso"}, :clojure.core/*agent* {:added "1.0", :ns "clojure.core", :name "*agent*", :type "var", :see-alsos [:clojure.core/agent], :examples [";; *agent* is often used with send or send-off to set up a repeated\n;; transformation of an agent's value. For example, to repeatedly \n;; increment the integer value of an agent 'myagent' until some \n;; flag value 'running' evaluates to false:\n\n;; Create an agent set to an initial value of 0:\n(def myagent (agent 0))\n\n;; Define a variable to act as a boolean flag:\n(def running true)\n\n;; Define a function to increment agent value repeatedly:\n(defn inc-while-running [agent-value]\n  (when running\n    (send-off *agent* inc-while-running)) ;sets up another call\n  (inc agent-value))\n\n;; Dereference myagent to confirm it is set to value 0:\nuser=> @myagent\n0\n\n;; Start the fun:\nuser=> (send-off myagent inc-while-running)\n#&lt;Agent@5fb9f88b: 20&gt;\n\n;; The agent has already been incremented many times (20 when I ran this)\n;; by the time the REPL prints.\n\n;; Redefine running as false to stop repeated send-off:\n(def running false)\n\n;; Dereference myagent to find its new value:\nuser=> @myagent\n848167\n\n;; Dereference again to make sure incrementation has stopped:\nuser=> @myagent\n848167"], :notes nil, :tag "clojure.lang.Agent", :arglists [], :doc "The agent currently running an action on this thread, else nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*agent*"}, :clojure.core/tagged-literal? {:added "1.7", :ns "clojure.core", :name "tagged-literal?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7639, :examples nil, :notes nil, :arglists ["value"], :doc "Return true if the value is the data representation of a tagged literal", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/tagged-literal_q"}, :clojure.java.javadoc/javadoc {:added "1.2", :ns "clojure.java.javadoc", :name "javadoc", :file "clojure/java/javadoc.clj", :type "function", :column 1, :see-alsos [:clojure.repl/doc], :line 76, :examples ["user=> (use 'clojure.java.javadoc)\nnil\n\nuser=> (javadoc String)\n\"http://java.sun.com/javase/6/docs/api/java/lang/String.html\"\n\nuser=> (javadoc (java.util.Date.))\n\"http://java.sun.com/javase/6/docs/api/java/util/Date.html\"\n" "user> (javadoc 1)\n\"http://java.sun.com/javase/7/docs/api/java/lang/Long.html\"\n\n(javadoc \"abc\")\n\"http://java.sun.com/javase/7/docs/api/java/lang/String.html\"" "user> (javadoc org.joda.time.DateTime)\n\"http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&q=allinurl:org/joda/time/DateTime.html\""], :notes nil, :arglists ["class-or-object"], :doc "Opens a browser window displaying the javadoc for the argument.\n  Tries *local-javadocs* first, then *remote-javadocs*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/javadoc"}, :clojure.main/main {:ns "clojure.main", :name "main", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 387, :examples ["java -cp clojure-1.6.0.jar clojure.main hey.clj"], :notes nil, :arglists ["& args"], :doc "Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \"Clojure ~(clojure-version)\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/main"}, :clojure.core/unchecked-inc {:added "1.0", :ns "clojure.core", :name "unchecked-inc", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-add :clojure.core/unchecked-dec :clojure.core/unchecked-inc :clojure.core/unchecked-negate :clojure.core/unchecked-divide :clojure.core/unchecked-subtract :clojure.core/unchecked-multiply :clojure.core/unchecked-remainder :clojure.core/inc :clojure.core/inc'], :line 1148, :examples ["users=> (unchecked-inc Integer/MAX_VALUE)\n-2147483648\n\nusers=> (unchecked-inc 0)\n1" ";; Illustrates the difference between (inc), (inc') and (unchecked-inc)\n\n;; The \"N\" suffix denotes a BigInt instance\n;; https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/BigInt.java\n\nLong/MAX_VALUE\n;;=> 9223372036854775807\n\n(inc Long/MAX_VALUE)\n;;=> ArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1501)\n\n(inc' Long/MAX_VALUE)\n;;=> 9223372036854775808N\n\n;; Notice how the resulting number becomes NEGATIVE:\n(unchecked-inc Long/MAX_VALUE)\n;;=> -9223372036854775808"], :notes nil, :arglists ["x"], :doc "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-inc"}, :clojure.core.logic.fd/list-sorted? {:ns "clojure.core.logic.fd", :name "list-sorted?", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1031, :examples nil, :notes nil, :arglists ["pred ls"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/list-sorted_q"}, :clojure.pprint/print-length-loop {:added "1.3", :ns "clojure.pprint", :name "print-length-loop", :file "clojure/pprint/pprint_base.clj", :type "macro", :column 1, :see-alsos nil, :line 391, :examples nil, :macro true, :notes nil, :arglists ["bindings & body"], :doc "A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/print-length-loop"}, :clojure.test/run-tests {:added "1.1", :ns "clojure.test", :name "run-tests", :file "clojure/test.clj", :type "function", :column 1, :see-alsos [:clojure.test/run-all-tests], :line 767, :examples [";; assuming current namespace is user\n(use 'clojure.test)\n(deftest eg-tests (is (= 1 1)))\n(run-tests)\n;;=> Testing user\n;;=> Ran 1 tests containing 1 assertions.\n;;=> 0 failures, 0 errors.\n;;=> {:type :summary, :fail 0, :error 0, :pass 1, :test 1}\n\n(run-tests 'user)  ; if supplying a namespace to test, must quote\n;;=> Testing user\n;;=> Ran 1 tests containing 1 assertions.\n;;=> 0 failures, 0 errors.\n;;=> {:type :summary, :fail 0, :error 0, :pass 1, :test 1}"], :notes nil, :arglists ["" "& namespaces"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/run-tests"}, :clojure.core/finally {:ns "clojure.core", :name "finally", :type "var", :see-alsos [:clojure.core/try :clojure.core/catch :clojure.core/ex-data :clojure.core/throw], :examples ["(try\n  (/ 1 0)\n  (catch ArithmeticException e (str \"caught exception: \" (.getMessage e)))\n  (finally (prn \"final exception.\")))\n\"final exception.\"\n\"caught exception: Divide by zero\""], :notes nil, :arglists [], :doc "The exprs are evaluated and, if no exceptions occur, the value of the last\nis returned. If an exception occurs and catch clauses are provided, each is\nexamined in turn and the first for which the thrown exception is an instance\nof the named class is considered a matching catch clause. If there is a\nmatching catch clause, its exprs are evaluated in a context in which name is\nbound to the thrown exception, and the value of the last is the return value\nof the function. If there is no matching catch clause, the exception\npropagates out of the function. Before returning, normally or abnormally,\nany finally exprs will be evaluated for their side effects. See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/finally"}, :clojure.core/double-array {:added "1.0", :ns "clojure.core", :name "double-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/doubles :clojure.core/aget :clojure.core/aset :clojure.core/aset-double], :line 5257, :examples [";; create a double array using double-array\n;; and show it can be used with the standard Java functions\n;; binarySearch and fill\n\nuser=> (def ds (double-array (range 3 20)))\n#'user/ds\nuser=> (type ds)\n[D\nuser=> (vec ds)\n[3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0]\nuser=> (java.util.Arrays/binarySearch ds 10.0)\n7\nuser=> (java.util.Arrays/fill ds 3 8 99.0)\nnil\nuser=> (vec ds)\n[3.0 4.0 5.0 99.0 99.0 99.0 99.0 99.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19\n.0]\nuser=>"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of doubles", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/double-array"}, :clojure.core/sorted-map-by {:added "1.0", :ns "clojure.core", :name "sorted-map-by", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-map :clojure.core/subseq :clojure.core/rsubseq :clojure.core/sorted-set-by :clojure.core/compare :clojure.core/comparator], :line 407, :examples ["; The basic function requires discrete elements, and cannot accept a \n; pre-existing map:\nuser=> (sorted-map-by > 1 \"a\", 2 \"b\", 3 \"c\")\n{3 \"c\", 2 \"b\", 1 \"a\"}\n\n; We can use the syntax \"(sorted-map >)\" to create an empty sorted map that sorts \n; in reverse order (i.e. the opposite of \"(sorted-map)\").  It we can then fill\n; it using (into ...) with a pre-existing map:\nuser=> (into (sorted-map-by >)  {1 :a  2 :b  3 :c} )\n{3 :c, 2 :b, 1 :a}\n\n; This two are the same\nuser=> (into (sorted-map-by <)  {1 :a  2 :b  3 :c} )\n{1 :a, 2 :b, 3 :c}\nuser=> (into (sorted-map)  {1 :a  2 :b  3 :c} )\n{1 :a, 2 :b, 3 :c}\n\n" ";; If you wish to sort the map according to the values, instead of by keys \n;; the following code WILL NOT WORK! This is because the map values are not unique.\n\nuser=> (let [results {:A 1 :B 2 :C 2 :D 5 :E 1 :F 1}]\n  (into (sorted-map-by (fn [key1 key2]\n                         (compare (get results key2)\n                                  (get results key1))))\n        results))\n\n=> {:D 5, :C 2, :A 1}\n\n;; To make sure that the sorting works, we can make sure that the comparator \n;; works on unique values\n\nuser=> (let [results {:A 1 :B 2 :C 2 :D 5 :E 1 :F 1}]\n  (into (sorted-map-by (fn [key1 key2]\n                         (compare [(get results key2) key2]\n                                  [(get results key1) key1])))\n        results))\n\n=> {:D 5, :C 2, :B 2, :F 1, :E 1, :A 1}"], :notes ["an unstable sorting function will give nonsense results:\n\n<pre>\nuser=> (into (sorted-map-by (fn [_ _] (rand-int Integer/MAX_VALUE))) [[:a 0] [:a 1] [:a 2]])\n\n{:a 0, :a 1, :a 2}\n<pre/>"], :arglists ["comparator & keyvals"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sorted-map-by"}, :clojure.core/make-array {:added "1.0", :ns "clojure.core", :name "make-array", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/int-array :clojure.core/double-array :clojure.core/float-array :clojure.core/short-array :clojure.core/long-array :clojure.core/char-array :clojure.core/byte-array :clojure.core/boolean-array :clojure.core/object-array :clojure.core/to-array :clojure.core/to-array-2d :clojure.core/into-array :clojure.core/aget :clojure.core/aset :clojure.core/alength :clojure.core/amap :clojure.core/areduce], :line 3952, :examples ["(make-array Integer/TYPE 3)\n\n; Types are defined in clojure/genclass.clj:\n;    Boolean/TYPE\n;    Character/TYPE\n;    Byte/TYPE\n;    Short/TYPE\n;    Integer/TYPE\n;    Long/TYPE\n;    Float/TYPE\n;    Double/TYPE\n;    Void/TYPE" "user=> (pprint (make-array Double/TYPE 3))\n[0.0, 0.0, 0.0]\n\nuser=> (pprint (make-array Integer/TYPE 2 3))\n[[0, 0, 0], [0, 0, 0]]\n\n\n;; Create an array of Threads, then show content and type\nuser=> (def ar (make-array Thread 3))\n#'user/ar\n\nuser=> (pprint ar)\n[nil, nil, nil]\n\nuser=> (type ar)\n[Ljava.lang.Thread;\n"], :notes nil, :arglists ["type len" "type dim & more-dims"], :doc "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/make-array"}, :clojure.core.logic/sort-by-strategy {:ns "clojure.core.logic", :name "sort-by-strategy", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2223, :examples nil, :notes nil, :arglists ["v x a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/sort-by-strategy"}, :clojure.core.logic/ifu* {:ns "clojure.core.logic", :name "ifu*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1369, :examples nil, :macro true, :notes nil, :arglists ["" "[e & gs] & grest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ifu*"}, :clojure.core.async/admix* {:ns "clojure.core.async", :name "admix*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m ch"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/admix*"}, :clojure.core/boolean {:added "1.0", :ns "clojure.core", :name "boolean", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/boolean?], :line 1597, :examples [";; Everything except `false' and `nil' is true in boolean context.\nuser=> (into {} (map #(vector % (boolean %)) [true false nil [] {} '() #{} \"\"]))\n{true true, false false, nil false, [] true, {} true, #{} true, \"\" true}\n\nuser=> (clojure.pprint/pp)\n{true true,\n false false,\n nil false,\n [] true,\n {} true,\n #{} true,\n \"\" true}\nnil\n\n;; Unrelated to `boolean`, but notice that the `'()` entry is missing. This\n;; due to Clojure treating `[]` and `'()` as equal. When combined into the map \n;; the `'() => true` key-value pair is overwritten by the `[] => true` key-value\n;; pair. See https://github.com/zk/clojuredocs/issues/114#issuecomment-132153637\n" ";; Beware that boolean returns true for numbers 0 and 1\nuser=> (boolean 0)\ntrue\nuser=> (boolean 1)\ntrue" ";; Simply defined: Everything except false and nil is logically true in Clojure." ";; Corrected definition:\n;; returns `false' for `false', `nil' and `(Boolean. false)`.\n;; returns `true' for everything else.\n"], :notes nil, :arglists ["x"], :doc "Coerce to boolean", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/boolean"}, :clojure.core/*print-namespace-maps* {:added "1.9", :ns "clojure.core", :name "*print-namespace-maps*", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 41, :examples [";; In a REPL:\n\n(prn {:num/val 1 :num/name \"one\"})\n;; #:num{:val 1, :name \"one\"}\n;;=> nil\n\n(binding [*print-namespace-maps* false] \n  (prn {:num/val 1 :num/name \"one\"}))\n;; {:num/val 1, :num/name \"one\"}\n;;=> nil\n"], :notes nil, :arglists [], :doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax. It defaults to false, but the REPL binds\n  to true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-namespace-maps*"}, :clojure.spec.alpha/*explain-out* {:ns "clojure.spec.alpha", :name "*explain-out*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 239, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*explain-out*"}, :clojure.core.logic.fd/->IntervalFD {:ns "clojure.core.logic.fd", :name "->IntervalFD", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 231, :examples nil, :notes nil, :arglists ["lb ub"], :doc "Positional factory function for class clojure.core.logic.fd.IntervalFD.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/->IntervalFD"}, :clojure.core/re-groups {:added "1.0", :ns "clojure.core", :name "re-groups", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-find :clojure.core/re-matcher], :line 4798, :examples ["user=> (def phone-number \"672-345-456-3212\")\n#'user/phone-number\n\nuser=> (def matcher (re-matcher #\"((\\d+)-(\\d+))\" phone-number))\n#'user/matcher\n\nuser=> (re-find matcher)\n[\"672-345\" \"672-345\" \"672\" \"345\"]\n\n;; re-groups gets the most recent find or matches\nuser=> (re-groups matcher)\n[\"672-345\" \"672-345\" \"672\" \"345\"]\nuser=> (re-groups matcher)\n[\"672-345\" \"672-345\" \"672\" \"345\"]\n\n\nuser=> (re-find matcher)\n[\"456-3212\" \"456-3212\" \"456\" \"3212\"]\n\nuser=> (re-groups matcher)\n[\"456-3212\" \"456-3212\" \"456\" \"3212\"]\nuser=> (re-groups matcher)\n[\"456-3212\" \"456-3212\" \"456\" \"3212\"]\n\n\nuser=> (re-find matcher)\nnil\n\nuser=> (re-groups matcher)\nIllegalStateException No match found  java.util.regex.Matcher.group (Matcher.java:468)" ";;given a string to match\nuser=> (def flight \"AF-22-CDG-JFK-2017-09-08\")\n#'User/flight\n;; groups and give a name to matches\nuser=> (def flight-regex #\"(?<airlineCode>[A-Z0-9]+)-(?<flightNumber>[0-9]+[A-Z]?)-(?<from>[A-Z]+)-(?<to>[A-Z]+)-(?<year>[0-9]+)-(?<month>[0-9]+)-(?<day>[0-9]+)\")\n#'user/flight-regex\nuser=> (def matcher (re-matcher flight-regex flight))\n#'user/matcher\n;; it allows good grasp of meaning and understanding of the data extraction from the regex\nuser=> (if (.matches matcher)\n           {:airline-code (.group matcher \"airlineCode\") \n            :flight-number (.group matcher \"flightNumber\") \n            :from (.group matcher \"from\") \n            :to (.group matcher \"to\") \n            :year (.group matcher \"year\") \n            :month (.group matcher \"month\") \n            :day (.group matcher \"day\")}\n           (throw (ex-info (str \"Can't extract detailed value from flight\"))))\n{:airline-code \"AF\", :flight-number \"22\", :from \"CDG\", :to \"JFK\", :year \"2017\", :month \"09\", :day \"08\"}\nuser=>\n;;Beware that groups are available in Java Regex not in Javascript ones..."], :notes nil, :arglists ["m"], :doc "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-groups"}, :clojure.core.logic/tree-term? {:ns "clojure.core.logic", :name "tree-term?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 884, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/tree-term_q"}, :clojure.core/bit-shift-left {:added "1.0", :ns "clojure.core", :name "bit-shift-left", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-shift-left :clojure.core/unsigned-bit-shift-right :clojure.core/bit-shift-right], :line 1348, :examples ["<pre>user=> (bit-shift-left 1 10)\n1024\n</pre>\n\n<pre>user=> (bit-shift-left 2r1101 2) ; fill rightmost bits with 0s\n52 \n;; 52 = 2r110100\n</pre>\n" ";;a bogus bit-array implementation\n\n(def ba (atom (long 0)))\n\n(defn set-ba \n\"sets bit n in long atom ba\"\n  [n]\n  (let [number-set (bit-shift-left 1 n)\n\t_ (println \"number to set: \" number-set)\n\tnew-array (bit-or @ba number-set)]\n    (reset! ba new-array)))\n\n(defn get-ba \n\"gets bit n in long atom ba\"\n[n]\n  (not (zero? (bit-and (bit-shift-left 1 n) @ba))))\n\n(comment\n  (set-ba 0) ;; 0 [....0001]\n  (set-ba 3) ;; 2^3 = 8  [....1001]\n  (get-ba 0) ;; (bit-and ba 2^0) = 1\n  (get-ba 1) ;; (bit-and ba 2^1) = 0\n  (get-ba 3) ;; (bit-and ba 2^3) = 1\n  ;;but:\n  (set-ba 65) ;; [....1011]\n  ;;number to set:  2\n  ;;modulo because long has only 64 bit\n  ;;also note that long always is two-complemented (signed) in java implementation\n  )"], :notes nil, :arglists ["x n"], :doc "Bitwise shift left", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-shift-left"}, :clojure.walk/postwalk-demo {:added "1.1", :ns "clojure.walk", :name "postwalk-demo", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/postwalk :clojure.walk/postwalk-replace], :line 79, :examples ["(use 'clojure.walk)\n\nuser> (postwalk-demo [[1 2] [3 4 [5 6]] [7 8]])\nWalked: 1\nWalked: 2\nWalked: [1 2]\nWalked: 3\nWalked: 4\nWalked: 5\nWalked: 6\nWalked: [5 6]\nWalked: [3 4 [5 6]]\nWalked: 7\nWalked: 8\nWalked: [7 8]\nWalked: [[1 2] [3 4 [5 6]] [7 8]]\n[[1 2] [3 4 [5 6]] [7 8]]\n\nuser> (postwalk-demo {:a 1 :b 2})\nWalked: :a\nWalked: 1\nWalked: [:a 1]\nWalked: :b\nWalked: 2\nWalked: [:b 2]\nWalked: {:a 1, :b 2}\n{:a 1, :b 2}"], :notes nil, :arglists ["form"], :doc "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/postwalk-demo"}, :clojure.core.logic/master {:ns "clojure.core.logic", :name "master", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1976, :examples nil, :notes nil, :arglists ["argv cache"], :doc "Take the argument to the goal and check that we don't\n   have an alpha equivalent cached answer term in the cache.\n   If it doesn't already exist in the cache add the new\n   answer term.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/master"}, :clojure.test/with-test {:added "1.1", :ns "clojure.test", :name "with-test", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.core/test :clojure.core/meta :clojure.test/deftest], :line 608, :examples [";with test is the same as using {:test #((is...)(is...))} in the meta data of the function.\n\n(:use 'clojure.test)\n\n(with-test\n    (defn my-function [x y]\n      (+ x y))\n  (is (= 4 (my-function 2 2)))\n  (is (= 7 (my-function 3 4))))\n\n(test #'my-function)            ;(test (var my-function))\n=> :ok"], :macro true, :notes nil, :arglists ["definition & body"], :doc "Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/with-test"}, :clojure.spec.alpha/describe {:ns "clojure.spec.alpha", :name "describe", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 184, :examples nil, :notes nil, :arglists ["spec"], :doc "returns an abbreviated description of the spec as data", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/describe"}, :clojure.core/bytes {:added "1.1", :ns "clojure.core", :name "bytes", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/byte-array], :line 5293, :examples [";; for fast interop\n(bytes (byte-array (map (comp byte int) \"ascii\")))\n;=> #<byte[] [B@7a004f62>\n(def the-bytes *1)\n;=> #'user/the-bytes\n(defn get-byte [the-bytes i] (aget the-bytes i))\n;=> #'user/get-byte Reflection warning, NO_SOURCE_PATH:1 - call to aget can't be resolved.\n\n(defn get-byte [the-bytes i] \n   (let [the-bytes (bytes the-bytes)] \n      (aget the-bytes i)))\n;=> #'user/get-byte\n(get-byte the-bytes 0)\n;=> 97\n"], :notes ["Why is the `(comp byte int)` required in the example? This seems to work just as well:\r\n\r\n<pre>\r\nuser=> (def b (bytes (byte-array (map byte \"ascii\"))))\r\nuser=> (String. b)\r\n\"ascii\"\r\n</pre>" "For that matter, why is the `bytes` needed? Consider:\r\n\r\n<pre>\r\nuser=> (String. (byte-array (map byte \"ascii\")))\r\n\"ascii\"\r\n</pre>\r\n" "AFAIK, `bytes` is used for referring to `bytes[].class` from JAVA\r\n\r\nExample (midje):\r\n\r\n     (fact (class (.getBytes \"test\")) => bytes) ; true\r\n"], :arglists ["xs"], :doc "Casts to bytes[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bytes"}, :clojure.core/future-call {:added "1.1", :ns "clojure.core", :name "future-call", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/future], :line 6883, :examples [";; future-call is used to implement 'future'.  See examples for 'future'\n;; for discussion of an undesirable 1-minute wait that can occur before\n;; your standalone Clojure program exits if you do not use shutdown-agents."], :notes ["`future-call` will also preserve the calling thread's dynamic bindings in the thread that executes f."], :arglists ["f"], :doc "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future-call"}, :clojure.core/resultset-seq {:added "1.0", :ns "clojure.core", :name "resultset-seq", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5642, :examples [";; To run this you need [mysql/mysql-connector-java \"5.1.x\"] dependency \n;; in the classpath and a running MySql instance. The statement is set\n;; to enable streaming and go fully lazy with restultset-seq.\n;; \"f\" is expected to produce the required results *before* exiting \n;; the try-finally block that closes the connection.\n\n(import '[java.sql DriverManager ResultSet])\n\n(defn with-mysql-query [url query f]\n  (Class/forName \"com.mysql.jdbc.Driver\")\n  (let [db url\n        conn (DriverManager/getConnection db)\n        stmt (doto\n               (.createStatement conn\n                 ResultSet/TYPE_FORWARD_ONLY\n                 ResultSet/CONCUR_READ_ONLY)\n               (.setFetchSize Integer/MIN_VALUE))\n        rs (.executeQuery stmt query)]\n    (try\n      (f (resultset-seq rs))\n      (finally\n        (.close stmt)\n        (.close conn)))))\n\n(with-mysql-query\n  \"jdbc:mysql://localhost/mysql?user=root&password=\"\n  \"SELECT * FROM user\"\n  (comp count keys first))\n\n;; 45\n"], :notes nil, :arglists ["rs"], :doc "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/resultset-seq"}, :clojure.core/refer-clojure {:added "1.0", :ns "clojure.core", :name "refer-clojure", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/refer], :line 5762, :examples [";; Prevent namespace conflicts like:\n\n;; `WARNING: time already refers to: #'clojure.core/time in namespace: \n;; time, being replaced by: #'time/time`\n\nuser=> (ns time\n         (:refer-clojure :exclude [time]))\n\n(defn time []\n  (System/nanoTime))\n" ";; Copied from https://gist.github.com/jkk/284230 (ns-cheatsheet.clj):\n\n;; Excludes built-in print\n(:refer-clojure :exclude [print])\n\n;; Excludes all built-ins except print\n(:refer-clojure :only [print])\n\n;; Renames built-in print to core-print\n(:refer-clojure :rename {print core-print})"], :macro true, :notes nil, :arglists ["& filters"], :doc "Same as (refer 'clojure.core <filters>)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/refer-clojure"}, :clojure.java.io/Coercions {:added "1.2", :ns "clojure.java.io", :name "Coercions", :file "clojure/java/io.clj", :type "var", :column 1, :see-alsos nil, :line 35, :examples nil, :notes nil, :arglists [], :doc "Coerce between various 'resource-namish' things.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/Coercions"}, :clojure.core/satisfies? {:added "1.2", :ns "clojure.core", :name "satisfies?", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos [:clojure.core/extend :clojure.core/defprotocol :clojure.core/instance? :clojure.core/extends? :clojure.core/extenders], :line 569, :examples ["(ns foo)\n\n(defprotocol Foo\n  (foo [this]))\n\n(defprotocol Bar\n  (bar [this]))\n\n(extend java.lang.Number\n  Bar\n  {:bar (fn [this] 42)})\n\n(extend java.lang.String\n  Foo\n  {:foo (fn [this] \"foo\")}\n  Bar\n  {:bar (fn [this] \"forty two\")})\n\n(satisfies? Foo \"zam\") ; => true\n(satisfies? Bar \"zam\") ; => true\n(satisfies? Foo 123)   ; => false\n(satisfies? Bar 123)   ; => true"], :notes nil, :arglists ["protocol x"], :doc "Returns true if x satisfies the protocol", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/satisfies_q"}, :clojure.java.io/default-streams-impl {:ns "clojure.java.io", :name "default-streams-impl", :file "clojure/java/io.clj", :type "var", :column 1, :see-alsos nil, :line 164, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/default-streams-impl"}, :clojure.core.logic.fd/finite-domain? {:ns "clojure.core.logic.fd", :name "finite-domain?", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 145, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/finite-domain_q"}, :clojure.core/assoc-in {:added "1.0", :ns "clojure.core", :name "assoc-in", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc :clojure.core/update-in :clojure.core/get-in], :line 6081, :examples ["(def users [{:name \"James\" :age 26}  {:name \"John\" :age 43}])\n\n;; update the age of the second (index 1) user \n(assoc-in users [1 :age] 44)\n;;=> [{:name \"James\", :age 26} {:name \"John\", :age 44}]\n\n;; insert the password of the second (index 1) user\n(assoc-in users [1 :password] \"nhoJ\")\n;;=> [{:name \"James\", :age 26} {:password \"nhoJ\", :name \"John\", :age 43}]\n\n;; create a third (index 2) user\n;; Also (assoc m 2 {...}) or (conj m {...})\n(assoc-in users [2] {:name \"Jack\" :age 19})  \n;;=> [{:name \"James\", :age 26} {:name \"John\", :age 43} {:name \"Jack\", :age 19}]\n\n;; From http://clojure-examples.appspot.com/clojure.core/assoc-in" ";; can be used to update a mutable item.\n(def ppl (atom {\"persons\" {\"joe\" {:age 1}}}))\n(swap! ppl assoc-in [\"persons\" \"bob\"] {:age 11})\n\n@ppl\n;;=> {\"persons\" {\"joe\" {:age 1}, \"bob\" {:age 11}}}" ";; be careful with that empty path sequence, it's seldom what you want\n(assoc-in {} [] {:k :v})\n;;=> {nil {:k :v}}\n\n;; In general, you find that for a non-empty path\n;;   (get-in (assoc-in m path v) path) \n;; is equal to v.\n;; Surprisingly this does not hold true in case of an empty path." ";; another example of updating a mutable item.\n;; this time the first key is to a map and the second to a vector.\n(def foo (atom {:users [{:a \"a\"} {:b \"b\"}]}))\n(swap! foo assoc-in [:users 2] {:c \"c\"})\n;;=> {:users [{:a \"a\"} {:b \"b\"} {:c \"c\"}]}\n\n" ";; assoc-in into a nested map structure\n(def foo {:user {:bar \"baz\"}})\n(assoc-in foo [:user :id] \"some-id\")\n;;=> {:user {:bar \"baz\", :id \"some-id\"}}\n" "(assoc-in {} [:cookie :monster :vocals] \"Finntroll\")\n; => {:cookie {:monster {:vocals \"Finntroll\"}}}\n\n(get-in {:cookie {:monster {:vocals \"Finntroll\"}}} [:cookie :monster])\n; => {:vocals \"Finntroll\"}\n\n(assoc-in {} [1 :connections 4] 2)\n; => {1 {:connections {4 2}}}\n\n;; from http://www.braveclojure.com/functional-programming/" ";; assoc-in can be used on vectors too\n\n(def row 0)\n(def col 0)\n\n(assoc-in [[1 1 1]\n           [1 1 1]\n           [1 1 1]] [row col] 0)\n; => [[0 1 1][1 1 1][1 1 1]]\n\n(get-in [[0 1 1]\n         [1 1 1]\n         [1 1 1]] [row col])\n; => 0" "; Playing around with assoc-in\n\n(assoc-in {:person {:name \"Mike\"}} [:person :name] \"Violet\")\n; => {:person {:name \"Violet\"}}\n\n(assoc-in {:person {:name \"Mike\"}} [:person] \"Violet\")\n; => {:person \"Violet\"}\n\n(assoc-in [{:person {:name \"Mike\"}}] [0 :person :name] \"Violet\")\n; => [{:person {:name \"Violet\"}}]\n\n(assoc-in [{:person {:name [\"Mike\"]}}] [0 :person :name 1] \"Smith\")\n; => [{:person {:name [\"Mike\" \"Smith\"]}}]\n\n(assoc-in [{:person {:name [\"Mike\"]}}] [0 :person :name 2] \"Smith\")\n; => IndexOutOfBoundsException" ";; Note that, unlike `assoc`, `assoc-in` cannot be used with multiple values.\n\n(def my-map {})\n\n;; This works\n(assoc my-map :a 1\n              :b 2\n              :c 3)\n; => {:a 1, :b 2, :c 3}\n\n;; This doesn’t\n(assoc-in my-map [:a :aa] 1\n                 [:b :bb] 2\n                 [:c :cc] 3)\n; ArityException Wrong number of args (7) passed to: core/assoc-in"], :notes nil, :arglists ["m [k & ks] v"], :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/assoc-in"}, :clojure.core/tagged-literal {:added "1.7", :ns "clojure.core", :name "tagged-literal", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7645, :examples nil, :notes nil, :arglists ["tag form"], :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/tagged-literal"}, :clojure.core/gen-class {:added "1.0", :ns "clojure.core", :name "gen-class", :file "clojure/genclass.clj", :type "macro", :column 1, :see-alsos [:clojure.core/proxy :clojure.core/gen-interface], :line 507, :examples ["(gen-class\n\t:name \"some.package.RefMap\"\n\t:implements [java.util.Map]\n\t:state \"state\"\n\t:init \"init\"\n\t:constructors {[] []}\n\t:prefix \"ref-map-\")\n\n(defn ref-map-init []\n\t[[] (ref {})])\n\n(defn ref-map-size [this]\n\t(let [state (.state this)] (.size @state)))\n\t\n(defn ref-map-isEmpty [this]\n\t(let [state (.state this)] (.isEmpty @state)))\n\n(defn ref-map-containsKey [this o]\n\t(let [state (.state this)] (.containsKey @state o)))\n\t\n(defn ref-map-containsValue [this o]\n\t(let [state (.state this)] (.containsValue @state o)))\n\t\n(defn ref-map-get [this o]\n\t(let [state (.state this)] (.get @state o)))\n\t\n(defn ref-map-keySet [this]\n\t(let [state (.state this)] (.keySet @state)))\n\t\n(defn ref-map-values [this]\n\t(let [state (.state this)] (.values @state)))\n\t\n(defn ref-map-entrySet [this]\n\t(let [state (.state this)] (.entrySet @state)))\n\t\n(defn ref-map-equals [this o]\n\t(let [state (.state this)] (.equals @state o)))\n\t\n(defn ref-map-hashCode [this]\n\t(let [state (.state this)] (.hashCode @state)))\n\t\n(defn ref-map-put [this k v]\n\t(let [state (.state this)] \n\t\t(dosync (alter state assoc k v)) v))\n\t\n(defn ref-map-putAll [this m]\n\t(let [state (.state this)]\n\t\t(doseq [[k v] (map identity m)] (.put this k v))))\n\t\t\n(defn ref-map-remove [this o]\n\t(let [state (.state this) v (get @state o)] \n\t\t(dosync (alter state dissoc o)) v))\n\t\n(defn ref-map-clear [this]\n\t(let [state (.state this)] \n\t\t(dosync (ref-set state {}))))\n\t\n(defn ref-map-toString [this]\n\t(let [state (.state this)] (.toString @state)))" ";; I found managing state a bit confusing at first.\n;; here's a dumb little class with a getter and setter for a \"location\" field.\n\n(ns com.example )\n\n(gen-class\n      :name com.example.Demo\n      :state state\n      :init init\n      :prefix \"-\"\n      :main false\n      ;; declare only new methods, not superclass methods\n      :methods [[setLocation [String] void]\n                [getLocation [] String]])\n\n;; when we are created we can set defaults if we want.\n(defn -init []\n  \"store our fields as a hash\"\n  [[] (atom {:location \"default\"})])\n\n;; little functions to safely set the fields.\n(defn setfield\n  [this key value]\n      (swap! (.state this) into {key value}))\n\n(defn getfield\n  [this key]\n  (@(.state this) key))\n\n;; \"this\" is just a parameter, not a keyword\n(defn -setLocation [this loc]\n  (setfield this :location loc))\n\n(defn  -getLocation\n  [this]\n  (getfield this :location))\n\n;; running it -- you must compile and put output on the classpath\n;; create a Demo, check the default value, then set it and check again.\nuser=> (def ex (com.example.Demo.))\n#'user/ex\nuser=> (.getLocation ex)\n\"default\"\nuser=> (.setLocation ex \"time\")\nnil\nuser=> (.getLocation ex)\n\"time\"\n"], :macro true, :notes ["When implementing interface methods with `gen-class` (when using `:implements`) watch out for primitive return types in interface methods.\r\n\r\nWhen you get weird `NullPointerException`s or `ClassPathException`s then make sure whether the value returned by your functions can be converted by Clojure to the primitive return type defined in the interface for that method.\r\n\r\nExample:\r\n\r\nGiven:\r\n\r\n<pre>\r\ninterface Test {\r\n   boolean isTest();\r\n}\r\n</pre>\r\n\r\nClojure implementation:\r\n\r\n<pre>\r\n(gen-class :name \"MyTest\" :implements [Test])\r\n\r\n; Will throw NPE when executed, \r\n; can't be converted to boolean\r\n(defn -isTest [this] nil) \r\n</pre>\r\n\r\n<pre>\r\n(gen-class :name \"MyTest\" :implements [Test])\r\n\r\n; Will throw ClassCastExcpetion when executed, \r\n; can't be converted to boolean\r\n(defn -isTest [this] (Object.)) \r\n</pre>" "When implementing an interface or extending an abstract class that implements an interface, be careful to implement all methods in the implemented interfaces.  Note: The abstract class is not required to implement all methods in the interface. The clojure compiler does not throw compiler errors if you do not implement a method. A runtime error will be thrown when someone tries to use the function.  The documentation suggests that you will receive UnsupportedOperationException, however in the case of the abstract class a java.lang.AbstractMethodError is thrown. \r\n\r\n**example:**\r\n\r\nLog4j appender - Extending AppenderSkeleton will fail with runtime error\r\n<pre>(gen-class :name clj.TestAppender :extends  org.apache.log4j.AppenderSkeleton)\r\n\r\n(defn -append [this event]\r\n  (println (.getMessage event)))\r\n</pre>\r\n\r\n\r\nNeed to implement close and requireLayout. These are not in AppenderSkeleton but are required by the interface Appender.\r\n<pre>(gen-class :name TstAppender :extends org.apache.log4j.AppenderSkeleton)\r\n\r\n(defn -append [this event]\r\n  (println (.getMessage event)))\r\n\r\n(defn -close [this]) ;nothing to clean up\r\n\r\n(defn -requireLayout [this] false)\r\n\r\n</pre>\r\n\r\n\r\n" "If your namespace has dashes in it, then the class name will be mangled so the dashes become underscores, unless you have a <code>:name</code> directive. Your naive instantiation will fail with ClassNotFoundException.\n\n    (ns my-project.MyClass\n      (:gen-class))\n\n    (my-project.MyClass.) ;;=> java.lang.ClassNotFoundException\n    (my_project.MyClass.) ;;=> #<MyClass ...>" "Note:  If you are using :extends you must use the fully qualified class name even if the class is in the :import list for the namespace. "], :arglists ["& options"], :doc "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  Its return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/gen-class"}, :clojure.core/simple-keyword? {:added "1.9", :ns "clojure.core", :name "simple-keyword?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/keyword? :clojure.core/qualified-keyword?], :line 1629, :examples ["(simple-keyword? :keyword)\n;;=> true\n\n(simple-keyword? :user/:keyword)\n;;=> false\n(simple-keyword? ::keyword)\n;;=> false\n\n(simple-keyword? \"string\")\n;;=> false\n(simple-keyword? 42)\n;;=> false\n(simple-keyword? nil)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a keyword without a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/simple-keyword_q"}, :clojure.core.logic.fd/difference* {:ns "clojure.core.logic.fd", :name "difference*", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 408, :examples nil, :notes nil, :arglists ["is js"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/difference*"}, :clojure.core.logic.fd/== {:ns "clojure.core.logic.fd", :name "==", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 749, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u and v must be equal. u and v must\n   eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/=="}, :clojure.core.async/remove< {:ns "clojure.core.async", :name "remove<", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1086, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["p ch" "p ch buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/remove<"}, :clojure.core/symbol? {:added "1.0", :ns "clojure.core", :name "symbol?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/simple-symbol? :clojure.core/qualified-symbol?], :line 562, :examples ["user=> (symbol? 'a)\ntrue\nuser=> (symbol? 1)\nfalse\nuser=> (symbol? :a)\nfalse"], :notes nil, :arglists ["x"], :doc "Return true if x is a Symbol", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/symbol_q"}, :clojure.instant/read-instant-timestamp {:ns "clojure.instant", :name "read-instant-timestamp", :file "clojure/instant.clj", :type "var", :column 1, :see-alsos nil, :line 285, :examples nil, :notes nil, :arglists [], :doc "To read an instant as a java.sql.Timestamp, bind *data-readers* to a\nmap with this var as the value for the 'inst key. Timestamp preserves\nfractional seconds with nanosecond precision. The timezone offset will\nbe used to convert into UTC.", :library-url "https://github.com/clojure/clojure", :href "/clojure.instant/read-instant-timestamp"}, :clojure.spec.alpha/explain-out {:ns "clojure.spec.alpha", :name "explain-out", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 241, :examples nil, :notes nil, :arglists ["ed"], :doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n   by default explain-printer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain-out"}, :clojure.core.logic/resto {:ns "clojure.core.logic", :name "resto", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic/firsto], :line 1671, :examples nil, :notes nil, :arglists ["l d"], :doc "A relation where l is a collection, such that d is the rest of l", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/resto"}, :clojure.instant/validated {:ns "clojure.instant", :name "validated", :file "clojure/instant.clj", :type "function", :column 1, :see-alsos nil, :line 138, :examples nil, :notes nil, :arglists ["new-instance"], :doc "Return a function which constructs an instant by calling constructor\nafter first validating that those arguments are in range and otherwise\nplausible. The resulting function will throw an exception if called\nwith invalid arguments.", :library-url "https://github.com/clojure/clojure", :href "/clojure.instant/validated"}, :clojure.core/var-get {:added "1.0", :ns "clojure.core", :name "var-get", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-local-vars :clojure.core/var-set], :line 4293, :examples ["user=> map\n#<core$map clojure.core$map@cce27f>\n\nuser=> #'map\n#'clojure.core/map\n\nuser=> (var-get #'map)\n#<core$map clojure.core$map@cce27f>"], :notes nil, :arglists ["x"], :doc "Gets the value in the var object", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/var-get"}, :clojure.core/while {:added "1.0", :ns "clojure.core", :name "while", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/loop :clojure.core/dotimes :clojure.core/repeatedly], :line 6253, :examples [";; a var to be used for its side effects\n(def a (atom 10))                                \n;; #'user/a\n\n(while (pos? @a) (do (println @a) (swap! a dec)))\n;; 10\n;; 9\n;; 8\n;; 7\n;; 6\n;; 5\n;; 4\n;; 3\n;; 2\n;; 1\n;;=> nil" ";; calculate the MD5 of a file incrementally:\n\n(import\n  'java.io.File\n  'javax.xml.bind.DatatypeConverter\n  'java.security.MessageDigest\n  'java.security.DigestInputStream)\n\n(require '[clojure.java.io :as io])\n\n(defn md5-file [file]\n  (let [sha (MessageDigest/getInstance \"MD5\")]                    \n    (with-open [dis (DigestInputStream. (io/input-stream file) sha)]  \n      (while (> (.read dis) -1)))                                     \n    (DatatypeConverter/printHexBinary (.digest sha))))                \n\n(md5-file (File. \"/etc/hosts\"))\n;; \"04F186E74288A10E09DFBF8A88D64A1F33C0E698AAA6B75CDB0AC3ABA87D5644\""], :macro true, :notes nil, :arglists ["test & body"], :doc "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/while"}, :clojure.core/line-seq {:added "1.0", :ns "clojure.core", :name "line-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/read-line], :line 3077, :examples [";; Count lines of a file (loses head):\nuser=> (with-open [rdr (clojure.java.io/reader \"/etc/passwd\")]\n         (count (line-seq rdr)))\n\n" "(import '(java.io BufferedReader StringReader))\n\n;; line terminators are stripped\nuser=> (line-seq (BufferedReader. (StringReader. \"1\\n2\\n\\n3\")))\n(\"1\" \"2\" \"\" \"3\")\n\n;; empty string gives nil\nuser=> (line-seq (BufferedReader. (StringReader. \"\")))\nnil\n" ";; read from standard input\nuser=> (nth (line-seq (java.io.BufferedReader. *in*)) 2)\n  #_=> 0\n  #_=> 1\n  #_=> 2\n\"2\"\n"], :notes nil, :arglists ["rdr"], :doc "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/line-seq"}, :clojure.core/any? {:added "1.9", :ns "clojure.core", :name "any?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/constantly :clojure.core/some?], :line 538, :examples [";; All known practical uses are in the context of core.spec\n;; Specifically indicates that any type is allowed.\n\n;; https://clojure.org/guides/spec#_macros\n(s/fdef clojure.core/declare\n    :args (s/cat :names (s/* simple-symbol?))\n    :ret any?)\n"], :notes ["The current implementation of [any?](https://github.com/clojure/clojure/blob/clojure-1.9.0/src/clj/clojure/core.clj#L538-L542) is incorrect and must be fixed IMO.\nThere was a [PR](https://github.com/clojure/clojure/pull/49) (copied below) submitted in 2014 to add a correct implementation which is consistent with behaviour in other languages. \n\n```\n(def\n ^{:tag Boolean\n   :doc \"Returns true if (pred x) is logical true for any x in coll,\n  else false.\"\n   :arglists '([pred coll])\n   :added \"1.7\"}\n any? (comp boolean some))\n```"], :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true given any argument.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/any_q"}, :clojure.core/future? {:added "1.1", :ns "clojure.core", :name "future?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/future], :line 6450, :examples ["user=> (def f (future (inc 0)))\n#'user/f\n\nuser=> (future? f)\ntrue\n\nuser=> (future? 1)\nfalse\n"], :notes nil, :arglists ["x"], :doc "Returns true if x is a future", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future_q"}, :clojure.core/*reader-resolver* {:ns "clojure.core", :name "*reader-resolver*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*reader-resolver*"}, :clojure.spec.alpha/*coll-check-limit* {:ns "clojure.spec.alpha", :name "*coll-check-limit*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 29, :examples nil, :notes nil, :arglists [], :doc "The number of elements validated in a collection spec'ed with 'every'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*coll-check-limit*"}, :clojure.core/keep-indexed {:added "1.2", :ns "clojure.core", :name "keep-indexed", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map-indexed :clojure.core/keep], :line 7266, :examples ["user=> (keep-indexed #(if (odd? %1) %2) [:a :b :c :d :e])\n(:b :d)" "user=> (keep-indexed #(if (pos? %2) %1) [-9 0 29 -7 45 3 -8])\n(2 4 5)\n;; f takes 2 args: 'index' and 'value' where index is 0-based\n;; when f returns nil the index is not included in final result\nuser=> (keep-indexed (fn [idx v]\n                       (if (pos? v) idx)) [-9 0 29 -7 45 3 -8])\n(2 4 5)" "(defn position [x coll & {:keys [from-end all] :or {from-end false all false}}]\n  (let [all-idxs (keep-indexed (fn [idx val] (when (= val x) idx)) coll)]\n  (cond\n   (true? from-end) (last all-idxs)\n   (true? all)      all-idxs\n   :else            (first all-idxs))))\n\nuser> (position [1 1] [[1 0][1 1][2 3][1 1]])\n1\nuser> (position [1 1] [[1 0][1 1][2 3][1 1]] :from-end true)\n3\nuser> (position [1 1] [[1 0][1 1][2 3][1 1]] :all true)\n(1 3)\n\nuser> (def foo (shuffle (range 10)))\n#'user/foo\nuser> foo\n(5 8 9 1 2 7 0 6 3 4)\nuser> (position 5 foo)\n0\nuser> (position 0 foo)\n6" ";; Simpler version of \"position\" above\n;; Get position of first element that satisfies the predicate\n(let [predicate #(= 1 %)\n      sequence [3 2 4 1 5 6 7]]\n  (first (keep-indexed (fn [i x] (when (predicate x) i)) \n                sequence)))\n\n;; The same logic but implemented with map-indexed\n(let [predicate #(= 1 %)\n      sequence [3 2 4 1 5 6 7]]\n  (some identity \n        (map-indexed (fn [i x] (when (predicate x) i)) \n                     sequence)))" "(require '[clojure.pprint :as p]\n         '[clojure.java.jdbc :as j])\n \n(def db\n  {:classname   \"org.sqlite.JDBC\"\n   :subprotocol \"sqlite\"\n   :subname     \"/home/liuwensui/Downloads/chinook.db\"})\n \n(def orders (j/query db \"select billingcountry as country, count(*) as orders from invoices group by billingcountry;\"))\n \n(def clist '(\"USA\" \"India\" \"Canada\" \"France\")\n\n(def country (map #(get % :country) orders))\n\n(p/print-table \n  (map #(nth orders %) \n    (flatten (pmap (fn [c] (keep-indexed (fn [i v] (if (= v c) i)) country)) clist))))\n\n;| :country | :orders |\n;|----------+---------|\n;|      USA |      91 |\n;|    India |      13 |\n;|   Canada |      56 |\n;|   France |      35 |"], :notes nil, :arglists ["f" "f coll"], :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/keep-indexed"}, :clojure.core.logic/run-constraint {:ns "clojure.core.logic", :name "run-constraint", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2070, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-constraint"}, :clojure.core.logic/-reify {:ns "clojure.core.logic", :name "-reify", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 263, :examples nil, :notes nil, :arglists ["s v" "s v r"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-reify"}, :clojure.core.logic.fd/get-dom {:ns "clojure.core.logic.fd", :name "get-dom", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 591, :examples nil, :notes nil, :arglists ["a x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/get-dom"}, :clojure.core.logic/-conjo {:ns "clojure.core.logic", :name "-conjo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2768, :examples nil, :notes nil, :arglists ["coll args out"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-conjo"}, :clojure.core.logic/add-attr {:ns "clojure.core.logic", :name "add-attr", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 432, :examples nil, :notes nil, :arglists ["s x attr attrv"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/add-attr"}, :clojure.core.logic.fd/expand {:ns "clojure.core.logic.fd", :name "expand", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1113, :examples nil, :notes nil, :arglists ["form"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/expand"}, :clojure.test/is {:added "1.1", :ns "clojure.test", :name "is", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/are :clojure.test/deftest], :line 553, :examples ["(use '[clojure.test :only [is]])\n\nuser=> (is (true? true))\ntrue\n\n;; false assertions print a message and evaluate to false\n\nuser=> (is (true? false))\nFAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:1)\nexpected: (true? false)\n  actual: (not (true? false))\nfalse\n\n" "; Testing for thrown exceptions\n\n; Verifies that the specified exception is thrown\nuser=> (is (thrown? ArithmeticException (/ 1 0)))\n#<ArithmeticException java.lang.ArithmeticException: Divide by zero>\n\n; Verified that the exception is thrown, and that the error message matches the specified regular expression.\nuser=> (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n  #_=>                       (/ 1 0)))\n#<ArithmeticException java.lang.ArithmeticException: Divide by zero>\nuser=> \n\n"], :macro true, :notes nil, :arglists ["form" "form msg"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/is"}, :clojure.core/aget {:added "1.0", :ns "clojure.core", :name "aget", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/aclone :clojure.core/get :clojure.core/nth :clojure.core/contains?], :line 3878, :examples ["\n;; create two arrays\n(def a1 (double-array '(1.0 2.0 3.0 4.0)))\n;;=> #'user/a1\n(def a2 (int-array '(9 8 7 6)))\n;;=> #'user/a2\n\n;; get an item by index\n(aget a1 2)\n;;=> 3.0\n(aget a2 3)\n;;=> 6\n\n;; 2d array and 2 indicies\n(def a3 (make-array Integer/TYPE 100 100))\n;;=> #'user/a3\n(aget a3 23 42)\n;;=> 0" ";; aget can be used to check the existence of an element\n;; this approach works with documents in ClojureScript where core/contains? does not\n(aget js/document \"getElementById\")\n;;=> #object[getElementById \"function getElementById() { [native code] }\"]\n(contains? js/document \"getElementById\")\n;;=> false"], :notes nil, :arglists ["array idx" "array idx & idxs"], :doc "Returns the value at the index/indices. Works on Java arrays of all\n  types.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aget"}, :clojure.pprint/pprint {:added "1.2", :ns "clojure.pprint", :name "pprint", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos [:clojure.pprint/pp :clojure.pprint/print-table :clojure.core/prn :clojure.core/prn-str :clojure.core/pr :clojure.core/pr-str :clojure.pprint/pprint-tab], :line 241, :examples ["(def big-map (zipmap \n                 [:a :b :c :d :e] \n                 (repeat \n                   (zipmap [:a :b :c :d :e] \n                      (take 5 (range))))))\n;;=> #'user/big-map\n\nbig-map\n;;=> {:a {:a 0, :b 1, :c 2, :d 3, :e 4}, :b {:a 0, :b 1, :c 2, :d 3, :e 4}, :c {:a 0, :b 1, :c 2, :d 3, :e 4}, :d {:a 0, :b 1, :c 2, :d 3, :e 4}, :e {:a 0, :b 1, :c 2, :d 3, :e 4}}\n\n(clojure.pprint/pprint big-map)\n;; {:e {:e 4, :d 3, :c 2, :b 1, :a 0},\n;;  :d {:e 4, :d 3, :c 2, :b 1, :a 0},\n;;  :c {:e 4, :d 3, :c 2, :b 1, :a 0},\n;;  :b {:e 4, :d 3, :c 2, :b 1, :a 0},\n;;  :a {:e 4, :d 3, :c 2, :b 1, :a 0}}\n;; nil" ";; suppose you want to pretty print to a file.\n(clojure.pprint/pprint *map* (clojure.java.io/writer \"foo.txt\"))\n;; writes the contents of *map* to a file named 'foo.txt'" ";; pprint into a string using with-out-str\n(with-out-str (clojure.pprint/pprint {:x 1 :y -1}))\n;; => \"{:x 1, :y -1}\\n\"\n\n;; pprint into a string using StringWriter\n(let [out (java.io.StringWriter.)]\n  (clojure.pprint/pprint {:a 1 :b 2} out)\n  (clojure.pprint/pprint {:c 3 :d 4} out)\n  (.toString out))\n;; => \"{:a 1, :b 2}\\n{:c 3, :d 4}\\n\"\n" ";;how to use it with :require and :use\n\n;; :require \n(ns example.pprinter\n   (:require [clojure.pprint :as pp]))\n\n(def myname \"John Smith\")\n(pp/pprint myname)\n\n--------------\n\n;;:use\n(ns example.pprinter\n    (:use clojure.pprint))\n\n(def myname \"John Smith\")\n(pprint myname)" ";; get Clojure snippets to print nicely\n(require '[clojure.pprint :as p])\n\n(def lost-formatting \n  \"(defn op [sel] (condp = sel :plus + :minus - :mult * \n   :div / :rem rem :quot quot :mod mod))\")\n\n(p/with-pprint-dispatch\n  p/code-dispatch\n  (p/pprint \n    (clojure.edn/read-string lost-formatting)))\n\n;; (defn op [sel]\n;;   (condp = sel\n;;     :plus +\n;;     :minus -\n;;     :mult *\n;;     :div /\n;;     :rem rem\n;;     :quot quot\n;;     :mod mod))"], :notes ["When using Clojure from the REPL, you don't need to specify `clojure.pprint` to use `pprint` or `pp`. At the REPL `(clojure.pprint x)` is equivalent to `(pprint x)`."], :arglists ["object" "object writer"], :doc "Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pprint"}, :clojure.core.logic.fd/< {:ns "clojure.core.logic.fd", :name "<", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 825, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u must be less than v. u and v\n   must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/<"}, :clojure.core/throw {:ns "clojure.core", :name "throw", :type "var", :see-alsos [:clojure.core/try :clojure.core/catch :clojure.core/finally :clojure.core/ex-info :clojure.core/ex-data], :examples ["=> (throw (Exception. \"my exception message\"))\njava.lang.Exception: my exception message (NO_SOURCE_FILE:0)\n" ";; Different types of exception can be thrown\n=> (throw (AssertionError. \"Wrong input.\"))\njava.lang.AssertionError: Wrong input."], :notes nil, :arglists [], :doc "The expr is evaluated and thrown, therefore it should yield an instance of\nsome derivee of Throwable. Please see http://clojure.org/special_forms#throw", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/throw"}, :clojure.core.logic/map->PMap {:ns "clojure.core.logic", :name "map->PMap", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2518, :examples nil, :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.core.logic.PMap, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/map->PMap"}, :clojure.spec.alpha/conformer {:ns "clojure.spec.alpha", :name "conformer", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 645, :examples [";; One use of clojure.spec.alpha/conformer is to convert inputs to a data\n;; structure more suitable for further conforming. In this sketch we use a regex\n;; spec to describe a string representing a binary number.\n\n(require '[clojure.spec.alpha :as s]\n         '[clojure.spec.gen.alpha :as gen])\n\n(s/def ::str->chars (s/conformer seq #(apply str %)))\n\n(s/def ::binary-digits (s/cat :initial #{\\1}, :more (s/* #{\\0 \\1})))\n\n;; Look, no \"re-matches\"!\n(s/def ::binary-string\n  (s/with-gen (s/and string? ::str->chars ::binary-digits)\n    (fn []\n      (gen/fmap #(s/unform ::str->chars %) (s/gen ::binary-digits)))))\n\n(s/conform ::binary-string \"1011\")\n;;=> {:initial \\1, :more [\\0 \\1 \\1]}\n\n(gen/sample (s/gen ::binary-string) 5)\n;;=> (\"11\" \"100\" \"1010\" \"111\" \"111\")\n"], :macro true, :notes nil, :arglists ["f" "f unf"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :clojure.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/conformer"}, :clojure.core.logic/->LVar {:ns "clojure.core.logic", :name "->LVar", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 621, :examples nil, :notes nil, :arglists ["id unique name oname hash meta"], :doc "Positional factory function for class clojure.core.logic.LVar.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->LVar"}, :clojure.java.io/file {:added "1.2", :ns "clojure.java.io", :name "file", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.core/file-seq :clojure.java.io/reader :clojure.java.io/writer :clojure.java.io/delete-file :clojure.java.io/make-parents], :line 418, :examples ["user> (clojure.java.io/file \"/tmp/foo\")\n#<File /tmp/foo>\n\nuser> (clojure.java.io/file \"http://asdf.com\")\n#<File http:/asdf.com>\n\nuser> (clojure.java.io/file \"/tmp/foo\" \"bar\")\n#<File /tmp/foo/bar>" "; Use clojure.java.io to read in resources from the classpath\n\n(ns rescue.core\n  (:require [clojure.java.io :as io] ))\n\n; Populate the file on the command line:  \n;   echo \"Hello Resources!\" > resources/hello.txt\n(def data-file (io/resource \n                 \"hello.txt\" ))\n(defn -main []\n  (println (slurp data-file)) )\n; When do \"lein run\"\n; => Hello Resources!" "; slurp can be used directly on value of io/resource\n\n(ns rescue.core\n  (require [clojure.java.io :as io]))\n\n; echo \"hello world\"  > resources/hello.txt\n(def data (io/resource \"hello.txt\"))\n\n(defn -main []\n  (println (slurp data-file))\n; when do \"lein run\"\n; => hello world"], :notes nil, :tag "java.io.File", :arglists ["arg" "parent child" "parent child & more"], :doc "Returns a java.io.File, passing each arg to as-file.  Multiple-arg\n   versions treat the first argument as parent and subsequent args as\n   children relative to the parent.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/file"}, :clojure.core/print-method {:ns "clojure.core", :name "print-method", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/print-dup], :line 3655, :examples ["(deftype XYZ [])\n\n; without custom print-method defined:\nuser=> (prn (XYZ.))\n#<XYZ user.XYZ@2670d85b> \n\n(defmethod print-method XYZ [v ^java.io.Writer w]\n  (.write w \"<<-XYZ->>\"))\n\n; with print-method\nuser=> (prn (XYZ.))\n<<-XYZ->>\n"], :notes ["Take care when writing things that look like a reader macro, like `#mything<42 42 42>`.\nIt may break your AOT compilations with a `java.lang.RuntimeException: No reader function for tag mything`.\n\nA quick workaround is not to emit a `#` character.\nThe thorough solution starts by reading https://clojuredocs.org/clojure.core/*data-readers* and is beyond the scope of this note."], :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print-method"}, :clojure.core.logic/->AnswerCache {:ns "clojure.core.logic", :name "->AnswerCache", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1818, :examples nil, :notes nil, :arglists ["ansl anss _meta"], :doc "Positional factory function for class clojure.core.logic.AnswerCache.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->AnswerCache"}, :clojure.inspector/atom? {:ns "clojure.inspector", :name "atom?", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos [:clojure.core/isa?], :line 19, :examples [";; atom? returns true if the form passed does not \n;; implement IPersistentCollection. The atom referred \n;; here is not the atom used in managing mutable state  \n\nuser=> (use `[clojure.inspector :include (atom?)])\n\nuser=> (atom? 1)\ntrue\n\nuser=> (atom? \\a)\ntrue\n\nuser=> (atom? \"hello world\")\ntrue\n\nuser=> (atom? :keyword)\ntrue\n\nuser=> (atom? nil)\ntrue\n\nuser=> (atom? '())\nfalse\n\nuser=> (atom? [1, 3, 5])\nfalse\n\nuser=> (atom? #{\\a \\e \\i \\o \\u})\nfalse\n\nuser=> (atom? {:x 16 :y 25})\nfalse"], :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/atom_q"}, :clojure.spec.alpha/? {:ns "clojure.spec.alpha", :name "?", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 598, :examples nil, :macro true, :notes nil, :arglists ["pred-form"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/_q"}, :clojure.core/chunk-first {:ns "clojure.core", :name "chunk-first", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-next :clojure.core/chunk-rest], :line 693, :examples ["(let [chunked-cons (seq (range 1 42))\n      first-chunk (chunk-first chunked-cons)]\n\n  (class chunked-cons)\n  ;; => clojure.lang.ChunkedCons\n\n  (class first-chunk)\n  ;; clojure.lang.ArrayChunk\n\n  ;; Demonstrating chunk size of 32.\n  (.nth first-chunk 0)\n  ;; => 1\n  (.nth first-chunk 31)\n  ;; => 32\n)"], :notes nil, :tag "clojure.lang.IChunk", :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-first"}, :clojure.core/await-for {:added "1.0", :ns "clojure.core", :name "await-for", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/await], :line 3288, :examples nil, :notes nil, :arglists ["timeout-ms & agents"], :doc "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/await-for"}, :clojure.core/reduce-kv {:added "1.4", :ns "clojure.core", :name "reduce-kv", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduce :clojure.core/reduced], :line 6767, :examples ["Let's assume you want to apply a function to a vector of maps,\n\nInput: [{:a 1 :b 2} {:a 3 :b 4}]\n\nsuch that all vals are incremented by 1.\n\nResult: [{:a 2 :b 3} {:a 4 :b 5}]\n\nAn easy way to do so is using reduce-kv,\n\n(def vector-of-maps [{:a 1 :b 2} {:a 3 :b 4}])\n\n(defn update-map [m f] \n  (reduce-kv (fn [m k v] \n    (assoc m k (f v))) {} m))\n\n(map #(update-map % inc) vector-of-maps)\n\n=> ({:b 3, :a 2} {:b 5, :a 4})" ";; Swap keys and values in a map\nuser=> (reduce-kv #(assoc %1 %3 %2) {} {:a 1 :b 2 :c 3})\n{1 :a, 2 :b, 3 :c}" ";; Swap keys with values, only if values are not empty,\n;; while turning values into proper keys\n\n(def someMap { :foo \"food\", :bar \"barista\", :baz \"bazaar\"})\n\n(defn swap [someMap]\n  (reduce-kv (fn [m k v]\n               (if (empty? v) m (assoc m (keyword v) (name k)))) {} someMap))\n\n(swap someMap)\n\n=> {:food \"foo\", :barista \"bar\", :bazaar \"baz\"}\n" ";; Calculate total wins and winning streaks\n(def all-games \n  [{:game 1 :won true} \n   {:game 2 :won false} \n   {:game 3 :won true} \n   {:game 4 :won true}])\n\n(reduce-kv\n  (fn [result index game]\n    (let [last-game (last result)\n          wins (if (:won game) \n                 (inc (:total last-game 0)) \n                 (:total last-game))\n          streak (if (:won game) \n                   (inc (:streak last-game 0)) \n                   0)]\n      (println (assoc game :total wins :streak streak))\n      (conj result (assoc game :total wins :streak streak))))\n  []\n  all-games)\n\n;; Output\n;; {:game 1, :won true, :total 1, :streak 1}\n;; {:game 2, :won false, :total 1, :streak 0}\n;; {:game 3, :won true, :total 2, :streak 1}\n;; {:game 4, :won true, :total 3, :streak 2}\n\n;; [{:game 1, :won true, :total 1, :streak 1} {:game 2, :won false, :total 1, :streak 0} {:game 3, :won true, :total 2, :streak 1} {:game 4, :won true, :total 3, :streak 2}]" ";; You can define map-kv using reduce-kv, \n;; to do something to every value in a map.\n\n(defn map-kv [f coll]\n  (reduce-kv (fn [m k v] (assoc m k (f v))) (empty coll) coll))\n\n(map-kv inc {:a 12, :b 19, :c 2})\n;;=> {:c 3, :b 20, :a 13}\n\n;; It works on vectors, too.\n(map-kv inc [1 1 2 3 5])\n;;=> [2 2 3 4 6]" ";; It works with indexes on vectors as well\n\n(reduce-kv (fn [res idx itm] (assoc res idx itm)) {} [\"one\" \"two\" \"three\"])\n\n;;=> {2 \"three\", 1 \"two\", 0 \"one\"}" "\n(defn update-map-entries[m e]\n     (reduce-kv (fn [r k v] (assoc  r k v))  m e))\n\n;;user=> (update-map-entries {:a 1 :b 2 :c 3} {:a 5 :b 9})\n;;{:a 5, :b 9, :c 3}\n;;user=> (update-map-entries {:a 1 :b 2 :c 3} {:a 5 :b 9 :d 8})\n;;{:a 5, :b 9, :c 3, :d 8}\n\n\n"], :notes nil, :arglists ["f init coll"], :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reduce-kv"}, :clojure.core.logic/to-subst-val {:ns "clojure.core.logic", :name "to-subst-val", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 604, :examples nil, :notes nil, :arglists ["v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/to-subst-val"}, :clojure.core.async/unblocking-buffer? {:ns "clojure.core.async", :name "unblocking-buffer?", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 67, :examples nil, :notes nil, :arglists ["buff"], :doc "Returns true if a channel created with buff will never block. That is to say,\n   puts into this buffer will never cause the buffer to be full. ", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unblocking-buffer_q"}, :clojure.core/ensure {:added "1.0", :ns "clojure.core", :name "ensure", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/commute :clojure.core/ref-set :clojure.core/ref :clojure.core/alter], :line 2480, :examples nil, :notes ["This is for preventing [write skew](http://clojure.higher-order.net/?p=50), which Clojure's concurrency model is susceptible to. If you have a transaction where several refs' values must remain in some consistent relationship to each other, but you are only writing to some of them, you should use ensure on the other refs to prevent other transactions from writing to them in the meantime."], :arglists ["ref"], :doc "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ensure"}, :clojure.core.logic/let-dom {:ns "clojure.core.logic", :name "let-dom", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 2211, :examples nil, :macro true, :notes nil, :arglists ["a vars & body"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/let-dom"}, :clojure.core/hash-unordered-coll {:added "1.6", :ns "clojure.core", :name "hash-unordered-coll", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/hash :clojure.core/hash-ordered-coll], :line 5135, :examples [";;;; Clojure's (hash-unordered-coll) ALWAYS produces the same hash code EVEN:\n;;;;   (1) for different collection types\n;;;;   (2) for differently ordered collections of the same type\n;;;; AS LONG AS the collections contain the same elements \n\n(hash-unordered-coll #{1 2})\n;;=> 460223544\n(hash-unordered-coll (sorted-set 1 2))\n;;=> 460223544\n(hash-unordered-coll (doto (new java.util.HashSet) (.add 1) (.add 2)))\n;;=> 460223544\n(hash-unordered-coll (doto (new java.util.TreeSet) (.add 1) (.add 2)))\n;;=> 460223544\n(hash-unordered-coll [1 2])\n;;=> 460223544\n(hash-unordered-coll [2 1])\n;;=> 460223544\n(hash-unordered-coll (doto (new java.util.ArrayList) (.add 1) (.add 2)))\n;;=> 460223544\n(hash-unordered-coll (doto (new java.util.ArrayList) (.add 2) (.add 1)))\n;;=> 460223544\n\n;;;; On the other hand: both Clojure's (hash) and Java's .hashCode()\n;;;; CAN (and often WILL) produce different hash codes:\n;;;;   (1) for different collection types\n;;;;   (2) for differently ordered collections of the same type\n;;;; EVEN if the collections contain the same elements\n\n(hash #{1 2})\n;;=> 460223544\n(hash (sorted-set 1 2))\n;;=> 460223544\n(hash (doto (new java.util.HashSet) (.add 1) (.add 2)))\n;;=> 3\n(hash (doto (new java.util.TreeSet) (.add 1) (.add 2)))\n;;=> 3\n(hash [1 2])\n;;=> 156247261\n(hash [2 1])\n;;=> -1994590503\n(hash (doto (new java.util.ArrayList) (.add 1) (.add 2)))\n;;=> 994\n(hash (doto (new java.util.ArrayList) (.add 2) (.add 1)))\n;;=> 1024\n\n(.hashCode #{1 2})\n;;=> 3\n(.hashCode (sorted-set 1 2))\n;;=> 3\n(.hashCode (doto (new java.util.HashSet) (.add 1) (.add 2)))\n;;=> 3\n(.hashCode (doto (new java.util.TreeSet) (.add 1) (.add 2)))\n;;=> 3\n(.hashCode [1 2])\n;;=> 994\n(.hashCode [2 1])\n;;=> 1024\n(.hashCode (doto (new java.util.ArrayList) (.add 1) (.add 2)))\n;;=> 994\n(.hashCode (doto (new java.util.ArrayList) (.add 2) (.add 1)))\n;;=> 1024\n" ";;;;\n;;;; Only accepts implementations of java.lang.Iterable\n;;;;\n\n(hash-unordered-coll true)\n;;=> ClassCastException java.lang.Boolean cannot be cast to java.lang.Iterable\n(hash-unordered-coll 1)\n;;=> ClassCastException java.lang.Long cannot be cast to java.lang.Iterable\n(hash-unordered-coll \\c)\n;;=> ClassCastException java.lang.Character cannot be cast to java.lang.Iterable\n\n;;;;\n;;;; Being seqable is not sufficient!\n;;;;\n\n(hash-unordered-coll \"12\")\n;;=> ClassCastException java.lang.String cannot be cast to java.lang.Iterable\n(hash-unordered-coll (int-array [1 2]))\n;;=> ClassCastException [I cannot be cast to java.lang.Iterable\n(hash-unordered-coll nil)\n;;=> NullPointerException"], :notes nil, :arglists ["coll"], :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash-unordered-coll"}, :clojure.spec.alpha/keys* {:ns "clojure.spec.alpha", :name "keys*", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 1742, :examples nil, :macro true, :notes nil, :arglists ["& kspecs"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/keys*"}, :clojure.core/repeat {:added "1.0", :ns "clojure.core", :name "repeat", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/repeatedly :clojure.core/cycle :clojure.core/constantly :clojure.core/dotimes], :line 2991, :examples ["user=> (take 5 (repeat \"x\"))\n(\"x\" \"x\" \"x\" \"x\" \"x\")\n\n;; which is the same as:\nuser=> (repeat 5 \"x\")\n(\"x\" \"x\" \"x\" \"x\" \"x\")\n\n;; It should be noted that repeat simply repeats the value n number of times.\n;; If you wish to execute a function to calculate the value each time you \n;; probably want the repeatedly function.\n\n" "(defn tally [n]\n  (apply str\n         (concat\n           (repeat (quot n 5) \"卌\")\n           (repeat (mod n 5) \"|\"))))\n\n(map tally (range 1 11))\n;; (\"|\" \"||\" \"|||\" \"||||\" \"卌\" \"卌|\" \"卌||\" \"卌|||\" \"卌||||\" \"卌卌\")"], :notes nil, :arglists ["x" "n x"], :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/repeat"}, :clojure.core/seq {:added "1.0", :ns "clojure.core", :name "seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq? :clojure.core/empty? :clojure.core/iterator-seq :clojure.core/seqable?], :line 126, :examples ["(seq '(1))  ;;=> (1)\n(seq [1 2]) ;;=> (1 2)\n(seq \"abc\") ;;=> (\\a \\b \\c)\n\n;; Corner cases\n(seq nil)   ;;=> nil\n(seq '())   ;;=> nil\n(seq \"\")    ;;=> nil" ";; (seq x) is the recommended idiom for testing if a collection is not empty\n(every? seq [\"1\" [1] '(1) {:1 1} #{1}])\n;;=> true" ";; 'seq' can be used to turn a map into a list of vectors.\n;; Notice how the list is built adding elements to the beginning \n;; of the seq (list) not to the end, as with vectors.\n;; (Of course, the order that items are \n;;  taken from a map should not be relied upon\n;;  unless a deterministic 'sorted-map' is used.)\n(seq {:key1 \"value1\" :key2 \"value2\"})\n;;=> ([:key2 \"value 2\"] [:key1 \"value 1\"])" "Here is the difference between seq and sequence\n\nuser> (seq nil)\n;;=> nil\n\nuser> (seq ())\n;;=> nil\n\nuser> (sequence ())\n;;=> ()\n\nuser> (sequence nil)\n;;=> ()"], :notes nil, :tag "clojure.lang.ISeq", :arglists ["coll"], :doc "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/seq"}, :clojure.core/reduce {:added "1.0", :ns "clojure.core", :name "reduce", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reductions :clojure.core/apply :clojure.core/frequencies :clojure.core/reduced :clojure.core/reduced? :clojure.core/reduce-kv :clojure.core.reducers/fold], :line 6730, :examples ["(reduce + [1 2 3 4 5])  ;;=> 15\n(reduce + [])           ;;=> 0\n(reduce + [1])          ;;=> 1\n(reduce + [1 2])        ;;=> 3\n(reduce + 1 [])         ;;=> 1\n(reduce + 1 [2 3])      ;;=> 6" ";; converting a vector to a set\n(reduce conj #{} [:a :b :c])\n;;=> #{:a :c :b}\n" ";; Create a word frequency map out of a large string s.\n\n;; `s` is a long string containing a lot of words :)\n(reduce #(assoc %1 %2 (inc (%1 %2 0)))\n        {}\n        (re-seq #\"\\w+\" s))\n\n; (This can also be done using the `frequencies` function.)\n" ";; Calculate primes until 1000\n\n(reduce\n  (fn [primes number]\n    (if (some zero? (map (partial mod number) primes))\n      primes\n      (conj primes number)))\n  [2]\n  (take 1000 (iterate inc 3)))\n\n;;=> [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 \n;;    83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 \n;;    167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 \n;;    257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 \n;;    353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 \n;;    449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 \n;;    563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 \n;;    653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 \n;;    761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 \n;;    877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 \n;;    991 997]" ";; Add one collection to another (combining sequences is done with cons):\n(reduce conj [1 2 3] [4 5 6])\n;;=> [1 2 3 4 5 6]\n\n(reduce #(cons %2 %1) [1 2 3] [4 5 6])\n;;=> '(6 5 4 1 2 3)" ";; Combine a vector of collections into a single collection \n;; of the type of the first collection in the vector.\n(reduce into [[1 2 3] [:a :b :c] '([4 5] 6)])\n;;=> [1 2 3 :a :b :c [4 5] 6]\n\n;; The flatten function can be used to completely fuse \n;; all of the items of a nested tree into a single sequence.\n;; Sometimes all that is needed is to fuse the first level\n;; of a tree. This can be done with 'reduce' and 'into'.\n(reduce into [] '([] [[10 18]] [[8 18]] [[10 12]] [[0 -6]] [[2 6]]))\n;;=> [[10 18] [8 18] [10 12] [0 -6] [2 6]]\n" "(defn key-pres?\n    \"This function accepts a value (cmp-val) and a vector of vectors\n    (parsed output from clojure-csv) and returns the match value\n    back if found and nil if not found. \n\n    Using reduce, the function searches every vector row to see \n    if cmp-val is at the col-idx location in the vector.\"\n\n    [cmp-val cmp-idx csv-data]\n    (reduce\n        (fn [ret-rc csv-row]\n            (if (= cmp-val (nth csv-row col-idx nil))\n                    (conj ret-rc cmp-val)))\n        [] \n        csv-data))" "(defn reduce-csv-row\n    \"Accepts a csv-row (a vector) a list of columns to extract, \n     and reduces (and returns) a csv-row to a subset based on \n     selection using the values in col-nums (a vector of integer \n     vector positions.)\"\n\n    [csv-row col-nums]\n\n    (reduce\n        (fn [out-csv-row col-num]\n            ; Don't consider short vectors containing junk.\n            (if-not (<= (count csv-row) 1)\n                (conj out-csv-row (nth csv-row col-num nil))))\n        []\n        col-nums))\n\n" ";; Some functions update a collection with a single item.\n;; A number of functions have a 'more' argument which lets\n;; them work over collections.\n;; These functions can benefit 'reduce' which lets them work \n;; a collection of items...\n(into {} {:dog :food})\n(reduce into {} [{:dog :food} {:cat :chow}])\n;;=> {:dog :food, :cat :chow}\n\n\n" ";; The reduction will terminate early if an intermediate result uses the \n;; `reduced` function.\n\n(defn limit [x y] \n  (let [sum (+ x y)] \n    (if (> sum 10) (reduced sum) sum)))\n\n(reduce + 0 (range 10))\n;;=> 45\n\n(reduce limit 0 (range 10))\n;;=> 15" ";;This will generate the first 100 Fibonacci numbers\n;;(size of (range) + 2):\n\n(reduce \n  (fn [a b] (conj a (+' (last a) (last (butlast a)))))  \n  [0 1]                      \n  (range 98))\n\n;;[0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 27777890035288 44945570212853 72723460248141 117669030460994 190392490709135 308061521170129 498454011879264 806515533049393 1304969544928657 2111485077978050 3416454622906707 5527939700884757 8944394323791464 14472334024676221 23416728348467685 37889062373143906 61305790721611591 99194853094755497 160500643816367088 259695496911122585 420196140727489673 679891637638612258 1100087778366101931 1779979416004714189 2880067194370816120 4660046610375530309 7540113804746346429 12200160415121876738N 19740274219868223167N 31940434634990099905N 51680708854858323072N 83621143489848422977N 135301852344706746049N 218922995834555169026N]" ";;re-implementing (map):\n\n(defn remap [f & c]\n  (let [neues-c (partition (count c)\n                           (apply interleave c))]\n    (reduce (fn [s k] (conj s (apply f k))) [] neues-c)))\n\n;;user=> (remap * [0.5 0.5 0.5] (range))\n;;[0.0 0.5 1.0]\n;;user=> (remap str \"clojure\" (range))\n;;[\"c0\" \"l1\" \"o2\" \"j3\" \"u4\" \"r5\" \"e6\"]\n" ";;update map entries:\n(defn update-map-entries[m e]\n     (reduce #(update-in %1 [(first %2)] (fn[_](last %2))) m e))\n\n;;user=> (update-map-entries {:a 1 :b 2 :c 3} {:a 5 :b 9})\n;;{:a 5, :b 9, :c 3}\n;;user=> (update-map-entries {:a 1 :b 2 :c 3} {:a 5 :b 9 :d 8})\n;;{:a 5, :b 9, :c 3, :d 8}" ";;flatten values in a map\n(reduce (fn[ flattened [key val]]\n          (clojure.set/union flattened val))\n        #{}\n        {:e #{:m :f}, :c #{:f}, :b #{:c :f}, :d #{:m :f}, :a #{:c :f}})\n\n;;=> #{:m :c :f}" ";;simple factorial function using reduce.\n\n(defn fact [x] \n(reduce *' (range 1 (inc x))))" ";; reduce over maps by destructuring keys\n(def x {:a 1 :b 2})\n\n(reduce (fn [p [k v]]\n          (into p {k (+ 1 v)}))\n        {} ;first value for p\n        x)\n;;=> {:a 2, :b 3}\n" ";; conj! over transient array for speed.\n;; This example flattens over one level.\n;; To do so uses reduce twice.\n(persistent!\n  (reduce\n     (fn [acc0 item-vector]\n        (reduce \n           (fn [acc1 item]\n              (conj! acc1 item))\n           acc0 item-vector))\n     (transient [])\n     [[:foo :bar :baz] [] [:fred :barney]]))\n ;;=> [:foo :bar :baz :fred :barney]    " ";;reduce with side effects\n;;given a collection return a new collection\n\n(def initial-coll [1 2 3 4 5])\n\n(defn byten\n  [coll]\n  (reduce (fn [new-coll unit]\n            (into new-coll [(* 10 unit)]))\n          []\n          coll))\n\n(byten initial-coll)\n;;[10 20 30 40 50]\n\n\n" ";;reduce with side effects using an anonymous function\n;;given a collection return a new collection\n\n(def initial-coll [1 2 3 4 5])\n\n(defn byten\n  [coll]\n  (reduce #(into %1 [(* 10 %2)])\n          []\n          coll))\n\n(byten initial-coll)\n;;[10 20 30 40 50]" ";;practical example\n\n(reduce\n (fn [newcoll [k v]]\n   (assoc newcoll k (clojure.string/upper-case v)))\n {}\n {:a \"aaaaaaa\" :b \"bbbbbbb\"})\n\n;;{:a \"AAAAAAA\", :b \"BBBBBBB\"}"], :notes ["clojure.core/reduce seems to be a special case of a function that's defined twice in core.clj, and the first definition (at the line cited above: 773) is just a temporary definition; the real definition is later at line 5323, which contains the docstring." "The reducing function f is of shape:\n\n(f [accumulator next-element] ...)"], :arglists ["f coll" "f val coll"], :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reduce"}, :clojure.inspector/table-model {:ns "clojure.inspector", :name "table-model", :file "clojure/inspector.clj", :type "var", :column 1, :see-alsos nil, :line 139, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/table-model"}, :clojure.core/find-ns {:added "1.0", :ns "clojure.core", :name "find-ns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/create-ns :clojure.core/remove-ns :clojure.core/ns-map], :line 4092, :examples ["(find-ns 'clojure.string)\n;;=> nil\n\n(require 'clojure.string)\n;;=> nil\n\n(find-ns 'clojure.string)\n;;=> #<Namespace clojure.string>"], :notes nil, :arglists ["sym"], :doc "Returns the namespace named by the symbol or nil if it doesn't exist.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find-ns"}, :clojure.core/first {:added "1.0", :ns "clojure.core", :name "first", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rest :clojure.core/next :clojure.core/nth :clojure.core/second :clojure.core/take :clojure.core/ffirst :clojure.core/butlast], :line 49, :examples ["(first '(:alpha :bravo :charlie))\n;;=> :alpha" ";; nil is a valid (but empty) collection.\n(first nil)\n;;=> nil\n\n;; if collection is empty, returns nil.\n(first [])\n;;=> nil" "=> (first [1 2])\n1\n\n=> (first [ [1 2] [3 4] ])\n[1 2]"], :notes nil, :arglists ["coll"], :doc "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/first"}, :clojure.spec.alpha/def {:ns "clojure.spec.alpha", :name "def", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 327, :examples nil, :macro true, :notes nil, :arglists ["k spec-form"], :doc "Given a namespace-qualified keyword or resolvable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/def"}, :clojure.core.logic.pldb/ground? {:ns "clojure.core.logic.pldb", :name "ground?", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 38, :examples nil, :notes nil, :arglists ["s term"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/ground_q"}, :clojure.core/seq? {:added "1.0", :ns "clojure.core", :name "seq?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq :clojure.core/sequential? :clojure.core/vector? :clojure.core/coll? :clojure.core/list? :clojure.core/map? :clojure.core/set? :clojure.core/seqable?], :line 146, :examples ["user> (seq? 1)\nfalse\nuser> (seq? [1])\nfalse\nuser> (seq? (seq [1]))\ntrue" ";; contrast to example code for sequential?\n;;\nuser> (seq? '(1 2 3))\ntrue\nuser> (seq? [1 2 3])   ; for sequential?, returns true\nfalse\nuser> (seq? (range 1 5))\ntrue\nuser> (seq? 1)\nfalse\nuser> (seq? {:a 2 :b 1})\nfalse\nuser> " ";; Don't use seq? when you want to check for a vector.\n;; you may have intended to use seq instead\n\ncljs.user=> (def x [:a :b :c])\n#'cljs.user/x\ncljs.user=> (if (seq x) \"Seq ok\" \"No Seqing here\")\n\"Seq ok\"\ncljs.user=> (if (seq? x) \"Seq ok\" \"No Seqing here\")\n\"No Seqing here\""], :notes nil, :arglists ["x"], :doc "Return true if x implements ISeq", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/seq_q"}, :clojure.core/= {:added "1.0", :ns "clojure.core", :name "=", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/== :clojure.core/not= :clojure.core/identical?], :line 775, :examples ["user=> (= 1)\ntrue\nuser=> (= 1 1)\ntrue\nuser=> (= 1 2)\nfalse\nuser=> (= 1 1 1)\ntrue\nuser=> (= 1 1 2)\nfalse\nuser=> (= '(1 2) [1 2])\ntrue\nuser=> (= nil nil)\ntrue\nuser=> (= (sorted-set 2 1) (sorted-set 1 2))\ntrue\n\n;; It should be noted that equality is not defined for Java arrays.\n;; Instead you can convert them into sequences and compare them that way.\n;; (= (seq array1) (seq array2))\n" ";; There are functional differences between = and == \n;; = may introduce java autoboxing \n\n;; true:\n(= 1)\n(= 1 1)       \n(= 1/1, 2/2, 3/3, 4/4)   \n(= :foo)\n(= nil anything)     ; anything = nil\n\n\n;; false:\n(= 1, 1.0, 1/1) ; differs from ==\n(= 1 2)\n(= 1 \\1)        ; differs from ==\n(= 1 \"1\")       ; differs from ==\n\n" ";; If passed a single value (= x) the result is always true.\n(= 1)\n(= nil)\n(= false)\n(= true)\n(= {:a 1 :b2})\n(= 'false)\n;;=> true  \n"], :notes ["There is a difference between \"=\" and \"==\".  For primitives you definitely want to use \"==\" as \"=\" will result in a cast to the wrapped types for it's arguments.  \r\n\r\nThis may not be the case come Clojure 1.3 (see [1])\r\n\r\n[1] http://github.com/clojure/clojure/commit/df8c65a286e90e93972bb69392bc106128427dde"], :arglists ["x" "x y" "x y & more"], :doc "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/="}, :clojure.core.logic/defne {:ns "clojure.core.logic", :name "defne", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/defna :clojure.core.logic/defnu :clojure.core.logic/defnc :clojure.core.logic/fne :clojure.core.logic/conde], :line 1699, :examples ["(defne match1 [x y]\n  ([:foo :bar])\n  ([:baz :qux]))\n\n(run* [x y] (match1 x y)) ;; => ([:foo :bar] [:baz :qux])\n\n(defne match2 [x y]\n  ([[a b . tail] [b a . tail]]))\n\n(run* [r] (match2 '(a b c d) r)) ;; => ((b a c d))\n\n(defne match3 [x y]\n  ([[a . _] [a . _]]))\n\n(run* [r] (match3 [3 2 1] [3 4 5])) ;; => (_0)" ";; adapted from:\n;; http://stackoverflow.com/questions/11964055/constraining-two-vectors-to-be-in-the-same-domain-but-not-be-members-of-each-ot\n\n(defne not-membero [x l]\n  ([_ []])\n  ([_ [?y . ?r]]\n    (!= x ?y)\n    (not-membero x ?r)))\n\n(run* [q]\n  (not-membero q [:a :b :c])) ;; ((_0 :- (!= (_0 :a)) (!= (_0 :b)) (!= (_0 :c))) \n\n(run* [q]\n  (membero q [1 2 3 4 5])\n  (not-membero q [2 4])) ;; (1 3 5)"], :macro true, :notes nil, :arglists ["& rest"], :doc "Define a goal fn. Supports pattern matching. All\n   patterns will be tried. See conde.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/defne"}, :clojure.core/dec {:added "1.2", :ns "clojure.core", :name "dec", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/dec' :clojure.core/inc :clojure.core/unchecked-dec], :line 1134, :examples ["user=> (dec 2)\n1\n\nuser=> (dec 2.0)\n1.0\n\nuser=> (dec 1)\n0\n\nuser=> (dec -1)\n-2"], :notes nil, :arglists ["x"], :doc "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dec"}, :clojure.core/not {:added "1.0", :ns "clojure.core", :name "not", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/complement :clojure.core/false?], :line 524, :examples ["user=> (not true)\nfalse\nuser=> (not false)\ntrue\nuser=> (not nil)\ntrue\n\n;; acts as complement of `boolean`\nuser=> (boolean \"a string\")\ntrue\nuser=> (not \"a string\")\nfalse\nuser=> (boolean 1)\ntrue\nuser=> (not 1)\nfalse" "user=> (not (= \"a\" \"b\"))\ntrue"], :notes nil, :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true if x is logical false, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/not"}, :clojure.inspector/list-model {:ns "clojure.inspector", :name "list-model", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos nil, :line 129, :examples nil, :notes nil, :arglists ["provider"], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/list-model"}, :clojure.core.logic/defnu {:ns "clojure.core.logic", :name "defnu", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/defna :clojure.core.logic/defne :clojure.core.logic/defnc :clojure.core.logic/condu], :line 1733, :examples nil, :macro true, :notes nil, :arglists ["& rest"], :doc "Define a committed choice goal. See condu.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/defnu"}, :clojure.core/the-ns {:added "1.0", :ns "clojure.core", :name "the-ns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-name :clojure.core/create-ns], :line 4119, :examples [";; Let's play with a namespace by its name and by its symbol \n(def for-later-use (create-ns 'my-namespace))\n;;=> #'user/for-later-use\n\n(the-ns for-later-use)\n;;=> #<Namespace my-namespace>\n\n(the-ns 'my-namespace)\n;;=> #<Namespace my-namespace>\n\n;; not going to find anything this way because we just asked the repl\n;; not to perform an evaluate on it and there is not such \n;; namespace with the name \"for-later-use\"\n(the-ns 'for-later-use)\n;; java.lang.Exception: No namespace: for-later-use found (NO_SOURCE_FILE:0)\n\n;; not going to work either because \"my-namespace\" is the name of a namespace\n;; and not a symbol that points to something\n(the-ns my-namespace)\n;; java.lang.Exception: Unable to resolve symbol: my-namespace in this context (NO_SOURCE_FILE:12)\n"], :notes nil, :arglists ["x"], :doc "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/the-ns"}, :clojure.core.logic/tabled {:ns "clojure.core.logic", :name "tabled", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1997, :examples nil, :macro true, :notes nil, :arglists ["args & grest"], :doc "Macro for defining a tabled goal. Prefer ^:tabled with the\n  defne/a/u forms over using this directly.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/tabled"}, :clojure.core/unreduced {:added "1.7", :ns "clojure.core", :name "unreduced", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduced? :clojure.core/reduced :clojure.core/reduce :clojure.core/ensure-reduced], :line 2847, :examples ["(unreduced :foo)\n;;=> :foo\n\n(unreduced (reduced :foo))\n;;=> :foo\n\n(unreduced (clojure.lang.Reduced. :foo))\n;;=> :foo"], :notes nil, :arglists ["x"], :doc "If x is reduced?, returns (deref x), else returns x", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unreduced"}, :clojure.core/with-bindings* {:added "1.1", :ns "clojure.core", :name "with-bindings*", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-bindings], :line 1965, :examples ["user=> (let [f (fn [] *warn-on-reflection*)]\n         (with-bindings* {#'*warn-on-reflection* true} f))\ntrue"], :notes nil, :arglists ["binding-map f & args"], :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-bindings*"}, :clojure.core/*' {:added "1.0", :ns "clojure.core", :name "*'", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/*], :line 988, :examples [";; there is an implicit 1\n(*')\n;;=> 1 \n\n;; the implicit 1 comes into play\n(*' 6)\n;;=> 6\n\n(*' 2 3)\n;;=> 6\n\n(*' 2 3 4)\n;;=> 24\n\n(*' 0.5 200)\n;;=> 100.0\n\n;; great so it gives the same results as *.\n;; not quite check this out\n(* 1234567890 9876543210)\n;; ArithmeticException integer overflow\n(*' 1234567890 9876543210)\n;;=> 12193263111263526900N"], :notes nil, :arglists ["" "x" "x y" "x y & more"], :doc "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*'"}, :clojure.test/*report-counters* {:ns "clojure.test", :name "*report-counters*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 262, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*report-counters*"}, :clojure.core.logic.pldb/db-rel {:ns "clojure.core.logic.pldb", :name "db-rel", :file "clojure/core/logic/pldb.clj", :type "macro", :column 1, :see-alsos nil, :line 48, :examples nil, :macro true, :notes nil, :arglists ["name & args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db-rel"}, :clojure.core/vswap! {:added "1.7", :ns "clojure.core", :name "vswap!", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/volatile! :clojure.core/vreset! :clojure.core/volatile? :clojure.core/swap!], :line 2531, :examples ["(let [interrupt (volatile! false)\n      f1 (future (Thread/sleep 1000)\n                 (vswap! interrupt not))\n      f2 (future (while (not @interrupt)\n                        (println \"Another cycle!\")\n                        (Thread/sleep 100)))]\n  @f1\n  @f2)"], :macro true, :notes nil, :arglists ["vol f & args"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vswap!"}, :clojure.core/with-redefs-fn {:added "1.3", :ns "clojure.core", :name "with-redefs-fn", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/with-redefs], :line 7418, :examples ["(ns http)\n\n(defn post [url]\n  {:body \"Hello world\"})\n\n(ns app\n  (:require [clojure.test :refer [run-tests]]))\n\n(deftest is-a-fn\n  (with-redefs-fn {#'http/post (fn [url] {:body \"Hello world again\"})}\n    #(is (= {:body \"Hello world again\"} (http/post \"http://service.com/greet\")))))\n\n(run-tests) ;; test is passing" "=> (defn f [] false)\n\n=> (println (f))\n;; false\n\n=> (with-redefs-fn {#'f (fn [] true)} \n     #(println (f)))\n;; true" "(defn add-5 [n] (+ n 5))\n(with-redefs-fn {#'add-5 (fn [n] (+ n 50))}\n  #(is (= 60 (add-5 10))))\n\n;; Cannot redefine the reference in the partial function\n(def partial-add-5 (partial add-5))\n(with-redefs-fn {#'add-5 (fn [n] (+ n 50))}\n  #(is (= 15 (partial-add-5 10)))) \n"], :notes nil, :arglists ["binding-map func"], :doc "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-redefs-fn"}, :clojure.core/iterator-seq {:added "1.0", :ns "clojure.core", :name "iterator-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq], :line 5661, :examples [";; Note this is not strictly necessary since keySet is a collection\n;; implementing Iterable but it does show the usage.\n\nuser=> (iterator-seq (.iterator (.keySet (java.lang.System/getProperties))))\n\n(\"java.runtime.name\" \"sun.boot.library.path\" \"java.vm.version\" \"java.vm.vendor\" \"java.vendor.url\" \"path.separator\" \"java.vm.name\" \"file.encoding.pkg\" \"sun.java.launcher\" \"user.country\" \"sun.os.patch.level\" \"java.vm.specification.name\" \"user.dir\" \"java.runtime.version\" \"java.awt.graphicsenv\" \"java.endorsed.dirs\" \"os.arch\" \"javax.accessibility.assistive_technologies\" \"java.io.tmpdir\" \"line.separator\" \"java.vm.specification.vendor\" \"os.name\" \"cljr.home\" \"sun.jnu.encoding\" \"java.library.path\" \"java.specification.name\" \"java.class.version\" \"sun.management.compiler\" \"os.version\" \"user.home\" \"user.timezone\" \"java.awt.printerjob\" \"file.encoding\" \"java.specification.version\" \"include.cljr.repo.jars\" \"java.class.path\" \"user.name\" \"java.vm.specification.version\" \"java.home\" \"sun.arch.data.model\" \"user.language\" \"java.specification.vendor\" \"java.vm.info\" \"java.version\" \"java.ext.dirs\" \"sun.boot.class.path\" \"java.vendor\" \"file.separator\" \"java.vendor.url.bug\" \"clojure.home\" \"sun.io.unicode.encoding\" \"sun.cpu.endian\" \"sun.desktop\" \"sun.cpu.isalist\")\n" ";; Java 8 streams as sequences\n(->> \"Clojure is the best language\"\n  (.splitAsStream #\"\\s+\")\n  .iterator\n  iterator-seq)\n\n;; (\"Clojure\" \"is\" \"the\" \"best\" \"language\")"], :notes ["I've noticed that I needed to use iterator-seq when trying to map over a Java function that returns an AbstractList Iterator. It was not directly seq-able."], :arglists ["iter"], :doc "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/iterator-seq"}, :clojure.core.async/<! {:ns "clojure.core.async", :name "<!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/take! :clojure.core.async/<!! :clojure.core.async/>!], :line 116, :examples ["user=> (def c (chan 1))\n#'user/c\n\nuser=> (go-loop [data (<! c)]\n         (println \"Waited for => \" data)\n         (println \"No recur. Won't print again\"))\n\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@6a3d3df4>\n\nuser=> (put! c \"Example Async Data\")\n\nnil\n\nWaited for =>  Example Async Data\nNo recur. Won't print again\n\nuser=> (put! c \"Example Async Data\")\nnil\n" ";; Clojure 1.7\nuser=> (let [c (chan 1 (filter pos?))]\n \n         (go-loop []\n           (let [nums (<! c)]\n             (println nums))\n           (recur))\n   \n         (doseq [n (range -10 10)]\n           (put! c n)))\nnil\n1\n2\n3\n4\n5\n6\n7\n8\n9\n"], :notes nil, :arglists ["port"], :doc "takes a val from port. Must be called inside a (go ...) block. Will\n  return nil if closed. Will park if nothing is available.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/<!"}, :clojure.core.async/thread-call {:ns "clojure.core.async", :name "thread-call", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/thread :clojure.core.async/go], :line 430, :examples ["(defn fake-fetch []\n  (Thread/sleep 5000) \n  \"Ready!\")\n\n;; returns immediately, prints \"Ready!\" after 5 secs\n(let [c (thread-call fake-fetch)]\n  (go (println (<! c))))"], :notes nil, :arglists ["f"], :doc "Executes f in another thread, returning immediately to the calling\n  thread. Returns a channel which will receive the result of calling\n  f when completed, then close.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/thread-call"}, :clojure.core/sequence {:added "1.0", :ns "clojure.core", :name "sequence", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq :clojure.core/eduction], :line 2639, :examples ["user> (sequence [1 2 3])\n(1 2 3)\nuser> (class (sequence '(1 2 3)))\nclojure.lang.PersistentList" ";; let us make a transducer\nuser=> (def xf (comp (filter odd?) (take 5)))\n#'user/xf\nuser=> (sequence xf (range 1 10))\n(1 3 5 7 9)" ";; turns a string into a sequence of characters:\n(sequence \"abc\")\n=> (\\a \\b \\c)" ";; combine a bunch of collections together\n(sequence cat [[1 2 3] [5 6 7] [8 9 0]])\n;=> (1 2 3 5 6 7 8 9 0) \n(sequence cat [ '(1 2 3) '(5 6 7) '(8 9 0)))\n;=> (1 2 3 5 6 7 8 9 0)"], :notes ["Interesting background about `sequence` versus `eduction`: https://groups.google.com/d/msg/clojure/9I6MtgOTD0w/NiG5PimBCP8J"], :arglists ["coll" "xform coll" "xform coll & colls"], :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sequence"}, :clojure.core/complement {:added "1.0", :ns "clojure.core", :name "complement", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/not], :line 1425, :examples [";; a simple not-empty? predicate\n(def not-empty? (complement empty?))\n;; #'user/not-empty?\n\n(not-empty? [])    ;;=> false\n(not-empty? [1 2]) ;;=> true\n\n\n;; a slightly more complex example\n;; this function takes two arguments, and sometimes returns nil\n(defn contains-char? [the-string, the-char]\n         (some #(= the-char %) the-string))\n;; #'user/contains-char?\n\n(contains-char? \"abc\" \\b) ;;=> true\n(contains-char? \"abc\" \\j) ;;=> nil\n\n;; define the complement, to check if a char is absent\n(def does-not-contain-char? (complement contains-char?))\n;; #'user/does-not-contain-char?\n\n;; our complement does exactly what we expect\n(does-not-contain-char? \"abc\" \\b)  ;;=> false\n(does-not-contain-char? \"abc\" \\j)  ;;=> true\n" "(map (complement even?) '(1 2 3 4))\n\n;; return...\n;; (true false true false)\n\n;; see also ...\n(map even? '(1 2 3 4))\n;; (false true false true)\n\n;; WORNING\n;; This function returns ERROR!!!\n(map (not even?) '(1 2 3 4))\n\n(map #(not (even? %)) '(1 2 3 4)) ; This works\n" "(def not-empty? (complement empty?))\n\n(not-empty? \"abcde\")\n;;true\n\n(not-empty? \"\")\n;;false"], :notes nil, :arglists ["f"], :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/complement"}, :clojure.core.logic/bindable? {:ns "clojure.core.logic", :name "bindable?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 732, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/bindable_q"}, :clojure.spec.alpha/fdef {:ns "clojure.spec.alpha", :name "fdef", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 695, :examples [";; Example from Clojure.org spec guide:\n;; https://clojure.org/guides/spec\n\n(require '[clojure.spec.alpha :as s])\n\n(s/fdef ranged-rand\n  :args (s/and (s/cat :start int? :end int?)\n               #(< (:start %) (:end %)))\n  :ret int?\n  :fn (s/and #(>= (:ret %) (-> % :args :start))\n             #(< (:ret %) (-> % :args :end))))"], :macro true, :notes nil, :arglists ["fn-sym & specs"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner clojure.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef clojure.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/fdef"}, :clojure.spec.alpha/explain* {:ns "clojure.spec.alpha", :name "explain*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec path via in x"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain*"}, :clojure.core/transient {:added "1.1", :ns "clojure.core", :name "transient", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/persistent! :clojure.core/conj! :clojure.core/assoc! :clojure.core/pop! :clojure.core/dissoc! :clojure.core/disj!], :line 3334, :examples [";; As seen on http://clojure.org/transients\n;; array is initially made transient, modified, then finally made persistent.\n;; See assoc! for further discussion of why it must be done this way.\n\n(defn vrange2 [n]\n  (loop [i 0 v (transient [])]\n    (if (< i n)\n      (recur (inc i) (conj! v i))\n      (persistent! v))))\n\nuser=> (vrange2 10)\n[0 1 2 3 4 5 6 7 8 9]" "user> (def foo (transient [1 2 3]))\n#'user/foo\nuser> (get foo 0)\n1\nuser> (count foo)\n3\nuser> (nth foo 0)\n1\nuser> (def bar (transient {:honda 7 :kagawa 23 :ienaga 14}))\n#'user/bar\nuser> (get bar :kagawa)\n23\nuser> (count bar)\n3\n\n;; There is a known bug in Clojure 1.3 thru 1.6 where contains? always returns\n;; false for transients.  http://dev.clojure.org/jira/browse/CLJ-700\n;; contains? works fine for persistent data structures.\nuser> (contains? bar :kagawa)  ; Caution! \nfalse\nuser> (def bar2 (persistent! bar))\n#'user/bar2\nuser> (contains? bar2 :kagawa) ; Caution!\ntrue\n"], :notes nil, :arglists ["coll"], :doc "Returns a new, transient version of the collection, in constant time.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/transient"}, :clojure.core/select-keys {:added "1.0", :ns "clojure.core", :name "select-keys", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get :clojure.core/keys :clojure.core/dissoc :clojure.core/hash-map], :line 1532, :examples ["user=> (select-keys {:a 1 :b 2} [:a])\n{:a 1}\nuser=> (select-keys {:a 1 :b 2} [:a :c])\n{:a 1}\nuser=> (select-keys {:a 1 :b 2 :c 3} [:a :c])\n{:c 3, :a 1}" "user=> (select-keys [1 2 3] [0 0 2])\n{0 1, 2 3}" ";; Extract letters at even indexes from a word into a map:\n(let [word \"hello\"] \n  (select-keys (vec word) (filter even? (range (count word)))))\n;; {0 \\h, 2 \\l, 4 \\o}"], :notes ["Why does `select-keys` return a map with keys in reverse order of the keyseq vector?\n\nJay Fields has a [good blog post](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html) on `select-keys` with implementations of `select-values` (which is what I was really after)." "I think @gknapp is correct. `select-keys` returns a map with keys in the order of the keyseq vector. Perhaps this has changed since his comment, and the documentation needs to be updated. \n \n```clojure\nuser=> (select-keys {:a 1 :b 2 :c 3} [:a :c])\n{:a 1, :c 3}\nuser=> (select-keys {:a 1 :b 2 :c 3} [:c :a])\n{:c 3, :a 1}\n```\n\n" "Wouldn't the following signature be better for partial application?  \n\n    (select-keys keyseq map)\n\n    (def stooges [{:name \"Larry\" :birthday \"Oct 05\"} \n                  {:name \"Curly\" :birthday \"Jun 19\"} \n                  {:name \"Moe\"   :birthday \"Oct 22\"}])\n\nTacit style is about consistent order (general to specific), not concision:\n\n    (map (partial select-keys [:name]) stooges) ;tacit\n    (map #(select-keys % [:name]) stooges)" "If you are looking for a `select-vals` or `select-values` alternative of this function, you can do the following:\n\n<pre>\n(map {:a 1 :b 2 :c 3 :d 4} [:a :d])\n;;=> (1 4)\n</pre>" "`select-keys` will return in the order provided for `array-maps`. However, `array-maps` turn into `hash-maps` at a certain threshold, which are un-ordered. So generally, when you need certain ordering, use a sequence instead."], :arglists ["map keyseq"], :doc "Returns a map containing only those entries in map whose key is in keys", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/select-keys"}, :clojure.spec.alpha/Specize {:ns "clojure.spec.alpha", :name "Specize", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :line 121, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/Specize"}, :clojure.zip/edit {:added "1.0", :ns "clojure.zip", :name "edit", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/root :clojure.zip/zipper], :line 210, :examples ["(require '[clojure.xml :as xml]\n         '[clojure.zip :as zip])\n\n;; get xml with content added to root child\n(let [root      (zip/xml-zip (xml/parse-str \"<root><child/></root>\"))\n      child     (zip/down root)\n      new-child (zip/edit child #(assoc-in % [:content] \"content\"))\n      new-root  (zip/root new-child)]\n  (xml/emit-str new-root))\n;;=> \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><root><child>content</child></root>\""], :notes nil, :arglists ["loc f & args"], :doc "Replaces the node at this loc with the value of (f node args)", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/edit"}, :clojure.test/file-position {:added "1.1", :ns "clojure.test", :name "file-position", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 282, :examples ["(clojure.test/file-position 0)\n; => [\"test.clj\" 282]\n\n(take 5 (map clojure.test/file-position (range)))\n; => ([\"test.clj\" 282]\n;     [\"test.clj\" 282]\n;     [\"core.clj\" 2747]\n;     [\"LazySeq.java\" 40]\n;     [\"LazySeq.java\" 49])\n"], :deprecated "1.2", :notes nil, :arglists ["n"], :doc "Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/file-position"}, :clojure.core/unchecked-add {:added "1.0", :ns "clojure.core", :name "unchecked-add", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-dec :clojure.core/unchecked-inc :clojure.core/unchecked-negate :clojure.core/unchecked-divide :clojure.core/unchecked-subtract :clojure.core/unchecked-multiply :clojure.core/unchecked-remainder :clojure.core/+ :clojure.core/+'], :line 1190, :examples [";; can't interchange INTs with LONGs, only F(int, int) or F(long, long)\n;; F is a function, not an operator.\n;; overflow very easily as shown below.\n\nuser=> (unchecked-add Integer/MAX_VALUE 0)\n2147483647\n\nuser=> (unchecked-add Integer/MAX_VALUE 1)\n-2147483648\n\nuser=> (unchecked-add Integer/MAX_VALUE Integer/MAX_VALUE)\n-2\n\nuser=> (unchecked-add Integer/MAX_VALUE Long/MAX_VALUE)\njava.lang.IllegalArgumentException: No matching method found: unchecked_add (NO_SOURCE_FILE:0)\n\nuser=> (unchecked-add Integer/MAX_VALUE Long/MAX_VALUE)\njava.lang.IllegalArgumentException: No matching method found: unchecked_add (NO_SOURCE_FILE:0)\n\nuser=> (unchecked-add Long/MAX_VALUE Long/MAX_VALUE)\n-2\n\nuser=> (unchecked-add 5 Long/MAX_VALUE)\njava.lang.IllegalArgumentException: No matching method found: unchecked_add (NO_SOURCE_FILE:0)\n\nuser=> (unchecked-add 5555555555 Long/MAX_VALUE)\n-9223372031299220254"], :notes nil, :arglists ["x y"], :doc "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-add"}, :clojure.core/take-last {:added "1.1", :ns "clojure.core", :name "take-last", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/last :clojure.core/butlast :clojure.core/drop-last :clojure.core/subvec], :line 2933, :examples ["user=> (take-last 2 [1 2 3 4])\n(3 4)\n\nuser=> (take-last 2 [4])\n(4)\n\nuser=> (take-last 2 [])\nnil\n\nuser=> (take-last 2 nil)\nnil\n\nuser=> (take-last 0 [1])\nnil\n\nuser=> (take-last -1 [1])\nnil"], :notes ["Unlike \"drop-last\" (but like \"last\"), \"take-last\" is not lazy:\n\n<pre>\n(def bomb (take-last 1 (range))) ;; infinite evaluation, never returns\n(def lazy-bomb (drop-last 1 (range))) ;; good, but don't use!\n</pre>"], :arglists ["n coll"], :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/take-last"}, :clojure.inspector/get-child {:ns "clojure.inspector", :name "get-child", :file "clojure/inspector.clj", :type "var", :column 1, :see-alsos nil, :line 32, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/get-child"}, :clojure.core/dosync {:added "1.0", :ns "clojure.core", :name "dosync", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/sync :clojure.core/ref :clojure.core/locking], :line 5016, :examples [";; Keep dosync body free of side-effects:\n(defn my-thread-unsafe-fn [important-ref]\n    (let [start-work (ref false)]\n       (dosync\n           (when (not @important-ref)\n                ;\"If a conflict occurs between 2 transactions \n                ;trying to modify the same reference, \n                ;one of them will be retried.\"\n                ;http://clojure.org/concurrent_programming\n                (ref-set important-ref true)\n                (ref-set start-work true)))\n        (when @start-work \n             ;launch side-effects here\n            )))\n" ";; Create 2 bank accounts\n(def acc1 (ref 100))\n(def acc2 (ref 200))\n\n;; How much money is there?\n(println @acc1 @acc2)\n;; => 100 200\n\n;; Either both accounts will be changed or none\n(defn transfer-money [a1 a2 amount]\n  (dosync\n    (alter a1 - amount)\n    (alter a2 + amount)\n    amount)) ; return amount from dosync block and function (just for fun)\n\n;; Now transfer $20\n(transfer-money acc1 acc2 20)\n;; => 20\n\n;; Check account balances again\n(println @acc1 @acc2)\n;; => 80 220\n\n;; => We can see that transfer was successful"], :macro true, :notes nil, :arglists ["& exprs"], :doc "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dosync"}, :clojure.core/prefer-method {:added "1.0", :ns "clojure.core", :name "prefer-method", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/prefers :clojure.core/get-method :clojure.core/methods], :line 1795, :examples ["(def m {:os ::osx})\n\n(defmulti ex :os)\n\n(defmethod ex ::unix\n [_]\n \"unix\")\n\n(derive ::osx ::unix)\n\n(ex m)\n;;=> \"unix\"\n\n(defmethod ex ::bsd\n  [_]\n  \"bsd\")\n\n(derive ::osx ::bsd)\n\n;; which one to choose ::unix or ::bsd ?? -> Conflict!!!\n(ex m)\n;;=> IllegalArgumentException Multiple methods in multimethod 'ex' match...\n\n(prefer-method ex ::unix ::bsd)\n\n(ex m)\n;;=> \"unix\"\n\n"], :notes nil, :arglists ["multifn dispatch-val-x dispatch-val-y"], :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/prefer-method"}, :clojure.core.logic.fd/interval->= {:ns "clojure.core.logic.fd", :name "interval->=", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 51, :examples nil, :notes nil, :arglists ["i j"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval->="}, :clojure.test/inc-report-counter {:added "1.1", :ns "clojure.test", :name "inc-report-counter", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 314, :examples nil, :notes nil, :arglists ["name"], :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/inc-report-counter"}, :clojure.core/find-var {:added "1.0", :ns "clojure.core", :name "find-var", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 2007, :examples ["user=> (find-var 'clojure.core/map)\n#'clojure.core/map\nuser=> (find-var 'clojure.core/qwerty)\nnil\nuser=> (find-var 'map)\nIllegalArgumentException Symbol must be namespace-qualified  clojure.lang.Var.find (Var.java:150)\n"], :notes ["For namespaces other than those in Clojure, you must do `(require 'the-ns)` first, followed by `(find-var 'the-ns/the-name)`. Failing to do this leads to `IllegalArgumentException` thrown complaining about no such namespace."], :arglists ["sym"], :doc "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find-var"}, :clojure.core/*clojure-version* {:added "1.0", :ns "clojure.core", :name "*clojure-version*", :file "clojure/core.clj", :type "var", :column 3, :see-alsos [:clojure.core/clojure-version], :dynamic true, :line 6989, :examples ["user=> *clojure-version*\n{:interim true, :major 1, :minor 2, :incremental 0, :qualifier \"master\"}"], :notes nil, :arglists [], :doc "The version info for Clojure core, as a map containing :major :minor \n  :incremental and :qualifier keys. Feature releases may increment \n  :minor and/or :major, bugfix releases will increment :incremental. \n  Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\"", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*clojure-version*"}, :clojure.string/split-lines {:added "1.2", :ns "clojure.string", :name "split-lines", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/split], :line 228, :examples ["user=> (clojure.string/split-lines \"test \\n string\")\n[\"test \" \" string\"]" "; ignores trailing newlines\nuser=> (clojure.string/split-lines \"test\\n\\n\")\n[\"test\"]" ";; About ignoring trailing newlines: split-lines is implemented something like:\nuser=> (clojure.string/split s #\"\\r?\\n\")\n\n;; To always get all the lines, you need to use split instead,\n;; and supply a negative third argument:\nuser=> (clojure.string/split \"\\ntest\\n\\n\" #\"\\r?\\n\" -1)\n;;=> [\"\" \"test\" \"\" \"\"]"], :notes nil, :arglists ["s"], :doc "Splits s on \\n or \\r\\n.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/split-lines"}, :clojure.core/char-array {:added "1.1", :ns "clojure.core", :name "char-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/into-array :clojure.core/to-array :clojure.core/chars], :line 5241, :examples ["user> (char-array \"asdf\")\n#<char[] [C@167fc18>\n\nuser> (seq (char-array \"asdf\"))\n(\\a \\s \\d \\f)\n\nuser> (seq (char-array 10))\n(\\^@ \\^@ \\^@ \\^@ \\^@ \\^@ \\^@ \\^@ \\^@ \\^@)"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of chars", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/char-array"}, :clojure.core/bounded-count {:added "1.9", :ns "clojure.core", :name "bounded-count", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/counted?], :line 7304, :examples [";;;; Length of a vector can be determined in constant time\n;;;; so this always returns the actual length of the vector\n\n(bounded-count 5 [1 2 3 4])\n;;=> 4\n(bounded-count 5 [1 2 3 4 5])\n;;=> 5\n(bounded-count 5 [1 2 3 4 5 6])\n;;=> 6\n\n;;;; Length of a lazy seq cannot be determined in constant time\n;;;; so this counts at most the first 5 elements\n\n(bounded-count 5 (map identity [1 2 3 4]))\n;;=> 4\n(bounded-count 5 (map identity [1 2 3 4 5]))\n;;=> 5\n(bounded-count 5 (map identity [1 2 3 4 5 6]))\n;;=> 5" ";;;; This would run forever\n\n(count (range))\n\n;;;; But this doesn't\n\n(bounded-count 10000 (range))\n;;=> 10000\n"], :notes nil, :arglists ["n coll"], :doc "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bounded-count"}, :clojure.core/vector? {:added "1.0", :ns "clojure.core", :name "vector?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/set? :clojure.core/vec :clojure.core/map? :clojure.core/list? :clojure.core/sequential?], :line 174, :examples [";; this is the idiomatic vector \n(vector? [1 2 3])\n;;=> true\n\n;; a list is not a vector\n(vector? '(1 2 3))\n;;=> false\n\n;; a list may be converted into a vector\n(vector? (vec '(1 2 3)))\n;;=> true\n\n;; a map is not a vector\n(vector? {:a 1 :b 2 :c 3})\n;;=> false\n\n;; a set is not a vector\n(vector? #{:a :b :c})\n;;=> false\n\n(first {:a 1 :b 2 :c 3})\n;;=> [:c 3]\n(vector? (first {:a 1 :b 2 :c 3}))\n;;=> true" ";; an quoted vector is still a vector\n(vector? '[])\n;;=> true"], :notes nil, :arglists ["x"], :doc "Return true if x implements IPersistentVector", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vector_q"}, :clojure.core/random-sample {:added "1.7", :ns "clojure.core", :name "random-sample", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7593, :examples [";; The output of random-sample is a sequence.\n;; Each element of the original collection has probability \"prob\"\n;; of being included in the output sequence.\n\n(random-sample 0.5 [1 2 3 4 5])\n;;=> (1 2 4)\n\n\n;; random-sample can operate on an infinite sequence,\n;; producing an infinite sequence.\n\n(take 10 (random-sample 0.1 (repeat :foo)))\n;;=> (:foo :foo :foo :foo :foo :foo :foo :foo :foo :foo)\n\n(take 10 (random-sample 0.01 (range)))\n;;=> (57 113 281 286 352 497 727 768 957 960)"], :notes nil, :arglists ["prob" "prob coll"], :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/random-sample"}, :clojure.pprint/pprint-tab {:added "1.2", :ns "clojure.pprint", :name "pprint-tab", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos nil, :line 356, :examples nil, :notes nil, :arglists ["kind colnum colinc"], :doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pprint-tab"}, :clojure.core.async/sub* {:ns "clojure.core.async", :name "sub*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["p v ch close?"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/sub*"}, :clojure.test/testing-contexts-str {:added "1.1", :ns "clojure.test", :name "testing-contexts-str", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 307, :examples nil, :notes nil, :arglists [""], :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/testing-contexts-str"}, :clojure.spec.alpha/maybe-impl {:ns "clojure.spec.alpha", :name "maybe-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1398, :examples nil, :notes nil, :arglists ["p form"], :doc "Do not call this directly, use '?'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/maybe-impl"}, :clojure.core.logic/log {:ns "clojure.core.logic", :name "log", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1288, :examples nil, :macro true, :notes nil, :arglists ["& s"], :doc "Goal for println", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/log"}, :clojure.core/butlast {:added "1.0", :ns "clojure.core", :name "butlast", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/rest :clojure.core/last :clojure.core/next :clojure.core/drop-last :clojure.core/take-last :clojure.core/pop], :line 272, :examples ["user=> (butlast [1 2 3])\n(1 2)\nuser=> (butlast (butlast [1 2 3]))\n(1)\nuser=> (butlast (butlast (butlast [1 2 3])))\nnil" ";really slow reverse\n;put the last item of the list at the start of a new list, and recur over all but the last item of the list.\n;butlast acts similar to next in that it returns null for a 1-item list.\n\n(defn my-reverse [xs]\n  (when xs\n    (cons (last xs) (my-reverse (butlast xs)))))" ";; A version of (into) that doesn't require (comp)\n;; for transducers arguments.\n\n(defn into* [to & args]\n  (into to\n    (apply comp (butlast args))\n    (last args)))\n\n(into* [] (range 10))\n;; [0 1 2 3 4 5 6 7 8 9]\n\n(into* [] (map inc) (range 10))\n;; [1 2 3 4 5 6 7 8 9 10]\n\n(into* [] (map inc) (filter odd?) (range 10))\n;; [1 3 5 7 9]"], :notes ["When using a vector, `pop` is faster than `butlast`." "`pop` will throw exception if the vector is empty, whereas `butlast` will return `nil`"], :arglists ["coll"], :doc "Return a seq of all but the last item in coll, in linear time", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/butlast"}, :clojure.java.shell/*sh-env* {:ns "clojure.java.shell", :name "*sh-env*", :file "clojure/java/shell.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 19, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.shell/*sh-env*"}, :clojure.core.logic/annotate {:ns "clojure.core.logic", :name "annotate", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 547, :examples nil, :notes nil, :arglists ["k v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/annotate"}, :clojure.spec.alpha/form {:ns "clojure.spec.alpha", :name "form", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 159, :examples nil, :notes nil, :arglists ["spec"], :doc "returns the spec as data", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/form"}, :clojure.core.logic.pldb/empty-db {:ns "clojure.core.logic.pldb", :name "empty-db", :file "clojure/core/logic/pldb.clj", :type "var", :column 1, :see-alsos nil, :line 6, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/empty-db"}, :clojure.core.logic.fd/bounded-listo {:ns "clojure.core.logic.fd", :name "bounded-listo", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1085, :examples nil, :notes nil, :arglists ["l n"], :doc "Ensure that the list l never grows beyond bound n.\n   n must have been assigned a domain.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/bounded-listo"}, :clojure.core/interpose {:added "1.0", :ns "clojure.core", :name "interpose", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/interleave :clojure.string/join], :line 5146, :examples [";; The quintessential interpose example:\nuser> (def my-strings [\"one\" \"two\" \"three\"])\n\nuser> (interpose \", \" my-strings)\n=> (\"one\" \", \" \"two\" \", \" \"three\")\n\nuser> (apply str (interpose \", \" my-strings))\n=> \"one, two, three\"\n\n;; Might use clojure.string/join if the plan is to join\n(use '[clojure.string :only (join)])\nuser> (join \", \" my-strings)\n=> \"one, two, three\"" ";; This example converts what would be comma-separated values into pipe '|'\n;; separated values for alternate database loads. By switching delimiters, \n;; quotes can be eliminated from each sequence element, which are not \n;; needed for some databases.\n\n(def test-data-in '((\"43\" \"MORRISON, VAN X DMD\" \"43 ROADWAY\"     \\;)\n                    (\"25\" \"JANE SMITH N\"        \"25 GARDEN PATH\" \\!)))\n\n(def test-data-out (map #(concat (interpose \\| %) (list \\| \"\\n\"))\n                        test-data-in))\n\ntest-data-out\n\n=> ((\"43\" \\| \"MORRISON, VAN X DMD\" \\| \"43 ROADWAY\" \\| \\; \\| \"\\n\")\n    (\"25\" \\| \"JANE SMITH N\" \\| \"25 GARDEN PATH\" \\| \\! \\| \"\\n\"))\n\n(doseq [in-seq test-data-out]\n  (doseq [val in-seq]\n    (spit \"temp1.csv\" val :append true)))\n\n;; cat temp1.csv:\n\n;; 43|MORRISON, VAN X DMD|43 ROADWAY|;|\n;; 25|JANE SMITH N|25  GARDEN PATH|!|"], :notes nil, :arglists ["sep" "sep coll"], :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/interpose"}, :clojure.core/proxy-mappings {:added "1.0", :ns "clojure.core", :name "proxy-mappings", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos nil, :line 323, :examples nil, :notes nil, :arglists ["proxy"], :doc "Takes a proxy instance and returns the proxy's fn map.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/proxy-mappings"}, :clojure.core/bit-shift-right {:added "1.0", :ns "clojure.core", :name "bit-shift-right", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-shift-left :clojure.core/bit-xor :clojure.core/bit-or :clojure.core/bit-and :clojure.core/bit-set :clojure.core/bit-test :clojure.core/bit-flip :clojure.core/bit-and-not :clojure.core/bit-clear :clojure.core/unsigned-bit-shift-right], :line 1354, :examples [";; Convert number into list of bits:\n(defn bits [n s]\n  (take s\n       (map\n         (fn [i] (bit-and 0x01 i))\n         (iterate\n           (fn [i] (bit-shift-right i 1))\n           n))))\n;; #'user/bits\n\n(map (fn [n] (bits n 3)) (range 8))\n;;=> ((0 0 0) (1 0 0) (0 1 0) (1 1 0) (0 0 1) (1 0 1) (0 1 1) (1 1 1))\n" "(bit-shift-right 2r1101 0)     ;;=> 13\n(bit-shift-right 2r1101 1)     ;;=>  6\n(bit-shift-right 2r1101 2)     ;;=>  3\n(bit-shift-right 2r1101 3)     ;;=>  1\n(bit-shift-right 2r1101 4)     ;;=>  0" ";; Warning: bit-shift-right upcasts arguments to Long and returns Long\n(format \"0x%x\" (byte -128))\n; => \"0x80\"\n(format \"0x%x\" (bit-shift-right (byte -128) 1)) ; You'd expect 0x40?\n; => \"0xffffffffffffffc0\"\n; You'd expect 0x40, but (byte -128) was converted to (long -128) and then\n; right-shifted, with the negative sign bit of 1 propagated.\n\n; This can't be avoided by using unsigned-bit-shift-right:\n(format \"0x%x\" (unsigned-bit-shift-right (byte -128) 1))\n; => \"0x7fffffffffffffc0\"\n\n; If you want unsigned \"byte\" operations, upcast the byte yourself via bit-and:\n(format \"0x%x\" (bit-shift-right (bit-and 0xff (byte -128)) 1))\n; => \"0x40\"\n\n; This works because the output of bit-and is always Long:\n(type (bit-and 0xff (byte -128)))\n; => java.lang.Long\n; Note that bit-and returns Long even if both arguments are smaller:\n(type (bit-and (short 0xff) (byte -128)))\n; => java.lang.Long" ";; floating point bit-shifting\n;; thanks to Gary Fredericks: https://github.com/gfredericks/doubles\n(defn bit-shift-double [x shifts]\n  (let [x-long (Double/doubleToRawLongBits x)]\n    (Double/longBitsToDouble\n     (bit-or (bit-and 1 x-long)\n             (bit-shift-left (- (bit-shift-right x-long 52) shifts) 52)\n             (bit-and 0xfffffffffffff x-long)))))"], :notes ["From the IRC channel, a way to get zero-fill bit-shift-right:\r\n\r\n<pre>06:08 &lt; mikera&gt; (defn &gt;&gt;&gt; [v bits] (bit-shift-right (bit-and 0xFFFFFFFF v) bits))</pre>\r\n\r\nThere's also an open ticket for a [built-in version](http://dev.clojure.org/jira/browse/CLJ-827)." "unsigned-bit-shift-right was added in Clojure 1.6.0.  Click the link in the See Also section above."], :arglists ["x n"], :doc "Bitwise shift right", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-shift-right"}, :clojure.core/every? {:added "1.0", :ns "clojure.core", :name "every?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/some :clojure.core/not-any? :clojure.core/not-every?], :line 2664, :examples ["user=> (every? even? '(2 4 6))\ntrue\nuser=> (every? even? '(1 2 3))\nfalse" ";; you can use every? with a set as the predicate to return true if \n;; every member of a collection is in the set\nuser=> (every? #{1 2} [1 2 3])\nfalse\nuser=> (every? #{1 2} [1 2])\ntrue\n\n;; or use a hash-map as the predicate with every? to return true \n;; if every member of a collection is a key within the map\nuser=> (every? {1 \"one\" 2 \"two\"} [1 2])\ntrue\nuser=> (every? {1 \"one\" 2 \"two\"} [1 2 3])\nfalse" ";; this is kind of weird IMO... but it works that way (the same for vectors)\n;; See: https://en.wikipedia.org/wiki/Vacuous_truth\nuser=> (every? true? '())\ntrue\nuser=> (every? false? '())\ntrue\n\n;; As such a better description of every? would be\n\n;; Returns false if there exists a value x in coll \n;; such that (pred? x) is false, else true.\" " ";; every? can replace clojure.set/subset? if and only if\n;; the sets do not contain false / nil values\n\n(subset? #{1}   #{1 2}) ;;=> true\n(every?  #{1 2} #{1}  ) ;;=> true ✔\n\n(subset? #{1 3} #{1 2}) ;;=> false\n(every?  #{1 2} #{1 3}) ;;=> false ✔\n\n;; however, invoking a set with a value returns the matched element,\n;; causing the comparison below to fail\n\n(subset? #{true false} #{true false}) ;;=> true\n(every?  #{true false} #{true false}) ;;=> false ✘ 😦\n"], :notes nil, :tag "java.lang.Boolean", :arglists ["pred coll"], :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/every_q"}, :clojure.core/subs {:added "1.0", :ns "clojure.core", :name "subs", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.string/replace :clojure.string/split :clojure.string/replace-first :clojure.core/re-find :clojure.core/re-seq :clojure.core/re-matches], :line 4921, :examples ["user=> (subs \"Clojure\" 1)    \n\"lojure\"\nuser=> (subs \"Clojure\" 1 3)\n\"lo\"\n\n\n;; String indexes have to be between 0 and (.length s)\n\nuser=> (subs \"Clojure\" 1 20)\njava.lang.StringIndexOutOfBoundsException: String index out of range: 20 (NO_SOURCE_FILE:0)\n" ";; Note that subs uses method java.lang.String/substring\n;; http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#substring%28int,%20int%29\n\n;; See this link for more details:\n\n;; https://dzone.com/articles/changes-stringsubstring-java-7\n\n;; This link was the original, but seems to no longer exist as of Nov 2017:\n;; http://www.javaadvent.com/2012/12/changes-to-stringsubstring-in-java-7.html\n\n;; Briefly, before Java version 7u6, Java's substring method was\n;; guaranteed to work in O(1) time, by creating a String that refers\n;; to the original string's characters, rather than copying them.\n\n;; After Java 7u6, substring was changed to copy the string's original\n;; characters, thus taking time linear in the length of the substring,\n;; but it never refers to the original string.\n\n;; The potential disadvantage of the pre-version-7u6 behavior is that\n;; if you read in one or more strings with a large total size, and then\n;; use methods based on substring to keep only a small subset of that,\n;; e.g., because you parsed and found a small collection of substrings of\n;; interest for your computation, the large strings will still have\n;; references to them, and thus cannot be garbage collected, even if you\n;; have no other references to them.\n\n;; You can use the Java constructor (String. s) to guarantee that you\n;; copy a string s.  (String. (subs s 5 20)) will copy the substring once\n;; pre-version-7u6, but it will copy the substring twice\n;; post-version-7u6.\n\n;; I believe java.util.regex.Matcher method group, and\n;; java.util.regex.Pattern method split, also have the same\n;; behavior as substring.\n\n;; This affects the behavior of Clojure functions such as:\n\n;; In clojure.core:\n;; subs, re-find, re-matches, re-seq\n;; In clojure.string:\n;; replace replace-first split\n" ";; Suppose you want to shorten a string of blanks [outdent]\n;; Starting with a string of length 5\n;; [Here I do not use blanks to illustrate what is happening]\n(def s5 \"abcdef\")\n;; and reducing its length by 2\n(subs s5 (min 2 (count s5))) \n;=> \"cdef\"\n(subs s5 (min 10 (count s5))) \n;=> \"\""], :notes nil, :arglists ["s start" "s start end"], :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/subs"}, :clojure.core/memfn {:added "1.0", :ns "clojure.core", :name "memfn", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 3837, :examples ["user=> (def *files* (file-seq (java.io.File. \"/tmp/\")))\n#'user/*files*\nuser=> (count (filter (memfn isDirectory) *files*))\n68\nuser=> (count (filter #(.isDirectory %) *files*))\n68\n" "user=> ;; you must pass arguments to your method to add up to the expected arity\n\nuser=> (def starts-with (memfn startsWith prefix))\n#'user/starts-with\nuser=> (starts-with \"pikachu\" \"pika\")\ntrue\nuser=> (starts-with \"pikachu\" \"bulba\")\nfalse" "(set! *warn-on-reflection* true)\n\n;; memfn is inherently subject to reflective calls\n\n(time (dotimes [n 100000] (mapv (memfn toLowerCase) [\"A\" \"B\" \"C\"])))\n;; Reflection warning, call to toLowerCase can't be resolved\n;; \"Elapsed time: 794.081758 msecs\"\n\n;; But accepts and propagate type hints to avoid it\n\n(time (dotimes [n 100000] (mapv (memfn ^String toLowerCase) [\"A\" \"B\" \"C\"])))\n;; \"Elapsed time: 33.708462 msecs\""], :macro true, :notes nil, :arglists ["name & args"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/memfn"}, :clojure.core/+' {:added "1.0", :ns "clojure.core", :name "+'", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/+ :clojure.core/unchecked-add], :line 964, :examples ["(+')\n;;=> 0\n\n(+' 1)\n;;=> 1\n\n(+' -10)\n;;=> -10\n\n(+' 1 2)\n;;=> 3\n\n(+' 1 2 3)\n;;=> 6\n\n(apply + (range 10000000000000 10000000001000))\n;; ArithmeticException: integer overflow\n\n(apply +' (range 10000000000000 10000000001000))\n;;=> 1000000000499500" "(class 1)\n;; => java.lang.Long\n\n(+ 1 Long/MAX_VALUE)\n;; => java.lang.ArithmeticException: integer overflow\n;;        Numbers.java:1388 clojure.lang.Numbers.throwIntOverflow\n;;        Numbers.java:1687 clojure.lang.Numbers.add\n\n(+' 1 Long/MAX_VALUE)\n;; => 9223372036854775808N\n\n(class (+' 1 Long/MAX_VALUE))\n;; => clojure.lang.BigInt\n"], :notes nil, :arglists ["" "x" "x y" "x y & more"], :doc "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/+'"}, :clojure.core/newline {:added "1.0", :ns "clojure.core", :name "newline", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3689, :examples [";; This is equivalent to System.out.println() in Java\nuser=> (newline)\n\nnil\n; Calling println w/o args is equivalent.\nuser=> (println)\n\nnil\nuser=>"], :notes nil, :arglists [""], :doc "Writes a platform-specific newline to *out*", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/newline"}, :clojure.core/class? {:added "1.0", :ns "clojure.core", :name "class?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/class], :line 5383, :examples ["user=> (class? 1)\nfalse\n\nuser=> (class? java.lang.String)\ntrue\n\nuser=> (class? [])\nfalse"], :notes nil, :arglists ["x"], :doc "Returns true if x is an instance of Class", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/class_q"}, :clojure.test/assert-predicate {:added "1.1", :ns "clojure.test", :name "assert-predicate", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 435, :examples nil, :notes nil, :arglists ["msg form"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/assert-predicate"}, :clojure.core/*e {:added "1.0", :ns "clojure.core", :name "*e", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.repl/pst], :dynamic true, :line 6214, :examples ["user=> (ns-refers) ;;Oops! we missed a namespace (ns-refers 'user)\n; Evaluation aborted.\n\nuser=> *e\n#<ArityException clojure.lang.ArityException: Wrong number of args (0) passed to: core/ns-refers>"], :notes nil, :arglists [], :doc "bound in a repl thread to the most recent exception caught by the repl", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*e"}, :clojure.core/pvalues {:added "1.0", :ns "clojure.core", :name "pvalues", :file "clojure/core.clj", :static true, :type "macro", :column 1, :see-alsos [:clojure.core/pmap :clojure.core/future :clojure.core/pcalls], :line 6964, :examples [";; expressions are calculated in parallel\n\nuser=> (pvalues (expensive-calc-1) (expensive-calc-2))\n(2330 122)\n" ";; pvalues is implemented using Clojure futures.  See examples for 'future'\n;; for discussion of an undesirable 1-minute wait that can occur before\n;; your standalone Clojure program exits if you do not use shutdown-agents."], :macro true, :notes nil, :arglists ["& exprs"], :doc "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pvalues"}, :clojure.test/*load-tests* {:added "1.1", :ns "clojure.test", :name "*load-tests*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 245, :examples nil, :notes nil, :arglists [], :doc "True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*load-tests*"}, :clojure.core/sort-by {:added "1.0", :ns "clojure.core", :name "sort-by", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sort :clojure.core/compare], :line 3111, :examples ["user=> (sort-by count [\"aaa\" \"bb\" \"c\"])\n(\"c\" \"bb\" \"aaa\")\n\nuser=> (sort-by first [[1 2] [2 2] [2 3]])   \n([1 2] [2 2] [2 3])\n\nuser=> (sort-by first > [[1 2] [2 2] [2 3]])   \n([2 2] [2 3] [1 2])" "user=> (sort-by :rank [{:rank 2} {:rank 3} {:rank 1}])\n({:rank 1} {:rank 2} {:rank 3})" "(def x [{:foo 2 :bar 11}\n        {:bar 99 :foo 1}\n        {:bar 55 :foo 2}\n        {:foo 1 :bar 77}])\n\n;sort by :foo, and where :foo is equal, sort by :bar\n(sort-by (juxt :foo :bar) x)\n;=>({:foo 1, :bar 77} {:bar 99, :foo 1} {:foo 2, :bar 11} {:bar 55, :foo 2})" "(def x [{:foo 2 :bar 11}\n {:bar 99 :foo 1}\n {:bar 55 :foo 2}\n {:foo 1 :bar 77}])\n; sort-by given key order (:bar)\n(def order [55 77 99 11])\n(sort-by \n  #((into {} (map-indexed (fn [i e] [e i]) order)) (:bar %)) \n  x)\n;=> ({:bar 55, :foo 2} {:foo 1, :bar 77} {:bar 99, :foo 1} {:foo 2, :bar 11})" ";sort entries in a map by value\nuser=> (sort-by val > {:foo 7, :bar 3, :baz 5})\n([:foo 7] [:baz 5] [:bar 3])" ";; Warning: You can sort a Java array and get back a sorted immutable Clojure\n;; data structure, but it will also change the input Java array, by sorting it.\n;; Copy the array before sorting if you want to avoid this.\n\nuser=> (def x (to-array [32 -5 4 11]))\n#'user/x\n\nuser=> (seq x)\n(32 -5 4 11)\n\nuser=> (def y (sort-by - x))\n#'user/y\n\n;; Return sorted sequence\nuser=> y\n(32 11 4 -5)\n\n;; but also modifies x, because it used the array to do the sorting.\nuser=> (seq x)\n(32 11 4 -5)\n\n;; One way to avoid this is copying the array before sorting:\nuser=> (def y (sort-by - (aclone x)))\n#'user/y" ";;; from the joy of clojure 2nd\n;;; function as arguments\n\n(def plays [{:band \"Burial\", :plays 979, :loved 9}\n            {:band \"Eno\", :plays 2333, :loved 15}\n            {:band \"Bill Evans\", :plays 979, :loved 9}\n            {:band \"Magma\", :plays 2665, :loved 31}])\n\n(def sort-by-loved-ratio (partial sort-by #(/ (:plays %) (:loved %))))\n\n(sort-by-loved-ratio plays)\n\n;=> ({:band \"Magma\", :plays 2665, :loved 31}\n    {:band \"Burial\", :plays 979, :loved 9}\n    {:band \"Bill Evans\", :plays 979, :loved 9}\n    {:band \"Eno\", :plays 2333, :loved 15})\n\n\n;;; others.\n(sort-by second [[:a 7], [:c 13], [:b 21]])\n;;=> ([:a 7] [:c 13] [:b 21])\n\n(sort-by str [\"z\" \"x\" \"a\" \"aa\" 1 5 8])\n;;=> (1 5 8 \"a\" \"aa\" \"x\" \"z\")\n\n(sort-by :age [{:age 99}, {:age 13}, {:age 7}])\n;;=> ({:age 7} {:age 13} {:age 99})" ";; you can pass a comparator to specify the order to sort in\n\n;; typical sort, low to high\n(sort-by :value [{:value 1 :label \"a\"} {:value 3 :label \"c\"} {:value 2 :label \"b\"}])\n;=> ({:value 1, :label \"a\"} {:value 2, :label \"b\"} {:value 3, :label \"c\"})\n\n;; override the default comparator to sort high to low\n(sort-by :value #(> %1 %2) [{:value 1 :label \"a\"} {:value 3 :label \"c\"} {:value 2 :label \"b\"}])\n;=> ({:value 3 :label \"c\"} {:value 2, :label \"b\"} {:value 1, :label \"a\"})" ";; to sort by nested hash-map values\n;; with the help of get-in and custom comparator\n\n> (sort-by #(get-in (val %) [:price]) {:chair {:price 10} :table {:price 9} :lamp {:price 9}})\n;;=> ([:table {:price 9}] [:lamp {:price 9}] [:chair {:price 10}])\n"], :notes nil, :arglists ["keyfn coll" "keyfn comp coll"], :doc "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sort-by"}, :clojure.spec.alpha/fspec-impl {:ns "clojure.spec.alpha", :name "fspec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1693, :examples nil, :notes nil, :arglists ["argspec aform retspec rform fnspec fform gfn"], :doc "Do not call this directly, use 'fspec'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/fspec-impl"}, :clojure.core/restart-agent {:added "1.2", :ns "clojure.core", :name "restart-agent", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/agent-error :clojure.core/agent], :line 2169, :examples ["(deftest t-rstart\n  (future (println \"running in a thread...\"))\n  (let [agt (agent 0)\n\n        ; This doesn't work\n        h01 (fn [a e]\n              (println :10 \"agent error found:\" )\n              (println :11 \"restarting agent...\")\n              (restart-agent a 100)\n              (Thread/sleep 100)\n              (println :12 \"agent restarted, state=\" @a))\n\n        ; This works. Need to call restart-agent in a separate thread\n        h02 (fn [a e]\n              (println :20 \"agent error found:\" )\n              (future\n                (println :21 \"restarting agent...\")\n                (restart-agent a 200)\n                (println :22 \"agent restarted, state=\" @a))) ;=> 200\n  ]\n    (set-error-handler! agt h02)\n    (send agt inc)\n    (Thread/sleep 100) (println :01 @agt)  ;=> 1\n    (Thread/sleep 100) (send agt #(/ % 0))\n    (Thread/sleep 100) (println :02 @agt)  ;=> 200\n    (Thread/sleep 100) (send agt inc)\n    (Thread/sleep 100) (println :03 @agt)  ;=> 201\n))\n\n; Output\n;   running in a thread...\n;   :01 1\n;   :20 agent error found:\n;   :21 restarting agent...\n;   :22 agent restarted, state= 200\n;   :02 200\n;   :03 201\n"], :notes nil, :arglists ["a new-state & options"], :doc "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/restart-agent"}, :clojure.pprint/simple-dispatch {:added "1.2", :ns "clojure.pprint", :name "simple-dispatch", :file "clojure/pprint/dispatch.clj", :type "function", :column 1, :see-alsos nil, :line 151, :examples nil, :notes nil, :arglists ["object"], :doc "The pretty print dispatch function for simple data structure format.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/simple-dispatch"}, :clojure.core.logic.pldb/contains-lvar? {:ns "clojure.core.logic.pldb", :name "contains-lvar?", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 35, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/contains-lvar_q"}, :clojure.core/rem {:added "1.0", :ns "clojure.core", :name "rem", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/quot :clojure.core/mod], :line 1261, :examples ["user=> (rem 10 9)\n1\nuser=> (rem 2 2)\n0" ";; rem and mod are commonly used to get the remainder.\n;; mod means Gaussian mod, so the result is always\n;; non-negative.  Don't confuse it with ANSI C's %\n;; operator, which despite being pronounced\n;; 'mod' actually implements rem, i.e. -10 % 3 = -1.\n\nuser=> (mod -10 3)\n2\n\nuser=> (rem -10 3)\n-1"], :notes nil, :arglists ["num div"], :doc "remainder of dividing numerator by denominator.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rem"}, :clojure.core/doall {:added "1.0", :ns "clojure.core", :name "doall", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/dorun :clojure.core/doseq], :line 3140, :examples [";; Nothing is printed because map returns a lazy-seq\nuser=> (def foo (map println [1 2 3]))\n#'user/foo\n\n;; doall forces the seq to be realized\nuser=> (def foo (doall (map println [1 2 3])))\n1\n2\n3\n#'user/foo\n\n;; where\n(doall (map println [1 2 3]))\n1\n2\n3\n(nil nil nil)" ";;map a function which makes database calls to either retrieve or \n;;create and retrieves records from the database over a vector of values. \n;;The function returns a map of fields and values\nuser=> (map #(db/make-n-get-or-get :person {:name %}) [\"Fred\" \"Ethel\" \"Lucy\" \"Ricardo\"])\nJdbcSQLException The object is already closed [90007-170]  org.h2.message.DbE\nxception.getJdbcSQLException (DbException.java:329)\n\n;;database connection was closed before we got a chance to do our transactions\n;;lets wrap it in doall\nuser=> (doall (map #(db/make-n-get-or-get :person {:name %}) \n[\"Fred\" \"Ethel\" \"Lucy\" \"Ricardo\"]))\nDEBUG :db insert into person values name = 'Fred'\nDEBUG :db insert into person values name = 'Ethel'\nDEBUG :db insert into person values name = 'Lucy'\nDEBUG :db insert into person values name = 'Ricardo'\n({:name \"Fred\"} {:name \"Ethel\"} {:name \"Lucy\"} {:name \"Ricardo\"})\n\n;;notice that unlike using dorun, this returns a list of maps" ";; The (doall n coll) form only forces the first n (or more) items in coll to\n;; be realized, but still returns the entire coll.\n(def pr-123 (lazy-seq (cons (pr 1)\n                            (lazy-seq (cons (pr 2)\n                                            (lazy-seq (cons (pr 3) nil)))))))\n#'user/pr-123\n\n;; Since doall returns the collection, be careful not to let the REPL realize\n;; the whole thing, as it would if we were to call (doall 1 pr-123) instead.\nuser=> (do (doall 1 pr-123) (println))\n12\nnil\n;; The 1 is triggered when (seq pr-123) is called, then the 2 is triggered\n;; when (next pr-123) is called (both inside dorun, via doall).\n\nuser=> pr-123\n3(nil nil nil)\n;; The 3 is finally triggered when the REPL realizes the entirety of pr-123\n\n;; pr-123 is built of nested lazy-seq's because (map pr coll) isn't very lazy:\n(do (doall 1 (map pr (range 100))) (println))\n012345678910111213141516171819202122232425262728293031\nnil\n;; Due to occult clojure.lang.RT/JVM internals (?), (next coll) on this sort\n;; of coll realizes the items in batches of 32 each.\n" ";; #'for is create lazy-seq\n(def x (for [i (range 10)]\n     i)\n\n(type x) ;;=> clojure.lang.LazySeq\n\n;; doall return evaluated value\n(doall x) ;;=> (0 1 2 3 4 ...)\n\n\n;; Notice!\n;; but it is clojure.lang.LazySeq\n(type (doall x)) ;;=> clojure.lang.LazySeq\n\n;; if you want to get list ...\n(into-array x)\n(type (into-array x)) ;;=> [Ljava.lang.Long;"], :notes ["Shouldn't we use seq instead of coll in the function signature since we should really pass a sequence?" "'seq' is a function; using it in the function args as a value would shadow the function (and thereby making the function seq unusable in that scope)"], :arglists ["coll" "n coll"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/doall"}, :clojure.core.logic/pred {:ns "clojure.core.logic", :name "pred", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1336, :examples ["user> (run* [q]  (pred q symbol?))\n()\nuser> (run* [q] (== q 'x) (pred q symbol?))\n(x)\nuser> (run* [q] (== q 1) (pred q symbol?))\n()\nuser> (run* [q] (== q 1) (pred q number?))\n(1)"], :macro true, :notes nil, :arglists ["v f"], :doc "Check a predicate against the value logic var. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/pred"}, :clojure.core/enumeration-seq {:added "1.0", :ns "clojure.core", :name "enumeration-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 5671, :examples ["user=> (enumeration-seq (java.util.StringTokenizer. \"exciting example\"))\n(\"exciting\" \"example\")\n" ";; A parallel distinct, using ConcurrentHashMap as a\n;; set of keys to get rid of duplicates. \n;; Keys at the end can be retrieved as an enumeration, \n;; and from that as a sequence, thanks to enumeration-seq\n\n(import '[java.util.concurrent ConcurrentHashMap])\n(require '[clojure.core.reducers :refer [fold]])\n\n(defn parallel-distinct [v]\n  (let [m (ConcurrentHashMap.)\n        combinef (fn ([] m) ([_ _]))\n        reducef (fn [^ConcurrentHashMap m k] (.put m k 1) m)]\n    (fold combinef reducef v)\n    (enumeration-seq (.keys m))))\n\n(defn many-repeating-numbers [n]\n  (into [] (take n (apply concat (repeat (range 10))))))\n\n(parallel-distinct (many-repeating-numbers 1e6))\n;; (0 1 2 3 4 5 6 7 8 9)"], :notes nil, :arglists ["e"], :doc "Returns a seq on a java.util.Enumeration", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/enumeration-seq"}, :clojure.core/eduction {:added "1.7", :ns "clojure.core", :name "eduction", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/transduce :clojure.core/reduce :clojure.core/reductions :clojure.core/sequence], :line 7614, :examples [";; inc with debugging output\n(defn inc-with-print [x]\n  (println x)\n  (inc x))\n\n(eduction (map inc-with-print) (map inc-with-print) (range 3))\n;; 0\n;; 1\n;; 1\n;; 2\n;; 2\n;; 3\n;;=> (2 3 4)\n\n(->> (range 3)\n     (map inc-with-print)\n     (map inc-with-print))\n;; 0\n;; 1\n;; 2\n;; 1\n;; 2\n;; 3\n;;=> (2 3 4)\n\n;; Explanation by freckletonj ---------------------\n;; It took me a minute to figure out the documentation and this example.\n;; Here's what's going on with the call order:\n;;\n;; in the `eduction` example, the calling order looks like -\n;;     (map #(inc-with-print (inc-with-print %)) (range 3))\n;; where as in the `->>` thread example, it looks like -\n;;     (map #(inc-with-print %)\n;;          (map #(inc-with-print %) (range 3)))\n;;\n;; So, `eduction` calls the stack of transformers on each element, each time\n;;     `->>` calls transformer 1 on a collection, then transformer 2 on the result, etc.\n" ";; eduction: just run an xform over a collection\n\n(eduction (map inc) [1 2 3])            ; => (2 3 4)\n(eduction (filter even?) (range 5))     ; => (0 2 4)\n\n;; several transducers can be given, without using 'comp'\n(eduction (filter even?) (map inc)\n          (range 5))                    ; => (1 3 5)\n\n" ";; This will run out of memory eventually,\n;; because the entire seq is realized, \n;; because the head of the lazy seq is retained.\n(let \n  [s (range 100000000)] \n  (do (apply print s) (first s)))\n\n;; This iterates through the lazy seq without realizing the seq.\n(let \n  [s (eduction identity (range 100000000))] \n  (do (apply print s) (first s)))\n\n" ";; Result of eduction is of clojure.core.Eduction type which acts as a lazy\n;; collection that re-executes all the steps again and again. This could be\n;; useful when you don't want to store the collection separately.\n;;\n;; Eductions can be efficiently used with reduce and transduce.\n\n(def ed (eduction (map inc-with-print) (map inc-with-print) (range 3)))\n\n(defn identity-with-print [x]\n  (println \"identity:\" x)\n  x)\n\n(map identity-with-print ed)\n;; 0\n;; 1\n;; 1\n;; 2\n;; 2\n;; 3\n;; identity: 2\n;; identity: 3\n;; identity: 4\n;; => (2 3 4)\n\n(defn sum-with-print [x y]\n  (println \"sum:\" x \"+\" y)\n  (+ x y))\n\n(reduce sum-with-print ed)\n;; 0\n;; 1\n;; 1\n;; 2\n;; sum: 2 + 3\n;; 2\n;; 3\n;; sum: 5 + 4\n;; => 9\n\n(transduce (map identity-with-print) + ed)\n;; 0\n;; 1\n;; identity: 2\n;; 1\n;; 2\n;; identity: 3\n;; 2\n;; 3\n;; identity: 4\n;; 1496674214GET/accounts{}\n;; => 9\n"], :notes ["`eduction` is particularly useful as an adapter for collection-processing functions that don’t have a transducers arity. For example, you might want to transform a collection before passing it to `frequencies`. `eduction` makes that possible and efficient:\n\n<pre>\n(->> coll\n     (eduction (map #(quot % 5))\n               (filter odd?))\n     frequencies)\n</pre>\n\nSo `eduction` turns out to be quite powerful in that it brings the benefits of transducers to all collection-processing functions, even those that predate transducers: `first`, `last`, `group-by`, `run!`, `str/join`, …\n" "Interesting background about `sequence` versus `eduction`: https://groups.google.com/d/msg/clojure/9I6MtgOTD0w/NiG5PimBCP8J"], :arglists ["xform* coll"], :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/eduction"}, :clojure.string/ends-with? {:added "1.8", :ns "clojure.string", :name "ends-with?", :file "clojure/string.clj", :type "function", :column 1, :see-alsos nil, :line 366, :examples ["(use 'clojure.string)\n\n(ends-with? \"Minsun\" \"sun\")\n;;=> true\n(ends-with? \"Minsun\" \"suns\")\n;;=> false\n(ends-with? \"Minsun\" \"un\")\n;;=> true"], :notes nil, :arglists ["s substr"], :doc "True if s ends with substr.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/ends-with_q"}, :clojure.core.async/pipeline-blocking {:ns "clojure.core.async", :name "pipeline-blocking", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/pipeline-async :clojure.core.async/pipeline], :line 553, :examples ["(require '[clojure.core.async :as a :refer [chan to-chan pipeline-blocking <!!]])\n\n(defn blocking-operation [arg])\n\n(let [concurrent 10\n      output-chan (chan)\n      input-coll (range 0 1000)]\n  (pipeline-blocking concurrent \n                     output-chan \n                     (map blocking-operation) \n                     (to-chan input-coll))\n  (<!! (a/into [] output-chan)))"], :notes nil, :arglists ["n to xf from" "n to xf from close?" "n to xf from close? ex-handler"], :doc "Like pipeline, for blocking operations.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/pipeline-blocking"}, :clojure.inspector/inspect-tree {:added "1.0", :ns "clojure.inspector", :name "inspect-tree", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos [:clojure.inspector/inspect-table], :line 91, :examples nil, :notes nil, :arglists ["data"], :doc "creates a graphical (Swing) inspector on the supplied hierarchical data", :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/inspect-tree"}, :clojure.core/agent-error {:added "1.2", :ns "clojure.core", :name "agent-error", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/agent :clojure.core/restart-agent :clojure.core/set-error-handler!], :line 2161, :examples ["(def tdate (agent (java.util.Date.)))\n\n@tdate\n=> #<Date Wed Feb 15 23:25:26 CET 2012>\n\n(send tdate inc) ;;this has no meaning, rendering a (silent) error\n\n(agent-error tdate)\n=> #<ClassCastException java.lang.ClassCastException: java.util.Date cannot be cast to java.lang.Number>"], :notes nil, :arglists ["a"], :doc "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/agent-error"}, :clojure.test/deftest {:added "1.1", :ns "clojure.test", :name "deftest", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/run-all-tests :clojure.test/run-tests :clojure.test/is :clojure.test/are :clojure.test/testing :clojure.test/test-var], :line 621, :examples [";successful test example\n(ns testing)\n(use 'clojure.test)\n\n\n(deftest addition\n  (is (= 4 (+ 2 2)))\n  (is (= 7 (+ 3 4))))\n=> #'testing/addition\n\n(deftest subtraction\n  (is (= 1 (- 4 3)))\n  (is (= 3 (- 7 4))))\n=> #'testing/subtraction\n\n;composing tests\n(deftest arithmetic\n  (addition)\n  (subtraction))\n=> #'testing/arithmetic\n\n(run-tests 'testing)\n\n=> Testing testing\n\nRan 6 tests containing 10 assertions.\n0 failures, 0 errors.\n{:type :summary, :test 6, :pass 10, :fail 0, :error 0}" ";failure test example\n\n;there is nesting, so when a leaf test fails so does its parents, in this example 2 tests fail, though there was only one real error.\n\n(ns testing)\n(use 'clojure.test)\n\n\n(deftest addition\n  (is (= 4 (+ 2 2)))\n  (is (= 7 (+ 3 4))))\n=> #'testing/addition\n\n(deftest subtraction\n  (is (= 1 (- 4 3)))\n  (is (= 6 (- 7 4))))           ;error\n=> #'testing/subtraction\n\n;composing tests\n(deftest arithmetic\n  (addition)\n  (subtraction))\n=> #'testing/arithmetic\n\n(run-tests 'testing)\n\n=> Testing testing\n\nFAIL in (arithmetic subtraction) (NO_SOURCE_FILE:669)\nexpected: (= 6 (- 7 4))\n  actual: (not (= 6 3))\n\nFAIL in (subtraction) (NO_SOURCE_FILE:669)\nexpected: (= 6 (- 7 4))\n  actual: (not (= 6 3))\n\nRan 6 tests containing 10 assertions.\n2 failures, 0 errors.\n{:type :summary, :test 6, :pass 8, :fail 2, :error 0}"], :macro true, :notes nil, :arglists ["name & body"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/deftest"}, :clojure.core/*fn-loader* {:ns "clojure.core", :name "*fn-loader*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*fn-loader*"}, :clojure.walk/macroexpand-all {:added "1.1", :ns "clojure.walk", :name "macroexpand-all", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.core/macroexpand-1 :clojure.core/macroexpand], :line 125, :examples ["user=> (use 'clojure.walk)\nuser=> (macroexpand-all '(-> c (+ 3) (* 2)))\n(* (+ c 3) 2)" "user=> (use 'clojure.walk)\n\n; tryclj.com and lazybot on #clojure get the following wrong\nuser=> (let [-> inc] (-> 5)) \n6\n\n; Below macroexpansion is supposed to result in equivalent code to the above\nuser=> (macroexpand-all '(let [-> inc] (-> 5)))\n(let* [-> inc] 5)\nuser=> (let* [-> inc] 5)\n5\n\n; However, as is clear above, it does not" ";; differences between macroexpand-1, macroexpand and macroexpand-all \n\n(require '[clojure.pprint :as pp]\n         '[clojure.walk :as walk])\n\n(alter-var-root #'pp/*print-suppress-namespaces* (constantly true))\n\n\n(defmacro plus [n1 n2]\n  `(+ ~n1 ~n2))\n\n(pp/pprint (macroexpand-1 '(plus 3 4)))   ;=> (+ 3 4)\n(pp/pprint (macroexpand   '(plus 3 4)))   ;=> (+ 3 4)\n\n\n(defmacro pl [p1 p2]\n  `(plus ~p1 ~p2))\n\n(pp/pprint (macroexpand-1 '(pl 3 4)))     ;=> (plus 3 4)\n(pp/pprint (macroexpand   '(pl 3 4)))     ;=> (+ 3 4)\n\n\n(defmacro minus [m1 m2]\n  `(- ~m1 ~m2))\n\n(defmacro calc [c1 c2]\n  `(pl ~c1 (minus ~c1 ~c2)))\n\n(pp/pprint (macroexpand-1 '(calc 20 30)))\n;=> (pl 20 (minus 20 30))\n\n(pp/pprint (macroexpand   '(calc 20 30)))\n;=> (+ 20 (minus 20 30))\n\n(pp/pprint (walk/macroexpand-all '(calc 20 30)))\n;=> (+ 20 (- 20 30))"], :notes ["DO NOT USE THIS FUNCTION, it doesn't handle special forms at all, and, as such, does not in fact expand into the ultimate macroexpansion of the form.\r\n\r\nFor example,\r\n<pre>(require '[clojure.walk :as walk])\r\n(println (walk/macroexpand-all '(quote (let [a 1] a))))\r\n</pre>\r\nWill print\r\n<pre>(quote (let* [a 1] a))\r\n</pre>\r\nWhen the correct answer is\r\n<pre>(quote (let [a 1] a))\r\n</pre>\r\nShowing an utter unawareness of proper handling of special forms\r\n\r\nDO NOT USE THIS FUNCTION" "@Sgeo - `let` is just a macro for `let*`:\r\n\r\n    (clojure.repl/source let) =>\r\n\r\n    (defmacro let\r\n    \"binding => binding-form init-expr\r\n\r\n     Evaluates the exprs in a lexical context in which the symbols in\r\n     the binding-forms are bound to their respective init-exprs or parts\r\n     therein.\"\r\n     {:added \"1.0\", :special-form true, :forms '[(let [bindings*] exprs*)]}\r\n     [bindings & body]\r\n     (assert-args let\r\n         (vector? bindings) \"a vector for its binding\"\r\n         (even? (count bindings)) \"an even number of forms in binding vector\")\r\n      `(let* ~(destructure bindings) ~@body))" "(quote (let [a 1] a)) is '(let [a 1] a) which evaluates to a list containing the symbol let, a vector [a 1], and a symbol a. In this context, the (let [a 1] a) is not code, but mere data, and as such, should not be macroexpanded at all, anymore than a string like \"(-&gt; a b c)\" should be macroexpanded into \"(c (b a))\" (and yes, I know that's not the exact macroexpansion)."], :arglists ["form"], :doc "Recursively performs all possible macroexpansions in form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/macroexpand-all"}, :clojure.main/repl-caught {:ns "clojure.main", :name "repl-caught", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 152, :examples nil, :notes nil, :arglists ["e"], :doc "Default :caught hook for repl", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl-caught"}, :clojure.core.logic/rem-attr {:ns "clojure.core.logic", :name "rem-attr", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 440, :examples nil, :notes nil, :arglists ["s x attr"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/rem-attr"}, :clojure.core.logic.fd/ext-dom-fd {:ns "clojure.core.logic.fd", :name "ext-dom-fd", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 597, :examples nil, :notes nil, :arglists ["a x dom domp"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/ext-dom-fd"}, :clojure.java.io/make-parents {:added "1.2", :ns "clojure.java.io", :name "make-parents", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/file], :line 438, :examples ["(let [file-name \"path/to/whatever.txt\"]\n  (make-parents file-name)\n  (spit file-name \"whatever\"))"], :notes nil, :arglists ["f & more"], :doc "Given the same arg(s) as for file, creates all parent directories of\n   the file they represent.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/make-parents"}, :clojure.java.shell/with-sh-env {:added "1.2", :ns "clojure.java.shell", :name "with-sh-env", :file "clojure/java/shell.clj", :type "macro", :column 1, :see-alsos [:clojure.java.shell/sh], :line 28, :examples nil, :macro true, :notes nil, :arglists ["env & forms"], :doc "Sets the environment for use with sh, see sh for details.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.shell/with-sh-env"}, :clojure.core.logic.pldb/rel-indexes {:ns "clojure.core.logic.pldb", :name "rel-indexes", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 28, :examples nil, :notes nil, :arglists ["rel"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/rel-indexes"}, :clojure.core.async/Mix {:ns "clojure.core.async", :name "Mix", :file "clojure/core/async.clj", :type "var", :column 1, :see-alsos nil, :line 729, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/Mix"}, :clojure.core.async/unsub-all {:ns "clojure.core.async", :name "unsub-all", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 911, :examples nil, :notes nil, :arglists ["p" "p topic"], :doc "Unsubscribes all channels from a pub, or a topic of a pub", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unsub-all"}, :clojure.main/stack-element-str {:added "1.3", :ns "clojure.main", :name "stack-element-str", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 51, :examples nil, :notes nil, :arglists ["el"], :doc "Returns a (possibly unmunged) string representation of a StackTraceElement", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/stack-element-str"}, :clojure.core.logic.fd/interval-> {:ns "clojure.core.logic.fd", :name "interval->", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 48, :examples nil, :notes nil, :arglists ["i j"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval->"}, :clojure.core/*compile-path* {:added "1.0", :ns "clojure.core", :name "*compile-path*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*compile-path*"}, :clojure.core.logic/defna {:ns "clojure.core.logic", :name "defna", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/defnc :clojure.core.logic/defne :clojure.core.logic/defnu], :line 1728, :examples nil, :macro true, :notes nil, :arglists ["& rest"], :doc "Define a soft cut goal. See conda.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/defna"}, :clojure.core/mix-collection-hash {:added "1.6", :ns "clojure.core", :name "mix-collection-hash", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 5115, :examples nil, :notes nil, :arglists ["hash-basis count"], :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/mix-collection-hash"}, :clojure.core/with-open {:added "1.0", :ns "clojure.core", :name "with-open", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/slurp :clojure.java.io/input-stream], :line 3797, :examples [";; Opens the file 'myfile.txt' and prints out the contents.  The \n;; 'with-open' ensures that the reader is closed at the end of the \n;; form.  \n;; \n;; Please note that reading a file a character at a time is not \n;; very efficient.\n\nuser=> (with-open [r (clojure.java.io/input-stream \"myfile.txt\")] \n         (loop [c (.read r)] \n           (if (not= c -1)\n             (do \n               (print (char c)) \n               (recur (.read r))))))\n" "(defn write-csv-file\n  \"Writes a csv file using a key and an s-o-s (sequence of sequences)\"\n  [out-sos out-file]\n\n  (spit out-file \"\" :append false)\n  (with-open [out-data (io/writer out-file)]\n      (csv/write-csv out-data out-sos)))\n\n" ";; Try to read 3 lines of text from a test file and return them (to the REPL)\n;; as a list:\n(with-open [r (clojure.java.io/reader \"test-0.txt\")]\n  (binding [*in* r] (repeatedly 3 read-line)))\n\n;; The above returns a lazy seq without reading any lines while *in* is bound\n;; to the file, resulting in the original *in* (usually stdin) being read.\n;; To fix, wrap the body within the *in* binding in (doall ...):\n(with-open [r (clojure.java.io/reader \"test-0.txt\")]\n  (binding [*in* r] (doall (repeatedly 3 read-line))))\n\n;; That ensures the sequence will be fully realized with the binding of *in*\n;; still in effect, thus reading all 3 lines from the test file."], :macro true, :notes nil, :arglists ["bindings & body"], :doc "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-open"}, :clojure.spec.alpha/registry {:ns "clojure.spec.alpha", :name "registry", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 335, :examples nil, :notes nil, :arglists [""], :doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/registry"}, :clojure.core/type {:added "1.0", :ns "clojure.core", :name "type", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/class :clojure.core/supers :clojure.core/instance?], :line 3458, :examples [";; Checking numbers\nuser=> (type 10)\njava.lang.Long\n\nuser=> (type 10.0)\njava.lang.Double\n\nuser=> (type nil)\nnil\n\n;; Checking collections\nuser=> (type [10 20])\nclojure.lang.PersistentVector\n\nuser=> (type '(10 20))\nclojure.lang.PersistentList\n\n\n;; Checking other, but somewhat intuitive, forms\nuser=> (type \"A string\")\njava.lang.String\n\nuser=> (type :a)\nclojure.lang.Keyword\n\nuser=> (type Thread)\njava.lang.Class\n\n\n;; Checking a symbol\nuser=> (type 'whatever)\nclojure.lang.Symbol\n\n;; A surprise attack yields\nuser=> (type clojure.lang.Symbol)\n;; not such a surprising response\njava.lang.Class\n\n\n;; Checking a function\nuser=> (defn foo [] (\"any string\"))\n#'user/foo\nuser=> (type foo)\nuser$foo\n\n\n;; Checking a macro\nuser=> (type clojure.core/fn)\njava.lang.Exception: Can't take value of a macro: #'clojure.core/fn (NO_SOURCE_FILE:94)\n\n" ";This example demonstrates how to add type information to regular clojure maps\n(defn purchase-order [id date amount]\n  ^{:type ::PurchaseOrder} ;metadata\n   {:id id :date date :amount amount})\n\n(def my-order (purchase-order 10 (java.util.Date.) 100.0))\n\n(my-order)\n=> {:id 10, :date #<Date Sun May 15 14:29:19 EDT 2011>, :amount 100.0}\n\n(type my-order)\n=> PurchaseOrder"], :notes nil, :arglists ["x"], :doc "Returns the :type metadata of x, or its Class if none", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/type"}, :clojure.core.logic/cgoal {:ns "clojure.core.logic", :name "cgoal", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2187, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/cgoal"}, :clojure.core.logic/u# {:ns "clojure.core.logic", :name "u#", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 1150, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/u#"}, :clojure.core/vector {:added "1.0", :ns "clojure.core", :name "vector", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vec :clojure.core/vector? :clojure.core/vector-of :clojure.core/pop :clojure.core/into], :line 353, :examples [";; create an empty vector the long way\nuser=> (vector)\n[]\n\n;; create an empty vector the short way\nuser=> []\n[]\n\n;; you can even create vectors with nil values\nuser=> (vector nil)\n[nil]\n\n;; create a vector the long way\nuser=> (vector 1 2 3)\n[1 2 3]\n\n;; create a vector the short way\nuser=> [1 2 3]\n[1 2 3]\n\n;; checking for the 2 results above\nuser=> (class (vector 1 2 3))\nclojure.lang.PersistentVector\n\nuser=> (class [1 2 3])\nclojure.lang.PersistentVector\n\nuser=> (= (vector 1 2 3) [1 2 3])\ntrue\n\n" ";; Destructuring with a vector, inside a \"let\" form, a simple case (a symbol\n;; for each element):\n\n;; destructuring with an inline vector\nuser=> (let [[first-element second-element third-element fourth-element] \n             [10 20 30 40]] \n         (str \"first=\" first-element \" second=\" second-element \n           \" third=\" third-element \" fourth=\" fourth-element))\n\"first=10 second=20 third=30 fourth=40\"\n;; notice how 4 symbols were created pointing to the scalars 10, 20, 30 and 40\n\n\n;; destructuring with a symbol to a vector\nuser=> (def my-vector [1 2 3 4])\n#'user/my-vector\n\nuser=> (let [[first-element second-element third-element fourth-element] my-vector] \n         (str \"first=\" first-element \" second=\" second-element \n           \" third=\" third-element \" fourth=\" fourth-element))\n\"first=1 second=2 third=3 fourth=4\"" ";; Destructuring with a vector, inside a \"let\" form, more complex cases:\n\nuser=> (let [[first-element second-element & the-rest] my-vector] \n         (str \"first=\" first-element \" second=\" second-element \" \n           the-rest=\" the-rest))\n\"first=1 second=2 the-rest=(3 4)\"\n;; notice how \"the-rest\" is a sequence\n\nuser=> (let [[first-element second-element third-element fourth-element \n               :as everything] \n             my-vector] \n         (str \"first=\" first-element \" second=\" second-element \" \n           third=\" third-element \" fourth=\" fourth-element \" \n           everything=\" everything))\n\"first=1 second=2 third=3 fourth=4 everything=[1 2 3 4]\"\n;; notice how \"everything\" is the whole vector" ";; Create pairs from a seq\n;; (1 2 3 4) -> ([1 2] [2 3] [3 4])\n\n\n(def inp (list 1 2 3 4))\n;; (1 2 3 4)\n(map vector inp (drop 1 inp))\n;; ([1 2] [2 3] [3 4])"], :notes nil, :arglists ["" "a" "a b" "a b c" "a b c d" "a b c d e" "a b c d e f" "a b c d e f & args"], :doc "Creates a new vector containing the args.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vector"}, :clojure.core/spit {:added "1.2", :ns "clojure.core", :name "spit", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/slurp :clojure.java.io/writer :clojure.core/load-file :clojure.java.io/make-parents], :line 6874, :examples ["user=> (spit \"flubber.txt\" \"test\")\nnil\nuser=> (slurp \"flubber.txt\")\n\"test\"" "user=> (spit \"event.log\" \"test 1\\n\" :append true)\nnil\n\nuser=> (spit \"event.log\" \"test 2\\n\" :append true)\nnil\n\nuser=> (println (slurp \"event.log\"))\ntest 1\ntest 2\n\nnil\n" "(defn append-to-file\n  \"Uses spit to append to a file specified with its name as a string, or\n   anything else that writer can take as an argument.  s is the string to\n   append.\"     \n  [file-name s]\n  (spit file-name s :append true))" ";;Create a record and save a log message to a log file\n;;Constructor with side effects\n\n;;define a Person record\n(defrecord Person [fname lname])\n\n;;define a function to save a log message into the log.txt using spit and :append\n(defn log-entry [msg] (spit \"log.txt\" (apply str msg \"\\n\") :append true))\n\n;;build the constructor which: 1) log the message; 2)create a Person\n(defn make-person [fname lname]\n  (log-entry (apply str \"[log] New Person created : \" lname \",\" fname))\n    (->Person fname lname))\n\n;;create a person\n(def person (make-person \"John\" \"Smith\"))\n\n;;print the content of the log.txt to the console\n(println  (slurp \"log.txt\"))"], :notes ["The only valid options for `spit` are `:append` and `:encoding`."], :arglists ["f content & options"], :doc "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/spit"}, :clojure.core/bit-and {:added "1.0", :ns "clojure.core", :name "bit-and", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-or], :line 1285, :examples [";; bits can be entered using radix notation\n;; but they are long integers so by default they\n;; display in decimal.\n(bit-and 2r1100 2r1001)\n;;=> 8\n;; 8 = 2r1000\n\n;; here we see the same bits entered in decimal\n(bit-and 12 9)\n;;=> 8" ";; bits can be entered in hexidecimal\n(bit-and 0x08 0xFF)\n;;=> 8\n\n;; bits can be show with Integer/toHexString\n(Integer/toHexString (bit-and 0x0108 0xFFFF))\n;;=> \"108\"" ";; bits can also be shown with Integer/toBinaryString\n\n(Integer/toBinaryString 235)\n;;=> \"11101011\"\n\n(Integer/toBinaryString 199)\n;;=> \"11000111\"\n\n(bit-and 235 199)\n;;=> 195\n\n(Integer/toBinaryString 195)\n;;=> \"11000011\"\n\n;;  11101011  = 235\n;;& 11000111  = 199\n;;==========\n;;  11000011  = 195" ";; here is the truth table for AND \n(Integer/toBinaryString (bit-and 2r1100 2r1010) )\n;;=> \"1000\"\n;; or 2r1000"], :notes nil, :arglists ["x y" "x y & more"], :doc "Bitwise and", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-and"}, :clojure.core/await {:added "1.0", :ns "clojure.core", :name "await", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/await-for], :line 3266, :examples [";; construct a simple agent\n(def *agnt* (agent {}))\n\n(send-off *agnt* (fn [state] \n               (Thread/sleep 10000)\n               (assoc state :done true)))\n;;=> <Agent@5db18235: {}>\n\n;; blocks till the agent action is finished\n(await *agnt*) \n;;=> nil" "(import '(java.io BufferedWriter FileWriter))\n\n;; Generally the agent can be sent messages asynchronously, send and forget.\n;; In some cases a rendezvous is needed, e.g. in the case of an output file.\n\n(def write-out \n  (agent {:handle (clojure.java.io/writer \"results.txt\" )\n          :last-msg [\"init\"]}\n        :validator (fn [state] \n                       (and (contains? state :handle) (contains? state :last-msg))) \n        :error-handler (fn [result] \n                           (println \"invalid result\") )))\n\n(defn write-a-line [state msg nap] \n  (.write (:handle state) (str msg \" line \" \"\\n\")) \n  (let [new-state (update-in state [:last-msg] into [msg])]\n    (println \"message : \" msg \" : \" new-state)\n    (Thread/sleep nap)\n    new-state))\n\n\n\n;; these all have the same return value\n(send-off write-out write-a-line \"first\" 2000)\n(send-off write-out write-a-line \"second\" 1000)\n(send-off write-out write-a-line \"third\" 5000)\n(send-off write-out write-a-line \"fourth\" 1000)\n@write-out\n;;=> {:handle #<BufferedWriter java.io.BufferedWriter@e175cca>, :last-msg [\"init\"]}\n\n(time (await write-out))\n;; 9000.307 msecs\n\n;; here we can see that the await causes the thread to block\n;; until the agent's queue is empty.\n@write-out\n;;=> {:handle #<BufferedWriter java.io.BufferedWriter@e175cca>, \n;;    :last-msg [\"init\" \"first\" \"second\" \"third\" \"fourth\"]}\n\n;; But wait the \"result.txt\" file is empty!\n;; We need to close the file handle.\n;; And now that we know the agent's queue is empty we\n;; are free to close it.\n;; This could do this in the current thread with the dereferenced\n;; agents :handle '(.close (:handle @write-out))' \n;; but it is probably better to be formal and let the agent do it.\n(defn close-the-agent [state] \n  (.close (:handle state)) \n  state)\n\n(send-off write-out close-the-agent)\n\n;; And the contents of \"result.txt\" are: (less the leading '; ')\n; first line\n; second line\n; third line\n; fourth line"], :notes nil, :arglists ["& agents"], :doc "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/await"}, :clojure.zip/insert-child {:added "1.0", :ns "clojure.zip", :name "insert-child", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/zipper :clojure.zip/append-child], :line 216, :examples ["(use 'clojure.zip) ;;warnings OK\n\n(def zp (zipper vector? seq (fn [_ c] c) [[1 2 3] [4 [5 6] 7] [8 9]]) )\n\n(root (insert-child (-> zp down right) 42))\n=>([1 2 3] (42 4 [5 6] 7) [8 9])\n\n\n(def zp2 (zipper vector? seq (fn [_ c] c) [74 75])\n\n(root (insert-right (-> zp down right) zp2))\n=>([1 2 3] [4 [5 6] 7] [[74 75] nil] [8 9])\n\n(root (insert-left (-> zp down right) zp2))\n=>([1 2 3] [[74 75] nil] [4 [5 6] 7] [8 9])\n\n\n\n"], :notes nil, :arglists ["loc item"], :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/insert-child"}, :clojure.core.logic.pldb/facts-using-index {:ns "clojure.core.logic.pldb", :name "facts-using-index", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 19, :examples nil, :notes nil, :arglists ["dbs kname index val"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/facts-using-index"}, :clojure.core/loaded-libs {:added "1.0", :ns "clojure.core", :name "loaded-libs", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 6024, :examples nil, :notes nil, :arglists [""], :doc "Returns a sorted set of symbols naming the currently loaded libs", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/loaded-libs"}, :clojure.core.logic/-reify* {:ns "clojure.core.logic", :name "-reify*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 259, :examples nil, :notes nil, :arglists ["s v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-reify*"}, :clojure.core.logic/predc {:ns "clojure.core.logic", :name "predc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2687, :examples nil, :notes nil, :arglists ["x p" "x p pform"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/predc"}, :clojure.core/deliver {:added "1.1", :ns "clojure.core", :name "deliver", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/promise], :line 7047, :examples ["user=> (def x (promise))\n#'user/x\n;; Trying to deref at this point will make your repl wait forever\n\n\nuser=> (deliver x 100)\n#&lt;core$promise$reify__5534@4369a50b: 100&gt;\n\n;; the promise has been delivered, deref x will return immediately\nuser=> @x\n100\n" ";; Create a promise\nuser> (def p (promise))\n#'user/p ; p is our promise\n\n;; Check if was delivered/realized\nuser> (realized? p)\nfalse ; No yet\n\n;; Delivering the promise\nuser> (deliver p 42)\n#<core$promise$reify__5727@47122d: 42>\n\n;; Check again if it was delivered\nuser> (realized? p)\ntrue ; Yes!\n\n;; Deref to see what has been delivered\nuser> @p\n42\n\n;; Note that @ is shorthand for deref\nuser> (deref p)\n42" ";; Illustrates how threads can work together via promises\n;; First, an example to show a future that delivers\n\nuser=> (def p (promise))\n#'user/p\n\n;; future that will deliver the promise from another thread after 10 sec delay\nuser=> (future\n         (Thread/sleep 10000)\n         (deliver p 123))\n#future[{:status :pending, :val nil} 0x9a51df1]\n\n;; within 10 seconds dereference p, and wait for delivery of the value\nuser=> @p\n123\n\n\n;; Now, an example to show a future that blocks while waiting for a promise\n;; to be delivered -- this is used to achieve callback-style functionality\n\n;; redefine p\nuser=> (def p (promise))\n#'user/p\n\n;; create a new 'callback' thread that will wait for a promise to be delivered\nuser=> (future\n         (println \"About to block while waiting for 'p'\")\n         (println \"Now I can do some work with the value \" @p))\nAbout to block while waiting for 'p'\n#future[{:status :pending, :val nil} 0x1737df29]\n\n;; deliver the promise, triggering the blocking callback thread\nuser=> (deliver p 123)\nNow I can do some work with the value  123\n#promise[{:status :ready, :val 123} 0x674a4c4a]"], :notes ["As of Clojure 1.3 `deliver` does not throw an exception when it is called multiple times on the same promise. See [CLJ-1038](http://dev.clojure.org/jira/browse/CLJ-1038)."], :arglists ["promise val"], :doc "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/deliver"}, :clojure.xml/emit-element {:ns "clojure.xml", :name "emit-element", :file "clojure/xml.clj", :type "function", :column 1, :see-alsos [:clojure.core/with-out-str :clojure.xml/element], :line 95, :examples ["(use 'clojure.xml)\n\n;;If just a string it's text inside or something. just print it\n(emit-element \"hello\")\nhello\n\n;;we want a map with a tag\n(emit-element {:tag :hello})\n<hello/>\n\n;;strings works as well (since we're using the \"name\" function)\n(emit-element {:tag \"hello\"})\n<hello/>\n\n;;:attrs is for all the attributes\n(emit-element {:tag :hello :attrs {:place \"world\"}})\n<hello place='world'/>\n\n;;:content is for all the children in the element\n(emit-element {:tag :parent :attrs {:id \"22\" :name \"fritz\"} :content [\n                {:tag :child :attrs {:id \"56\"}} \n                {:tag :child :attrs {:id \"57\"}]}))\n<parent id='22' name='fritz'>\n<child id='56'/>\n<child id='57'/>\n</parent>\n\n;; also, look out for not supplying :content with another xml-ish map\n;; or at minimum a vector containing the string you want to put as the content:\n(emit-element {:tag :hello :content \"world\"})\n<hello>\njava.lang.NullPointerException (NO_SOURCE_FILE:0)\n\n(emit-element {:tag :hello :content [\"world\"])\n<hello>world</hello>\n"], :notes ["you can catch the printed code with the macro <pre>with-out-str</pre> if you want to catch it in variables."], :arglists ["e"], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/emit-element"}, :clojure.core/instance? {:added "1.0", :ns "clojure.core", :name "instance?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/type :clojure.core/supers :clojure.core/doto :clojure.core/class :clojure.core/satisfies? :clojure.core/isa?], :line 139, :examples ["user=> (instance? Long 1)\ntrue\nuser=> (instance? Integer 1)\nfalse\nuser=> (instance? Number 1)\ntrue\nuser=> (instance? String 1)\nfalse\nuser=> (instance? String \"1\")\ntrue\n" "user=> (def al (new java.util.ArrayList))\n#'user/al\nuser=> (instance? java.util.Collection al)\ntrue\nuser=> (instance? java.util.RandomAccess al)\ntrue\nuser=> (instance? java.lang.String al)\nfalse" ";; Some things are more than what they seem to be at first glance\nuser=> (instance? clojure.lang.IFn +)\ntrue\nuser=> (instance? clojure.lang.Keyword :a)\ntrue\nuser=> (instance? clojure.lang.IFn :a)\ntrue\nuser=> (instance? clojure.lang.IFn {:a 1})\ntrue\n" ";; If `c` is specified with a literal class name, this is a Java\n;; class name.  If any of the namespace components of the class\n;; include dashes, the dashes have to be replaced with underscores:\n\n(ns foo-bar)\n(defrecord Box [x])\n(def box (Box. 42))\n\n(instance? foo-bar.Box box)\n;=> CompilerException java.lang.ClassNotFoundException: foo-bar.Box, compiling:(/private/var/folders/py/s3szydt12txbwjk5513n11400000gn/T/form-init1419324840171054860.clj:1:1)\n(instance? foo_bar.Box box)\n;=> true\n\n;; This rule doesn't apply to the last component of the class name:\n\n(defrecord My-Box [x])   ; not an idiomatic choice\n(def mybox (My-Box. 42))\n\n(instance? foo_bar.My-Box mybox)\n;=> true\n"], :notes nil, :arglists ["c x"], :doc "Evaluates x and tests if it is an instance of the class\n    c. Returns true or false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/instance_q"}, :clojure.core/reverse {:added "1.0", :ns "clojure.core", :name "reverse", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rseq], :line 939, :examples ["user=> (reverse '(1 2 3))\n(3 2 1)\n"], :notes ["If you've got a vector rseq is a good option instead of reverse."], :arglists ["coll"], :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reverse"}, :clojure.core/release-pending-sends {:added "1.0", :ns "clojure.core", :name "release-pending-sends", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 2125, :examples nil, :notes nil, :arglists [""], :doc "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/release-pending-sends"}, :clojure.core/*verbose-defrecords* {:ns "clojure.core", :name "*verbose-defrecords*", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 39, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*verbose-defrecords*"}, :clojure.core/sequential? {:added "1.0", :ns "clojure.core", :name "sequential?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq? :clojure.core/coll? :clojure.core/seqable?], :line 6170, :examples ["user=> (sequential? '(1 2 3))\ntrue\n\nuser=> (sequential? [1 2 3])\ntrue\n\nuser=> (sequential? (range 1 5))\ntrue\n\nuser=> (sequential? '())\ntrue\n\nuser=> (sequential? [])\ntrue\n\nuser=> (sequential? nil)\nfalse\n\nuser=> (sequential? 1)\nfalse\n\nuser=> (sequential? \"abc\")\nfalse\n\nuser=> (sequential? {:a 2 :b 1})\nfalse\n\nuser=> (sequential? #{1 2 3})\nfalse"], :notes nil, :arglists ["coll"], :doc "Returns true if coll implements Sequential", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sequential_q"}, :clojure.java.javadoc/*remote-javadocs* {:ns "clojure.java.javadoc", :name "*remote-javadocs*", :file "clojure/java/javadoc.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 28, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/*remote-javadocs*"}, :clojure.string/includes? {:added "1.8", :ns "clojure.string", :name "includes?", :file "clojure/string.clj", :type "function", :column 1, :see-alsos nil, :line 372, :examples [";; String-oriented alternative to regular-expression functions in core\n(string/includes? \"clojure\" \"cl\")\n;;=> true\n\n;; Does *not* work with regular expressions!\n(string/includes? \"clojure\" #\"cl\")\n;;=> java.util.regex.Pattern cannot be cast to java.lang.CharSequence\n;;   (java.lang.ClassCastException)"], :notes nil, :arglists ["s substr"], :doc "True if s includes substr.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/includes_q"}, :clojure.core/recur {:ns "clojure.core", :name "recur", :type "var", :see-alsos [:clojure.core/loop :clojure.core/trampoline], :examples ["(def factorial\n  (fn [n]\n    (loop [cnt n\n           acc 1]\n       (if (zero? cnt)\n            acc\n          (recur (dec cnt) (* acc cnt))\n; in loop cnt will take the value (dec cnt)\n; and acc will take the value (* acc cnt)\n))))" "; A loop that sums the numbers 10 + 9 + 8 + ...\n\n; Set initial values count (cnt) from 10 and down\n(loop [sum 0\n       cnt 10]\n    ; If count reaches 0 then exit the loop and return sum\n    (if (= cnt 0)\n      sum\n    ; Otherwise add count to sum, decrease count and \n    ; use recur to feed the new values back into the loop\n    (recur (+ cnt sum) (dec cnt))))" "(loop [i 0]  \n  (when (< i 5)    \n    (println i)    \n    (recur (inc i)); loop i will take this value\n))" "(defn compute-across [func elements value]\n  (if (empty? elements)\n    value\n    (recur func (rest elements) (func value (first elements)))))\n\n(defn total-of [numbers]\n  (compute-across + numbers 0))\n\n(defn larger-of [x y]\n  (if (> x y) x y))\n\n(defn greatest-of [numbers]\n  (compute-across larger-of numbers (first numbers)))" "; Note that recur can be surprising when using variadic functions.\n\n(defn foo [& args]\n  (let [[x & more] args]\n    (prn x)\n    (if more (recur more) nil)))\n\n(defn bar [& args]\n  (let [[x & more] args]\n    (prn x)\n    (if more (bar more) nil)))\n\n; The key thing to note here is that foo and bar are identical, except\n; that foo uses recur and bar uses \"normal\" recursion. And yet...\n\nuser=> (foo :a :b :c)\n:a\n:b\n:c\nnil\n\nuser=> (bar :a :b :c)\n:a\n(:b :c)\nnil\n\n; The difference arises because recur does not gather variadic/rest args\n; into a seq." ";;This will generate the first 1000 Fibonacci numbers \n;;(using incrementing and decrementing):  \n\n(loop [res [0 1]]\n        (if (>= (count res) 1000)\n          res\n          (recur (conj res (+' (inc (last res)) (dec (last (butlast res))))))))" ";; The recursion point can be a 'loop' or a 'fn' method.\n\n(loop [n (bigint 5), accumulator 1]\n  (if (zero? n)\n    accumulator  ; we're done\n    (recur (dec n) (* accumulator n))))\n;;=> 120N\n\n\n((fn factorial\n   ([n] (factorial n 1))\n\n   ([n accumulator]\n    (if (zero? n)\n      accumulator  ; we're done\n      (recur (dec n) (* accumulator n)))))\n\n (bigint 5))\n;;=> 120N"], :notes nil, :arglists [], :doc "Evaluates the exprs in order, then, in parallel, rebinds the bindings of\nthe recursion point to the values of the exprs. See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/recur"}, :clojure.core/swap-vals! {:added "1.9", :ns "clojure.core", :name "swap-vals!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/swap! :clojure.core/reset! :clojure.core/compare-and-set! :clojure.core/atom], :line 2349, :examples [";; You can use `swap-vals` to perform an atomic `deref`\n;; and `swap!` without a race condition.\n\n(def queue (atom '(1 2 3)))\n(let [head (ffirst (swap-vals! queue pop))]\n  (println head)     ;; 1\n  (println @queue))  ;; (2 3)"], :notes nil, :arglists ["atom f" "atom f x" "atom f x y" "atom f x y & args"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/swap-vals!"}, :clojure.core.async/pub {:ns "clojure.core.async", :name "pub", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/sub], :line 843, :examples ["user=> (def c (chan 1))\n#'user/c\n\nuser=> (def sub-c (pub c :route))\n#'user/sub-c\n\nuser=> (def cx (chan 1))\n#'user/cx\n\nuser=> (sub sub-c :up-stream cx)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@526eb67f>\n\nuser=> (def cy (chan 1))\n#'user/cy\n\nuser=> (sub sub-c :down-stream cy)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@777692ac>\n\nuser=> (go-loop [_ (<! cx)]\n         (println \"Got something coming up!\"))\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@49e2e0f9>\n\nuser=> (go-loop [_ (<! cy)]\n         (println \"Got something going down!\"))\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@33498147>\n\nuser=> (put! c {:route :up-stream :data 123})\ntrue\nGot something coming up!\n\nuser=> (put! c {:route :down-stream :data 123})\nGot something going down!\ntrue\n" "(def news (chan 1))\n(def shouter (pub news :topics))\n\n(def alice (chan 1))\n(def bob (chan 1))\n(def clyde (chan 1))\n\n(sub shouter :celebrity-gossip alice)\n(sub shouter :space-x bob)\n(sub shouter :space-x clyde)\n\n(go-loop [heard (<! alice)] (println \"alice heard: \" heard))\n(go-loop [heard (<! bob)] (println \"bob heard: \" heard))\n(go-loop [heard (<! clyde)] (println \"clyde heard: \" heard))\n\n(put! news {:topics :celebrity-gossip :data \"omg she's prego!\"})\n(put! news {:topics :space-x :data \"omg we're landing!\"})\n\n; notice: they both \"heard\" the space-x news\n; Also, since I'm a bit new to `async`, I'm not sure on this:\n; There seems to be some issues with bob only hearing when clyde is listening.\n; not sure what's up."], :notes nil, :arglists ["ch topic-fn" "ch topic-fn buf-fn"], :doc "Creates and returns a pub(lication) of the supplied channel,\n  partitioned into topics by the topic-fn. topic-fn will be applied to\n  each value on the channel and the result will determine the 'topic'\n  on which that value will be put. Channels can be subscribed to\n  receive copies of topics using 'sub', and unsubscribed using\n  'unsub'. Each topic will be handled by an internal mult on a\n  dedicated channel. By default these internal channels are\n  unbuffered, but a buf-fn can be supplied which, given a topic,\n  creates a buffer with desired properties.\n\n  Each item is distributed to all subs in parallel and synchronously,\n  i.e. each sub must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow subs from holding up the pub.\n\n  Items received when there are no matching subs get dropped.\n\n  Note that if buf-fns are used then each topic is handled\n  asynchronously, i.e. if a channel is subscribed to more than one\n  topic it should not expect them to be interleaved identically with\n  the source.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/pub"}, :clojure.reflect/type-reflect {:added "1.3", :ns "clojure.reflect", :name "type-reflect", :file "clojure/reflect.clj", :type "function", :column 1, :see-alsos [:clojure.reflect/reflect], :line 58, :examples [";;;; Alphabetically list all public static fields in java.lang.Integer\n\n(use 'clojure.reflect)\n\n(->> java.lang.Integer \n     clojure.reflect/type-reflect\n     :members \n     (filter #(instance? clojure.reflect.Field %)) \n     (filter #(:public (:flags %)))\n     (filter #(:static (:flags %)))\n     (map #(vector (:name %) (:type %)))\n     (sort)\n     (pprint))\n\n;;=> ([BYTES int]\n;;    [MAX_VALUE int]\n;;    [MIN_VALUE int]\n;;    [SIZE int]\n;;    [TYPE java.lang.Class])" ";;;; List class hierarchy for a particular class \n\n(defn class-hierarchy [clazz]\n  (let [refl (fn [c] (assoc (clojure.reflect/type-reflect c) :name c))]\n    (loop [type (refl clazz) hierarchy '()]\n      (let [parent (->> type\n                        :bases\n                        (map refl)\n                        (remove #(:interface (:flags %)))\n                        first)]\n         (if parent\n           (recur parent (conj hierarchy (:name type)))\n           (conj hierarchy java.lang.Object))))))\n\n(pprint (class-hierarchy javax.security.auth.login.CredentialNotFoundException))\n;;=> (java.lang.Object\n;;    java.lang.Throwable\n;;    java.lang.Exception\n;;    java.security.GeneralSecurityException\n;;    javax.security.auth.login.LoginException\n;;    javax.security.auth.login.CredentialException\n;;    javax.security.auth.login.CredentialNotFoundException)\n\n(pprint (class-hierarchy javax.swing.JPasswordField$AccessibleJPasswordField))\n;;=> (java.lang.Object\n;;    javax.accessibility.AccessibleContext\n;;    java.awt.Component$AccessibleAWTComponent\n;;    java.awt.Container$AccessibleAWTContainer\n;;    javax.swing.JComponent$AccessibleJComponent\n;;    javax.swing.text.JTextComponent$AccessibleJTextComponent\n;;    javax.swing.JTextField$AccessibleJTextField\n;;    javax.swing.JPasswordField$AccessibleJPasswordField)\n" "(require '(clojure [reflect :as cr] [pprint :as pp]))\n\n;; Let us see what is available in the DynamicClassLoader\n(->> clojure.lang.DynamicClassLoader \n     cr/type-reflect\n     :members\n     (sort-by :name)\n     (pp/print-table [:name :flags :parameter-types]))\n;|                           :name |                      :flags |                           :parameter-types |\n;|---------------------------------+-----------------------------+--------------------------------------------|\n;|                      EMPTY_URLS |           #{:static :final} |                                            |\n;|                          addURL |                  #{:public} |                             [java.net.URL] |\n;|                      classCache |                  #{:static} |                                            |\n;| clojure.lang.DynamicClassLoader |                  #{:public} |                    [java.lang.ClassLoader] |\n;| clojure.lang.DynamicClassLoader |                  #{:public} |                                         [] |\n;|                    constantVals |                         #{} |                                            |\n;|                     defineClass |                  #{:public} | [java.lang.String byte<> java.lang.Object] |\n;|                       findClass |               #{:protected} |                         [java.lang.String] |\n;|               findInMemoryClass |                  #{:static} |                         [java.lang.String] |\n;|                    getConstants |                  #{:public} |                                      [int] |\n;|                       loadClass | #{:synchronized :protected} |                 [java.lang.String boolean] |\n;|               registerConstants |                  #{:public} |                   [int java.lang.Object<>] |\n;|                              rq |           #{:static :final} |                                            |"], :notes nil, :arglists ["typeref & options"], :doc "Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each member is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/type-reflect"}, :clojure.core/ensure-reduced {:added "1.7", :ns "clojure.core", :name "ensure-reduced", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduced :clojure.core/reduced? :clojure.core/unreduced :clojure.core/reduce], :line 2841, :examples ["(ensure-reduced :foo)\n;;=> object[clojure.lang.Reduced 0x7dc19a70 {:status :ready, :val :foo}]\n\n(ensure-reduced (reduced :foo))\n;;=> object[clojure.lang.Reduced 0x45385f75 {:status :ready, :val :foo}]"], :notes nil, :arglists ["x"], :doc "If x is already reduced?, returns it, else returns (reduced x)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ensure-reduced"}, :clojure.core.async/close! {:ns "clojure.core.async", :name "close!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/chan], :line 177, :examples ["(let [c (chan 2) ]\n  (>!! c 1)\n  (>!! c 2)\n  (close! c)\n  (println (<!! c)) ; 1\n  (println (<!! c)) ; 2\n  ;; since we closed the channel this will return false(we can no longer add values)\n  (>!! c 1))"], :notes nil, :arglists ["chan"], :doc "Closes a channel. The channel will no longer accept any puts (they\n  will be ignored). Data in the channel remains available for taking, until\n  exhausted, after which takes will return nil. If there are any\n  pending takes, they will be dispatched with nil. Closing a closed\n  channel is a no-op. Returns nil.\n\n  Logically closing happens after all puts have been delivered. Therefore, any\n  blocked or parked puts will remain blocked/parked until a taker releases them.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/close!"}, :clojure.core.async/toggle {:ns "clojure.core.async", :name "toggle", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 821, :examples nil, :notes nil, :arglists ["mix state-map"], :doc "Atomically sets the state(s) of one or more channels in a mix. The\n  state map is a map of channels -> channel-state-map. A\n  channel-state-map is a map of attrs -> boolean, where attr is one or\n  more of :mute, :pause or :solo. Any states supplied are merged with\n  the current state.\n\n  Note that channels can be added to a mix via toggle, which can be\n  used to add channels in a particular (e.g. paused) state.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/toggle"}, :clojure.core.logic/seqc {:ns "clojure.core.logic", :name "seqc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2887, :examples nil, :notes nil, :arglists ["v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/seqc"}, :clojure.core/*print-level* {:added "1.0", :ns "clojure.core", :name "*print-level*", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 27, :examples ["user=> *print-level*\nnil\nuser=> [1 [2 [3]]]\n[1 [2 [3]]]\n\nuser=> (set! *print-level* 2)\n2\nuser=> [1 [2 [3]]]\n[1 [2 #]]"], :notes nil, :arglists [], :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-level*"}, :clojure.core.async/take {:ns "clojure.core.async", :name "take", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 980, :examples nil, :notes nil, :arglists ["n ch" "n ch buf-or-n"], :doc "Returns a channel that will return, at most, n items from ch. After n items\n   have been returned, or ch has been closed, the return channel will close.\n\n  The output channel is unbuffered by default, unless buf-or-n is given.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/take"}, :clojure.core/map-indexed {:added "1.2", :ns "clojure.core", :name "map-indexed", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map :clojure.core/keep-indexed], :line 7203, :examples ["user=> (map-indexed (fn [idx itm] [idx itm]) \"foobar\")\n([0 \\f] [1 \\o] [2 \\o] [3 \\b] [4 \\a] [5 \\r])\n\n" ";; or simply\nuser=> (map-indexed vector \"foobar\")\n([0 \\f] [1 \\o] [2 \\o] [3 \\b] [4 \\a] [5 \\r])" "user=> (map-indexed hash-map \"foobar\")\n({0 \"f\"} {1 \"o\"} {2 \"o\"} {3 \"b\"} {4 \"a\"} {5 \"r\"})"], :notes nil, :arglists ["f" "f coll"], :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/map-indexed"}, :clojure.core.logic/->SubstValue {:ns "clojure.core.logic", :name "->SubstValue", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 197, :examples nil, :notes nil, :arglists ["v doms eset"], :doc "Positional factory function for class clojure.core.logic.SubstValue.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->SubstValue"}, :clojure.core/shuffle {:added "1.2", :ns "clojure.core", :name "shuffle", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rand-nth], :line 7194, :examples [";; Make five permutations of the [1 2 3] vector.\n;; Notice that the type of the shuffled collection is retained.\n(repeatedly 5 (partial shuffle [1 2 3]))\n;;=> ([2 3 1] [2 1 3] [2 3 1] [3 2 1] [3 1 2])"], :notes nil, :arglists ["coll"], :doc "Return a random permutation of coll", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/shuffle"}, :clojure.zip/make-node {:added "1.0", :ns "clojure.zip", :name "make-node", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 83, :examples nil, :notes nil, :arglists ["loc node children"], :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/make-node"}, :clojure.core/val {:added "1.0", :ns "clojure.core", :name "val", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vals :clojure.core/key :clojure.core/keys], :line 1566, :examples [";; emulate 'vals'\n(map val {:a 1 :b 2})\n;;=> (1 2)\n" "(val (first {:one :two}))\n;;=> :two" ";syntactic sugar for (val)\n(:doc (meta #'meta))" ";; extracts the key of a map entry\n(val (clojure.lang.MapEntry. :a :b))\n;;=> :b"], :notes ["This is my first attempt at using this site to gain an understanding of a closure function. Two of the examples above seem incorrect.  \r\n\r\nExample 3(?) seems to have nothing to do with val  \r\n\r\n(notice the lack of example identifiers)\r\n"], :arglists ["e"], :doc "Returns the value in the map entry.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/val"}, :clojure.core/list* {:added "1.0", :ns "clojure.core", :name "list*", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 640, :examples [";; `list*` function:\nuser=> (list* 1 [2 3])\n(1 2 3)\nuser=> (list* 1 2 [3 4])\n(1 2 3 4)\n\n;; compared to regular `list` function:\nuser=> (list 1 [2 3])\n(1 [2 3])\nuser=> (list 1 2 [3 4])\n(1 2 [3 4])\n\n;; Corner cases:\nuser=> (list* nil [1 2])\n(nil 1 2)\nuser=> (list* 1 nil)\n(1)\nuser=> (list* () [1 2])\n(() 1 2)\nuser=> (list* 1 ())\n(1)\n" ";;Prepend a map to a list\nuser=> (list* {:name \"Anne\"} [{:city \"NJ\"}]) \n({:name \"Anne\"} {:city \"NJ\"})" ";; Useful if you want to get all the arguments of a function into a list (actually a seq, but that is not important)\n(defn args-to-list [a b c & args]\n  (list* a b c args))\n\nuser=> (args-to-list 1 2 3 4 5 6)\n(1 2 3 4 5 6)\n\n;; same as list, but it expects the last element to be a sequence which is then unpacked \n\n;; Example usage in the wild\n(defn my-max\n  ([a] a)\n  ([a b] (if (> a b) a b))\n  ([a b & args] (reduce my-max (list* a b args))))\n\n" ";; `list*` function:\nuser=> (list* 1 (2 3))\n(1 2 3)\n\nuser=> (list* 1 2 (3 4))\n(1 2 3 4)"], :notes ["The doc string mentions returning a new list, but it should say a new sequence.  Surprisingly, `list*` typically does not return an actual list. Instead, it usually returns a Cons, which works as a seq, but is not strictly a list.  \n\n```\n(list? (list* 1 '(2 3)))\n;=> false\n\n(type (list* 1 '(2 3)))\n;=> clojure.lang.Cons\n\n(first (list* 1 '(2 3)))\n;=> 1\n\n(peek (list* 1 '(2 3)))\nClassCastException clojure.lang.Cons cannot be cast to clojure.lang.IPersistentStack\n\n(list? (list* '(2 3)))\n;=> true\n\n(list? (into () (list* 1 '(2 3))))\n;=> true\n```\n\nI think `seq*` would have been a better name for this function."], :arglists ["args" "a args" "a b args" "a b c args" "a b c d & more"], :doc "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/list*"}, :clojure.core/unchecked-subtract {:added "1.0", :ns "clojure.core", :name "unchecked-subtract", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-add :clojure.core/unchecked-dec :clojure.core/unchecked-inc :clojure.core/unchecked-negate :clojure.core/unchecked-divide :clojure.core/unchecked-subtract :clojure.core/unchecked-multiply :clojure.core/unchecked-remainder :clojure.core/- :clojure.core/-'], :line 1204, :examples [";; can't interchange INTs with LONGs, only F(int, int) or F(long, long)\n;; F is a function, not an\n;; overflow very easily as shown below.\n\n(unchecked-subtract Long/MIN_VALUE 5555555554)\nuser=> 9223372031299220254\n\n;; it promotes to long\n(unchecked-subtract Long/MIN_VALUE (int 1))\nuser=> 9223372036854775807\n\n(unchecked-subtract Integer/MIN_VALUE Long/MIN_VALUE)\nuser=> 9223372034707292160\n\n(unchecked-subtract Long/MIN_VALUE Long/MIN_VALUE)\nuser=> 0\n\n(unchecked-subtract Integer/MIN_VALUE Integer/MIN_VALUE)\nuser=> 0\n\n(unchecked-subtract Integer/MIN_VALUE 0)\nuser=> -2147483648\n\n;; Again, promote to long\n(unchecked-subtract Integer/MIN_VALUE 1)\nuser=> -2147483649\n\n;; To prevent long promotion, see unchecked-subtract-int "], :notes nil, :arglists ["x y"], :doc "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-subtract"}, :clojure.core.logic/empty-s {:ns "clojure.core.logic", :name "empty-s", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 537, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/empty-s"}, :clojure.core/dotimes {:added "1.0", :ns "clojure.core", :name "dotimes", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/repeat :clojure.core/for :clojure.core/doseq], :line 3305, :examples ["user=> (dotimes [n 5] (println \"n is\" n))\nn is 0\nn is 1\nn is 2\nn is 3\nn is 4\nnil" "user=> (dotimes [n 10] \n         (println (map #(* % (inc n)) (range 1 11))))\n\n(1 2 3 4 5 6 7 8 9 10)\n(2 4 6 8 10 12 14 16 18 20)\n(3 6 9 12 15 18 21 24 27 30)\n(4 8 12 16 20 24 28 32 36 40)\n(5 10 15 20 25 30 35 40 45 50)\n(6 12 18 24 30 36 42 48 54 60)\n(7 14 21 28 35 42 49 56 63 70)\n(8 16 24 32 40 48 56 64 72 80)\n(9 18 27 36 45 54 63 72 81 90)\n(10 20 30 40 50 60 70 80 90 100)\nnil"], :macro true, :notes nil, :arglists ["bindings & body"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dotimes"}, :clojure.core.logic.fd/->fd {:ns "clojure.core.logic.fd", :name "->fd", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1147, :examples nil, :notes nil, :arglists ["vars exprs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/->fd"}, :clojure.core/update-in {:added "1.0", :ns "clojure.core", :name "update-in", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc-in :clojure.core/get-in :clojure.core/fnil :clojure.core/update], :line 6092, :examples ["(def users [{:name \"James\" :age 26}  {:name \"John\" :age 43}])\n#'user/users\n\n;; similar to assoc-in but does not simply replace the item.\n;; the specified function is performed on the matching item.\n;; here the age of the second (index 1) user is incremented.\n(update-in users [1 :age] inc)\n;;=> [{:name \"James\", :age 26} {:name \"John\", :age 44}]\n" "(def p {:name \"James\" :age 26})\n#'user/p\n\n(update-in p [:age] inc)\n;;=> {:name \"James\", :age 27}\n\n;; remember, the value of p hasn't changed!\n(update-in p [:age] + 10)\n;;=> {:name \"James\", :age 36}\n\n;; Here we see that the keyed object is \n;; the first argument in the function call.\n;; i.e. :age (- 26 10) => 16\n(update-in p [:age] - 10)\n;;=> {:name \"James\", :age 16}\n\n" "(defn char-cnt [s]\n  \"Counts occurence of each character in s\"\n  (reduce\n    (fn [m k]\n      (update-in m [k] (fnil inc 0)))\n  {}\n  s))\n;; Note use of fnil above \n;; - returns 0 if nil is passed to inc (avoids null pointer exception)\n\n(char-cnt \"foo-bar\")\n;;=> {\\r 1, \\a 1, \\b 1, \\- 1, \\o 2, \\f 1}\n" ";; f has args\n;; The keyed value is placed as the first argument\n;; :a  (/ 3 4 5) => 3/20 \n(update-in {:a 3} [:a] / 4 5)\n;;=> {:a 3/20}" ";; be careful with that empty path sequence, it's seldom what you want\n(update-in {} [] (constantly {:k :v}))\n;;=> {nil {:k :v}}\n\n;; In general, you find that for a non-empty path\n;;   (get-in (update-in m path (constantly v)) path) \n;; is equal to v.\n;; Surprisingly this does not hold true in case of an empty path." ";;You can use update-in in a nested map too, in order to update more than\n;;one value:\n\n(def m {:1 {:value 0, :active false}, :2 {:value 0, :active false}})\n\n(update-in m [:1] assoc :value 1 :active true)\n;;=>{:1 {:value 1, :active true}, :2 {:value 0, :active false}}" ";; We may dig into multiple levels with `update-in`:\n(def player1 {:name \"Player 1\" :attribs {:str 10 :int 11 :wis 9}})\n\n(update-in player1 [:attribs :str] inc)\n;; {:name \"Player 1\", :attribs {:str 11, :int 11, :wis 9}}\n\n(update-in player1 [:attribs :str] * 2)\n;; {:name \"Player 1\", :attribs {:str 20, :int 11, :wis 9}}\n\n;; We can see one level via `update`...\n\n(update player1 :attribs #(update % :str inc))\n;; {:name \"Player 1\", :attribs {:str 11, :int 11, :wis 9}}" "user=> (update-in {:a {:b 3}} [:a :b] inc)\n\n;;=> {:a {:b 4}}" ";; can also use in []\n\nuser=> (update-in [1 2 [1 2 3]] [2 0] inc)\n;;=> [1 2 [2 2 3]]" ";; can mix associative types as well\n\nuser=> (update-in [1 {:a 2 :b 3 :c 4}] [1 :c] (fnil inc 5))\n;; => [1 {:a 2, :b 3, :c 5}]\nuser=> (update-in [1 {:a 2 :b 3 :c 4}] [1 :d] (fnil inc 5))\n;; => [1 {:a 2, :b 3, :c 4, :d 6}]\n\n;; but of course vector indices must be appropriate types\n\nuser=> (update-in [1 {:a 2 :b 3 :c 4}] [:b :c] (fnil inc 5))\nIllegalArgumentException Key must be integer  clojure.lang.APersistentVector.assoc (APersistentVector.java:345)" "(def ds [{:id 1.0 :name \"name1\"}\n         {:id 2.0 :name \"name2\"}\n         {:id 3.0 :name \"name3\"}])\n\n(map (fn [x] (update-in x [:name] #(if (= \"name2\" %) % \"not 2\"))) ds)\n\n;; | :id | :name |\n;; |-----+-------|\n;; | 1.0 | not 2 |\n;; | 2.0 | name2 |\n;; | 3.0 | not 2 |\n"], :notes nil, :arglists ["m ks f & args"], :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/update-in"}, :clojure.core/range {:added "1.0", :ns "clojure.core", :name "range", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3011, :examples [";; default value of 'end' is infinity\nuser=> (range)\n(0 1 2 3 4 5 6 7 8 9 10 ... 12770 12771 12772 12773 ... n)\n\n;; Since clojure 1.2:\nuser=> (take 10 (range))\n(0 1 2 3 4 5 6 7 8 9)\n\nuser=> (range 10)\n(0 1 2 3 4 5 6 7 8 9)\n\nuser=> (range -5 5)\n(-5 -4 -3 -2 -1 0 1 2 3 4)\n\nuser=> (range -100 100 10)\n(-100 -90 -80 -70 -60 -50 -40 -30 -20 -10 0 10 20 30 40 50 60 70 80 90)\n\nuser=> (range 0 4 2)\n(0 2)\n\nuser=> (range 0 5 2)\n(0 2 4)\n\nuser=> (range 0 6 2)\n(0 2 4)\n\nuser=> (range 0 7 2)\n(0 2 4 6)\n\nuser=> (range 100 0 -10)\n(100 90 80 70 60 50 40 30 20 10)\n\nuser=> (range 10 -10 -1)\n(10 9 8 7 6 5 4 3 2 1 0 -1 -2 -3 -4 -5 -6 -7 -8 -9)\n \n\n" ";; Since clojure 1.2:\n\nuser=> (take 10 (range))\n(0 1 2 3 4 5 6 7 8 9)\n" ";; finite range over java Integers\nuser=> (take 5 (range 42 (java.lang.Integer/MAX_VALUE)))\n(42 43 44 45 46)\n\n;; infinite range starting at a certain point\nuser=> (take 5 (drop 42 (range)))\n(42 43 44 45 46)\n" ";; Using a double as the value of step can produce an unexpected extra value.\n;; In the second example below, there's an extra final value that's almost = 0.8.\n\n(range 0 0.8 1/10)\n(0 1/10 1/5 3/10 2/5 1/2 3/5 7/10)\n\nuser=> (range 0 0.8 0.1)\n(0 0.1 0.2 0.30000000000000004 0.4 0.5 0.6 0.7 0.7999999999999999)\n\n;; It's difficult to guess when this behavior will occur, unless you know\n;; whether the double representation of step plus what \"should\" be the\n;; last number is in fact less than end.  From the second example above, you \n;; can see that the extra value won't be included if you replace 0.8 by a \n;; number in 0.1, ..., 0.7 (e.g. since 0.7 is not less than 0.7) but you \n;; wouldn't necessarily know that you will get the extra value for end = 0.9,\n;; 1.0, 1.1, but not for end = 1.2.\n" "user=> (range 0 0)\n()\n\nuser=> (range 0 1)\n(0)"], :notes nil, :arglists ["" "end" "start end" "start end step"], :doc "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/range"}, :clojure.core/future-done? {:added "1.1", :ns "clojure.core", :name "future-done?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/future :clojure.core/future-cancel :clojure.core/future? :clojure.core/future-cancelled?], :line 6456, :examples ["user=> (def f (future (Thread/sleep 5000) (inc 0)))\n\nuser=> (future-done? f)                            \nfalse\n\nuser=> (Thread/sleep 5000)\nnil\n\nuser=> (future-done? f)\ntrue\n\n" ";; beware of cancellation !!!\n\nuser=> (def f (future (Thread/sleep 5000) (inc 0)))\n#'user/f\n\nuser=> (future-cancel f)                           \ntrue\n\nuser=> (future-cancelled? f)                       \ntrue\n\nuser=> (future-done? f)                            \ntrue\n\nuser=> @f                                          \njava.util.concurrent.CancellationException (NO_SOURCE_FILE:0)"], :notes ["Future \"done\" returns true even for abnormal termination like being cancelled or throwing an exception.\r\n\r\nhttp://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html#isDone()"], :arglists ["f"], :doc "Returns true if future f is done", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future-done_q"}, :clojure.core/doseq {:added "1.0", :ns "clojure.core", :name "doseq", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/doall :clojure.core/dorun :clojure.core/for :clojure.core/dotimes :clojure.core/run!], :line 3208, :examples [";; Multiplies every x by every y.\n\n(doseq [x [-1 0 1]\n        y [1  2 3]] \n  (prn (* x y)))\n-1\n-2\n-3\n0\n0\n0\n1\n2\n3\nnil\n\n;; Notice that the x iterates more slowly than y.\n" "user=> (doseq [[x y] (map list [1 2 3] [1 2 3])] \n         (prn (* x y)))\n1\n4\n9\nnil\n\n;; where\nuser=> (map list [1 2 3] [1 2 3])\n((1 1) (2 2) (3 3))" "user=> (doseq [[[a b] [c d]] (map list (sorted-map :1 1 :2 2) (sorted-map :3 3 :4 4))]\n         (prn (* b d)))\n3\n8\nnil\n\n;; where\nuser=> (map list (sorted-map :1 1 :2 2) (sorted-map :3 3 :4 4))\n(([:1 1] [:3 3]) ([:2 2] [:4 4]))" "user=> (doseq [[k v] (map identity {:1 1 :2 2 :3 3})] \n         (prn k v))\n:1 1\n:2 2\n:3 3\nnil\n\n;; where\nuser=> (map identity {:1 1 :2 2 :3 3})\n([:1 1] [:2 2] [:3 3])\n\n;; or simply\nuser=> (doseq [[k v] {:1 1 :2 2 :3 3}]\n         (prn k v))\n:1 1\n:3 3\n:2 2\nnil" ";; Multiple sequences results in a Cartesian cross of their values.\nuser=> (doseq [a [1 2]\n               b [3 4]]\n         (println a b))\n1 3\n1 4\n2 3\n2 4\nnil" ";; Keywords :let, :when, and :while are supported, the same as \"for\"\nuser=> (doseq [x (range 6)\n               :when (odd? x)\n               :let [y (* x x)] ]\n         (println [x y]) )\n[1 1]\n[3 9]\n[5 25]\nnil\n\nuser=> (doseq [x (range 99)\n               :let [y (* x x)] \n               :while (< y 30)\n              ]\n         (println [x y]) )\n[0 0]\n[1 1]\n[2 4]\n[3 9]\n[4 16]\n[5 25]\nnil\nuser=> \n" ";; ClojureCLR example\n;; Prints names of running processes\n\nuser=> (doseq [x (System.Diagnostics.Process/GetProcesses)] \n         (println (.get_ProcessName x)))\navgnt\nSearchIndexer\nsvchost\nchrome\naudiodg\nsvchost\nmbamscheduler\nspoolsv\nnvxdsync\navwebg7\nGoogleCrashHandler64\nsvchost\nCCleaner64\nViakaraokeSrv\n..." ";; simplest use\n\nuser=> (doseq [x [1 2 3 4 5]] (prn x))\n1\n2\n3\n4\n5\nnil" ";;looping over a collection \n\n;;define CarMaker record\n(defrecord CarMaker [cm-name])\n\n;;define CarModel record\n(defrecord CarModel [model-name cmaker doors color])\n\n;;create a car-makes\n(def car-maker {\"cm1\" (->CarMaker \"Renault\")})\n\n;;createa models and add an CarMaker identifier to which model\n(def models {\n              \"m1\" (->CarModel \"Megane\" \"cm1\" 3 \"Black\")\n              \"m2\" (->CarModel \"Zoe\" \"cm1\" 5 \"White\")\n              })\n;;println all model-name in the collection\n(doseq [[k v] models] (println (:model-name (get models k))))" ";;doseq  on vector\n(def my-vector [1 2 3 \"a\" \"b\" \"c\" :a :b :c])\n(doseq [v my-vector] (println v))\n\n;;doseq on hash-map\n(def my-map {:a \"A\" :b \"B\" :c \"C\" :d 1 :e 2 :f 3})\n(doseq [[k v] my-map] (println k \"->\" v))"], :macro true, :notes nil, :arglists ["seq-exprs & body"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/doseq"}, :clojure.core/aset-int {:added "1.0", :ns "clojure.core", :name "aset-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3912, :examples [";; create an array of 10 ints and set one of the values to 31415\n\nuser=> (def is (int-array 10))\n#'user/is\nuser=> (vec is)\n[0 0 0 0 0 0 0 0 0 0]\nuser=> (aset-int is 3 31415)\n31415\nuser=> (vec is)\n[0 0 0 31415 0 0 0 0 0 0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of int. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-int"}, :clojure.test/with-test-out {:added "1.1", :ns "clojure.test", :name "with-test-out", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos nil, :line 273, :examples nil, :macro true, :notes nil, :arglists ["& body"], :doc "Runs body with *out* bound to the value of *test-out*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/with-test-out"}, :clojure.core/print-dup {:ns "clojure.core", :name "print-dup", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/print-ctor :clojure.core/print-method], :line 3658, :examples [";; print-dup can be used for basic serialization\n;; the following methods write/read clojure forms to/from a file\n\n(defn to-file\n  \"Save a clojure form to a file\"\n  [#^java.io.File file form]\n  (with-open [w (java.io.FileWriter. file)]\n    (print-dup form w)))\n \n(defn from-file\n  \"Load a clojure form from file.\"\n  [#^java.io.File file]\n  (with-open [r (java.io.PushbackReader. (java.io.FileReader. file))]\n     (read r)))" ";; print-dup is a multimethod, you can extend it to support new types.\n;; The following statement adds print-dup support to \n;; the java.util.Date class\n(defmethod print-dup java.util.Date [o w]\n  (print-ctor o (fn [o w] (print-dup (.getTime  o) w)) w)) "], :notes ["This is a multimethod that can be implemented to define the printing of various values when \\*print-dup\\* is bound to true."], :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print-dup"}, :clojure.core.logic/composeg* {:ns "clojure.core.logic", :name "composeg*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1060, :examples nil, :macro true, :notes nil, :arglists ["g0" "g0 & gs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/composeg*"}, :clojure.core/delay {:added "1.0", :ns "clojure.core", :name "delay", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/force :clojure.core/realized? :clojure.core/memoize :clojure.core/future :clojure.core/delay?], :line 738, :examples [";; In this example you can see that the first time the delay is forced\n;; the println is executed however the second dereference shows just the\n;; precomputed value.\n\nuser=> (def my-delay (delay (println \"did some work\") 100))\n#'user/my-delay\n\nuser=> @my-delay\ndid some work\n100\n\nuser=> @my-delay\n100\n" ";; Note that the implementation of deref for delays makes it impossible for the\n;; body of the delay to be executed more than once, even if the derefs occur\n;; from multiple threads near the same time, because it is a synchronized method\n;; in Java." ";; test example"], :macro true, :notes nil, :arglists ["& body"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/delay"}, :clojure.core.logic/assoc-dom {:ns "clojure.core.logic", :name "assoc-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 30, :examples nil, :notes nil, :arglists ["x k v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/assoc-dom"}, :clojure.core/isa? {:added "1.0", :ns "clojure.core", :name "isa?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/derive :clojure.core/instance? :clojure.core/underive :clojure.core/ancestors :clojure.core/parents :clojure.core/descendants :clojure.core/make-hierarchy], :line 5504, :examples ["user=> (import 'java.util.PriorityQueue)\njava.util.PriorityQueue\n\nuser=> (bases PriorityQueue)\n(java.util.AbstractQueue java.io.Serializable)\n\nuser=> (import 'java.util.AbstractQueue)\njava.util.AbstractQueue\n\nuser=> (isa? PriorityQueue AbstractQueue)\ntrue\n\nuser=> (bases AbstractQueue)\n(java.util.AbstractCollection java.util.Queue)\n\nuser=> (isa? PriorityQueue java.util.AbstractCollection)\ntrue\n\nuser=> (isa? PriorityQueue java.util.Queue)\ntrue\n\nuser=> (isa? java.util.PriorityQueue java.util.TreeMap)\nfalse" "user=> (derive ::Feline ::Animal)\nnil\nuser=> (derive ::Cat ::Feline)\nnil\n\nuser=> (derive ::Lion ::Feline)\nnil\n\nuser=> (isa? ::Lion ::Feline)\ntrue\n\nuser=> (isa? ::Lion ::Animal)\ntrue\n\nuser=> (isa? ::Tuna ::Feline)\nfalse" ";; you can use vectors to test multiple child/parent pairs\n\nuser=> (derive ::child-1 ::parent-1)\nnil\n\nuser=> (derive ::child-2 ::parent-2)\nnil\n\nuser=> (isa? [::child-1 ::child-2] [::parent-1 ::parent-2])\ntrue"], :notes nil, :arglists ["child parent" "h child parent"], :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/isa_q"}, :clojure.core/eval {:added "1.0", :ns "clojure.core", :name "eval", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/read-string], :line 3202, :examples ["user=> (def *foo* \"(println [1 2 3])\")\n#'user/*foo*\n\nuser=> *foo*\n\"(println [1 2 3])\"\n\nuser=> (eval *foo*)   ; Notice eval'ing a string does not work.\n\"(println [1 2 3])\"\n\nuser=> (eval (read-string *foo*))\n[1 2 3]\nnil" "user=> (eval '(let [a 10] (+ 3 4 a)))\n17\n" "(def x '(+ 2 3))\n(println x) \n=> (+ 2 3)\n(println (eval x))\n=> 5"], :notes ["In normal code, `eval` is rarely used." "Once you get used to eval you will use it more often. You can make nifty things with it."], :arglists ["form"], :doc "Evaluates the form data structure (not text!) and returns the result.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/eval"}, :clojure.test/report {:added "1.1", :ns "clojure.test", :name "report", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 324, :examples nil, :notes nil, :arglists [], :doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/report"}, :clojure.core/*source-path* {:ns "clojure.core", :name "*source-path*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*source-path*"}, :clojure.core.logic/fk {:ns "clojure.core.logic", :name "fk", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 19, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fk"}, :clojure.core/munge {:ns "clojure.core", :name "munge", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 129, :examples ["user> (defn foo [] (println \"foo\"))\n#'user/foo\n\nuser> foo\n#<user$foo user$foo@a0dc71>\n\nuser> (munge foo)\n\"user_DOLLARSIGN_foo_CIRCA_a0dc71\"" "(doseq [c (remove #(Character/isLetterOrDigit %) (map char (range 32 127)))]\n  (println c \"->\" (munge c)))\n;; Prints:\n  ->\n! -> _BANG_\n\" -> _DOUBLEQUOTE_\n# -> _SHARP_\n$ -> $\n% -> _PERCENT_\n& -> _AMPERSAND_\n' -> _SINGLEQUOTE_\n( -> (\n) -> )\n* -> _STAR_\n+ -> _PLUS_\n, -> ,\n- -> _\n. -> .\n/ -> _SLASH_\n: -> _COLON_\n; -> ;\n< -> _LT_\n= -> _EQ_\n> -> _GT_\n? -> _QMARK_\n@ -> _CIRCA_\n[ -> _LBRACK_\n\\ -> _BSLASH_\n] -> _RBRACK_\n^ -> _CARET_\n_ -> _\n` -> `\n{ -> _LBRACE_\n| -> _BAR_\n} -> _RBRACE_\n~ -> _TILDE_"], :notes nil, :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/munge"}, :clojure.core.logic.fd/-lb {:ns "clojure.core.logic.fd", :name "-lb", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-lb"}, :clojure.core.logic.fd/-keep-before {:ns "clojure.core.logic.fd", :name "-keep-before", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this n"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-keep-before"}, :clojure.core/simple-symbol? {:added "1.9", :ns "clojure.core", :name "simple-symbol?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/symbol? :clojure.core/qualified-symbol?], :line 1619, :examples ["(simple-symbol? 'symbol)\n;;=> true\n\n(simple-symbol? 'clojure.core/symbol)\n;;=> false\n\n(simple-symbol? \"string\")\n;;=> false\n(simple-symbol? 42)\n;;=> false\n(simple-symbol? nil)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a symbol without a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/simple-symbol_q"}, :clojure.core.logic.fd/to-vals {:ns "clojure.core.logic.fd", :name "to-vals", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 668, :examples nil, :notes nil, :arglists ["dom"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/to-vals"}, :clojure.core.async/alt!! {:ns "clojure.core.async", :name "alt!!", :file "clojure/core/async.clj", :type "macro", :column 1, :see-alsos [:clojure.core.async/alt! :clojure.core.async/alts!! :clojure.core.async/alts!], :line 340, :examples [";; This example is taken from Timothy Baldridge's `core.async` course on Udemy\n;; https://www.udemy.com/communicating-sequential-processes-with-coreasync/learn/v4/overview\n\n;; Create two channels, c1 and c2\n(let [c1 (chan 1)\n      c2 (chan 1)]\n  ;; Put a value in each channel\n  (>!! c1 42)\n  (>!! c2 44)\n  (thread\n    ;; Take a value from one of the channels.\n    ;; - If the value is taken from c1, return the keyword :c1 and channel c1\n    ;; - Analogously for c2\n    (let [[v c] (alt!! [c1] [:c1 c1]\n                       [c2] [:c2 c2])]\n      ;; Print the returned keyword and whether the value was taken from c1 or c2\n      (println \"Value: \" v)\n      (println \"Chan 1?: \" (= c1 c))\n      (println \"Chan 1?: \" (= c2 c)))))"], :macro true, :notes nil, :arglists ["& clauses"], :doc "Like alt!, except as if by alts!!, will block until completed, and\n  not intended for use in (go ...) blocks.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/alt!!"}, :clojure.core.async/<!! {:ns "clojure.core.async", :name "<!!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/<! :clojure.core.async/take! :clojure.core.async/>!!], :line 106, :examples ["user=> (>!! c \"Blocking - not in go-block\")\ntrue\nuser=> (<!! c)\n\"Blocking - not in go-block\"\n"], :notes nil, :arglists ["port"], :doc "takes a val from port. Will return nil if closed. Will block\n  if nothing is available.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/<!!"}, :clojure.pprint/pprint-newline {:added "1.2", :ns "clojure.pprint", :name "pprint-newline", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos nil, :line 329, :examples nil, :notes nil, :arglists ["kind"], :doc "Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pprint-newline"}, :clojure.core.logic/dissoc-meta {:ns "clojure.core.logic", :name "dissoc-meta", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 27, :examples nil, :notes nil, :arglists ["x k"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/dissoc-meta"}, :clojure.core/add-watch {:added "1.0", :ns "clojure.core", :name "add-watch", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove-watch], :line 2136, :examples [";; Add useful context to watcher function:\n(defn watch-agent [_agent context]\n    (let [watch-fn (fn [_context _key _ref old-value new-value] ;...\n               )] \n        (add-watch _agent nil (partial watch-fn context))))\n" "Notice that it is nondeterministic that return happens first\nor the `print` call happens first. (because they are happening in different threads)\n \nuser> (def a (agent 0))\n=> #'user/a\nuser> a\n=> #agent[{:status :ready, :val 0} 0x591e4e8e]\nuser> (add-watch a :key (fn [k r os ns] (print k r os ns)))\n=> #agent[{:status :ready, :val 0} 0x591e4e8e]\nuser> (send a inc)\n=> #agent[{:status :ready, :val 1} 0x591e4e8e]\n:key #agent[{:status :ready, :val 1} 0x591e4e8e] 0 1\nuser> (send a inc)\n:key #agent[{:status :ready, :val 2} 0x591e4e8e] 1 2\n=> #agent[{:status :ready, :val 2} 0x591e4e8e]\n" "(def a (atom {}))\n\n(add-watch a :watcher\n  (fn [key atom old-state new-state]\n    (prn \"-- Atom Changed --\")\n    (prn \"key\" key)\n    (prn \"atom\" atom)\n    (prn \"old-state\" old-state)\n    (prn \"new-state\" new-state)))\n\n(reset! a {:foo \"bar\"})\n\n;; \"-- Atom Changed --\"\n;; \"key\" :watcher\n;; \"atom\" #<Atom@4b020acf: {:foo \"bar\"}>\n;; \"old-state\" {}\n;; \"new-state\" {:foo \"bar\"}\n;; {:foo \"bar\"}" ";; The name of my account can change, and I want to update another atom accordingly.\n;; I just take the fourth argument that contains the new state and I ignore the other arguments.\n\n(let [account (atom {:name \"pending\" \n                     :funds 100.50 \n                     :profit-loss 23.45})\n      label-account-name (atom \"no-name-yet\")]\n   (add-watch account :listener-one #(reset! label-account-name (:name %4)))\n   (println \"Before swap:\" @label-account-name)\n   (swap! account assoc :name \"CFD\")\n   (println \"After swap:\" @label-account-name))\n\n;; Before swap: no-name-yet\n;; After swap: CFD" ";; ClojureScript: Log the new value of the ref to console whenever it changes\n\n(def a (atom nil))\n\n(add-watch a :logger #(-> %4 clj->js js/console.log))\n\n(reset! a (my-app/initial-state))"], :notes ["One \"gotcha\" is that atoms `add-watch`es do not always guarantee order semantics. So if you have a watch put `[old-val new-val]` on a channel, and your atom operation is something like `(swap! a inc)`, you may see values in your channel like this:\n\n```\n[0 1]\n[2 3]\n[1 2]\n[3 4]\n[6 7]\n[4 5]\n```\n\nThis is because the watches are dispatched in different threads.\n\n[Source](https://groups.google.com/d/msg/clojure/RI1Pq3E3188/YyqyGq36f1oJ)"], :arglists ["reference key fn"], :doc "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/add-watch"}, :clojure.core/some {:added "1.0", :ns "clojure.core", :name "some", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/every? :clojure.core/not-any? :clojure.core/keep :clojure.core/keep-indexed :clojure.core/some-fn :clojure.core/some->], :line 2684, :examples [";; 2 is even, so `some` stops there, 3 and 4 are never tested\n(some even? '(1 2 3 4))\n;;=> true\n\n;; they are all odd, so not true, i.e. nil\n(some even? '(1 3 5 7))\n;;=> nil" "(some true? [false false false])\n;;=> nil\n\n(some true? [false true false])\n;;=> true\n\n(some true? [true true true])\n;;=> true\n" "(some #(= 5 %) [1 2 3 4 5])\n;;=> true\n\n(some #(= 5 %) [6 7 8 9 10])\n;;=> nil" ";; the first logical true value is returned, i.e. anything but nil and false\n;; when return nil if its predicate is logical false.\n(some #(when (even? %) %) '(1 2 3 4))\n;;=> 2" ";; a hash acts as a function returning nil when the\n;; key is not present and the key value otherwise.\n(some {2 \"two\" 3 \"three\"} [nil 3 2])\n;;=> \"three\"\n\n;; there is nothing special about the 'nil' in the collection\n;; other than it is not found in the hash.\n(some {nil \"nothing\" 2 \"two\" 3 \"three\"} [nil 3 2])\n;;=> \"nothing\"\n\n;; the hash (as function) returns a nil for the key of '3';\n(some {2 \"two\" 3 nil} [nil 3 2])\n;;=> \"two\"" ";; some can be used as a substitute for (first (filter ...\n;; in most cases.\n\n(first (filter even? [1 2 3 4]))\n;;=> 2\n\n;; 'some' returns exactly one item (nil if nothing is found)\n(some #(if (even? %) %) [1 2 3 4])\n;;=> 2\n" ";; find a whether a word is in a list of words.\n(def word \"foo\")\n(def words [\"bar\" \"baz\" \"foo\" \"\"])\n(some (partial = word) words)\n;;=> true" ";; here we see sets being used as a predicates\n;; the first member of the collection that appears in the set is returned\n\n(some #{2} (range 0 10))      ;;=> 2\n(some #{6 2 4} (range 0 10))  ;;=> 2\n(some #{2 4 6} (range 3 10))  ;;=> 4\n(some #{200} (range 0 10))    ;;=> nil\n\n" ";; be careful, 'nil' can occasionally be returned on success.\n(#{nil} nil)\n;;=> nil \n\n;; almost as troublesome is returning a false\n(#{false} false)\n;;=> false" ";; if you have a case where the predicate arguments are fixed/known, \n;; but the predicate function isn't:\n;; coll can supply the predicate function instead of the predicate arguments\n\n;; define the function 'not equal' (ne)\n(defn ne [n1 n2] (not= n1 n2))\n;;=> #'user/ne\n\n(some #(% 3 7) (list ne))\n;;=>true\n\n(some #(% 3 3) (list ne))\n;;=>nil\n\n\n" ";; extending the previous example: supplying multiple functions.\n(defn ne [n1 n2] (not= n1 n2)) \n;;=> #'user/ne\n\n;; function to check if the sum is less than 'limit'\n(defn sumlt [limit n1 n2] (> limit (+ n1 n2))) \n;;=>'user/sumlt\n\n(some #(% 3 7) (list ne #(sumlt 10 %1 %2)))   \n;;=>true\n\n(some #(% 3 3) (list ne #(sumlt 10 %1 %2)))   \n;;=>true\n\n(some #(% 7 7) (list ne #(sumlt 10 %1 %2)))   \n;;=>nil\n\n;; same, but one of the functions returns a value instead a boolean.\n(some #(% 3 7) (list ne (fn [n1 n2] (+ n1 n2))))                 \n;;=>true\n\n(some #(% 7 7) (list ne (fn [n1 n2] (+ n1 n2))))                 \n;;=>14\n\n;; the importance of order of the function list.\n(some #(% 7 7) (list ne #(sumlt 10 %1 %2) (fn [n1 n2] (+ n1 n2)))) \n;;=>14\n\n(some #(% 7 7) (list ne (fn [n1 n2] (+ n1 n2)) #(sumlt 10 %1 %2))) \n;;=>14\n\n(some #(% 3 3) (list ne #(sumlt 10 %1 %2) (fn [n1 n2] (+ n1 n2)))) \n;;=>true\n\n(some #(% 3 3) (list ne (fn [n1 n2] (+ n1 n2)) #(sumlt 10 %1 %2))) \n;;=>6\n" ";;if you want to return the element the caused the predicate to return true\n;;use the \"and\" function on the predicate and the argument:\n\n(some #(and (even? %) %) [1 3 5 7 8 2])\n;;=> 8"], :notes ["Be careful about using sets as predicates if you don't know what is in the set.\r\nIn particular, <pre>(#{nil} nil)</pre> is <pre>nil</pre> and <pre>(#{false} false)</pre> is <pre>false</pre> Consider using <pre>contains?</pre> instead."], :arglists ["pred coll"], :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/some"}, :clojure.core/unchecked-divide-int {:added "1.0", :ns "clojure.core", :name "unchecked-divide-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/quot], :line 1225, :examples nil, :notes nil, :arglists ["x y"], :doc "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-divide-int"}, :clojure.core.logic.fd/IIntervals {:ns "clojure.core.logic.fd", :name "IIntervals", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 20, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/IIntervals"}, :clojure.core/unchecked-dec-int {:added "1.0", :ns "clojure.core", :name "unchecked-dec-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1155, :examples nil, :notes nil, :arglists ["x"], :doc "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-dec-int"}, :clojure.core/dorun {:added "1.0", :ns "clojure.core", :name "dorun", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/doall :clojure.core/doseq :clojure.core/run!], :line 3125, :examples ["user=> (dorun 5 (repeatedly #(println \"hi\")))\nhi\nhi\nhi\nhi\nhi\nhi\nnil" "user=> (let [x (atom 0)]\n         (dorun (take 10 (repeatedly #(swap! x inc))))\n         @x)\n10" "user=> (dorun (map #(println \"hi\" %) [\"mum\" \"dad\" \"sister\"]))\nhi mum\nhi dad\nhi sister\nnil" ";;map a function which makes database calls over a vector of values \nuser=> (map #(db/insert :person {:name %}) [\"Fred\" \"Ethel\" \"Lucy\" \"Ricardo\"])\nJdbcSQLException The object is already closed [90007-170]  org.h2.message.DbE\nxception.getJdbcSQLException (DbException.java:329)\n\n;;database connection was closed before we got a chance to do our transactions\n;;lets wrap it in dorun\nuser=> (dorun (map #(db/insert :person {:name %}) [\"Fred\" \"Ethel\" \"Lucy\" \"Ricardo\"]))\nDEBUG :db insert into person values name = 'Fred'\nDEBUG :db insert into person values name = 'Ethel'\nDEBUG :db insert into person values name = 'Lucy'\nDEBUG :db insert into person values name = 'Ricardo'\nnil"], :notes ["`clojure.core/run!` can take the place of `(dorun (map ...))`."], :arglists ["coll" "n coll"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dorun"}, :clojure.core/ns-publics {:added "1.0", :ns "clojure.core", :name "ns-publics", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-map :clojure.core/ns-interns :clojure.core/resolve], :line 4155, :examples [";; create the namespace and switch to it\nuser=> (in-ns 'demo.ns)\n#<Namespace demo.ns>\n\n;; Make sure all of the good stuff in clojure.core is usable here, too.\ndemo.ns=> (clojure.core/use 'clojure.core)\nnil\n\n;; define some public functions\ndemo.ns=> (defn public-fn1 [x y] (+ x y))\n#'demo.ns/public-fn1\ndemo.ns=> (defn public-fn2 [t] (* t t t))\n#'demo.ns/public-fn2\n\n;; define a private function with defn-\ndemo.ns=> (defn- private-fn [s] (/ s 5))\n#'demo.ns/private-fn\n\n;; Switch back to the user namespace\ndemo.ns=> (in-ns 'user)\n#<Namespace user>\n\n;; Get a map of all intern mappings for namespace demo.ns\nuser=> (ns-interns 'demo.ns)\n{public-fn1 #'demo.ns/public-fn1, private-fn #'demo.ns/private-fn, public-fn2 #'demo.ns/public-fn2}\n\n;; Now get a map of only the public mappings.  No private-fn here.\nuser=> (ns-publics 'demo.ns)\n{public-fn1 #'demo.ns/public-fn1, public-fn2 #'demo.ns/public-fn2}\n" ";; See also http://clojure.org/namespaces for information on namespaces in Clojure and how to inspect and manipulate them"], :notes nil, :arglists ["ns"], :doc "Returns a map of the public intern mappings for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-publics"}, :clojure.spec.alpha/& {:ns "clojure.spec.alpha", :name "&", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 637, :examples nil, :macro true, :notes nil, :arglists ["re & preds"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/&"}, :clojure.core.logic/run-constraints {:ns "clojure.core.logic", :name "run-constraints", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2105, :examples nil, :notes nil, :arglists ["xcs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-constraints"}, :clojure.core/ex-data {:added "1.4", :ns "clojure.core", :name "ex-data", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ex-info :clojure.core/try :clojure.core/throw :clojure.core/catch :clojure.core/finally], :line 4748, :examples ["(try\n  (let [response (http/post\n                   \"http://localhost:8080/v1/leads\"\n                   {:form-params {:foo \"somethingBad\"}})]\n    (prn \"This is the response\" response))\n  (catch Exception e\n    (prn \"This is the error\" (ex-data e))))\n\n-------\n\n> \"This is the error\" {:status 500, :headers {\"Content-Type\" \"application/json; \ncharset=utf-8\", \"Content-Length\" \"73\", \"Server\" \"http-kit\", \"Date\" \"Mon, 10 Oct 2016\n 16:53:12 GMT\"}, :body \"{\\\"type\\\":\\\"unknown-\nexception\\\",\\\"class\\\":\\\"java.lang.IllegalArgumentException\\\"}\", :request-time 7,\n :trace-redirects [\"http://localhost:8080/v1/leads\"], :orig-content-encoding nil}" ";; See also: Throwable->map"], :notes nil, :arglists ["ex"], :doc "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ex-data"}, :clojure.core.reducers/append! {:added "1.5", :ns "clojure.core.reducers", :name "append!", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 308, :examples nil, :notes nil, :arglists ["acc x"], :doc ".adds x to acc and returns acc", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/append!"}, :clojure.pprint/code-dispatch {:added "1.2", :ns "clojure.pprint", :name "code-dispatch", :file "clojure/pprint/dispatch.clj", :type "function", :column 1, :see-alsos nil, :line 453, :examples nil, :notes nil, :arglists ["object"], :doc "The pretty print dispatch function for pretty printing Clojure code.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/code-dispatch"}, :clojure.main/repl-exception {:ns "clojure.main", :name "repl-exception", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 147, :examples nil, :notes nil, :arglists ["throwable"], :doc "Returns the root cause of throwables", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl-exception"}, :clojure.core/drop {:added "1.0", :ns "clojure.core", :name "drop", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/take :clojure.core/drop-last :clojure.core/drop-while :clojure.core/nthnext :clojure.core/nthrest], :line 2901, :examples [";; although negative (or zero) drop-item-counts are accepted they do nothing\n(drop -1 [1 2 3 4])\n;;=> (1 2 3 4) \n\n(drop 0 [1 2 3 4])\n;;=> (1 2 3 4) \n\n(drop 2 [1 2 3 4])\n;;=> (3 4) \n\n;; dropping more items than are present is allowed, and all items are dropped.\n(drop 5 [1 2 3 4])\n;;=> ()" ";; similar to subvec but lazy and with seqs\n(take 3 (drop 5 (range 1 11)))\n;;=> (6 7 8)"], :notes nil, :arglists ["n" "n coll"], :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/drop"}, :clojure.zip/up {:added "1.0", :ns "clojure.zip", :name "up", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/down :clojure.zip/left :clojure.zip/right :clojure.zip/next :clojure.zip/seq-zip :clojure.zip/zipper], :line 123, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/up"}, :clojure.core/ident? {:added "1.9", :ns "clojure.core", :name "ident?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/simple-ident? :clojure.core/qualified-ident?], :line 1604, :examples nil, :notes nil, :arglists ["x"], :doc "Return true if x is a symbol or keyword", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ident_q"}, :clojure.core/ancestors {:added "1.0", :ns "clojure.core", :name "ancestors", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/parents :clojure.core/derive :clojure.core/underive :clojure.core/descendants :clojure.core/make-hierarchy :clojure.core/isa? :clojure.core/supers], :line 5538, :examples [";; make up a hierarchy a beagle is a sporting breed is a dog is a quadraped is an \n;; animal\n\nuser=> (derive ::quadruped ::animal)\nnil\nuser=> (derive ::dog ::quadruped)\nnil\nuser=> (derive ::sporting_breed ::dog)\nnil\nuser=> (derive ::beagle ::sporting_breed)\nnil\nuser=> (ancestors ::beagle)\n#{:user/dog :user/sporting_breed :user/animal :user/quadruped}\nuser=>" ";; use ancestors to show which classes ArrayList derives from and which\n;; interfaces it implements\n\nuser=> (ancestors java.util.ArrayList)\n#{java.util.Collection java.util.AbstractList java.io.Serializable java.lang.Cloneable java.util.List java.lang.Object java.util.AbstractCollection java.util.RandomAccess java.lang.Iterable}\nuser=>"], :notes nil, :arglists ["tag" "h tag"], :doc "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ancestors"}, :clojure.spec.alpha/and-spec-impl {:ns "clojure.spec.alpha", :name "and-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1098, :examples nil, :notes nil, :arglists ["forms preds gfn"], :doc "Do not call this directly, use 'and'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/and-spec-impl"}, :clojure.core.logic/all {:ns "clojure.core.logic", :name "all", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1268, :examples nil, :macro true, :notes nil, :arglists ["" "& goals"], :doc "Like fresh but does does not create logic variables.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/all"}, :clojure.core/neg? {:added "1.0", :ns "clojure.core", :name "neg?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/pos? :clojure.core/zero?], :line 1246, :examples ["user=> (neg? -1)\ntrue\nuser=> (neg? 0)\nfalse\nuser=> (neg? 1)\nfalse" "user=> (neg? -0.1)\ntrue\nuser=> (neg? 0.1)\nfalse"], :notes nil, :arglists ["num"], :doc "Returns true if num is less than zero, else false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/neg_q"}, :clojure.core/EMPTY-NODE {:ns "clojure.core", :name "EMPTY-NODE", :file "clojure/gvec.clj", :type "var", :column 1, :see-alsos nil, :line 19, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/EMPTY-NODE"}, :clojure.core.async/partition-by {:ns "clojure.core.async", :name "partition-by", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1163, :examples ["; Source: 4clojure (https://www.4clojure.com/problem/31)\n(partition-by identity [1 1 2 1 1 1 3 3])\n=> ((1 1) (2) (1 1 1) (3 3))"], :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["f ch" "f ch buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/partition-by"}, :clojure.xml/emit {:ns "clojure.xml", :name "emit", :file "clojure/xml.clj", :type "function", :column 1, :see-alsos [:clojure.core/with-out-str], :line 111, :examples ["(use 'clojure.xml)\n;;attrs stores the attributes of a tag and content contains the children\n(emit {:tag :parent :attrs {:value \"Hello\"} :content[\n\t{:tag :child1 :attrs {:value \"World\"}}\n\t{:tag :child2 :attrs {:value \"Clojure\"}}\n\t]})\n\n;; prints this to *out*:\n<?xml version='1.0' encoding='UTF-8'?>\n<parent value='Hello'>\n<child1 value='World'/>\n<child2 value='Clojure'/>\n</parent>"], :notes ["this one have a problem when trying to export xml with string containing & etc (should be escaped). Contribs prxml has this functionality." "A 1.3 compatible version of prxml can be found here:\r\n\r\nhttps://github.com/weissjeffm/clojure.prxml"], :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/emit"}, :clojure.core/delay? {:added "1.0", :ns "clojure.core", :name "delay?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/delay], :line 747, :examples ["user=> (def v (delay (do (println \"start sleeping\") \n                         (Thread/sleep 1000) \n                         10)))\n#'user/v\nuser=> (delay? v)\ntrue\nuser=> (force v)\nstart sleeping\n10\nuser=> (delay? v)\ntrue\nuser=> (force v)\n10\nuser=> "], :notes nil, :arglists ["x"], :doc "returns true if x is a Delay created with delay", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/delay_q"}, :clojure.core/-cache-protocol-fn {:ns "clojure.core", :name "-cache-protocol-fn", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 575, :examples nil, :notes nil, :arglists ["pf x c interf"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/-cache-protocol-fn"}, :clojure.core/doubles {:added "1.0", :ns "clojure.core", :name "doubles", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5318, :examples nil, :notes ["Anybody know what this is used for?\r\nAll I could find is that you can cast an existing double-array to another \r\ndouble-array???\r\n\r\n<pre>user=&gt; (doubles [1 2 3 4 5])\r\njava.lang.ClassCastException: clojure.lang.PersistentVector cannot be cast to [D (NO_SOURCE_FILE:0)\r\nuser=&gt; (doubles (int-array [2 3 2]))\r\njava.lang.ClassCastException: [I cannot be cast to [D (NO_SOURCE_FILE:0)\r\nuser=&gt; (doubles (float-array [2 3 2]))\r\njava.lang.ClassCastException: [F cannot be cast to [D (NO_SOURCE_FILE:0)\r\nuser=&gt; (doubles (double-array [2 3 2]))\r\n#<double[] [d@3c1fc1a6=\"\">\r\nuser=&gt; (type (double-array [2 3 2]))\r\n[D\r\nuser=&gt; (type (doubles (double-array [2 3 2])))\r\n[D\r\nuser=&gt;\r\n</pre>\r\n"], :arglists ["xs"], :doc "Casts to double[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/doubles"}, :clojure.java.javadoc/*feeling-lucky* {:ns "clojure.java.javadoc", :name "*feeling-lucky*", :file "clojure/java/javadoc.clj", :type "var", :column 1, :see-alsos [:clojure.java.javadoc/*feeling-lucky-url*], :dynamic true, :line 17, :examples [";; If true, clojure.java.javadoc/javadoc opens a browser using\n;; *feeling-lucky-url* when it can’t find the proper documentation URL\n;; for a class.\n\n;; opens a browser with *feeling-lucky-url*\n(clojure.java.javadoc/javadoc inc)\n\n;; prints \"Could not find Javadoc for clojure.core$inc\"\n(binding [clojure.java.javadoc/*feeling-lucky* false] \n  (clojure.java.javadoc/javadoc inc))"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/*feeling-lucky*"}, :clojure.core.logic.pldb/with-db {:ns "clojure.core.logic.pldb", :name "with-db", :file "clojure/core/logic/pldb.clj", :type "macro", :column 1, :see-alsos nil, :line 12, :examples nil, :macro true, :notes nil, :arglists ["db & body"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/with-db"}, :clojure.core/if-not {:added "1.0", :ns "clojure.core", :name "if-not", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/if :clojure.core/when-not], :line 759, :examples ["user=> (defn has-neg [coll] \n  (if-not (empty? coll)   ;;  = (if (not (empty? coll)) ...\n    (or (neg? (first coll)) (recur (rest coll)))))\n#'user/has-neg\n\nuser=> (has-neg [])\nnil \n\nuser=> (has-neg [1 2 -3 4])\ntrue" "user=> (if-not (zero? 0) :then :else)\n:else" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false."], :macro true, :notes nil, :arglists ["test then" "test then else"], :doc "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/if-not"}, :clojure.core.logic.fd/unify-with-domain* {:ns "clojure.core.logic.fd", :name "unify-with-domain*", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 34, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/unify-with-domain*"}, :clojure.zip/insert-right {:added "1.0", :ns "clojure.zip", :name "insert-right", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 193, :examples [";;; zip is not default required in clj\n(require '[clojure.zip :as zip])\n\n(def root-tree (zip/seq-zip '(:root (:1st-left-child ) (:1st-right-child\n))))\n\n;;; get the location , in this case is the root of the tree\n(def location (-> root-tree zip/next))\n\n\n(zip/insert-right location :inserted)\n\n;; = > [:root\n;; {:changed? true,\n;;  :l [],\n;;  :pnodes [(:root (:1st-left-child) (:1st-right-child))],\n;;  :ppath nil,\n;;  :r (:inserted (:1st-left-child) (:1st-right-child))}]"], :notes nil, :arglists ["loc item"], :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/insert-right"}, :clojure.java.io/delete-file {:added "1.2", :ns "clojure.java.io", :name "delete-file", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/file :clojure.java.io/copy], :line 430, :examples [";; create a file using spit, then show its contents using slurp\n;; delete it and verify that it has been deleted by trying to print its\n;; contents again\n\nuser=> (require '[clojure.java.io :as io])\nnil\nuser=> (spit \"stuff.txt\" \"blurp\")\nnil\nuser=> (println (slurp \"stuff.txt\"))\nblurp\nnil\nuser=> (io/delete-file \"stuff.txt\")\ntrue\nuser=> (println (slurp \"stuff.txt\"))\njava.io.FileNotFoundException: stuff.txt (The system cannot find the file specif\nied) (NO_SOURCE_FILE:0)\nuser=>" "(require '[clojure.java.io :as io])\n\nuser> (io/delete-file \"d:/code/python/file-which-does-not-exist.py\")\nIOException Couldn't delete d:/code/python/exist.py  \nclojure.java.io/delete-file (io.clj:426)\n\nuser> (io/delete-file \"d:/code/python/file-which-does-not-exist.py\" true)\ntrue"], :notes nil, :arglists ["f & [silently]"], :doc "Delete file f. If silently is nil or false, raise an exception on failure, else return the value of silently.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/delete-file"}, :clojure.core/load {:added "1.0", :ns "clojure.core", :name "load", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/load-file :clojure.core/*read-eval* :clojure.core/load-string], :line 6029, :examples [";; file located at src/address_book/core.clj\n\n(load \"address_book/core\")"], :notes nil, :arglists ["& paths"], :doc "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/load"}, :clojure.core.logic/ext-run-csg {:ns "clojure.core.logic", :name "ext-run-csg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1152, :examples nil, :notes nil, :arglists ["u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ext-run-csg"}, :clojure.core/char {:added "1.1", :ns "clojure.core", :name "char", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/char? :clojure.core/int :clojure.core/chars :clojure.core/char-array], :line 3502, :examples [";; can coerce an int (or similar)\nuser=> (char 97)\n\\a\n\n;; a byte can be coerced to a char\nuser=> (let [bytes-array (.getBytes \"abc\")]\n         (char (first bytes-array)))\n\\a\n\n;; char is just a function\nuser=> (map char [65 66 67 68])\n(\\A \\B \\C \\D)" "(->> [67 108 111 106 117 114 101]\n     (map char)\n     (apply str))\n\n\"Clojure\""], :notes nil, :arglists ["x"], :doc "Coerce to char", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/char"}, :clojure.core.logic/matche {:ns "clojure.core.logic", :name "matche", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1705, :examples [";; Taken from: https://github.com/frenchy64/Logic-Starter/wiki#matche\n;; These are equivalent:\n(run* [q]\n      (conde\n        ((== 'extra q) succeed)\n        ((== 'virgin q) succeed)\n        ((== 'olive q) succeed)\n        ((== 'oil q) succeed)))\n;=> (extra virgin olive oil)\n\n(run* [q]\n      (matche [q]\n              (['extra]  succeed)\n              (['virgin] succeed)\n              (['olive]  succeed)\n              (['oil]    succeed)))\n;=> (extra virgin olive oil)\n\n;; Wild Cards and destructuring: https://github.com/frenchy64/Logic-Starter/wiki#matche-sugar-combining-wildcards-and-destructuring\n(run* [q]\n  (fresh [a o]\n    (== a [1 2 3 4 5])\n    (matche [a]\n            ([ [1 . _] ]\n             (== q \"first\"))\n            ([ [_ . o] ]\n             (== q [\"second\" o])))))\n;=> (\"first\" \n;    [\"second\" (2 3 4 5)])\n\n;; Implicit Variables: https://github.com/frenchy64/Logic-Starter/wiki#matche-sugar-implicit-variables\n(run* [q]\n  (fresh [a o]\n    (== a [1 2 3 4 5])\n    (matche [a]\n            ([ [1 . o] ]\n             (== q [\"one\" o]))\n            ([ [1 2 . ?o] ]\n             (== q [\"two\" ?o]))\n            ([ [o . ?o] ]\n             (== q [\"third\" o ?o])))))\n;=> ([\"one\" (2 3 4 5)] \n;    [\"two\" (3 4 5)] \n;    [\"third\" 1 (2 3 4 5)] "], :macro true, :notes nil, :arglists ["xs & cs"], :doc "Pattern matching macro. All patterns will be tried.\n  See conde.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/matche"}, :clojure.core/extend-type {:added "1.2", :ns "clojure.core", :name "extend-type", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/extend :clojure.core/extend-protocol :clojure.core/defprotocol], :line 814, :examples [";;; This is a library for the shopping result.\n\n(defrecord Banana [qty])\n\n;;; 'subtotal' differ from each fruit.\n\n(defprotocol Fruit\n  (subtotal [item]))\n\n(extend-type Banana\n  Fruit\n  (subtotal [item]\n    (* 158 (:qty item))))\n\n;;; Please see the term of 'reify'."], :macro true, :notes nil, :arglists ["t & specs"], :doc "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/extend-type"}, :clojure.spec.alpha/spec-impl {:ns "clojure.spec.alpha", :name "spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 860, :examples nil, :notes nil, :arglists ["form pred gfn cpred?" "form pred gfn cpred? unc"], :doc "Do not call this directly, use 'spec'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/spec-impl"}, :clojure.core.logic/appendo {:ns "clojure.core.logic", :name "appendo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1772, :examples ["(run* [q]\n  (appendo [:a :b] [:c :d :e] q)) ;; ((:a :b :c :d :e))\n(run* [q]\n  (appendo [:a :b] q [:a :b :c :d :e])) ;; ((:c :d :e))\n"], :notes nil, :arglists ["x y z"], :doc "A relation where x, y, and z are proper collections,\n  such that z is x appended to y", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/appendo"}, :clojure.core.reducers/drop {:added "1.5", :ns "clojure.core.reducers", :name "drop", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 248, :examples nil, :notes nil, :arglists ["n" "n coll"], :doc "Elides the first n values from the reduction of coll.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/drop"}, :clojure.walk/postwalk-replace {:added "1.1", :ns "clojure.walk", :name "postwalk-replace", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/prewalk-replace :clojure.core/replace], :line 117, :examples ["(use 'clojure.walk)\n\n(postwalk-replace {:a 1 :b 2} [:a :b])\n;=> [1 2]\n\n(postwalk-replace {:a 1 :b 2} [:a :b :c])\n;=> [1 2 :c]\n\n(postwalk-replace {:a 1 :b 2} [:a :b [:a :b] :c])\n;=> [1 2 [1 2] :c]" "(postwalk-replace {nil :NIL} {:a 1, :b nil, :c 3, nil 4})\n;=> {:NIL 4, :a 1, :b :NIL, :c 3}"], :notes nil, :arglists ["smap form"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/postwalk-replace"}, :clojure.test/compose-fixtures {:added "1.1", :ns "clojure.test", :name "compose-fixtures", :file "clojure/test.clj", :type "function", :column 1, :see-alsos [:clojure.test/join-fixtures], :line 688, :examples nil, :notes nil, :arglists ["f1 f2"], :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/compose-fixtures"}, :clojure.core.async/unmix* {:ns "clojure.core.async", :name "unmix*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m ch"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unmix*"}, :clojure.core/unchecked-negate {:added "1.0", :ns "clojure.core", :name "unchecked-negate", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-add :clojure.core/unchecked-dec :clojure.core/unchecked-inc :clojure.core/unchecked-negate :clojure.core/unchecked-divide :clojure.core/unchecked-subtract :clojure.core/unchecked-multiply :clojure.core/unchecked-remainder :clojure.core/-], :line 1176, :examples [";; *Almost* always the same as \"-\"\nuser=> (= (- 2) (unchecked-negate 2))\ntrue\nuser=> (= (- (Long/MAX_VALUE)) (unchecked-negate (Long/MAX_VALUE)))\ntrue\n\n;; Except when it's not, because (- (Long/MIN_VALUE)) overflows:\nuser=> (= (- (Long/MIN_VALUE)) (unchecked-negate (Long/MIN_VALUE)))\nArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1501)\n\n;; Indeed:\nuser=> (unchecked-negate (Long/MIN_VALUE))\n-9223372036854775808\n\n;; Careful!\nuser=> (= (Long/MIN_VALUE) (unchecked-negate (Long/MIN_VALUE)))\ntrue"], :notes nil, :arglists ["x"], :doc "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-negate"}, :clojure.core/gensym {:added "1.0", :ns "clojure.core", :name "gensym", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 582, :examples ["user=> (gensym \"foo\")\nfoo2020\n\nuser=> (gensym \"foo\")\nfoo2027\n\nuser=> (gensym \"foo\")\n;; ...\n" "user=> (gensym)\nG__2034\n\nuser=> (let [my-unique-sym (gensym)]\n         my-unique-sym)\nG__2075\n" ";; syntax-reader uses gensym for non-namespace-qualified symbols ending with '#'\n;; http://clojure.org/reader\n\nuser=> `(name0#)       ; gensym, form is useful in defmacro\n(name0__1206__auto__)\n\nuser=> `(user/name1#)  ; no gensym, namespace-qualified\n(user/name1#)\n\nuser=> `(:key0#)       ; no gensym, keyword\n(:key0#)\n\nuser=> `(::key1#)      ; no gensym, keyword\n(:user/key1#)\n"], :notes ["The <pre>(. clojure.lang.RT (nextID))</pre> present gensym's source code (https://github.com/clojure/clojure/blob/clojure-1.5.1/src/jvm/clojure/lang/RT.java#L468) uses java.util.concurrent.atomic.AtomicInteger (and has for the past 6 years, if you trust the Git history)."], :arglists ["" "prefix-string"], :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/gensym"}, :clojure.core/boolean-array {:added "1.1", :ns "clojure.core", :name "boolean-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5225, :examples [";; create an array of Java boolean's using boolean-array\n;; and demonstrate that it can be used for input into the standard\n;; Java Arrays.fill function\n\nuser=> (def bs (boolean-array (map even? (range 3 10))))\n#'user/bs\nuser=> (type bs)\n[Z\nuser=> (vec bs)\n[false true false true false true false]\nuser=> (java.util.Arrays/fill bs 3 7 false)\nnil\nuser=> (vec bs)\n[false true false false false false false]\nuser=>"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of booleans", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/boolean-array"}, :clojure.zip/append-child {:added "1.0", :ns "clojure.zip", :name "append-child", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 223, :examples nil, :notes nil, :arglists ["loc item"], :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/append-child"}, :clojure.core/keep {:added "1.2", :ns "clojure.core", :name "keep", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/keep-indexed :clojure.core/map :clojure.core/filter], :line 7233, :examples ["(keep even? (range 1 10))\n;;=> (false true false true false true false true false)\n" ";; comparisons among keep, filter, map and for.\n\n(keep #(if (odd? %) %) (range 10))\n;;=> (1 3 5 7 9)\n\n(map #(if (odd? %) %) (range 10))\n;;=> (nil 1 nil 3 nil 5 nil 7 nil 9)\n\n(for [ x (range 10) :when (odd? x)] x)\n;;=> (1 3 5 7 9)\n\n(filter odd? (range 10))\n;;=> (1 3 5 7 9)" ";; Sieve of Eratosthenes by using 'keep'.\n\n(defn keep-mcdr [f coll]\n  (lazy-seq\n     (when-let [x (first coll)]\n       (cons x  (keep-mcdr f (f x (rest coll)))))))\n\n(defn prime-number [n]\n  (cons 1\n\t(keep-mcdr\n\t (fn[x xs] (if (not-empty xs)\n\t\t     (keep #(if-not (zero? (rem % x)) %)\n\t\t\t   xs)))\n\t (range 2 n))))\n\n(prime-number 100)\n;;=> (1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)\n" "(keep seq [() [] '(1 2 3) [:a :b] nil])\n;;=> ((1 2 3) (:a :b))" ";; `keep` is useful with maps:\n\n(keep {:a 1, :b 2, :c 3} [:a :b :d])\n;;=> (1 2)\n" ";; A set will work as a predicate for another set.\n(keep #{0 1 2 3} #{2 3 4 5})\n;;=> (3 2)" ";; keep returns the results of predicates, \n;; filter returns the original values of collection\n\n(keep (fn [[k _]] (#{:a :b} k)) {:a 1 :b 2 :c 3})\n;;=> (:a :b)\n\n(filter (fn [[k _]] (#{:a :b} k)) {:a 1 :b 2 :c 3})\n;;=> ([:a 1] [:b 2])"], :notes ["Note the difference between `filter` and `keep`.  `filter` returns the original items in a collection that satisfy the predicate.  `keep` returns the non-nil *results* of the given function." "`keep` is like a `map` that filters out `nil` values produced by `f` and could be defined as:\n<pre>\n(def my-keep (comp (partial remove nil?) map))\n</pre>\nor, perhaps more traditionally:\n<pre>\n\n(defn my-keep [& args]\n  (remove nil? (apply map args)))\n</pre>\n" "Note that, unlike `map`, `keep` doesn’t accept multiple collections:\n\n```clojure\n(filter identity (map get [{:a 1} {:b 2} {:d 3}] [:a :b :c]))\n; => (1 2)\n\n(keep get [{:a 1} {:b 2} {:d 3}] [:a :b :c])\n; => ArityException Wrong number of args (3) passed to: core/keep\n```"], :arglists ["f" "f coll"], :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/keep"}, :clojure.core/char-name-string {:added "1.0", :ns "clojure.core", :name "char-name-string", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos [:clojure.core/char-escape-string], :line 342, :examples ["user=> (char-name-string \\newline)\n\"newline\""], :notes nil, :tag "java.lang.String", :arglists [], :doc "Returns name string for char or nil if none", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/char-name-string"}, :clojure.zip/vector-zip {:added "1.0", :ns "clojure.zip", :name "vector-zip", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/seq-zip :clojure.zip/xml-zip :clojure.zip/next :clojure.zip/end?], :line 44, :examples ["\n(require '[clojure.zip :as zip])\n\n(defn zip-map [f loc]\n  \" Map f over every node of the zipper.\n    The function received has the form (f node-value loc),\n    the node value and its location\"\n  (loop [z loc]\n    (if (zip/end? z)\n      (zip/root z) ; perhaps you can call zip/seq-zip or zip/vector-zip?\n      (recur (zip/next (zip/edit z f z))))))\n\n;; Multiply by 100 every node in the tree\nuser=> (zip-map (fn [n nx] (if (vector? n) n (* n 100) )) (zip/vector-zip '[5 [10 20 30] [1 2 3] ]))\n;; Be careful! the returned result by zip/root is not a zipper anymore!\n[500 [1000 2000 3000] [100 200 300]]\n"], :notes nil, :arglists ["root"], :doc "Returns a zipper for nested vectors, given a root vector", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/vector-zip"}, :clojure.zip/leftmost {:added "1.0", :ns "clojure.zip", :name "leftmost", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/rightmost], :line 174, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the leftmost sibling of the node at this loc, or self", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/leftmost"}, :clojure.spec.alpha/conform {:ns "clojure.spec.alpha", :name "conform", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos [:clojure.spec.alpha/unform :clojure.spec.alpha/explain :clojure.spec.alpha/gen], :line 146, :examples ["(require '[clojure.spec.alpha :as s])\n\n;; define spec as a sequential concatenation of two more specs:\n;; pos? and one of possible units (:meters :miles)\n;; :amount and :unit are the names we are giving to each position\n(s/def ::distance (s/cat :amount pos?\n                         :unit #{:meters :miles}))\n\n(s/conform ::distance [3 :meters])\n;; => {:amount 3, :unit :meters}\n\n(s/conform ::distance [3 :steps])\n;; => :clojure.spec.alpha/invalid"], :notes nil, :arglists ["spec x"], :doc "Given a spec and a value, returns :clojure.spec.alpha/invalid \n\tif value does not match spec, else the (possibly destructured) value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/conform"}, :clojure.core.logic/->PMap {:ns "clojure.core.logic", :name "->PMap", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2518, :examples nil, :notes nil, :arglists [""], :doc "Positional factory function for class clojure.core.logic.PMap.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->PMap"}, :clojure.core.logic.pldb/db-retraction {:ns "clojure.core.logic.pldb", :name "db-retraction", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic.pldb/db-fact], :line 100, :examples ["; db-retraction is the reverse operation to db-fact. \n; You can think of db-rel as learning a fact and db-retraction as unlearning it.\n\n; Step 1: define a relation\n(db-rel user x)\n\n; Step 2: create a simple DB\n(def my-db (-> empty-db\n               (db-fact user \"me\")\n               (db-fact user \"you\")))\n;; => {\"user/user_1\" {:clojure.core.logic.pldb/unindexed #{(\"you\") (\"me\")}}}\n\n;; Step 3: retract from \"me\" being a user.\n(db-retraction my-db user \"me\")\n;; => {\"user/user_1\" {:clojure.core.logic.pldb/unindexed #{(\"you\")}}}"], :notes nil, :arglists ["db rel & args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db-retraction"}, :clojure.java.io/make-input-stream {:added "1.2", :ns "clojure.java.io", :name "make-input-stream", :type "function", :see-alsos [:clojure.java.io/IOFactory], :examples nil, :notes nil, :arglists ["x opts"], :doc "Creates a BufferedInputStream. See also IOFactory docs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/make-input-stream"}, :clojure.core.logic/conde {:ns "clojure.core.logic", :name "conde", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1175, :examples nil, :macro true, :notes nil, :arglists ["& clauses"], :doc "Logical disjunction of the clauses. The first goal in\n  a clause is considered the head of that clause. Interleaves the\n  execution of the clauses.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/conde"}, :clojure.core.logic/update-dom {:ns "clojure.core.logic", :name "update-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 480, :examples nil, :notes nil, :arglists ["s x dom f" "s x dom f seenset"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/update-dom"}, :clojure.core/boolean? {:added "1.9", :ns "clojure.core", :name "boolean?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/true?], :line 519, :examples ["(boolean? true)\n;;=> true\n(boolean? false)\n;;=> true\n(boolean? (new Boolean \"true\"))\n;;=> true\n(boolean? (new Boolean \"false\"))\n;;=> true\n\n(boolean? nil)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a Boolean", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/boolean_q"}, :clojure.core/or {:added "1.0", :ns "clojure.core", :name "or", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/and :clojure.core/if], :line 846, :examples ["user> (or true false false)\ntrue\n\nuser> (or true true true)\ntrue\n\nuser> (or false false false)\nfalse\n\nuser> (or nil nil)\nnil\n\nuser> (or false nil)\nnil\n\nuser> (or true nil)\ntrue\n\n;; or doesn't evaluate if the first value is true\nuser> (or true (println \"foo\"))\ntrue\n\n;; order matters\nuser> (or (println \"foo\") true)\nfoo\ntrue\n\n;; does not coerce a given value to a boolean true, returns the value\nuser> (or false 42)\n42\n\nuser> (or false 42 9999)\n42\n\nuser> (or 42 9999)\n42" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";;evaluates last expression for this case\nuser> (or nil false)\nfalse\n\nuser> (or false nil)\nnil"], :macro true, :notes nil, :arglists ["" "x" "x & next"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/or"}, :clojure.core/refer {:added "1.0", :ns "clojure.core", :name "refer", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/refer-clojure :clojure.core/ns], :line 4183, :examples ["user=> (refer 'clojure.string :only '[capitalize trim])\nnil\n\nuser=> (capitalize (trim \" hOnduRAS  \"))\n\"Honduras\"" "user=> (refer 'clojure.string\n              :rename '{capitalize cap, trim trm})\nWARNING: replace already refers to: #'clojure.core/replace in namespace: user, being replaced by: #'clojure.string/replace\nWARNING: reverse already refers to: #'clojure.core/reverse in namespace: user, being replaced by: #'clojure.string/reverse\nnil\n\nuser=> (cap (trm \" hOnduRAS  \"))\n\"Honduras\"\n\nuser=> (join \\, [1 2 3])\n\"1,2,3\"" ";;; `:only' accepts only original names.\n;; wrong\nuser=> (refer 'clojure.string\n              :rename '{capitalize cap, trim trm}\n              :only '[cap trm])\nIllegalAccessError cap does not exist  clojure.core/refer (core.clj:3849)\n\n;; right\nuser=> (refer 'clojure.string\n              :rename '{capitalize cap, trim trm}\n              :only '[capitalize trim])\nnil\n\n;; work well\nuser=> (cap (trm \" hOnduRAS  \"))\n\"Honduras\"\n\n;; and also, cannot use either of them.\nuser=> (join \\, [1 2 3])\nCompilerException java.lang.RuntimeException: Unable to resolve symbol: join in this context, compiling:(NO_SOURCE_PATH:1:1)"], :notes nil, :arglists ["ns-sym & filters"], :doc "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/refer"}, :clojure.stacktrace/print-trace-element {:added "1.1", :ns "clojure.stacktrace", :name "print-trace-element", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos nil, :line 26, :examples ["(clojure.stacktrace/print-trace-element (Exception. \"foo\"))\n; \n;=> nil"], :notes nil, :arglists ["e"], :doc "Prints a Clojure-oriented view of one element in a stack trace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/print-trace-element"}, :clojure.core/.. {:added "1.0", :ns "clojure.core", :name "..", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/-> :clojure.core/doto], :line 1651, :examples ["user> (.. \"fooBAR\" (toLowerCase) (contains \"ooba\"))\ntrue\n\n;; use macroexpand to see how the form above will appear\nuser> (macroexpand '(.. \"fooBAR\" (toLowerCase) (contains \"ooba\")))\n(. (. \"fooBAR\" (toLowerCase)) (contains \"ooba\"))" "user=> (.. \"abc\" toUpperCase (equals \"ABC\"))\n;;=> true" ";; With .. you do not need to add a . to your method.\n(.. \"fooBAR\" (toLowerCase) (contains \"ooba\"))\n\n;; Which you do if using -> instead.\n(-> \"fooBAR\" (.toLowerCase) (.contains \"ooba\"))"], :macro true, :notes nil, :arglists ["x form" "x form & more"], :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/_.."}, :clojure.core.reducers/fold {:added "1.5", :ns "clojure.core.reducers", :name "fold", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos [:clojure.core/pmap :clojure.core/reduce], :line 84, :examples ["(require '[clojure.core.reducers :as reducers])\n(defn diddly ([xs x] (conj xs x)) ([] []))\n(reducers/fold diddly '(1 2 3 4 5 6))     \n;; [1 2 3 4 5 6]                                   \n\n\n;; CAUTION! This example is buggy, as diddly can NOT be used as combinef\n;; Correct combinef can be `into` as combinef is operating on 2 vectors" ";; word-frequencies on large text\n(require '[clojure.core.reducers :as r] '[clojure.string :as s])\n\n(defn count-occurrences [words]\n  (r/fold\n    (r/monoid #(merge-with + %1 %2) (constantly {}))\n    (fn [m [k cnt]] (assoc m k (+ cnt (get m k 0))))\n    (r/map #(vector % 1) words)))\n\n(defn word-count [s]\n  (count-occurrences (s/split s #\"\\s+\")))\n\n(def war-and-peace \"http://www.gutenberg.org/files/2600/2600-0.txt\")\n(def book (slurp war-and-peace))\n\n(def freqs (word-count book))\n(freqs \"Andrew\")\n;; 700" ";; One pitfall of clojure.core.reducers/fold is that the reducing function must\n;; take either three or two arguments according to whether the foldable\n;; collection is a map or not!\n\n(require '[clojure.core.reducers :as r])\n\n(def my-vector (vec (range 10000)))\n(def my-map (into {} (map (juxt (comp keyword str) identity)) my-vector))\n\n;; Identity folds for vector and map. Notice the differing arities of reducef.\n\n(->> my-vector\n     (r/fold (r/monoid into vector)\n             (fn [ret v] (conj ret v)))  ; <- arity 2\n     (= my-vector))\n\n(->> my-map\n     (r/fold (r/monoid merge hash-map)\n             (fn [ret k v] (assoc ret k v)))  ; <- arity 3\n     (= my-map))\n\n;; Caution: this behaviour is not documented. It breaks down as soon as you wrap\n;; the map in a reducer/folder.\n" ";; This example demonstrates how the partition size used to parallelize\n;; fold can be modified. \n(require '[clojure.core.reducers :as r])\n\n(defn simple-fold \n  [partition-size]\n  (r/fold partition-size\n          + ;; function that returns the init value. (x) => 0\n          +\n          (r/filter odd?\n                    (r/map inc\n                           (r/filter number?\n                                     (range 10000))))))\n\n;; Default partition size.\n(simple-fold 512) \n;;=> 25000000\n\n;; Raises the number of elements from coll that will be processed in each partition.\n(simple-fold 1000) \n;; => 25000000\n\n;; Partition each element to be processed separately.\n(simple-fold 1) \n;; =>> 25000000\n\n;; All of the above return the same result, but they utilize different\n;; sized partitions to achieve parallelization."], :notes nil, :arglists ["reducef coll" "combinef reducef coll" "n combinef reducef coll"], :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/fold"}, :clojure.core/long-array {:added "1.0", :ns "clojure.core", :name "long-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/longs], :line 5280, :examples [";; create a long array using long-array and show it can be used\n;; with the standard Java Arrays functions binarySearch and fill\n;; note the needed coercions\n\nuser=> (def is (long-array (range 3 20)))\n#'user/is\nuser=> (vec is)\n[3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]\nuser=> (java.util.Arrays/binarySearch is (long 10))\n7\nuser=> (java.util.Arrays/fill is 3 8 (long 99))\nnil\nuser=> (vec is)\n[3 4 5 99 99 99 99 99 11 12 13 14 15 16 17 18 19]\nuser=>"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of longs", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/long-array"}, :clojure.core/bit-flip {:added "1.0", :ns "clojure.core", :name "bit-flip", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 1335, :examples ["user=> (bit-flip 2r1011 2)\n15 \n;; 15 = 2r1111\n\n(bit-flip 2r1111 2)\n11 \n;; 11 = 2r1011"], :notes nil, :arglists ["x n"], :doc "Flip bit at index n", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-flip"}, :clojure.core/name {:added "1.0", :ns "clojure.core", :name "name", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/namespace], :line 1581, :examples [";; the name of the keyword is without the ':'\n;; \"str\" will retain the ':'.\n(name :x)\n;;=> \"x\"\n\n(name \"x\")\n;;=> \"x\"\n\n;; returns the symbol name as a string without the namespace.\n(name 'x)\n;;=> \"x\"\n\n(name 'user/x)\n;;=> \"x\"\n\n;; throws an error for invalid types, no nil punning\n(name nil)\n;;=> Error: Doesn't support name:\n\n(name 2)\n;;=> Error: Doesn't support name: 2" ";; Note that for namespaced keywords, (name) only returns the keyword part.\n(name :my-ns/my-key)\n;;=> \"my-key\"\n\n;; If you want the namespace part, you can use (namespace):\n(namespace :my-ns/my-key)\n;;=> \"my-ns\"\n\n;; Using (str) will give you both parts, but also includes the leading colon.\n(str :my-ns/my-key)\n;;=> \":my-ns/my-key\"" ";; To get full key\n(defn keyname [key] (str (namespace key) \"/\" (name key)))\n(keyname :ns/key)\n=> \"ns/key\"\n(keyname :ns/deep/key)\n=> \"ns/deep/key\"\n;; Just for fun\n(string/replace :key/val #\"^:\" \"\")\n=> \"key/val\""], :notes nil, :tag "java.lang.String", :arglists ["x"], :doc "Returns the name String of a string, symbol or keyword.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/name"}, :clojure.core/re-seq {:added "1.0", :ns "clojure.core", :name "re-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-find :clojure.core/re-groups :clojure.core/re-pattern :clojure.core/re-matcher :clojure.core/re-matches :clojure.string/split :clojure.core/subs], :line 4814, :examples ["user=> (re-seq #\"\\d\" \"clojure 1.1.0\")\n(\"1\" \"1\" \"0\")\n" ";; Get a sequence of words out of a string.\nuser=> (re-seq #\"\\w+\" \"mary had a little lamb\")\n(\"mary\" \"had\" \"a\" \"little\" \"lamb\")\n" ";; Parenthesized groups in the regex cause each returned match to be a\n;; vector of matched strings.  See re-find for more examples.\nuser=> (def line \" RX pkts:18 err:5 drop:48\")\n#'user/line\n\nuser=> (re-seq #\"(\\S+):(\\d+)\" line)\n([\"pkts:18\" \"pkts\" \"18\"] [\"err:5\" \"err\" \"5\"] [\"drop:48\" \"drop\" \"48\"])\n" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases." ";; separate with Camel case words and digits and\n;; join with single white-space character\n\nuser=> (clojure.string/join \" \" (re-seq #\"[A-Z][a-z]+|[0-9]+\" \"ManishKumar12332\"))\n\"Manish Kumar 12332\"" ";; re-seq requires the string to be in memory. What if the string is in a file\n;; many GB in size? You can roll a \"line-seq of re-seq each line\" or use:\n\n(defn restream-seq\n[^java.util.regex.Pattern re ^java.io.InputStream is]\n  (let [s (java.util.Scanner. is)]\n    ((fn step []\n       (if-let [token (.findInLine s re)]\n         (cons token (lazy-seq (step)))\n         (when (.hasNextLine s) (.nextLine s) (step)))))))\n\n;; first 10 digits of Pi out of the book (1M available)\n(let [pi-book \"http://www.gutenberg.org/files/50/50.txt\"]\n  (with-open [is (.openStream (java.net.URL. pi-book))]\n    (doall\n      (sequence\n        (comp cat (map str) (take 10))\n        (restream-seq #\"\\d{10}\" is)))))\n; (\"1\" \"4\" \"1\" \"5\" \"9\" \"2\" \"6\" \"5\" \"3\" \"5\")"], :notes nil, :arglists ["re s"], :doc "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-seq"}, :clojure.core/aset-byte {:added "1.0", :ns "clojure.core", :name "aset-byte", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3942, :examples [";; create an array of 10 bytes and set one of the values to 127\n\nuser=> (def bs (byte-array 10))\n#'user/bs\nuser=> (vec bs)\n[0 0 0 0 0 0 0 0 0 0]\nuser=> (aset-byte bs 2 127)\n127\nuser=> (vec bs)\n[0 0 127 0 0 0 0 0 0 0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of byte. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-byte"}, :clojure.core.logic/matchu {:ns "clojure.core.logic", :name "matchu", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1744, :examples nil, :macro true, :notes nil, :arglists ["xs & cs"], :doc "Define a committed choice goal. See condu.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/matchu"}, :clojure.core/merge {:added "1.0", :ns "clojure.core", :name "merge", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/merge-with :clojure.core/hash-map :clojure.core/assoc], :line 3033, :examples ["(merge {:a 1 :b 2 :c 3} {:b 9 :d 4})\n;;=> {:d 4, :a 1, :b 9, :c 3}" "(merge {:a 1} nil)   ;=> {:a 1}\n(merge nil {:a 1})   ;=> {:a 1}\n(merge nil nil)      ;=> nil\n" ";; `merge` can be used to support the setting of default values\n(merge {:foo \"foo-default\" :bar \"bar-default\"} \n       {:foo \"custom-value\"})\n;;=> {:foo \"custom-value\" :bar \"bar-default\"}\n\n;; This is useful when a function has a number of options\n;; with default values.\n(defn baz [& options]\n   (let [options (merge {:opt1 \"default-1\" :opt2 \"default-2\"} \n                        (first options))]\n      options))\n\n(baz {:opt1 \"custom-1\" :opt3 \"custom-3\"})\n;;=> {:opt3 \"custom-3\" :opt1 \"custom-1 :opt2 \"default-2\"}\n" ";; For recursively merging deeply-nested maps:\n\n(defn deep-merge [v & vs]\n  (letfn [(rec-merge [v1 v2]\n            (if (and (map? v1) (map? v2))\n              (merge-with deep-merge v1 v2)\n              v2))]\n    (if (some identity vs)\n      (reduce #(rec-merge %1 %2) v vs)\n      (last vs))))\n\n(deep-merge {:a {:b true}} {:a {:b false}} {:a {:b nil}})\n;; {:a {:b nil}}\n\n(deep-merge {:a 1} nil)\n;; nil ;; note that this isn't consistent with the regular merge function\n\n;; Source: https://gist.github.com/danielpcox/c70a8aa2c36766200a95#gistcomment-2677502"], :notes nil, :arglists ["& maps"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/merge"}, :clojure.core/byte-array {:added "1.1", :ns "clojure.core", :name "byte-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bytes :clojure.core/byte], :line 5233, :examples [";; create an array of bytes\n;; and demonstrate that you can use it in the standard Java fill function\n;; note the needed byte coercion in the fill function call\n\nuser=> (def bees (byte-array 10))\n#'user/bees\n\nuser=> (for [i (range 10)](aset-byte bees i (* i i)))\n(0 1 4 9 16 25 36 49 64 81)\n\nuser=> (vec bees)\n[0 1 4 9 16 25 36 49 64 81]\n\nuser=> (java.util.Arrays/fill bees (byte 122))\nnil\nuser=> (vec bees)\n[122 122 122 122 122 122 122 122 122 122]\nuser=>" ";; copied from the example in clojure.core/byte\nuser=> (def x (byte-array [(byte 0x43) \n                           (byte 0x6c)\n                           (byte 0x6f)\n                           (byte 0x6a)\n                           (byte 0x75)\n                           (byte 0x72)\n                           (byte 0x65)\n                           (byte 0x21)]))\n#'user/x\n\nuser=> (String. x)\n\"Clojure!\""], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of bytes", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/byte-array"}, :clojure.string/trim-newline {:added "1.2", :ns "clojure.string", :name "trim-newline", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/trim :clojure.string/triml :clojure.string/trimr], :line 274, :examples ["<pre>\r\nuser=> (clojure.string/trim-newline \"test\\n\\r\")\r\n\"test\"\r\n</pre>"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/trim-newline"}, :clojure.core/accessor {:added "1.0", :ns "clojure.core", :name "accessor", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get], :line 4037, :examples ["(defstruct car-struct :make :model :year :color)\n\n(def car (struct car-struct \"Toyota\" \"Prius\" 2010))\n\n(def make (accessor car-struct :make))\n\nuser=> (make car)  ; Same as both (car :make) and (:make car)\n\"Toyota\"           \n\n"], :notes nil, :arglists ["s key"], :doc "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/accessor"}, :clojure.core/char? {:added "1.0", :ns "clojure.core", :name "char?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/char], :line 153, :examples ["user=> (char? \\a)\ntrue\n\nuser=> (char? 22)\nfalse\n\nuser=> (char? \"a\")\nfalse\n\nuser=> (char? (first \"abc\"))\ntrue"], :notes nil, :arglists ["x"], :doc "Return true if x is a Character", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/char_q"}, :clojure.core.logic/-fnm {:ns "clojure.core.logic", :name "-fnm", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1628, :examples nil, :macro true, :notes nil, :arglists ["fn-gen t as & cs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-fnm"}, :clojure.core.logic.fd/sorted-set->domain {:ns "clojure.core.logic.fd", :name "sorted-set->domain", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 148, :examples nil, :notes nil, :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/sorted-set->domain"}, :clojure.core.logic/force-ans {:ns "clojure.core.logic", :name "force-ans", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2273, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/force-ans"}, :clojure.xml/startparse-sax {:ns "clojure.xml", :name "startparse-sax", :file "clojure/xml.clj", :type "function", :column 1, :see-alsos nil, :line 75, :examples nil, :notes nil, :arglists ["s ch"], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/startparse-sax"}, :clojure.core/assoc! {:added "1.1", :ns "clojure.core", :name "assoc!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/dissoc! :clojure.core/transient :clojure.core/conj! :clojure.core/pop! :clojure.core/disj! :clojure.core/persistent!], :line 3360, :examples [";; The key concept to understand here is that transients are \n;; not meant to be `bashed in place`; always use the value \n;; returned by either assoc! or other functions that operate\n;; on transients.\n\n(defn merge2\n  \"An example implementation of `merge` using transients.\"\n  [x y]\n  (persistent! (reduce\n                (fn [res [k v]] (assoc! res k v))\n                (transient x)\n                y)))\n\n;; Why always use the return value, and not the original?  Because the return\n;; value might be a different object than the original.  The implementation\n;; of Clojure transients in some cases changes the internal representation\n;; of a transient collection (e.g. when it reaches a certain size).  In such\n;; cases, if you continue to try modifying the original object, the results\n;; will be incorrect.\n\n;; Think of transients like persistent collections in how you write code to\n;; update them, except unlike persistent collections, the original collection\n;; you passed in should be treated as having an undefined value.  Only the return\n;; value is predictable." "(def m (assoc! (transient {})  :x 1 :y 2))\n\n(:x m)\n;; 1\n\n(:y m)\n;; 2\n\n(count m)\n;; 2"], :notes nil, :arglists ["coll key val" "coll key val & kvs"], :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/assoc!"}, :clojure.core.async/partition {:ns "clojure.core.async", :name "partition", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1138, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["n ch" "n ch buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/partition"}, :clojure.core/>= {:added "1.0", :ns "clojure.core", :name ">=", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/<=], :line 1077, :examples ["user=> (>= 2 1)\ntrue\nuser=> (>= 2 2)\ntrue\nuser=> (>= 1 2)\nfalse\nuser=> (>= 6 5 4 3 2)\ntrue"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/>="}, :clojure.core.logic/unify-with-map* {:ns "clojure.core.logic", :name "unify-with-map*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 911, :examples nil, :notes nil, :arglists ["u v s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unify-with-map*"}, :clojure.core/rest {:added "1.0", :ns "clojure.core", :name "rest", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/next :clojure.core/first :clojure.core/drop :clojure.core/pop :clojure.core/nthrest :clojure.core/nthnext], :line 66, :examples ["(rest [1 2 3 4 5])            ;;=> (2 3 4 5)\n(rest [\"a\" \"b\" \"c\" \"d\" \"e\"])  ;;=> (\"b\" \"c\" \"d\" \"e\")" ";; For the most part rest must take a collection as its argument.\n;; It always returns a seq.\n(rest '())\n;;=> ()" ";; There is one case where the input is not required to be a collection.\n;; But, 'rest' still returns a list.\n(rest nil)\n;;=> ()" ";; A simple (re-)implementation of 'map' using 'rest' for recursing over a collection.  \n;; Note that (seq coll) is used as the test.\n(defn my-map [func coll]\n  (when-let [s (seq coll)]\n    (cons (func (first s))\n          (my-map func (rest s)))))\n\n(my-map #(* % %) [2 3 5 7 11 13])\n;;=> (4 9 25 49 121 169)" ";; Any collection can be used\n(rest '(1 2 3 4 5))   ;;=> (2 3 4 5)\n(rest [1 2 3 4 5])    ;;=> (2 3 4 5)\n(rest #{1 2 3 4 5})   ;;=> (2 3 4 5)\n\n(rest {1 nil 2 nil 3 nil 4 nil 5 nil}) ;;=> ([2 nil] [3 nil] [4 nil] [5 nil])" ";; Difference between next and rest:\n(rest [:a])\n;; => ()\n(next [:a])\n;; => nil\n\n(rest [])\n;; => ()\n(next [])\n;; => nil\n\n(rest nil)\n;; => ()\n(next nil)\n;; => nil"], :notes ["<b>rest</b> is generally preferred over [next](../clojure.core/next).  See the Clojure.org documentation on writing [lazy](http://clojure.org/lazy) functions.\r\n\r\nAlso, the topic is covered on StackOverflow.com: [rest vs. next](http://stackoverflow.com/questions/4288476/clojure-rest-vs-next).\r\n"], :tag "clojure.lang.ISeq", :arglists ["coll"], :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rest"}, :clojure.core.logic.fd/binops {:ns "clojure.core.logic.fd", :name "binops", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 1111, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/binops"}, :clojure.core/dissoc! {:added "1.1", :ns "clojure.core", :name "dissoc!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc!], :line 3373, :examples [";; dissoc! works on a transient map\n\n;; WARNING: Below is an example of what is called \"bashing in place\" of\n;; a transient, and is _NOT_ the correct way to use transients.  See assoc!\n;; examples for some discussion of the reason.\n\n(let [my-map (transient {:x 1 :y 2 :z 3})]\n  (dissoc! my-map :x)   ; mistake is to use my-map below, not dissoc! return val\n  (persistent! my-map)) ; returns persistent map {:y 2 :z 3}\n\n\n;; Here is a correct way to do the operation described above:\n\n(let [my-map (transient {:x 1 :y 2 :z 3})\n      x (dissoc! my-map :x)]    ; after this, don't use my-map again, only x\n  (persistent! x))    ; returns persistent map {:y 2 :z 3}"], :notes nil, :arglists ["map key" "map key & ks"], :doc "Returns a transient map that doesn't contain a mapping for key(s).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dissoc!"}, :clojure.core.logic/answer-cache {:ns "clojure.core.logic", :name "answer-cache", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1844, :examples nil, :notes nil, :arglists [""], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/answer-cache"}, :clojure.core/floats {:added "1.0", :ns "clojure.core", :name "floats", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5308, :examples nil, :notes nil, :arglists ["xs"], :doc "Casts to float[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/floats"}, :clojure.core/descendants {:added "1.0", :ns "clojure.core", :name "descendants", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ancestors], :line 5554, :examples [";; simple example a toy poodle is a poodle is a dog is an animal\n\nuser=> (derive ::dog ::animal)\nnil\nuser=> (derive ::poodle ::dog)\nnil\nuser=> (derive ::toy_poodle ::poodle)\nnil\nuser=> (descendants ::animal)\n#{:user/toy_poodle :user/poodle :user/dog}\nuser=>"], :notes nil, :arglists ["tag" "h tag"], :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/descendants"}, :clojure.core/hash-set {:added "1.0", :ns "clojure.core", :name "hash-set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-set :clojure.core/set], :line 389, :examples [";; Any duplicates are squashed (no error)\n(hash-set 1 2 1 3 1 4 1 5)\n;;=> #{1 4 3 2 5}\n\n;; There is an equivalent reader macro '#{...}'\n(= (hash-set :c :a :b) #{:b :a :c})\n;;=> true \n\n;; A string can be treated as a sequence to produce\n;; a set of the characters found in the string.\n(apply hash-set (seq \"Lorem ipsum dolor sit amet\"))\n;;=> #{\\space \\a \\d \\e \\i \\L \\l \\m \\o \\p \\r \\s \\t \\u}\n\n;; or simply (see \"set\")\n(set \"Lorem ipsum dolor sit amet\")\n;;=> #{\\space \\a \\d \\e \\i \\L \\l \\m \\o \\p \\r \\s \\t \\u}"], :notes nil, :arglists ["" "& keys"], :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash-set"}, :clojure.core/ref-history-count {:added "1.1", :ns "clojure.core", :name "ref-history-count", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref-min-history :clojure.core/ref-max-history :clojure.core/ref], :line 2455, :examples ["user=> (def store (ref {}))\n#'user/store\nuser=> (ref-history-count store)\n0\nuser=> (ref-max-history store)\n10\nuser=> (ref-min-history store)\n0"], :notes nil, :arglists ["ref"], :doc "Returns the history count of a ref", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ref-history-count"}, :clojure.core.logic.pldb/db-fact {:ns "clojure.core.logic.pldb", :name "db-fact", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 79, :examples nil, :notes nil, :arglists ["db rel & args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db-fact"}, :clojure.core/disj {:added "1.0", :ns "clojure.core", :name "disj", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/dissoc :clojure.core/disj! :clojure.set/difference], :line 1510, :examples ["user=> (disj #{1 2 3}) ; disjoin nothing \n#{1 2 3} \n\nuser=> (disj #{1 2 3} 2) ; disjoin 2\n#{1 3} \n\nuser=> (disj #{1 2 3} 4) ; disjoin non-existent item\n#{1 2 3} \n\nuser=> (disj #{1 2 3} 1 3) ; disjoin several items at once\n#{2}"], :notes nil, :arglists ["set" "set key" "set key & ks"], :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/disj"}, :clojure.core.logic/occurs-check {:ns "clojure.core.logic", :name "occurs-check", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 216, :examples nil, :notes nil, :arglists ["s u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/occurs-check"}, :clojure.core.logic.pldb/db-retractions {:ns "clojure.core.logic.pldb", :name "db-retractions", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 128, :examples nil, :notes nil, :arglists ["base-db & retractions"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db-retractions"}, :clojure.core.async/untap* {:ns "clojure.core.async", :name "untap*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m ch"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/untap*"}, :clojure.java.io/input-stream {:added "1.2", :ns "clojure.java.io", :name "input-stream", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/reader :clojure.java.io/output-stream :clojure.java.io/IOFactory :clojure.core/with-open :clojure.java.io/make-input-stream], :line 121, :examples ["(require '(clojure.java [io :as io]))\n\n;; A common task it to load a file into a byte array.\n(defn file->bytes [file]\n  (with-open [xin (io/input-stream file)\n              xout (java.io.ByteArrayOutputStream.)]\n    (io/copy xin xout)\n    (.toByteArray xout)))\n;=> #'boot.user/file->bytes\n\n(file->bytes (io/file \"/foo-pc\" \"junk.txt\"))\n;=> #object[\"[B\" 0x7813db81 \"[B@7813db81\"]\n\n\n" "(require '[clojure.java.io :as io])\n\n;; these return a java.io.BufferedInputStream for a local file:\n(io/input-stream \"file.txt\")\n(io/input-stream \"/home/user/file.txt\")\n(io/input-stream \"file:///home/user/file.txt\")\n(io/input-stream (java.io.File. \"/home/user/file.txt\"))\n(io/input-stream (java.io.FileInputStream. \"file.txt\"))\n(io/input-stream (java.net.URL. \"file:///home/user/file.txt\"))\n(io/input-stream (java.net.URI. \"file:///home/user/file.txt\"))\n\n;; these return a java.io.BufferedInputStream for a remote resource:\n(io/input-stream \"http://clojuredocs.org/\")\n(io/input-stream (java.net.URL. \"http://clojuredocs.org\"))\n(io/input-stream (java.net.URI. \"http://clojuredocs.org\"))\n(let [socket (java.net.Socket. \"clojuredocs.org\" 80)\n      out (java.io.PrintStream. (.getOutputStream socket))]\n   (.println out \"GET /index.html HTTP/1.0\")\n   (.println out \"Host: clojuredocs.org\\n\\n\")\n   (io/input-stream socket))\n\n;; these return a java.io.BufferedInputStream from an in-memory source:\n(io/input-stream (.getBytes \"text\"))\n(io/input-stream (java.io.ByteArrayInputStream. (.getBytes \"text\")))\n(io/input-stream (byte-array [116 101 120 116]))\n"], :notes nil, :tag "java.io.InputStream", :arglists ["x & opts"], :doc "Attempts to coerce its argument into an open java.io.InputStream.\n   Default implementations always return a java.io.BufferedInputStream.\n\n   Default implementations are defined for InputStream, File, URI, URL,\n   Socket, byte array, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the InputStream is properly\n   closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/input-stream"}, :clojure.core.logic/add-var {:ns "clojure.core.logic", :name "add-var", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 178, :examples nil, :notes nil, :arglists ["cs x c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/add-var"}, :clojure.core/cons {:added "1.0", :ns "clojure.core", :name "cons", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/conj], :line 22, :examples [";; prepend 1 to a list\n(cons 1 '(2 3 4 5 6))\n;;=> (1 2 3 4 5 6)\n\n;; notice that the first item is not expanded\n(cons [1 2] [4 5 6])\n;;=> ([1 2] 4 5 6)" ";; may return results of different types but always a seq\n(map (juxt identity type seq? list?)\n     [(cons 1 nil)\n      (cons 1 '())])\n;; => ([(1) clojure.lang.PersistentList true true] \n;;     [(1) clojure.lang.Cons true false])\n" ";; Cons new-element into nested structures \"cons-in\"\n\n(def db {:users [{:name \"Eduardo\"}]})\n(def new-element {:name \"Eva\"})\n\n(assoc db :users (cons new-element (:users db)))\n;; => {:users ({:name \"Eva\"} {:name \"Eduardo\"})}" "(defn zeros [] \n    (lazy-seq (cons 0 (zeros))))\n;; \"cons\" does not realize second parameter, \n;;    opening the world for recursive functions that create lazy sequences\n\n(first (zeroes))\n0\n\n(first (rest (zeroes)))\n0\n\n(first (rest (rest (zeroes))))\n0\n\n;; example stolen from youtuber : \n;;   https://youtu.be/iaph8m63HQw?list=PLAC43CFB134E85266" ";; conj behave differently with \"set\" like structures.\n\n(def a-set #{1 2 3})\n\n(conj a-set 3)  ;; will add 3 to the set\n;; => #{1 3 2}\n\n(conj a-set 4)\n;; => #{1 4 3 2}\n\n(first (conj a-set 4))\n;; => 1"], :notes ["useful for creating lazy sequences, because it does not need to realize the param \"seq\" (it just appends the whole thing to param \"x\"\n\nhttp://stackoverflow.com/questions/12389303/clojure-cons-vs-conj-with-lazy-seq"], :arglists ["x seq"], :doc "Returns a new seq where x is the first element and seq is\n    the rest.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cons"}, :clojure.core/counted? {:added "1.0", :ns "clojure.core", :name "counted?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bounded-count], :line 6182, :examples ["user=> (counted? [:a :b :c])\ntrue\n\nuser=> (counted? '(:a :b :c))\ntrue\n\nuser=> (counted? {:a 1 :b 2 :c 3})\ntrue\n\nuser=> (counted? #{:a :b :c})\ntrue\n\nuser=> (counted? \"asdf\")\nfalse\n\nuser=> (counted? (into-array Integer/TYPE [1 2 3]))\nfalse" ";; Lazy sequences are not counted?\n(counted? (map inc (range 5)))\n;;=> false"], :notes nil, :arglists ["coll"], :doc "Returns true if coll implements count in constant time", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/counted_q"}, :clojure.core.async/promise-chan {:ns "clojure.core.async", :name "promise-chan", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 90, :examples nil, :notes nil, :arglists ["" "xform" "xform ex-handler"], :doc "Creates a promise channel with an optional transducer, and an optional\n  exception-handler. A promise channel can take exactly one value that consumers\n  will receive. Once full, puts complete but val is dropped (no transfer).\n  Consumers will block until either a value is placed in the channel or the\n  channel is closed. See chan for the semantics of xform and ex-handler.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/promise-chan"}, :clojure.core.async/unique {:ns "clojure.core.async", :name "unique", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1120, :examples ["()"], :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["ch" "ch buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unique"}, :clojure.template/do-template {:ns "clojure.template", :name "do-template", :file "clojure/template.clj", :type "macro", :column 1, :see-alsos nil, :line 45, :examples [";; Because it is expanded at compile time, you can also use special \n;; forms as in full blown macros:\n\nuser=> (use 'clojure.template)\nuser=> (do-template [a b] (def a b) d 1 e 2 f 3)\n#'user/f\nuser=> d\n1\nuser=> e\n2\nuser=> f\n3\n\n;; and if you are curious why\nuser=> (use 'clojure.walk)\nuser=> (macroexpand-all '(do-template [a b] (def a b) d 1 e 2 f 3))\n(do (def d 1) (def e 2) (def f 3))\n\n"], :macro true, :notes nil, :arglists ["argv expr & values"], :doc "Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))", :library-url "https://github.com/clojure/clojure", :href "/clojure.template/do-template"}, :clojure.core.logic.fd/distinctc {:ns "clojure.core.logic.fd", :name "distinctc", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1042, :examples nil, :notes nil, :arglists ["v*"], :doc "The real distinct constraint. v* can be seq of logic vars and\n   values or it can be a logic var itself. This constraint does not \n   run until v* has become ground. When it has become ground we group\n   v* into a set of logic vars and a sorted set of known singleton \n   values. We then construct the individual constraint for each var.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/distinctc"}, :clojure.core/with-redefs {:added "1.3", :ns "clojure.core", :name "with-redefs", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-redefs-fn :clojure.core/alter-var-root :clojure.core/with-bindings], :line 7438, :examples ["user=> [(type []) (class [])]\n[clojure.lang.PersistentVector clojure.lang.PersistentVector]\n\nuser=> (with-redefs [type (constantly java.lang.String)\n                     class (constantly 10)]\n         [(type [])\n          (class [])])\n[java.lang.String 10]" "(ns http)\n\n(defn post [url]\n  {:body \"Hello world\"})\n\n(ns app\n  (:require [clojure.test :refer [deftest is run-tests]]))\n\n(deftest is-a-macro\n  (with-redefs [http/post (fn [url] {:body \"Goodbye world\"})]\n    (is (= {:body \"Goodbye world\"} (http/post \"http://service.com/greet\")))))\n\n(run-tests) ;; test is passing" ";; be careful, with-redefs can permanently change a var if applied concurrently:\n\nuser> (defn ten [] 10)\n#'user/ten\nuser> (doall (pmap #(with-redefs [ten (fn [] %)] (ten)) (range 20 100)))\n...\nuser> (ten)\n79" ";; redefine var\n(def foo 1)\n#'user/foo\n(with-redefs [foo 2] foo)\n2\n\n;; redefine private var\n(ns first)\n(def ^:private foo 1)\n#'first/foo\n\n(ns second)\n(with-redefs [first/foo 2] @#'first/foo)\n2\n\n;; @#' is the macros of (deref (var first/foo))\n(with-redefs [first/foo 2] (deref (var first/foo))\n2"], :macro true, :notes nil, :arglists ["bindings & body"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-redefs"}, :clojure.core/hash {:added "1.0", :ns "clojure.core", :name "hash", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get :clojure.core/hash-ordered-coll :clojure.core/hash-unordered-coll], :line 5105, :examples ["user=> (hash \"a\")\n1455541201\nuser=> (.hashCode \"a\")  ; notice that this is different than (hash \"a\")\n97\nuser=> (hash 1)\n1392991556\nuser=> (.hashCode 1)    ; notice that this is different than (hash 1)\n1\nuser=> (hash nil)\n0\nuser=> (hash [1 2 3])\n30817\nuser=> (hash [1 2 3 4])\n955331"], :notes ["Despite what the doc-string says values returned by `(hash)` are different from `(.hashCode)` for more than just `Integer`, `Short`, `Byte` and Clojure collections.\n\nThe list also includes: Keywords, Symbols, Functions, Sequences, `String`, `Long` and `BigInteger` (as of Clojure 1.7.0)."], :arglists ["x"], :doc "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash"}, :clojure.core.logic.fd/->MultiIntervalFD {:ns "clojure.core.logic.fd", :name "->MultiIntervalFD", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 477, :examples nil, :notes nil, :arglists ["min max is"], :doc "Positional factory function for class clojure.core.logic.fd.MultiIntervalFD.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/->MultiIntervalFD"}, :clojure.core/bit-clear {:added "1.0", :ns "clojure.core", :name "bit-clear", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bit-set], :line 1323, :examples ["user=> (bit-clear 2r1011 3) ; index is 0-based\n3 \n;; 3 = 2r0011\n\n;; the same in decimal\nuser=> (bit-clear 11 3) \n3"], :notes nil, :arglists ["x n"], :doc "Clear bit at index n", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-clear"}, :clojure.set/rename-keys {:added "1.0", :ns "clojure.set", :name "rename-keys", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/rename], :line 78, :examples ["user=> (rename-keys {:a 1, :b 2} {:a :new-a, :b :new-b})\n{:new-a 1, :new-b 2}\n\n\n;; The behavior when the second map contains a key not in the first is interesting.\n;; I suspect you shouldn't depend on it. (Clojure 1.1 - no longer happens in 1.2.1)\n\nuser=> (rename-keys {:a 1} {:b :new-b})\n{ :a 1, :new-b nil}\n" ";; You need to be careful about key collisions.  You probably shouldn't \n;; depend on the exact behavior.\nuser=> (rename-keys {:a 1 :b 2} {:a :b})\n{:b 1}\n\nuser=> (rename-keys  {:a 1 :b 2}  {:a :b :b :a})\n{:a 1}\n\n;; You can work around key collisions by using an array-map to control\n;; the order of the renamings.\nuser=> (rename-keys  {:a 1 :b 2 :c 3}  (array-map :a :tmp :b :a :tmp :b))\n{:b 1, :a 2, :c 3}\n"], :notes nil, :arglists ["map kmap"], :doc "Returns the map with the keys in kmap renamed to the vals in kmap", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/rename-keys"}, :clojure.core.reducers/foldcat {:added "1.5", :ns "clojure.core.reducers", :name "foldcat", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos [:clojure.core.reducers/fold], :line 314, :examples [";; Worth remembering that parallel fold in Clojure is enabled for: \n;; vectors, maps and clojure.core.reducers.Cat objects.\n;; r/foldcat returns a \"Cat\", so it can be parallel folded again:\n\n(r/fold + \n  (r/foldcat \n    (r/filter even? \n      (r/foldcat \n        (r/map inc (into [] (range 100000)))))))\n;; 2500050000" ";; One non-obvious thing about clojure.core.reducers/foldcat is its return type,\n;; which is either clojure.core.reducers.Cat or java.util.ArrayList (!)\n;; depending on the size of the source collection.\n\n(require '[clojure.core.reducers :as r])\n\n(def small-vector (vec (range 10)))\n(def big-vector (vec (range 100000)))\n\n(type (r/foldcat (r/filter odd? small-vector)))  ;;=> java.util.ArrayList\n(type (r/foldcat (r/filter odd? big-vector)))  ;;=> clojure.core.reducers.Cat\n\n;; Both return types are suited for further reduce-like processing, but they are\n;; not general-purpose data types like proper Clojure collections.\n"], :notes nil, :arglists ["coll"], :doc "Equivalent to (fold cat append! coll)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/foldcat"}, :clojure.spec.alpha/assert* {:ns "clojure.spec.alpha", :name "assert*", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1912, :examples nil, :notes nil, :arglists ["spec x"], :doc "Do not call this directly, use 'assert'.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/assert*"}, :clojure.core.async/unmix-all {:ns "clojure.core.async", :name "unmix-all", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/unmix :clojure.core.async/admix :clojure.core.async/mix :clojure.core.async/toggle :clojure.core.async/solo-mode], :line 816, :examples nil, :notes nil, :arglists ["mix"], :doc "removes all inputs from the mix", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unmix-all"}, :clojure.core/short {:added "1.0", :ns "clojure.core", :name "short", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/int :clojure.core/byte :clojure.core/shorts :clojure.core/short-array :clojure.core/unchecked-short], :line 3490, :examples ["user=> (class (short 1))\njava.lang.Short"], :notes nil, :arglists ["x"], :doc "Coerce to short", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/short"}, :clojure.core/alter {:added "1.0", :ns "clojure.core", :name "alter", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref :clojure.core/commute :clojure.core/ref-set], :line 2435, :examples [";; alter is a way to change the value of a reference.\n\n;; Here we're defining a ref named 'names' and setting its value to\n;; an empty vector.\n(def names (ref []))\n;;=> #'user/names\n\n;; A function to add a name to the vector (notice the meat's wrapped\n;; in a dosync\n(defn add-name [name]\n  (dosync\n    (alter names conj name)))\n;;=> #'user/add-name\n\n(add-name \"zack\")\n;;=> [\"zack\"]\n\n(add-name \"shelley\")\n;;=> [\"zack\" \"shelley\"]\n\n;; Notice that the var 'names' points to the reference that we created\n(println names)\n;; #<Ref@658ba380: [zack shelley]>\n\n;; To get the actual value of the ref, you use the '@' symbol, or deref\n(println @names)\n;; [zack shelley]\n\n(println (deref names))\n;; [zack shelley]"], :notes ["I was fooling around with how exactly ref works with maps. Since the example here uses a vector, I thought maybe some of you might want to see a short example using a map.\r\n\r\nIn an aggregator I'm working on, I want to keep a record of how many sources and how many articles I've aggregated. Instead of using an atom for each, I'll reference a map called \"counts.\" Here's a simple little function that increments and returns the new value of the counter stored in the map:\r\n\r\n<pre> (def counts (ref {:articles 0 :sources 0}))\r\n(defn inc-ref [ref type]\r\n\"increment a map value with key type stored in ref\"\r\n\t(dosync\r\n\t (alter ref assoc type (inc (type @ref)))\r\n\t (type @ref)))\r\nuser&gt; (inc-ref counts :sources)\r\n=&gt;1\r\nuser&gt; counts\r\n=&gt;{:articles 0, :sources 1}\r\n</pre>\r\n\r\nand if you wanted to be able to add counters dynamically (one of the advantages of using a map in this context) you could redefine the function employ an optional argument, which if present instructs the function to create a new key-value pair using the name and initial value provided:\r\n\r\n<pre>(defn inc-ref [ref type & [init-value]]\r\n  (if init-value\r\n    (dosync\r\n     (alter ref assoc type init-value)\r\n     (type @ref))\r\n    (dosync\r\n     (alter ref assoc type (inc (name @ref)))\r\n     (type @ref))))\r\n\r\nuser&gt; (inc-ref counts :articles)\r\n=&gt;1\r\nuser&gt; (inc-ref counts :magazines 1)\r\n=&gt;1\r\nuser&gt; (:magazines @counts)\r\n=&gt;1</pre>" "In the previous example at row 07 has a reference to 'name @ref':\r\n <pre>(alter ref assoc type (inc (name @ref)))</pre>\r\nmaybe is incorrect and the correct mode  is:  \r\n<pre> (alter ref assoc type (inc (type @ref)))</pre>"], :arglists ["ref fun & args"], :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/alter"}, :clojure.core/definline {:added "1.0", :ns "clojure.core", :name "definline", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 5169, :examples nil, :macro true, :notes ["Note that, as for macros, the arguments to definline are potentially subject to double evaluation if they are used more than once in the body. For example:\r\n\r\n<pre>\r\nuser=> (definline bad-sqr [x] `(* ~x ~x))\r\n#'user/bad-sqr\r\nuser=> (bad-sqr (do (println \"x\") 5))\r\nx\r\nx\r\n25\r\n</pre>\r\n\r\n" "Any non-like-a-function behaviour should be avoided, because otherwise function will behave differently depending on whether it's inlined or not:\r\n\r\n    user=> (definline bad-if [cond then] `(if ~cond ~then))\r\n    #'user/bad-if\r\n    user=> (bad-if nil (do (prn :side-effect) :not-returned))\r\n    nil\r\n    user=> (let [bad-if bad-if] (bad-if nil (do (prn :side-effect)     :not-returned)))\r\n    :side-effect\r\n    nil\r\n"], :arglists ["name & decl"], :doc "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/definline"}, :clojure.spec.alpha/inst-in-range? {:ns "clojure.spec.alpha", :name "inst-in-range?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1837, :examples nil, :notes nil, :arglists ["start end inst"], :doc "Return true if inst at or after start and before end", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/inst-in-range_q"}, :clojure.core/var? {:added "1.0", :ns "clojure.core", :name "var?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/def :clojure.core/var :clojure.core/var-get :clojure.core/var-set :clojure.core/with-local-vars], :line 4915, :examples ["(def my-symbol)\n(var? #'my-symbol)\n=> true\n\n(var? (var my-symbol))\n=> true\n\n(var? (def my-symbol2))\n=> true" "=> *clojure-version*\n{:major 1, :minor 5, :incremental 0, :qualifier \"RC17\"}\n=> var?\n#<core$var_QMARK_ clojure.core$var_QMARK_@669251cc>\n=> (var?)\n;ArityException Wrong number of args (0) passed to: core$var-QMARK-  clojure.lang.AFn.throwArity (AFn.java:437)\n=> (var? 1)\nfalse\n=> (var? defn)\n;CompilerException java.lang.RuntimeException: Can't take value of a macro: #'clojure.core/defn, compiling:(NO_SOURCE_PATH:1:1) \n=> (var? #'defn)\ntrue\n=> (var? #'defn 1 2 3 4)\n;ArityException Wrong number of args (5) passed to: core$var-QMARK-  clojure.lang.AFn.throwArity (AFn.java:437)\n=> (var? (var defn))\ntrue\n=> (var? apply)\nfalse\n=> (var? #'apply)\ntrue\n"], :notes nil, :arglists ["v"], :doc "Returns true if v is of type clojure.lang.Var", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/var_q"}, :clojure.core/bit-and-not {:added "1.0", :ns "clojure.core", :name "bit-and-not", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 1312, :examples ["user=> (bit-and-not 2r1100 2r1001) ; (and X (not Y))\n4\n;; 4 = 2r0100" ";; here is the truth table for AND-NOT (which is not the same as NAND) \n(Integer/toBinaryString (bit-and-not 2r1100 2r1010) )\n;;=> \"100\"\n;; or 2r0100\n\n;; NAND would be...\n(Integer/toBinaryString (bit-not (bit-and 2r1100 2r1010)) )\n;;=> \"11111111111111111111111111110111\"\n;; which is clearly not the same\n\n;; this operation is material non-implication\n(= (bit-and-not 2r1100 2r1010) (bit-and 2r1100 (bit-not 2r1010)) )\n;;=> true\n"], :notes nil, :arglists ["x y" "x y & more"], :doc "Bitwise and with complement", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-and-not"}, :clojure.core/methods {:added "1.0", :ns "clojure.core", :name "methods", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get-method :clojure.core/remove-method :clojure.core/prefer-method :clojure.core/prefers], :line 1803, :examples ["user=> (use 'clojure.pprint)\nuser=> (pprint (methods print-dup))\n{nil #<core$fn__5424 clojure.core$fn__5424@b08549>,\n java.lang.String #<core$fn__5475 clojure.core$fn__5475@1bddeea>,\n java.lang.Boolean #<core$fn__5446 clojure.core$fn__5446@1b40b96>,\n clojure.lang.IPersistentList\n #<core$fn__5461 clojure.core$fn__5461@d5b26d>,\n java.sql.Timestamp\n #<instant$fn__6277 clojure.instant$fn__6277@ce52d1>,\n java.util.UUID #<uuid$fn__6290 clojure.uuid$fn__6290@17e7fa1>,\n clojure.lang.Var #<core$fn__5455 clojure.core$fn__5455@78be86>,\n clojure.lang.PersistentVector\n #<core$fn__5525 clojure.core$fn__5525@15fc948>,\n java.util.Calendar\n #<instant$fn__6266 clojure.instant$fn__6266@1733349>,\n java.util.Map #<core$fn__5486 clojure.core$fn__5486@806f9b>,\n java.lang.Class #<core$fn__5531 clojure.core$fn__5531@1daa05b>,\n java.util.regex.Pattern #<core$fn__5544 clojure.core$fn__5544@10dfca>,\n java.lang.Number #<core$fn__5436 clojure.core$fn__5436@27edc3>,\n java.lang.Long #<core$fn__5511 clojure.core$fn__5511@1edea9d>,\n clojure.lang.Namespace #<core$fn__5546 clojure.core$fn__5546@f1a434>,\n java.math.BigDecimal #<core$fn__5517 clojure.core$fn__5517@1a5a160>,\n clojure.lang.Symbol #<core$fn__5451 clojure.core$fn__5451@17d2095>,\n clojure.lang.Keyword #<core$fn__5432 clojure.core$fn__5432@ea3d50>,\n clojure.lang.LazilyPersistentVector\n #<core$fn__5527 clojure.core$fn__5527@1b77718>,\n java.util.Collection #<core$fn__5465 clojure.core$fn__5465@1f784a4>,\n java.lang.Double #<core$fn__5513 clojure.core$fn__5513@5e0db2>,\n clojure.lang.Fn #<core$fn__5440 clojure.core$fn__5440@ce073>,\n clojure.lang.IRecord #<core$fn__5502 clojure.core$fn__5502@19b43b4>,\n clojure.lang.PersistentHashSet\n #<core$fn__5523 clojure.core$fn__5523@1b93220>,\n clojure.lang.IPersistentCollection\n #<core$fn__5469 clojure.core$fn__5469@1fb7c3>,\n clojure.lang.BigInt #<core$fn__5519 clojure.core$fn__5519@1f5d7d>,\n clojure.lang.ISeq #<core$fn__5459 clojure.core$fn__5459@412c94>,\n java.util.Date #<instant$fn__6261 clojure.instant$fn__6261@d7bf11>,\n clojure.lang.PersistentHashMap\n #<core$fn__5521 clojure.core$fn__5521@14a5481>,\n clojure.lang.IPersistentMap\n #<core$fn__5490 clojure.core$fn__5490@1a4f2db>,\n clojure.lang.Ratio #<core$fn__5515 clojure.core$fn__5515@146f3dc>,\n java.lang.Character #<core$fn__5509 clojure.core$fn__5509@f09e3f>}" "user=> (defmulti do-math (fn [operation x y] operation))\n\n#'user/do-math\n\nuser=> (defmethod do-math :add [_ x y] (+ x y))\n...    (defmethod do-math :subtract [_ x y] (- x y))\n...    (defmethod do-math :hypotenuse [_ x y] (Math/sqrt (+ (* x x) (* y y))))\n\n#multifn[do-math 0x3a1c348]\n\nuser=> (methods do-math)\n\n{:hypotenuse #function[user/eval42540$fn--42541],\n :add #function[user/eval42521$fn--42522],\n :subtract #function[user/eval42525$fn--42526]}\n"], :notes ["Not the most useful output format I've ever seen. :-)"], :arglists ["multifn"], :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/methods"}, :clojure.inspector/inspect-table {:added "1.0", :ns "clojure.inspector", :name "inspect-table", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos [:clojure.pprint/print-table :clojure.inspector/inspect-tree], :line 100, :examples ["(use 'clojure.inspector)\n(inspect-table [{:a 1 :b 2 :c 3}{:a 4 :b 5 :c 6}])"], :notes nil, :arglists ["data"], :doc "creates a graphical (Swing) inspector on the supplied regular\n  data, which must be a sequential data structure of data structures\n  of equal length", :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/inspect-table"}, :clojure.core/pos-int? {:added "1.9", :ns "clojure.core", :name "pos-int?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/neg-int? :clojure.core/nat-int? :clojure.core/int?], :line 1400, :examples ["(pos-int? 1)\n;;=> true\n(pos-int? 9223372036854775807)\n;;=> true\n\n;;;; false for non-positive values\n\n(pos-int? 0)\n;;=> false\n(pos-int? -1)\n;;=> false\n\n;;;; false for decimal values\n\n(pos-int? 1.0)\n;;=> false\n(pos-int? 1/2)\n;;=> false\n\n;;;; false for BigInt values\n\n(pos-int? 1N)\n;;=> false\n(pos-int? 9223372036854775808)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a positive fixed precision integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pos-int_q"}, :clojure.core.logic/lvars {:ns "clojure.core.logic", :name "lvars", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 729, :examples nil, :notes nil, :arglists ["n"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lvars"}, :clojure.core/get-method {:added "1.0", :ns "clojure.core", :name "get-method", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove-method :clojure.core/methods], :line 1809, :examples [";; define a multi-method, then demonstrate that you may use \n;; get-method in the same way you can call the method directly\n\nuser=> (defmulti tos :Ob)\n#'user/tos\nuser=> (defn line [p1 p2] {:Ob :line :p1 p1 :p2 p2})\n#'user/line\nuser=> (defn circle [cent rad] {:Ob :circle :cent cent :rad rad})\n#'user/circle\nuser=> (defmethod tos :line [l] (str \"Line:\" (l :p1) (l :p2)))\n#<MultiFn clojure.lang.MultiFn@a0b1cd0>\nuser=> (defmethod tos :circle [c] (str \"Circle:\" (c :cent) (c :rad)))\n#<MultiFn clojure.lang.MultiFn@a0b1cd0>\nuser=> (println (tos (circle [2 3] 3.3)))\nCircle:[2 3]3.3\nnil\nuser=> (println (tos (line [1 1][0 0])))\nLine:[1 1][0 0]\nnil\nuser=> (println ((get-method tos :line) (line [1 2][3 4]) ))\nLine:[1 2][3 4]\nnil\nuser=>"], :notes nil, :arglists ["multifn dispatch-val"], :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get-method"}, :clojure.core/reset-vals! {:added "1.9", :ns "clojure.core", :name "reset-vals!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 2375, :examples [";; An atom is defined\n(def open-sockets (atom []))\n;;=> #'user/open-sockets\n\n;; Conjoin a value or two onto the atom\n(swap! open-sockets conj socket)\n;;=> [<< stream: 1 >> << stream: 2 >>]\n\n;; Knock the first socket out of open-sockets\n(reset-vals! open-sockets (subvec @open-sockets 1))\n;;=> [[<< stream: 1 >> << stream: 2 >>][<< stream: 2 >>]]\n\n;; Knock the last socket out of open-sockets\n(reset-vals! open-sockets (pop @open-sockets))\n;;=> [[<< stream: 2 >>] []]"], :notes nil, :arglists ["atom newval"], :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reset-vals!"}, :clojure.core/unchecked-short {:added "1.3", :ns "clojure.core", :name "unchecked-short", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/short], :line 3514, :examples ["(unchecked-short 1)\n;;=> 1\n(unchecked-short 1N)\n;;=> 1\n(unchecked-short 1.1)\n;;=> 1\n(unchecked-short 1.9)\n;;=> 1\n(unchecked-short 5/3)\n;;=> 1\n\n(unchecked-short -1)\n;;=> -1\n(unchecked-short -1N)\n;;=> -1\n(unchecked-short -1.1)\n;;=> -1\n(unchecked-short -1.9)\n;;=> -1\n(unchecked-short -5/3)\n;;=> -1\n\n;;;; Note that (unchecked-short) does not range check its argument\n;;;; so integer overflow or rounding may occur. \n;;;; Use (short) if you want to throw an exception in such cases.\n\n(unchecked-short 32768)\n;;=> -32768\n(unchecked-short -32769)\n;;=> 32767\n\n(short 32768)\n;;=> IllegalArgumentException Value out of range for short: 32768\n(short -32769)\n;;=> IllegalArgumentException Value out of range for short: -32769\n\n(unchecked-short 1.0E4)\n;;=> 10000\n(unchecked-short 1.0E5)\n;;=> -31072\n\n(short 1.0E4)\n;;=> 10000\n(short 1.0E5)\n;;=> IllegalArgumentException Value out of range for short: 100000.0\n"], :notes nil, :arglists ["x"], :doc "Coerce to short. Subject to rounding or truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-short"}, :clojure.core/hash-ordered-coll {:added "1.6", :ns "clojure.core", :name "hash-ordered-coll", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/hash-unordered-coll :clojure.core/hash], :line 5126, :examples [";;;; Clojure's (hash-ordered-coll) produces the same hash code regardless\n;;;; of collection type when both of the following two conditions are met:\n;;;;   (1) collections contain the same elements\n;;;;   (2) collection elements are ordered the same when returned by .iterator()\n\n(hash-ordered-coll [1 2])\n;;=> 156247261\n(hash-ordered-coll '(1 2))\n;;=> 156247261\n(hash-ordered-coll (sorted-set 1 2))\n;;=> 156247261\n(hash-ordered-coll (doto (new java.util.ArrayList) (.add 1) (.add 2)))\n;;=> 156247261\n(hash-ordered-coll (doto (new java.util.TreeSet) (.add 1) (.add 2)))\n;;=> 156247261\n\n(hash-ordered-coll [2 1])\n;;=> -1994590503\n(hash-ordered-coll '(2 1))\n;;=> -1994590503\n(hash-ordered-coll (sorted-set-by > 2 1))\n;;=> -1994590503\n(hash-ordered-coll (doto (new java.util.ArrayList) (.add 2) (.add 1)))\n;;=> -1994590503\n(hash-ordered-coll (doto (new java.util.TreeSet >) (.add 2) (.add 1)))\n;;=> -1994590503\n\n;;;; Notice that this differs from (hash) which \n;;;;   (1) doesn't rely on element order as returned by .iterator()\n;;;;   (2) falls back on Java's .hashCode() for non-Clojure collections\n\n(hash [1 2])\n;;=> 156247261\n(hash '(1 2))\n;;=> 156247261\n(hash (sorted-set 1 2))\n;;=> 460223544\n(hash (sorted-set-by > 2 1))\n;;=> 460223544\n(hash (doto (new java.util.ArrayList) (.add 1) (.add 2)))\n;;=> 994\n(hash (doto (new java.util.TreeSet) (.add 1) (.add 2)))\n;;=> 3\n" ";;;;\n;;;; Only accepts implementations of java.lang.Iterable\n;;;;\n\n(hash-ordered-coll true)\n;;=> ClassCastException java.lang.Boolean cannot be cast to java.lang.Iterable\n(hash-ordered-coll 1)\n;;=> ClassCastException java.lang.Long cannot be cast to java.lang.Iterable\n(hash-ordered-coll \\c)\n;;=> ClassCastException java.lang.Character cannot be cast to java.lang.Iterable\n\n;;;;\n;;;; Being seqable is not sufficient!\n;;;;\n\n(hash-ordered-coll \"12\")\n;;=> ClassCastException java.lang.String cannot be cast to java.lang.Iterable\n(hash-ordered-coll (int-array [1 2]))\n;;=> ClassCastException [I cannot be cast to java.lang.Iterable\n(hash-ordered-coll nil)\n;;=> NullPointerException"], :notes nil, :arglists ["coll"], :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash-ordered-coll"}, :clojure.spec.alpha/check-asserts {:ns "clojure.spec.alpha", :name "check-asserts", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1903, :examples nil, :notes nil, :arglists ["flag"], :doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\n\nInitially set to boolean value of clojure.spec.check-asserts\nsystem property. Defaults to false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/check-asserts"}, :clojure.core.logic/build {:ns "clojure.core.logic", :name "build", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 271, :examples nil, :notes nil, :arglists ["s u"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/build"}, :clojure.stacktrace/print-throwable {:added "1.1", :ns "clojure.stacktrace", :name "print-throwable", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos [:clojure.stacktrace/print-stack-trace :clojure.stacktrace/print-cause-trace], :line 38, :examples [";; let's make an exception\n(def anex (try (/ 1 0) (catch Exception ex ex)))\n\n;; now print the exception\n(clojure.stacktrace/print-throwable anex)\n;; java.lang.ArithmeticException: Divide by zero\n;=> nil\n\n;; and catch it in a string\n(def msg (with-out-str (clojure.stacktrace/print-throwable anex)))\n;=> #'boot.user/msg\n\nmsg\n;=> \"java.lang.ArithmeticException: Divide by zero\"\n\n"], :notes nil, :arglists ["tr"], :doc "Prints the class and message of a Throwable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/print-throwable"}, :clojure.core/odd? {:added "1.0", :ns "clojure.core", :name "odd?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/even?], :line 1386, :examples ["user=> (odd? 1)\ntrue\nuser=> (odd? 2)\nfalse\nuser=> (odd? 0)\nfalse" "user=> (filter odd? (range 15))\n(1 3 5 7 9 11 13)"], :notes nil, :arglists ["n"], :doc "Returns true if n is odd, throws an exception if n is not an integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/odd_q"}, :clojure.core/if-some {:added "1.6", :ns "clojure.core", :name "if-some", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/when-some :clojure.core/if-let :clojure.core/some], :line 1868, :examples ["(if-some [a 10]    :true :false)   ; => :true\n(if-some [a true]  :true :false)   ; => :true\n(if-some [a false] :true :false)   ; => :true\n(if-some [a nil]   :true :false)   ; => :false\n\n;; for comparison\n(if-let [a 10]     :true :false)   ; => :true\n(if-let [a true]   :true :false)   ; => :true \n(if-let [a false]  :true :false)   ; => :false\n(if-let [a nil]    :true :false)   ; => :false\n"], :macro true, :notes ["See [this Jira ticket](http://dev.clojure.org/jira/browse/CLJ-1343) for some background on this.\n\n    (if-some [var test] then else)\n\nis essentially equivalent to:\n\n    (if-let [var (not (nil? test))] then else)\n"], :arglists ["bindings then" "bindings then else & oldform"], :doc "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/if-some"}, :clojure.core.logic/env-locals {:ns "clojure.core.logic", :name "env-locals", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1625, :examples nil, :notes nil, :arglists ["& syms"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/env-locals"}, :clojure.core/vary-meta {:added "1.0", :ns "clojure.core", :name "vary-meta", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-meta :clojure.core/alter-meta!], :line 667, :examples ["user=> (meta (vary-meta 'foo assoc :a 1))\n{:a 1}\n" ";; continuing from the previous with-meta example\nuser=> (def wm (with-meta [1 2 3] {:my \"meta\"}))\n#'user/wm\n\nuser=> wm\n[1 2 3]\n\nuser=> (meta wm)\n{:my \"meta\"}\n\nuser=> (def new-wm (vary-meta wm assoc :your \"new meta\"))\n#'user/new-wm\n\nuser=> new-wm\n[1 2 3]\n\nuser=> (meta new-wm)\n{:my \"meta\", :your \"new meta\"}\n\n"], :notes nil, :arglists ["obj f & args"], :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vary-meta"}, :clojure.core/alength {:added "1.0", :ns "clojure.core", :name "alength", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/into-array], :line 3864, :examples ["user=> (def my-array (into-array Integer/TYPE [1 2 3]))\n#'user/my-array\n\nuser=> (alength my-array)\n3" "2D simple array example\nuser=> (def a (to-array-2d [[1 2] [3 4 5] [1]]))\n#'user/a\nuser=> (alength a)\n3\n"], :notes nil, :arglists ["array"], :doc "Returns the length of the Java array. Works on arrays of all\n  types.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/alength"}, :clojure.core/re-pattern {:added "1.0", :ns "clojure.core", :name "re-pattern", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-find :clojure.string/replace :clojure.string/replace-first], :line 4779, :examples ["user=> (re-pattern \"\\\\d+\")\n#\"\\d+\"\n\nuser=> (re-find (re-pattern \"\\\\d+\") \"abc123def\") \n\"123\"\n\n;; If you want to construct a regex pattern dynamically at run time,\n;; then you need to use re-pattern to convert a string to a pattern\n;; that can be used for matching.  But if your pattern is one you\n;; write into the source code, it is more convenient to use the\n;; #\"pattern\" syntax.  The previous example can be written as follows.\nuser=> (re-find #\"\\d+\" \"abc123def\") \n\"123\"\n\n;; Below are two examples that are equivalent in the patterns they\n;; use, but the #\"pattern\" syntax helps significantly, because it lets\n;; us avoid the requirement to escape every \\ character with another \\\n;; character.  See the example with embedded comments below for more\n;; detail on what the pattern matches.\nuser=> (re-find #\"\\\\\\d+\\s+\\S+\" \"\\\\ it sh0uld match in \\\\5 here somewhere.\")\n\"\\\\5 here\"\n\nuser=> (re-find (re-pattern \"\\\\\\\\\\\\d+\\\\s+\\\\S+\")\n                \"\\\\ it sh0uld match in \\\\5 here somewhere.\")\n\"\\\\5 here\"\n\n;; If you want to embed (ignored) whitespace and comments from #\n;; characters until end-of-line in your regex patterns, start the\n;; pattern with (?x)\nuser=> (re-find #\"(?x)  # allow embedded whitespace and comments\n                  \\\\    # backslash\n                  \\d+   # one or more digits\n                  \\s+   # whitespace\n                  \\S+   # non-whitespace\"\n                \"\\\\ it sh0uld match in \\\\5 here somewhere.\")\n\"\\\\5 here\"\n\n;; Other pattern flags like Java's DOTALL, MULTILINE and UNICODE_CASE\n;; pattern matching modes, can be set by combining these embedded flags\n\n;; (?d) Unix lines (only match \\newline)\n;; (?i) Case-insensitive\n;; (?u) Unicode-aware Case\n;; (?m) Multiline\n;; (?s) Dot matches all (including newline)\n;; (?x) Ignore Whitespace and comments\n\nuser=> (re-seq #\"(?ix) test #Case insensitive and comments allowed\"\n               \"Testing,\\n testing,\\n 1 2 3\")\n(\"Test\" \"test\")\n"], :notes nil, :tag "java.util.regex.Pattern", :arglists ["s"], :doc "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-pattern"}, :clojure.core/zipmap {:added "1.0", :ns "clojure.core", :name "zipmap", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/interleave], :line 3063, :examples ["user=> (zipmap [:a :b :c :d :e] [1 2 3 4 5])\n{:a 1, :b 2, :c 3, :d 4, :e 5}\n" ";; 4 is not included in the result\nuser=> (zipmap [:a :b :c] [1 2 3 4])\n{:a 1, :b 2, :c 3}\n\n;; :c is not included in the result\nuser=> (zipmap [:a :b :c] [1 2])\n{:a 1, :b 2}" "user=> (pprint \n         (zipmap [:html :body :div] (repeat {:margin 0 :padding 0})))\n{:html {:margin 0, :padding 0},\n :body {:margin 0, :padding 0},\n :div {:margin 0, :padding 0}}" ";; transform a CSV file to an array of maps using the header line as keys\nuser=> (defn csv-map\n  \"ZipMaps header as keys and values from lines.\"\n  [head & lines]\n    (map #(zipmap (map keyword head) %1) lines))\n\nuser=> (apply csv-map [[\"FirstName\", \"LastName\"], [\"John\", \"Doe\"], [\"Jill\", \"Doh\"]])\n({:FirstName \"John\", :LastName \"Doe\"}, {:FirstName \"Jill\", :LastName \"Doh\"})" ";; initialize with 0 for all values\nuser=> (zipmap [:a :b :c] (repeat 0))\n{:a 0, :b 0, :c 0}" ";; Note that if the keys are not unique, you can potentially lose data:\nuser=> (zipmap [:a :b :c :a] [1 2 3 4])\n{:a 4, :b 2, :c 3}\n"], :notes nil, :arglists ["keys vals"], :doc "Returns a map with the keys mapped to the corresponding vals.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/zipmap"}, :clojure.core/method-sig {:ns "clojure.core", :name "method-sig", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos nil, :line 20, :examples [";;;; (method-sig) turns java.lang.reflect.Method into a vector \n;;;; of the form [name (param-types) return-type]\n\n(->> String .getMethods seq (filter #(= (.getName %) \"indexOf\")))\n;;=> (#object[java.lang.reflect.Method 0x4a499a6c \"public int java.lang.String.indexOf(java.lang.String,int)\"]\n;;    #object[java.lang.reflect.Method 0x29b045b3 \"public int java.lang.String.indexOf(int)\"]\n;;    #object[java.lang.reflect.Method 0x55ce8ae4 \"public int java.lang.String.indexOf(java.lang.String)\"]\n;;    #object[java.lang.reflect.Method 0x33a58323 \"public int java.lang.String.indexOf(int,int)\"])\n\n(->> String .getMethods seq (filter #(= (.getName %) \"indexOf\")) (method-sig))\n;;=> ([\"indexOf\" (java.lang.String int) int]\n;;    [\"indexOf\" (int) int]\n;;    [\"indexOf\" (java.lang.String) int]\n;;    [\"indexOf\" (int int) int])"], :notes nil, :arglists ["meth"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/method-sig"}, :clojure.java.io/make-writer {:added "1.2", :ns "clojure.java.io", :name "make-writer", :type "function", :see-alsos [:clojure.java.io/writer], :examples nil, :notes nil, :arglists ["x opts"], :doc "Creates a BufferedWriter. See also IOFactory docs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/make-writer"}, :clojure.core/*3 {:added "1.0", :ns "clojure.core", :name "*3", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/*1 :clojure.core/*2], :dynamic true, :line 6209, :examples ["user=> \"Hello!\"\n\"Hello!\"\n\nuser=> \"Hello World!\"\n\"Hello World!\"\n\nuser=> \"Hi Everyone!\"\n\"Hi Everyone!\"\n\nuser=> [*1 *2 *3]\n[\"Hi Everyone!\" \"Hello World!\" \"Hello!\"]\n" "user=> (range 5)\n(0 1 2 3 4)\nuser=> (last *1)\n4\nuser=> (last *2)\n4\nuser=> (last *3)\n4\n"], :notes nil, :arglists [], :doc "bound in a repl thread to the third most recent value printed", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*3"}, :clojure.core.logic/permuteo {:ns "clojure.core.logic", :name "permuteo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1781, :examples ["(run* [q]\n  (permuteo [:c q :a] [:b :a :c])) ;; :b"], :notes nil, :arglists ["xl yl"], :doc "A relation that will permute xl into the yl. May not\n   terminate if xl is not ground.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/permuteo"}, :clojure.core.logic.fd/domc {:ns "clojure.core.logic.fd", :name "domc", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 718, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/domc"}, :clojure.core/*2 {:added "1.0", :ns "clojure.core", :name "*2", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/*1 :clojure.core/*3], :dynamic true, :line 6204, :examples ["user=> \"Hello!\"\n\"Hello!\"\n\nuser=> \"Hello World!\"\n\"Hello World!\"\n\nuser=> [*1 *2]\n[\"Hello World!\" \"Hello!\"]\n"], :notes nil, :arglists [], :doc "bound in a repl thread to the second most recent value printed", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*2"}, :clojure.spec.alpha/regex-spec-impl {:ns "clojure.spec.alpha", :name "regex-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1645, :examples nil, :notes nil, :arglists ["re gfn"], :doc "Do not call this directly, use 'spec' with a regex op argument", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/regex-spec-impl"}, :clojure.core/pos? {:added "1.0", :ns "clojure.core", :name "pos?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/neg? :clojure.core/zero?], :line 1239, :examples ["user=> (pos? 1)\ntrue\nuser=> (pos? 0)\nfalse\nuser=> (pos? -1)\nfalse" "user=> (pos? 0.1)\ntrue\nuser=> (pos? -0.1)\nfalse"], :notes nil, :arglists ["num"], :doc "Returns true if num is greater than zero, else false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pos_q"}, :clojure.core.logic.fd/ISortedDomain {:ns "clojure.core.logic.fd", :name "ISortedDomain", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 23, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/ISortedDomain"}, :clojure.core.reducers/mapcat {:added "1.5", :ns "clojure.core.reducers", :name "mapcat", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos [:clojure.core.reducers/map], :line 171, :examples nil, :notes nil, :arglists ["f" "f coll"], :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/mapcat"}, :clojure.zip/root {:added "1.0", :ns "clojure.zip", :name "root", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/edit], :line 137, :examples nil, :notes nil, :arglists ["loc"], :doc "zips all the way up and returns the root node, reflecting any\n changes.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/root"}, :clojure.core/char-escape-string {:added "1.0", :ns "clojure.core", :name "char-escape-string", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos [:clojure.core/char-name-string :clojure.string/escape], :line 200, :examples [";; simple examples\n\nuser=> (char-escape-string \\newline)\n\"\\\\n\"\nuser=> (char-escape-string \\c) ; no escape sequence for 'c'\nnil\nuser=> (char-escape-string \\tab)\n\"\\\\t\"\nuser=> (char-escape-string \\backspace)\n\"\\\\b\"\nuser=>" "(require '[clojure.string :as s])\n\n;; Would like to print \"s\" as shown literally:\n(def s \"Type backslash-t '\\t' followed by backslash-n '\\n'\")\n\n;; This doesn't work, as \\t and \\n are interpreted:\n(println s)\n;; Type backslash-t '      ' followed by backslash-n '\n;; '\n\n;; Use with escape to print literally:\n(println (s/escape s char-escape-string))\n;; Type backslash-t '\\t' followed by backslash-n '\\n'"], :notes nil, :tag "java.lang.String", :arglists [], :doc "Returns escape string for char or nil if none", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/char-escape-string"}, :clojure.core/nthrest {:added "1.3", :ns "clojure.core", :name "nthrest", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/drop :clojure.core/nthnext :clojure.core/nth :clojure.core/rest :clojure.core/next], :line 3166, :examples ["(nthrest (range 10) 5)\n;;=> (5 6 7 8 9)\n\n;; in many cases gives the same result as nthnext\n(nthnext (range 10) 5)\n;;=> (5 6 7 8 9)\n\n;; here is a case where the results differ\n(nthrest [] 3)  ;;=> []\n(nthnext [] 3)  ;;=> nil\n\n(nthrest [1 2 3 4 5 6 7] 4)\n;;=> (5 6 7)" ";; drop is also similar, but lazy \n(nthrest (range 10) 5)   ;;=> (5 6 7 8 9)\n(drop    5 (range 10))   ;;=> (5 6 7 8 9)\n\n;; here is a case where the results differ\n(nthrest [] 3)  ;;=> []\n(drop    3 [])  ;;=> ()   ; returning a lazy sequence" ";; nthrest eagerly evaluates the dropped items:\n\n(def a (nthrest (map #(do (print \".\") %) (iterate inc 0)) 10))\n;; ..........#'user/a (note: processing already started)\n\n(def b (drop 10 (map #(do (print \".\") %) (iterate inc 0))))\n;; #'user/b (note: no evaluation)\n\n;; Possible use: always produce side effects (if any) independently \n;; from evaluation of kept items."], :notes ["This differs from clojure.core/drop in that it immediately drops the head of the seq, instead of doing so on the first call to first or seq."], :arglists ["coll n"], :doc "Returns the nth rest of coll, coll when n is 0.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nthrest"}, :clojure.core.logic.fd/*c {:ns "clojure.core.logic.fd", :name "*c", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 913, :examples nil, :notes nil, :arglists ["u v w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/*c"}, :clojure.core.async/alts! {:ns "clojure.core.async", :name "alts!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/alt! :clojure.core.async/alts!! :clojure.core.async/alt!!], :line 276, :examples ["user> (let [chans (partition-all 2\n                                 (interleave\n                                  [\"Bob\"\n                                   \"Jane\"\n                                   \"GuyGirl22\"]\n                                  (repeatedly 3 chan)))]\n        (go\n          (let [[owner port] (rand-nth chans)\n                chans-only (mapv second chans)]\n\n            (go\n              (<! (timeout 1500))\n              (>! port\n                  (str owner \": First!!!\")))\n\n            (let [[v p] (alts! chans-only)]\n              (println \"Message: \" v \"\\nFrom Object: \" p)))))\n\n;; Returns => #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@446ab69a>\n\n;; 1.5 seconds later =>\n;; Message:  Bob: First!!! \n;; From Object:  #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@15ac28ae>\n" ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; THIS example shows `:default`s and `:priority`s\n\n(let [f (fn [x ch] (go (Thread/sleep (rand 100))\n                                (>! ch x)))\n      a (chan)\n      b (chan)\n      c (chan)]\n  (println \"----------\")\n  (f 1 a)\n  (f 2 b)\n  (f 3 c)\n  (Thread/sleep 200) ; if this is commented out, it returns the\n                     ; `:default` every time. If the thread *does*\n                     ; sleep, then it returns the `a` channel's `1`\n                     ; every time\n  (let [[n ch2] (alts!! [a b c]\n                        :default 42\n                        :priority true\n                        )]\n    (println \"received: \" n)))"], :notes nil, :arglists ["ports & {:as opts}"], :doc "Completes at most one of several channel operations. Must be called\n  inside a (go ...) block. ports is a vector of channel endpoints,\n  which can be either a channel to take from or a vector of\n  [channel-to-put-to val-to-put], in any combination. Takes will be\n  made as if by <!, and puts will be made as if by >!. Unless\n  the :priority option is true, if more than one port operation is\n  ready a non-deterministic choice will be made. If no operation is\n  ready and a :default value is supplied, [default-val :default] will\n  be returned, otherwise alts! will park until the first operation to\n  become ready completes. Returns [val port] of the completed\n  operation, where val is the value taken for takes, and a\n  boolean (true unless already closed, as per put!) for puts.\n\n  opts are passed as :key val ... Supported options:\n\n  :default val - the value to use if none of the operations are immediately ready\n  :priority true - (default nil) when true, the operations will be tried in order.\n\n  Note: there is no guarantee that the port exps or val exprs will be\n  used, nor in what order should they be, so they should not be\n  depended upon for side effects.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/alts!"}, :clojure.core.logic/waiting-stream? {:ns "clojure.core.logic", :name "waiting-stream?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1860, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/waiting-stream_q"}, :clojure.spec.alpha/and {:ns "clojure.spec.alpha", :name "and", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 472, :examples nil, :macro true, :notes nil, :arglists ["& pred-forms"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/and"}, :clojure.core.logic/get-dom-fd {:ns "clojure.core.logic", :name "get-dom-fd", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2205, :examples nil, :notes nil, :arglists ["a x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/get-dom-fd"}, :clojure.core/identity {:added "1.0", :ns "clojure.core", :name "identity", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/nil? :clojure.core/some?], :line 1443, :examples ["user=> (identity 4)\n4" "user=> (filter identity [1 2 3 nil 4 false true 1234])\n(1 2 3 4 true 1234)" "user=> (map #(%1 %2) (cycle [inc identity]) [1 2 3 4 5 6 7 8 9 10])\n(2 2 4 4 6 6 8 8 10 10)\n" "user=> (partition-by identity (sort \"abcdaabccc\"))\n((\\a \\a \\a) (\\b \\b) (\\c \\c \\c \\c) (\\d))\n" "user=> (map first (partition-by identity [1 1 2 3 3 1 1 5 5]))\n(1 2 3 1 5)" "user=> (group-by identity \"abracadabra\")\n{\\a [\\a \\a \\a \\a \\a], \\b [\\b \\b], \\r [\\r \\r], \\c [\\c], \\d [\\d]}" "user=> (map #(identity %) [1 2 3 4]) ; ~ (map (fn [x] x) [1 2 3 4])\n(1 2 3 4)" "; `identity` can serve in workarounds, because you can't pass a macro\n; to a function. For example, you can't pass `and` as a parameter to `apply`:\n(apply and '(true 1 \"yes\"))\n; \\=> CompilerException... Can't take value of a macro...\n\n; Instead:\n(every? identity '(true 1 \"yes\"))\n"], :notes ["I don't quite see the usefulness of this :P" "It's useful for example with -&gt; macro when we eventually want to return its argument (in this case: state)\r\n\r\n\r\n\r\n(defn example[state]\r\n    (-> state\r\n        update-function-1\r\n        update-function-2\r\n        identity))" "Here is another good example:\r\n<pre>(some identity ((juxt :foo :bar) {:bar :b}))</pre>\r\nequivalent to \r\n<pre> (let [map {:bar b}] (or (:foo map) (:bar map)))" "user=> (mapcat identity [[[0 1] [1 2]] [[11 12]]])\n([0 1] [1 2] [11 12])\n"], :arglists ["x"], :doc "Returns its argument.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/identity"}, :clojure.core.logic.fd/-member? {:ns "clojure.core.logic.fd", :name "-member?", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this n"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-member_q"}, :clojure.core/send-off {:added "1.0", :ns "clojure.core", :name "send-off", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/send :clojure.core/agent :clojure.core/shutdown-agents], :line 2114, :examples ["user=> (def my-agent (agent \"\"))\n#'user/my-agent\nuser=> @my-agent\n\"\"\n\n;; Note the following happens asynchronously in a thread\n;; pool\nuser=> (send-off my-agent #(slurp %2) \"file.txt\")\n#<Agent@13c6641: \"\">\n\n;; while the slurp is in-progress, @my-agent will return \"\".\n\n;; Once the request has completed, the value will\n;; be updated when we look at it.\nuser=> @my-agent\n\"file contents\"\n" ";; send should be used for actions that are CPU limited,\n;; while send-off is appropriate for actions that may block on IO.\n\n;; send is like async/go, send-off is like async/thread\n;; so send use limited pool by CPU for agents to not overload CPU,\n;; while send-off use independent threads without limitations."], :notes ["The example uses \"send\", this is supposed to be an example for \"send-off\"." "\"send\" and \"send-off\" are identical in syntax and semantics.  The only difference is the thread pool used to dispatch the agent.  \"send\" uses a fixed-sized thread pool initialized at startup to contain a few more threads than the number of cores on the host computer.  Since \"send\"s thread pool is fixed size, using it to dispatch blocking code can result in all the pool's threads being blocked, and other \"send\"s queued waiting for a thread to finish its work.  This can produce artificially low performance, and in rare conditions, can deadlock (if a queued thread is needed to unblock the blocked pool threads).\n\n\"send-off\" uses a separate thread pool which can grow as-needed.  I.e. a \"send-off\" request will never be queued waiting for a thread; if the existing pool is empty, a new thread is created.  However, if many long-running CPU-bound (not blocking) requests are being submitted, \"send-off\" can be counter-productive; having more CPU-bound threads than cores results in unnecessary scheduling overhead as the threads are timeshared across the cores.  \"send\"s limited thread pool produces higher throughput for CPU-bound requests."], :arglists ["a f & args"], :doc "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/send-off"}, :clojure.spec.alpha/merge-spec-impl {:ns "clojure.spec.alpha", :name "merge-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1142, :examples nil, :notes nil, :arglists ["forms preds gfn"], :doc "Do not call this directly, use 'merge'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/merge-spec-impl"}, :clojure.core/proxy-name {:ns "clojure.core", :name "proxy-name", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos nil, :line 37, :examples nil, :notes nil, :tag "java.lang.String", :arglists ["super interfaces"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/proxy-name"}, :clojure.core.logic/distribute {:ns "clojure.core.logic", :name "distribute", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2283, :examples nil, :notes nil, :arglists ["v* strategy"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/distribute"}, :clojure.core.logic/lvar {:ns "clojure.core.logic", :name "lvar", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 706, :examples ["(let [x (lvar 'x)]\n  (run 10 [q]\n    (membero x [1 2 3])\n    (== q x)))"], :notes nil, :arglists ["" "name" "name unique"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lvar"}, :clojure.stacktrace/root-cause {:added "1.1", :ns "clojure.stacktrace", :name "root-cause", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos nil, :line 18, :examples [";; make an exception\n(def anex (try (/ 1 0) (catch Exception ex ex)))\n\n;; get the root cause\n(clojure.stacktrace/root-cause anex)\n;;=> #error {\n;;    :cause \"Divide by zero\"\n;;    :via\n;;    [{:type java.lang.ArithmeticException\n;;      :message \"Divide by zero\"\n;;      :at [clojure.lang.Numbers divide \"Numbers.java\" 163]}]\n;;    :trace\n;;    [[clojure.lang.Numbers divide \"Numbers.java\" 163]\n;;    [clojure.lang.Numbers divide \"Numbers.java\" 3833]\n;; ...\n;;    [java.lang.Thread run \"Thread.java\" 748]]}\n"], :notes nil, :arglists ["tr"], :doc "Returns the last 'cause' Throwable in a chain of Throwables.", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/root-cause"}, :clojure.core/compare-and-set! {:added "1.0", :ns "clojure.core", :name "compare-and-set!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/atom :clojure.core/reset! :clojure.core/swap! :clojure.core/swap-vals!], :line 2360, :examples [";; first we make a demonstration atom\n(def a (atom 0))\n;; #'user/a \n\n;; failing to set the demonstration atom because the old-value does not match. \n(compare-and-set! a 10 20)\n;;=> false\n\n;; as you can see there was no change to the atom\n@a\n;;=> 0\n\n;; but when  the old-value matches the atom is set to the new-value.\n(compare-and-set! a 0 10)\n;;=> true\n\n@a\n;;=> 10\n"], :notes ["`compare-and-set!` actually runs an equality comparison, not an identity comparison. The documentation should read:\n\n> Atomically sets the value of atom to newval if and only if the current value of the atom is <del>identical</del> <ins>equal</ins> to oldval.\n\n    (def my-sym (atom 'a))\n    (identical? @my-sym 'a)\n    ;;=> false\n    (= @my-sym 'a)\n    ;;=> true\n    (compare-and-set! my-sym 'a 'z)\n    ;;=> true\n    @my-sym\n    ;;=> z" "The note that `compare-and-set!` uses equality comparison is wrong, `compare-and-set!` really _does_ use *identity comparison* (Java `==`). Internally, Clojure uses the `AtomicReference.compareAndSet(old, new)` method.\n\nThe reason his example works is due to interning of the `a` symbol: in his example, each `a` is the same (identical) object.\n\nBut as you can see from the example below, even numeric autoboxing can lead to surprising results:\n\n    (def a (atom 0))\n    ;=> #'user/a\n    (compare-and-set! a 0 100)\n    ;=> true\n    ;(compare-and-set! a 100 200)\n    ;=> true\n    ;; Fails?! (on Oracle JVM 8 with default settings)\n    (compare-and-set! a 200 300)\n    ;=> false\n    @a\n    ;=> 200 ; WAT?\n\nClojure almost always uses boxed numbers (via Java autoboxing) unless you take special steps to avoid it. compare-and-set! only accepts Objects, so numbers are autoboxed to Longs.\n\nJava JVMs will usually intern small integers; by default Oracle/OpenJDK will intern -127 to 128 (the `byte` range) so that all such boxed numbers are identical. This can be altered with the `-XX:AutoBoxCacheMax=` command line flag.  This may vary by JVM implementation, too.\n\n(In fact, on ClojureCLR, `compare-and-set!` of longs always fails because the CLR does not intern small numbers, see [this bug report](https://dev.clojure.org/jira/browse/CLJCLR-28).)\n\nSo in the example above, `compare-and-set!` on 0 and 100 work fine due to this auto-interning, but the compare with 200 fails because: `(identical? 200 200)` is false due to autoboxing: two distinct invisible `Long` objects are created for each \"200\" value.\n\nYou don't have to worry about this with `swap!` because the \"old\" value it compares against for the compare-and-set operation is always from the atom itself, so identity comparison works as long as no one else put a different object in the atom in the meantime. However, it is easy to imagine a pathological case with a highly-contented atom where everyone keeps putting the same \"equal\" value into it over and over, and yet swappers have to retry over and over."], :arglists ["atom oldval newval"], :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/compare-and-set!"}, :clojure.test/use-fixtures {:added "1.1", :ns "clojure.test", :name "use-fixtures", :file "clojure/test.clj", :type "var", :column 1, :see-alsos [:clojure.test/join-fixtures :clojure.test/compose-fixtures], :line 669, :examples ["; See https://clojure.github.io/clojure/clojure.test-api.html for details\n\n; my-test-fixture will be passed a fn that will call all your tests \n; (e.g. test-using-db).  Here you perform any required setup \n; (e.g. create-db), then call the passed function f, then perform \n; any required teardown (e.g. destroy-db).\n(defn my-test-fixture [f]\n        (create-db)\n        (f)\n        (destroy-db))\n\n; Here we register my-test-fixture to be called once, wrapping ALL tests \n; in the namespace\n(use-fixtures :once my-test-fixture)\n \n; This is a regular test function, which is to be wrapped using my-test-fixture\n(deftest test-using-db\n  (is ... \n))" "; This fixture is intended to perform setup/teardown for each individual test in the namespace. Note that it assumes the :once fixture will handle creating/destroying the DB, while we only create/drop tables within the DB.\n(defn another-fixture [f]\n        (create-db-table)\n        (f)\n        (drop-db-table))\n\n; Here we register another-fixture to wrap each test in the namespace\n(use-fixtures :each another-fixture)" ";; `use-fixtures` supports multiples arguments. \n;; They wrap the tests in order (left-to-right).\n\n;; We define some fixtures that are to be run in order\n(defn with-db [f] \n  (start-db)\n  (f)\n  (stop-db))\n\n(defn with-data [f] \n  (fill-db)\n  (f)\n  (empty-db))\n\n;; Here we register them\n(use-fixtures :once with-db with-data)"], :notes nil, :arglists [], :doc "Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while :once wraps the whole run in a single function.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/use-fixtures"}, :clojure.core/float? {:added "1.0", :ns "clojure.core", :name "float?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/double? :clojure.core/bigdec? :clojure.core/decimal?], :line 3596, :examples ["user=> (float? 0)\nfalse\nuser=> (float? 0.0)\ntrue" ";; float? returns true for both float and double.\nuser=> (map (juxt type float?) [(float 1) (double 1)])\n([java.lang.Float true] [java.lang.Double true])\n\n;; Call instance? to check if the value is specifically float or double.\nuser=> (map (juxt type #(instance? Float %)) [(float 1) (double 1)])\n([java.lang.Float true] [java.lang.Double false])"], :notes nil, :arglists ["n"], :doc "Returns true if n is a floating point number", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/float_q"}, :clojure.core.logic/trace-lvars {:ns "clojure.core.logic", :name "trace-lvars", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1305, :examples nil, :macro true, :notes nil, :arglists ["title & lvars"], :doc "Goal for tracing the values of logic variables.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/trace-lvars"}, :clojure.core/inc' {:added "1.0", :ns "clojure.core", :name "inc'", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/inc :clojure.core/dec'], :line 907, :examples ["> (inc' 1)\n2\n\n> (inc' 3.14)\n4.140000000000001\n\n> (inc' 4/5)\n9/5\n\n> (inc' -1)\n0\n\n> (inc' -3/2)\n-1/2\n\n> (inc' -0.2)\n0.8" ";;;; (inc') auto-promotes on integer overflow:\n\n(inc' (Long/MAX_VALUE))\n;;=> 9223372036854775808N\n\n;;;; Unlike (inc) which does not:\n\n(inc (Long/MAX_VALUE))\n;;=> ArithmeticException integer overflow"], :notes nil, :arglists ["x"], :doc "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/inc'"}, :clojure.core.reducers/coll-fold {:ns "clojure.core.reducers", :name "coll-fold", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["coll n combinef reducef"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/coll-fold"}, :clojure.core/booleans {:added "1.1", :ns "clojure.core", :name "booleans", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/boolean-array], :line 5288, :examples [";; for fast interop\nuser=> (set! *warn-on-reflection* true)\ntrue\nuser=> (defn get-a-bool [bs] (aget bs 1))\nReflection warning, NO_SOURCE_PATH:1 - call to aget can't be resolved.\n#'user/get-a-bool\nuser=> (defn get-a-bool [bs] (let [bs (booleans bs)] (aget bs 1)))\n#'user/get-a-bool\n" ";; can also be used as type hint to avoid reflection:\nuser=> (set! *warn-on-reflection* true)\ntrue\nuser=> (defn get-a-bool [^booleans bs] (aget bs 1))\n#'user/get-a-bool"], :notes nil, :arglists ["xs"], :doc "Casts to boolean[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/booleans"}, :clojure.core/binding {:added "1.0", :ns "clojure.core", :name "binding", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-redefs :clojure.core/with-bindings :clojure.core/with-local-vars :clojure.core/def], :line 1939, :examples [";; Here are the definitions.\n(defn mymax [x y]\n  (min x y))\n\n(defn find-max [x y]\n  (max x y))\n\nuser=> (let [max mymax]\n         (find-max 10 20))\n\n20 ;let is ineffective outside current lexical scope\n\n\nuser=> (binding [max mymax]\n         (find-max 10 20))\n\n10 ;because max is now acting as min" ";; As of Clojure 1.3, vars need to be explicitly marked as ^:dynamic in order for\n;; them to be dynamically rebindable:\n\nuser=> (def ^:dynamic x 1)\nuser=> (def ^:dynamic y 1)\nuser=> (+ x y)\n2\n\n;; Within the scope of the binding, x = 2 and y = 3\n\nuser=> (binding [x 2 y 3]\n         (+ x y))\n5\n\n;; But once you leave the binding's scope, x and y maintain their original\n;; bindings:\n\nuser=> (+ x y)\n2" ";;Use t like a \"template\"\n\n(declare ^:dynamic t)\n\n(defn addt [] \n  (+ t 10))\n\n(binding [t 1]\n  (addt))\n=> 11" "; You can set! bindings. Useful in a stateful programming.\nuser=> (def ^:dynamic d)\n#'user/d\nuser=> d\n#<Unbound Unbound: #'user/d>\nuser=> (binding [d 0] (prn d) (set! d 1) (prn d))\n0\n1\nnil\nuser=> d\n#<Unbound Unbound: #'user/d>" "; Speed test. recur is the preferred way.\nuser=> (def a (atom 0))\n#'user/a\nuser=> (def ^:dynamic b)\n#'user/b\nuser=> (def d)\n#'user/d\nuser=> (time (loop [r 0] (when (< r 10000000) (recur (inc r)))))\n\"Elapsed time: 8.062612 msecs\"\nnil\nuser=> (time (dotimes [_ 10000000] (reset! a 1)))\n\"Elapsed time: 93.428704 msecs\"\nnil\nuser=> (time (binding [b 0] (dotimes [_ 10000000] (set! b 1))))\n\"Elapsed time: 484.331821 msecs\"\nnil\nuser=> (time (with-local-vars [w 0] (dotimes [_ 10000000] (var-set w 1))))\n\"Elapsed time: 490.598696 msecs\"\nnil\nuser=> (time (dotimes [_ 10000000] (def d 1)))\n\"Elapsed time: 2154.646688 msecs\"\nnil\n" ";; You can modify the variable inside a binding, \n;; inside a let, you can't.\n\n(def ^:dynamic z)\n\n(binding [z nil]\n  (doseq [x (range 4) y (range 4)]\n    (set! z [x y]))\n  z)\n\n; => [3 3]\n\n;; You can modify the variable inside a for, with dorun.\n\n(binding [z nil]\n  (dorun\n    (for [x (range 4) y (range 4)]\n      (set! z [x y])))\n  z)\n\n; => [3 3]" ";; from stackoverflow http://stackoverflow.com/questions/1523240/let-vs-binding-in-clojure\n;; let creates a lexically scoped immutable alias for some value.  \n;; binding creates a dynamically scoped binding for some Var.\n\n;; Dynamic binding means that the code inside your binding form and any code \n;; which that code calls (even if not in the local lexical scope) will see the new binding.\n\nuser> (def ^:dynamic x 0)\n#'user/x\n\n;; Lexical vs. dynamic binding:\n\nuser> (defn foo [] (println x))\n#'user/foo\nuser> (binding [x 1] (foo))\n1\nnil\nuser> (let [x 1] (foo))\n0\nnil" ";; Beware usage in ClojureScript around asynchronous calls, as the bound\n;; var's original value will be re-established before the async code executes:\n\n(def ^:dynamic *foo* nil)\n\n(binding [*foo* :bar]\n  (js/setTimeout\n    (fn []\n      *foo* ;;=> nil\n      ))\n\n;; Also beware *synchronous* usage inside `cljs.test/async`, as the bound\n;; var's original value will not be re-established:\n\n(ns my-ns\n  (:require [cljs.test :refer-macros [async deftest is]]))\n\n(def ^:dynamic *foo* nil)\n\n(deftest my-test\n  (async done\n    (binding [*foo* :bar]\n      (done))))\n\n(deftest another-test\n  (async done\n    (is (nil? *foo*))))\n\n;; FAIL in (another-test)\n;; expected: (nil? *foo*)\n;;   actual: (not (nil? :bar))\n\n;; At time of writing, the stable ClojureScript version is 1.9.89."], :macro true, :notes ["The first example (binding mymax to max) appears to be broken.  The last line generates the error:\r\n<pre>\r\n  IllegalStateException Can't dynamically bind non-dynamic var: clojure.core/max\r\n</pre>\r\n\r\nI tried inserting (.setDynamic #'max) at the top, and it got rid of the error, but the binding didn't seem to actually happen.  I.e. the last line prints 20.\r\n\r\n<br>The only way I could get it to work is by redefining max from scratch as dynamic:\r\n\r\n<pre>\r\n(defn ^:dynamic max\r\n  ([x] x)\r\n  ([x y] (. clojure.lang.Numbers (max x y)))\r\n  ([x y &amp; more]\r\n   (reduce max (max x y) more)))\r\n</pre>\r\n\r\nAfter THIS the first example succeeds.\r\n\r\n<br>The moral of the story - I guess you can't easily bind built-in functions.  You need to write your functions with the intention of them being bindable.  And I guess the first example should simply be removed?" "So about first example --\n<pre>\n(defn find-max [x y]\n  (max x y)) ;; => #'user/find-max\n(binding [max clojure.core/min]\n  (find-max 10 20)) ;; Can't dynamically bind non-dynamic var: clojure.core/max\n(def ^:dynamic max clojure.core/max)\n(binding [max clojure.core/min]\n  (find-max 10 20)) ;; => 20\n(defn find-max [x y]\n  (max x y)) ;; => #'user/find-max\n(binding [max clojure.core/min]\n  (find-max 10 20)) ;; => 10\n</pre>\nLong story short: var needs to be defined `^:dynamic` before you create your function with var being bound here, or else no dynamic building occur (which is intended behavior, I guess)."], :arglists ["bindings & body"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/binding"}, :clojure.core/*read-eval* {:added "1.0", :ns "clojure.core", :name "*read-eval*", :type "var", :see-alsos [:clojure.core/read :clojure.core/read-string :clojure.core/load], :examples [";;just from the doc\n\n(binding [*read-eval* false] (read-string \"#=(eval (def x 3))\"))\n=> EvalReader not allowed when *read-eval* is false.\n  [Thrown class java.lang.RuntimeException]\n\n;;remove the anonymous function:\n\n(binding [*read-eval* false] (read-string \"(def x 3)\"))\n=> (def x 3)\n\n;;which is evaluable\n\n(eval (binding [*read-eval* false] (read-string \"(def x 3)\")))\n=> #'user/x\n\nx\n=>3"], :notes nil, :arglists [], :doc "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: clojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'clojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dclojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dclojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*read-eval*"}, :clojure.core/transduce {:added "1.7", :ns "clojure.core", :name "transduce", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/completing], :line 6790, :examples [";; First, define a transducer for producing the first ten odd numbers:\n(def xf (comp (filter odd?) (take 10)))\n\n;; We can then apply this transducer in different ways using transduce.\n\n;; Get the numbers as a sequence:\n\n(transduce xf conj (range))\n;;=> [1 3 5 7 9 11 13 15 17 19]\n\n;; Or sum them:\n\n(transduce xf + (range))\n;; => 100\n\n;; ... with an initializer:\n\n(transduce xf + 17 (range))\n;; => 117\n\n;; Or concatenate them to a string:\n\n(transduce xf str (range))\n;; => \"135791113151719\"\n\n;; .. with an initializer:\n\n(transduce xf str \"...\" (range))\n;; => \"...135791113151719\"\n" ";; When studying Korean, I had notes with mixture of Korean and\n;; English and I wanted to filter out any English. \n\n(def example (str \"I will write an autobiography(자서전) later\\n\"\n                  \"(저는) 나중에 자서전을 쓸 거에요\"))\n\n;; Here's a transducer to filter out english characters\n\n(defn filter-out-english \n  \"filter out english characters in a string\"\n  []\n  (filter (fn [c] \n            (let [i (int c)] \n              (not (or (and (>= i 65) (<= i 90)) \n                       (and (>= i 97) (<= i 122))))))))\n\n;; Here's a transducer to help deal with extra spaces and newlines.\n;; Notice the mapcat ensures that the output will always be the same\n;; shape as the input\n\n(defn trim-chars [c n]\n  \"Ensure exactly n characters c in a row. For example, squash\n  multiple spaces into single space or expand newlines into 2\n  newlines\"\n  (comp (partition-by #{c})\n        (mapcat #(if (= c (first %)) (repeat n c) %))))\n\n\n;; put it all together, we filter out english characters, replace\n;; multiple spaces with single space, and ensure each line is double\n;; spaced (two line breaks between each line)\n(def xf (comp (filter-out-english) \n              (trim-chars \\space 1)\n              (trim-chars \\newline 2)))\n\n(apply str (transduce xf conj example))\n;; => \" (자서전) \\n\\n(저는) 나중에 자서전을 쓸 거에요\"\n" ";; transduce with the identity transform is equivalent to reduce,\n;; in the following way:\n(transduce identity f sample)\n(f (reduce f (f) sample))\n\n;; For example, we can define a reducing function and then use it:\n(defn conj-second\n  ([]\n   [])\n  ([result]\n   result)\n  ([result [x y]]\n   (conj result y)))\n\n(def sample [[1 :a] [2 :b] [3 :c]])\n\n(transduce identity conj-second sample)\n;;=>[:a :b :c]\n(conj-second (reduce conj-second (conj-second) sample))\n;;=>[:a :b :c]\n\n;; Let's prove the point with printing:\n(defn conj-second\n  ([]\n   (println \"0\") [])\n  ([result]\n   (println \"1\") result)\n  ([result [x y]]\n   (println \"2\") (conj result y)))\n\n;; Then the following both print 0 2 2 2 1\n(transduce identity conj-second sample)\n(conj-second (reduce conj-second (conj-second) sample))\n" ";;; BUILD A STATEFULL TRANSDUCER\n\n;; Make a transducer that accumulates a sequence when pred is truthy and\n;; returns individual values when pred is falsy.\n;;\n;; For example when pred is odd?, partition\n;;\n;;    [1 1 1 2 2 3 3 3]\n;;    \n;; into\n;; \n;;    [[1 1 1] [2] [2] [3 3 3]]\n;;\n\n(defn accumulate-when [pred]\n  ;; A transducer takes a reducer function and returns a reducer function.\n  (fn [rf]\n    ;; State (an accumulator) which is closed over by the reducer function.\n    (let [acc (java.util.ArrayList.)]\n      (fn\n        ;; Arity 0 (state initializer). In this step we can initialize `acc`\n        ;; based on the returned valued of (rf), but here, as it is usually the\n        ;; case, this is not needed.\n        ([] (rf))\n        \n        ;; Arity 1 (completer). Called after the reducing process has ended (if\n        ;; ever). In this step local state must be cleaned and residual reducing\n        ;; step may be performed. `result` is an unreduced value (see reduced\n        ;; and unreduced).\n        ([result]\n         (let [result (if (.isEmpty acc)\n                        ;; No residual state. Simply return the result.\n                        result\n                        ;; Need to clear the residual state and perform one last\n                        ;; reducing step on the so far accumulated values.\n                        (let [v (vec (.toArray acc))]\n                          (.clear acc)\n                          ;; This step might return a completed value (i.g. on\n                          ;; which reduced? gives true). We need to deref it\n                          ;; with `unreduced` in order to supply it to rf.\n                          (unreduced (rf result v))))]\n           ;; Nested rf call. Must happen once!\n           (rf result)))\n        \n        ;; Arity 2 (reducer). This is where the main work happens.\n        ([result input]\n         (if (pred input)\n           ;; When pred is truthy, accumulate and don't call the nested reducer.\n           (do\n             (.add acc input)\n             result)\n           ;; When pred is falsy, call nested reducer (possibly twice).\n           (if (.isEmpty acc)\n             ;; When accumulator is empty, reduce with a singleton.\n             (rf result [input])\n             (let [v (vec (.toArray acc))]\n               (.clear acc)\n               ;; First reduce on the accumulated sequence.\n               (let [ret (rf result v)]\n                 (if (reduced? ret)\n                   ;; If sequence is completed, no more reductions\n                   ret\n                   ;; else, reduce once more with the current (falsy) input.\n                   (rf ret [input])))))))))))\n\n(def x [1 1 1 2 2 3 3 3])\n\n;; Step through with the debugger in order to gain a better understanding of the\n;; involved steps.\n\n(transduce (accumulate-when odd?) conj x)\n;; user> [[1 1 1] [2] [2] [3 3 3]]\n\n(transduce (comp (take 4) (accumulate-when odd?)) conj x)\n;; user> [[1 1 1] [2]]\n\n(transduce (comp (accumulate-when odd?) (take 3)) conj x)\n;; user> [[1 1 1] [2] [2]]\n\n(transduce (comp (accumulate-when odd?) (take 4)) conj x)\n;; user> [[1 1 1] [2] [2] [3 3 3]]\n\n;; Clojure core statefull transducers are partition-by, partition-all, take,\n;; drop, drop-while, take-nth, distinct, interpose, map-indexed and\n;; keep-indexed.\n"], :notes ["Usually you use existing functions to create the transformation, using map, filter, paritition-all, etc. But you can also define your own transformations. A transformation (or transducer) is a function that takes a reducing function and returns a reducing function. See the source for [take](https://github.com/clojure/clojure/blob/clojure-1.8.0/src/clj/clojure/core.clj#L2752) and [filter](https://github.com/clojure/clojure/blob/clojure-1.8.0/src/clj/clojure/core.clj#L2684) for examples."], :arglists ["xform f coll" "xform f init coll"], :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/transduce"}, :clojure.core.logic.fd/binops->fd {:ns "clojure.core.logic.fd", :name "binops->fd", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 1099, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/binops->fd"}, :clojure.core.logic/reify-constraints {:ns "clojure.core.logic", :name "reify-constraints", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2164, :examples nil, :notes nil, :arglists ["v r a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/reify-constraints"}, :clojure.core/-> {:added "1.0", :ns "clojure.core", :name "->", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/->> :clojure.core/as-> :clojure.core/get-in :clojure.core/some-> :clojure.core/doto :clojure.core/..], :line 1669, :examples [";; Use of `->` (the \"thread-first\" macro) can help make code\n;; more readable by removing nesting. It can be especially\n;; useful when using host methods:\n\n;; Arguably a bit cumbersome to read:\nuser=> (first (.split (.replace (.toUpperCase \"a b c d\") \"A\" \"X\") \" \"))\n\"X\"\n\n;; Perhaps easier to read:\nuser=> (-> \"a b c d\" \n           .toUpperCase \n           (.replace \"A\" \"X\") \n           (.split \" \") \n           first)\n\"X\"\n\n;; It can also be useful for pulling values out of deeply-nested\n;; data structures:\nuser=> (def person \n            {:name \"Mark Volkmann\"\n             :address {:street \"644 Glen Summit\"\n                       :city \"St. Charles\"\n                       :state \"Missouri\"\n                       :zip 63304}\n             :employer {:name \"Object Computing, Inc.\"\n                        :address {:street \"12140 Woodcrest Dr.\"\n                                  :city \"Creve Coeur\"\n                                  :state \"Missouri\"\n                                  :zip 63141}}})\n \nuser=> (-> person :employer :address :city)\n\"Creve Coeur\"\n\n;; same as above, but with more nesting\nuser=> (:city (:address (:employer person)))\n\"Creve Coeur\"\n\n;; Note that this operator (along with ->>) has at times been\n;; referred to as a 'thrush' operator.\n\n;; http://blog.fogus.me/2010/09/28/thrush-in-clojure-redux/\n" ";; Your own REPL! (Read Eval Print Loop)\n\n;; We would need a little helper macro for that\n;; It does what its name says - loops forever\nuser=> (defmacro loop-forever [& body] `(loop [] ~@body (recur)))\n\n;; Your own REPL\nuser=> (loop-forever (println (eval (read))))                                                                     \n(+ 1 2)\n3\n\n;; If you read the above code left to right (outside in) it reads LPER.\n;; Inside out it reads REPL alright.\n\n;; Sometimes it might be easier to read code outside in, just like a sequence of steps:\n;; 1. Read, 2. Eval, 3. Print, 4. Loop\n;; Here's how -> helps you:\n\nuser=> (-> (read) (eval) (println) (loop-forever))                                                                \n(+ 1 2)\n3\n\n;; Does that read easier for you? If it does, -> is your friend!\n\n;; To see what Clojure did behind the scenes with your -> expression:\nuser=> (require 'clojure.walk)\nnil\nuser=> (clojure.walk/macroexpand-all '(-> (read) (eval) (println) (loop-forever)))\n(loop* [] (println (eval (read))) (recur))\n\n;; You can even use ->'s cousin ->> to setup your own REPL:\nuser=> (->> (read) (eval) (println) (while true))\n(+ 1 2)\n3\n\n;; Can you see why we can't use -> to write the above?\n\n" "user=> (def c 5)\nuser=> (-> c (+ 3) (/ 2) (- 1))                          \n3\n\n;; and if you are curious why\nuser=> (use 'clojure.walk)\nuser=> (macroexpand-all '(-> c (+ 3) (/ 2) (- 1)))\n(- (/ (+ c 3) 2) 1)\n" ";; simplest usage example, fill as second item in the first and second form\n\nuser=> (-> \"foo\"\n           (str \"bar\")\n           (str \"zoo\"))\n\"foobarzoo\"\nuser=> (str \"foo\" \"bar\")\n\"foobar\"\nuser=> (str (str \"foo\" \"bar\") \"zoo\")\n\"foobarzoo\"" "(-> 3 (- 2)) ; It means (- 3 2)\n=> 1\n\n(->> 3 (- 2)) ; It means (- 2 3)\n=> -1\n\n(doto 3 (- 2)) ; It means (- 3 2) but return the first object 3\n=> 3" ";; Be cautious with anonymous functions; they must be wrapped in an outer\n;; pair of parens.\n(-> 10\n    #(/ % 2))\n;; will throw an exception, but\n(-> 10\n    (#(/ % 2)))\n;; will work fine. Similarly,\n(-> 10\n    (fn [n] (/ n 2)))\n;; will throw an exception, but\n(-> 10\n    ((fn [n] (/ n 2))))\n;; works as intended.\n" ";; How to thread functions that expect more than one argument\n\n;; Say you want to thread this.\nuser=> (inc (/ 10 2))\n=> 6\n\n;; This obviously won't work\nuser=> (-> 2 10 / inc)\n=> ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn\n\n;; Since Clojure is expecting a function instead of `10` in `(10 2)`\nuser=> (clojure.walk/macroexpand-all '(-> 2 10 + inc))\n=> (inc (+ (10 2)))\n\n;; Instead you have two options, either just\nuser=> (-> (/ 10 2) inc)\n=> 6\n\n;; or\nuser=> (-> 10 (/ 2) inc)\n=> 6" ";; For large threads you can use commas (interpreted as whitespaces) \n;; to visualize where the items are going to be inserted.\n\nuser=> (-> + (reduce 10 [6 4]) (* 5) (/ 100))\n=> 1\n\n;; with two commas (you can use one if you prefer)\nuser=> (-> + (reduce ,, 10 [6 4]) (* ,, 5) (/ ,, 100))\n=> 1\n\n;; For instance:\n;; (reduce ,, 10 [6 4])\n;; means\n;; (reduce + 10 [6 4])" ";; 4Clojure Question 38\n\n(= (#(-> %& \n       sort \n       reverse \n       first)  1 8 3 4) 8)"], :macro true, :notes ["See also <a href=\"http://clojuredocs.org/v/1660\">-&gt;&gt;</a> which is similar but threads the first expr as the <b>last</b> argument of the forms." "I have a [short blog](http://wangjinquan.me/show/Clojure%20çº¿æ€§ï¼ˆç®­å¤´ï¼‰æ“�ä½œç¬¦) on this, in case you are still confused on it and understand Chinese." "Can be used as an alternative to get-in."], :arglists ["x & forms"], :doc "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->"}, :clojure.java.io/IOFactory {:added "1.2", :ns "clojure.java.io", :name "IOFactory", :file "clojure/java/io.clj", :type "var", :column 1, :see-alsos [:clojure.java.io/reader :clojure.java.io/writer :clojure.java.io/input-stream :clojure.java.io/output-stream], :line 69, :examples nil, :notes nil, :arglists [], :doc "Factory functions that create ready-to-use, buffered versions of\n   the various Java I/O stream types, on top of anything that can\n   be unequivocally converted to the requested kind of stream.\n\n   Common options include\n   \n     :append    true to open stream in append mode\n     :encoding  string name of encoding to use, e.g. \"UTF-8\".\n\n   Callers should generally prefer the higher level API provided by\n   reader, writer, input-stream, and output-stream.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/IOFactory"}, :clojure.core.logic/or* {:ns "clojure.core.logic", :name "or*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1185, :examples nil, :notes nil, :arglists ["goals"], :doc "A function version of conde, which takes a list of goals and tries them as if via conde.\n   Note that or* only does disjunction, ie (or* [a b c]) is the same as (conde [a] [b] [c]).\n   If you need something like (conde [a b] [c]), you can use and*, or all:\n   (or* [(and* a b) c]).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/or*"}, :clojure.java.javadoc/add-local-javadoc {:added "1.2", :ns "clojure.java.javadoc", :name "add-local-javadoc", :file "clojure/java/javadoc.clj", :type "function", :column 1, :see-alsos nil, :line 42, :examples nil, :notes nil, :arglists ["path"], :doc "Adds to the list of local Javadoc paths.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/add-local-javadoc"}, :clojure.core/repeatedly {:added "1.0", :ns "clojure.core", :name "repeatedly", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/repeat :clojure.core/iterate :clojure.core/lazy-seq :clojure.core/dotimes :clojure.core/doall :clojure.core/rand-int :clojure.core/constantly :clojure.core/while], :line 5083, :examples [";; these two functions are equivalent \n\n(take 5 (repeatedly #(rand-int 11)))\n;;=> (6 6 3 9 8)\n\n;; this version only returns the first five elements\n(repeatedly 5 #(rand-int 11))\n;;=> (1 8 6 9 6)\n\n;; compare with repeat, which\n;; only calls the 'rand-int' function once,\n;; repeating the value five times.\n(repeat 5 (rand-int 100))\n(94 94 94 94 94)" "(defn counter []  \n  (let [tick (atom 0)]\n    #(swap! tick inc)))\n\n(def tick (counter))\n\n(take 10 (repeatedly tick))\n;;=> (1 2 3 4 5 6 7 8 9 10)\n\n;; or equivalently\n(repeatedly 10 (counter))\n;;=> (1 2 3 4 5 6 7 8 9 10)" ";;;; If you want random values for each element in repeatedly\n;; don't call rand as an argument in partial\n(= true\n   (every? true?\n           [(apply = (flatten\n                      (repeatedly 2 (partial vector (rand)))))\n            (apply = (flatten\n                      (repeatedly 2 (partial (partial vector (rand))))))]))\n\n;; but do call it within a #(...) or (fn [] ...)\n(= true\n   (every? false?\n           [(apply = (repeatedly 2 rand)) \n            (apply = (repeatedly 2 #(rand))) \n            (apply = (repeatedly 2 (partial rand))) ; passing the rand function works\n            (apply = (flatten\n                      (repeatedly 2 (fn [] (vector (rand))))))\n            (apply = (flatten\n                      (repeatedly 2 #((partial vector (rand))))))\n            (apply = (flatten\n                      (repeatedly 2 #(vector (rand)))))]))" ";; \"repeatedly\" used to build a infinite sequence of side-effecting futures.\n;; Futures are taken in batch of \"parallel\" concurrent threads. The queue\n;; can be fed while the loop is running. \"done?\" determines the exit condition.\n\n(import '[java.util.concurrent ConcurrentLinkedQueue])\n(def q (ConcurrentLinkedQueue. (range 100)))\n\n(let [parallel 5\n      done? #(> (reduce + (remove nil? %)) 30)\n      task #(do (println \"start\" %) (Thread/sleep 1000) (inc %))]\n  (loop [workers (repeatedly\n                   #(let [out *out*]\n                      (future\n                        (binding [*out* out]\n                          (when-let [item (.poll q)]\n                            (task item))))))]\n    (println \"-> starting\" parallel \"new workers\")\n    (let [futures (doall (take parallel workers))\n          results (mapv deref futures)]\n      (cond\n        (done? results) results\n        (.isEmpty q) (println \"Empty.\")\n        :else (recur (drop parallel workers))))))\n\n;; -> starting 5 new workers\n;; startstart  03\n;;\n;; startstart  1\n;; 2start 4\n;;\n;; -> starting 5 new workers\n;; start 5start\n;; start start7start\n;;   6\n;; 8\n;;  9\n[6 7 8 9 10]\n"], :notes ["if the function you want to repeat doesn't have side effects and has an argument, 'iterate' may be what you are looking for."], :arglists ["f" "n f"], :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/repeatedly"}, :clojure.string/trimr {:added "1.2", :ns "clojure.string", :name "trimr", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/trim :clojure.string/triml], :line 263, :examples ["(use 'clojure.string)\n(trimr \"        my string         \")\n=> \"        my string\"" ";; Note: see an example at trim for the differences between\n;; \"whitespace\" for trim/trimr/triml and \n;; \"whitespace\" for regex (\\s)"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Removes whitespace from the right side of string.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/trimr"}, :clojure.core.logic/fail {:ns "clojure.core.logic", :name "fail", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1144, :examples nil, :notes nil, :arglists ["a"], :doc "A goal that always fails.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fail"}, :clojure.core/reversible? {:added "1.0", :ns "clojure.core", :name "reversible?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 6188, :examples ["user=> (reversible? [])\ntrue\nuser=> (reversible? (sorted-map))\ntrue\nuser=> (reversible? (sorted-set))\ntrue\nuser=> (reversible? '())\nfalse\nuser=> (reversible? {})\nfalse\nuser=> (reversible? #{})\nfalse"], :notes nil, :arglists ["coll"], :doc "Returns true if coll implements Reversible", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reversible_q"}, :clojure.core/unchecked-inc-int {:added "1.0", :ns "clojure.core", :name "unchecked-inc-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1141, :examples nil, :notes nil, :arglists ["x"], :doc "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-inc-int"}, :clojure.core.async/map< {:ns "clojure.core.async", :name "map<", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 999, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes ["Can anyone show, using an example, how to use a transducer instead of this function?"], :arglists ["f ch"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/map<"}, :clojure.core/empty? {:added "1.0", :ns "clojure.core", :name "empty?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq :clojure.core/empty :clojure.core/not-empty], :line 6126, :examples ["user=> (empty? ())\ntrue\nuser=> (empty? '(1))\nfalse" "user=> (every? empty? [\"\" [] () '() {} #{} nil])\ntrue\n\n;example of recommended idiom for testing if not empty\nuser=> (every? seq [\"1\" [1] '(1) {:1 1} #{1}])\ntrue" "user=> (drop-while empty? [\"\" [] \"foobar\"])\n(\"foobar\")" "user=> (empty? nil)\ntrue" ";; A collection with nothing in it is not empty.\n(= true\n   (every? false? [(empty? [nil])\n                   (empty? #{nil})\n                   (empty? '(nil))]))\n\n;; But a collection of nothing is empty.\n(= true\n   (every? true? [(empty? [])\n                  (empty? #{})\n                  (empty? '())]))"], :notes ["Some explanation of why (seq x) is preferable over (not (empty? x)) would be good. Because it's far less readable. When I come across (not (empty? x)) in some code, I immediately understand the author's intention. Not so much with (seq x)." "I think this is an efficiency thing.  If you expand the source you can see that empty? is equivalent to (not (seq coll))  so (not (empty? coll)) would macroexpand to (not (not (seq coll))  " "Avoiding `(not (empty? s))` because it macroexpands into `(not (not ...))`, on the grounds of efficiency, is ridiculous. \n\nI'm a fan of:\n\n```clojure\n(when (not-empty s)\n  ...)\n```" "If I just want to return false when empty, true when not empty, then what can I use if I am going to avoid (not (empty? ...))?" "Just note `(not (empty? x))` is not perfectly equivalent to `seq`:\n\n~~~\nuser=> (seq '(1 2))\n(1 2)\nuser=> (not (empty? '(1 2)))\ntrue\n~~~"], :arglists ["coll"], :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/empty_q"}, :clojure.core.async/tap* {:ns "clojure.core.async", :name "tap*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m ch close?"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/tap*"}, :clojure.core/== {:added "1.0", :ns "clojure.core", :name "==", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/= :clojure.core/identical?], :line 1092, :examples [";; true:\n(== 1)\n(== 1 1)       \n(== 1/1, 2/2, 3/3, 4/4)   \n(== 1, 1.0, 1/1)\n(== :foo)\n\n\n;; false:\n(== 1 2)\n\n;; ClassCastException\n(== 1 \\1)\n(== 1 \"1\")" "user=> (= 0.0 0)\nfalse\nuser=> (== 0.0 0)\ntrue" ";; Just what you would expect\n(== 2.0 1.9999999)\n;;=> false\n\n;; a suprising result\n(== 2.0 2 6/3 1.9999999999999999)\n;;=> true ??!?\n;; Yes, there is some rounding off going on.\n;; if you take off just one of the repeating 9 (on my machine) these compare.\n" "\n;; When floating point numbers are far enough from each other\n(== 2.0 1.9999999)\n;;=> false\n(- 100.0 100.00000000000001)  ;13(Thirteen) 0s after floating point in the last number\n;;=> -1.4210854715202004E-14\n\n;; When two floating point numbers are too close some basic algebraic properties don't strictly hold.\n(== 2.0 1.9999999999999999)\n;;=> true\n\n(* 100 (- 1.0 1.0000000000000001))  ;15(fifteen) 0s after floating point in the last number\n;;=> 0.0\n\n;; They are still different types\n(= 2 1.9999999999999999)\n;;=> false\n\n;; see more from https://en.wikibooks.org/wiki/Floating_Point/Epsilon\n;; I found above example was distracting by putting 6/3 and 2 in the equality check that is why I decided to write up a similar but new example."], :notes ["There is a difference between \"=\" and \"==\". For primitives you definitely want to use \"==\" as \"=\" will result in a cast to the wrapped types for it's arguments.\r\n\r\nThis may not be the case come Clojure 1.3 (see [1])\r\n\r\n[1] http://github.com/clojure/clojure/commit/df8c65a286e90e93972bb69392bc106128427dde" "So what is difference with =? " "'== is defined only for numbers, where '= is general equality. The example showing (== :foo) as true is a bit misleading because (== :foo :foo) produces an exception. Unary == always returns true as an optimization."], :arglists ["x" "x y" "x y & more"], :doc "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/=="}, :clojure.core.async/filter> {:ns "clojure.core.async", :name "filter>", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1047, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["p ch"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/filter>"}, :clojure.core/comp {:added "1.0", :ns "clojure.core", :name "comp", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partial :clojure.core/juxt :clojure.core/every-pred], :line 2549, :examples ["(def negative-quotient (comp - /))\n;; #'user/negative-quotient\n\n(negative-quotient 8 3)  ;;=> -8/3\n\n(def concat-and-reverse (comp (partial apply str) reverse str)) \n;; #'user/concat-and-reverse\n\n(concat-and-reverse \"hello\" \"clojuredocs\")\n;;=> \"scoderujolcolleh\"\n" "((comp str +) 8 8 8)   \n;;=> \"24\"\n" "(map\n   (comp - (partial + 3) (partial * 2))\n       [1 2 3 4])\n;;=>  (-5 -7 -9 -11)" "(filter (comp not zero?) [0 1 0 2 0 3 0 4])\n;;=> (1 2 3 4)" ";; make a struct 'goods'. it assumes that every goods has\n;; its id number and price.\n(defstruct goods :id :price)\n\n;; generate data.\n(def data (map #(struct goods %1 %2)\n\t       (shuffle (range 0 10)) \n               (shuffle\n\t          (into (range 100 500 100)\n\t\t\t(range 100 500 100)))))\n\n(defn comp-goods-price\n  \"a compare function by :price of the struct 'goods.' the sort order \n   is that the lower price is superior to the higher one and if the \n   price is same, the lower id is superior to the higher one.\"\n  [el1 el2]\n  (if (or  (< (:price el1) (:price el2))\n           (and (= (:price el1) (:price el2)) (< (:id el1) (:id el2))))\n    true\n    false))\n\n;; The shuffle will cause your results to differ.\ndata   \n;;=> ({:id 1, :price 300} {:id 6, :price 100} \n;;    {:id 3, :price 100} {:id 4, :price 400}\n;;    {:id 0, :price 300} {:id 2, :price 200} \n;;    {:id 5, :price 200} {:id 8, :price 400})\n\n(sort (comp comp-goods-price) data)\n;;=> ({:id 3, :price 100} {:id 6, :price 100} \n;;    {:id 2, :price 200} {:id 5, :price 200} \n;;    {:id 0, :price 300} {:id 1, :price 300}\n;;    {:id 4, :price 400} {:id 8, :price 400})\n\n(sort-by :price < data) ; compare this with the above.\n;;=> ({:id 6, :price 100} {:id 3, :price 100} \n;;    {:id 2, :price 200} {:id 5, :price 200} \n;;    {:id 1, :price 300} {:id 0, :price 300} \n;;    {:id 4, :price 400} {:id 8, :price 400})\n\n;; Yet another example of 'comp' by PriorityBlockingQueue.\n\n(import [java.util.concurrent PriorityBlockingQueue])\n;; java.util.concurrent.PriorityBlockingQueue\n\n(def pqdata (new PriorityBlockingQueue 8\n\t\t (comp comp-goods-price)))\n;; #'user/pqdata\n\n(doseq [x data] (.add pqdata x))\n;;=> nil\n\n(dotimes [_ 8] (println (.poll pqdata)))\n;;  {:id 3, :price 100}\n;;  {:id 6, :price 100}\n;;  {:id 2, :price 200}\n;;  {:id 5, :price 200}\n;;  {:id 0, :price 300}\n;;  {:id 1, :price 300}\n;;  {:id 4, :price 400}\n;;  {:id 8, :price 400}\n;;=> nil\n" "(def countif (comp count filter))\n#'user/countif\n\n(countif even? [2 3 1 5 4])\n;;=> 2" "; Get 2nd to last element from a list\n( (comp second reverse) '(\"a\" 2 7 \"b\"))   \n;;=> 7" "; We need an example that composes more than just two functions.\n; The following example is an overly complicated reimplementation of 'nth'\n; but it does show the composition of an arbitrary number of functions (rest).\n( #((apply comp first (repeat %2 rest)) %1) [1 2 3 4 5 6] 3 ) \n;;=> 4" "; `comp`-ing maps, filters with a little help from our friend `partial`\n; the following function filters numbers in a `coll` if it is divisible by 3\n; then on that filtered `coll`, multiplies all by 2\n\n; a little helper to find if a number is div by 3 \n; also comp-ed\n\n(def mod3nz? (comp not zero? #(mod % 3)))\n\n; now for that elusive function that muls by 2 after filter those not div by 3\n(def mul-2-nd-3\n  \"Takes a seq of numbers, filters those not divisible by 3 and muls them by 2\"\n  (comp (partial map #(* % 2))\n        (partial filter mod3nz?)))\n\n(mul-2-nd-3 [16 15 30 43]) ;; => (32 86)\n" "; Split a number into sequence of it's digits\n((comp (partial map (comp read-string str)) str) 33)\n;;=> (3 3)" ";; Keywords are used as functions to access data in maps.\n\n(:foo {:foo \"bar\"})\n;;=> \"bar\"\n\n;; With a nested data structure, it is common to use\n;; several keywords in sequence to navigate the hierarchy.\n\n(def my-data {:this {:that {:the-other \"val\"}}})\n;;=> #'user/my-data\n\n(-> my-data :this :that :the-other)\n;;=> \"val\"\n\n;; Since keywords are functions,\n;; they can be 'comp'ed just like any other function.\n\n(def those (comp :the-other :that :this))  ; Note: reverse order\n;;=> #'user/those\n\n(those my-data)\n;;=> \"val\"\n\n;; The composed keyword-sequence can be used with other keywords: -\n\n(def my-data-2\n  {:this {:that {:the-other {:a \"apple\" :b \"banana\"}}}})\n;;=> #'user/my-data-2\n\n(let [a (-> my-data-2 those :a)\n      b (-> my-data-2 those :b)]\n  (str \"These: \" a \", \" b))\n;;=> \"These: apple, banana\"" ";; ((comp func1 func2) data) mean ...\n;; (-> data func2 func1)\n;; so,\n((comp (partial * 3) inc) 1)\n;; means\n(* 3 (inc 1))\n\n;; advanced ...\n\n((comp seq re-seq) #\"(\\w+)=(\\S+)\" \"foo=bar\")\n;; ([\"foo=bar\" \"foo\" \"bar\"])\n(seq (re-seq #\"(\\w+)=(\\S+)\" \"foo=bar\"))\n\n;; * \"#(\\w+)...\" and \"foo=...\" are arguments for #re-seq" ";; comp is the transducer equivalent to thrush \n\n;; An example of using the \"thread-last\" macro to get\n;; the sum of the first 10 even squares.\n(->> (range)\n     (map #(* % %))\n     (filter even?)\n     (take 10)\n     (reduce +))\n;;=> 1140\n\n;; Many the seq functions now produce transducers.\n;; `reduce` does not but has been replaced with `transduce`.\n(transduce \n   (comp\n     (map #(* % %))\n     (filter even?)\n     (take 10))\n   + 0 (range) )\n;;=> 1140" ";;trim will remove the white spaces and return a new string which will be passed ;;to the second function capitalize which will return a new string\n\n((comp clojure.string/capitalize clojure.string/trim) \" london   \")\n;;\"London\"\n" "(def my-car\n  {:name \"audi\"\n   :data {:cc 2990\n          :bhp 350}})\n\n((comp :bhp :data) my-car)\n;;350\n\n;;which is the equivalent of\n\n(:bhp (:data my-car))\n;;350" "(require '[reagent.core :as r])\n\n(def float-parsable? (comp not js/isNaN js/parseFloat))\n(def find-parsable-or-nil \n  (comp first \n        (partial re-find \n                 #\"(\\-?\\d+\\.)?\\d+([eE][-+]?\\d+)?\")))\n\n(defn number-input\n \"HTML input element for number only input\"\n [value]\n [:input\n  {:value @value\n   :type \"text\"\n   :on-change (comp\n               #(when-let [new-value %]\n                 (reset! value new-value))\n               (fn [new-value]\n                (cond\n                 (empty? new-value) \"\"\n                 (float-parsable? new-value) new-value\n                 :otherwise (find-parsable-or-nil new-value)))\n               (fn [target]\n                (.-value target))\n               (fn [event]\n                (.-target event)))}])\n\n(def value (r/atom \"\"))\n\n(defn demo []\n [:div\n  ; Displays NaN when value is \"\", displays a number otherwise.\n  (-> @value js/parseFloat str) [:br]\n  [number-input value]])"], :notes nil, :arglists ["" "f" "f g" "f g & fs"], :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/comp"}, :clojure.core/byte {:added "1.0", :ns "clojure.core", :name "byte", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/byte-array :clojure.core/bytes :clojure.core/short :clojure.core/unchecked-byte], :line 3496, :examples ["user=> (def x (byte-array [(byte 0x43) \n                           (byte 0x6c)\n                           (byte 0x6f)\n                           (byte 0x6a)\n                           (byte 0x75)\n                           (byte 0x72)\n                           (byte 0x65)\n                           (byte 0x21)]))\n#'user/x\n\nuser=> (String. x)\n\"Clojure!\"\n"], :notes nil, :arglists ["x"], :doc "Coerce to byte", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/byte"}, :clojure.core.logic/fne {:ns "clojure.core.logic", :name "fne", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1693, :examples ["(run 10 [q]\n  ((fne [x y]\n        ([[h . t] t]))\n   [1 2 3] q)) ; => ((2 3))\n\n(run 10 [q]\n  ((fne [x y]\n        ([[o? 2 _ 4 5]] (== y o?))\n        ([[1 2 _ . o?]] (== y o?)))\n   [1 2 3 4 5] q))"], :macro true, :notes nil, :arglists ["& rest"], :doc "Define an anonymous goal fn. Supports pattern matching. All\n   patterns will be tried. See conde.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fne"}, :clojure.core.logic/lcons {:ns "clojure.core.logic", :name "lcons", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic/llist], :line 868, :examples ["(run* [q]\n  (fresh [a d]\n    (== [1 2 3 4] (lcons a d))\n    (== q d))) ;; ((2 3 4))"], :notes nil, :arglists ["a d"], :doc "Constructs a sequence a with an improper tail d if d is a logic variable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lcons"}, :clojure.instant/read-instant-calendar {:ns "clojure.instant", :name "read-instant-calendar", :file "clojure/instant.clj", :type "var", :column 1, :see-alsos nil, :line 279, :examples nil, :notes nil, :arglists [], :doc "To read an instant as a java.util.Calendar, bind *data-readers* to a map with\nthis var as the value for the 'inst key.  Calendar preserves the timezone\noffset.", :library-url "https://github.com/clojure/clojure", :href "/clojure.instant/read-instant-calendar"}, :clojure.java.io/as-relative-path {:added "1.2", :ns "clojure.java.io", :name "as-relative-path", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos nil, :line 408, :examples ["(require '[clojure.java.io :as io])\n\n; on windows\nuser> (io/as-relative-path \"this/is\")\n\"this\\\\is\n\nuser> (io/as-relative-path \"c:/code\")\nIllegalArgumentException c:\\code is not a relative path  clojure.java.io/as-relative-path (io.clj:405)"], :notes nil, :tag "java.lang.String", :arglists ["x"], :doc "Take an as-file-able thing and return a string if it is\n   a relative path, else IllegalArgumentException.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/as-relative-path"}, :clojure.core.async/unmix-all* {:ns "clojure.core.async", :name "unmix-all*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unmix-all*"}, :clojure.data/diff {:added "1.3", :ns "clojure.data", :name "diff", :file "clojure/data.clj", :type "function", :column 1, :see-alsos nil, :line 120, :examples ["(use 'clojure.data)\n(def uno {:same \"same\", :different \"one\"})\n(def dos {:same \"same\", :different \"two\", :onlyhere \"whatever\"})\n(diff uno dos)\n=> ({:different \"one\"} {:onlyhere \"whatever\", :different \"two\"} {:same \"same\"})\n;;  {different in uno} {     different or unique in dos       } {same in both}\n(diff {:a 1} {:a 1 :b 2})\n=> (nil {:b 2} {:a 1})\n;; the first contains nothing unique, but only the second contains :b\n;; and both contain :a" "(diff [1 2 3] [5 9 3 2 3 7])              ;;=> [[1 2] [5 9 nil 2 3 7] [nil nil 3]]\n(diff (set [1 2 3]) (set [5 9 3 2 3 7]))  ;;=> [#{1}  #{7 9 5}        #{3 2}]" ";; To invert a  diff  you can re-apply diff to its output and then merge this back with the prior state \n;; This works in almost all cases (with the exception of preserving empty maps) \n\n(defn- seqzip\n  \"returns a sequence of [[ value-left] [value-right]....]  padding with nulls for shorter sequences \"\n  [left right]\n  (loop [list [] a left b right]\n    (if (or (seq a) (seq b))\n      (recur (conj list [(first a) (first b)] ) (rest a) (rest b))\n       list)))\n\n(defn- recursive-diff-merge\n  \" Merge two structures recusively , taking non-nil values from sequences and maps and merging sets\" \n  [part-state original-state]\n  (cond\n    (sequential? part-state) (map (fn [[l r]] (recursive-diff-merge l r)) (seqzip part-state original-state))\n    (map? part-state) (merge-with recursive-diff-merge part-state original-state)\n    (set? part-state) (set/union part-state original-state)\n    (nil? part-state ) original-state\n    :default part-state))\n\n(defn undiff\n  \"returns the state of x after reversing the changes described by a diff against\n   an earlier state (where before and after are the first two elements of the diff)\"\n  [x before after]\n  (let [[a _ _] (clojure.data/diff x after)]\n    (recursive-diff-merge a before)))\n\n;;  examples: \n\n;; Simple data types\n(clojure.data/diff :before :after )\n=> [:before :after nil]\n\n(undiff :after :before :after)\n=> :before\n\n;; Lists \n(clojure.data/diff [1 2 3 4] [1 2 3 5] )\n=> [[nil nil nil 4] [nil nil nil 5] [1 2 3]]\n(undiff [1 2 3 5] [nil nil nil 4] [nil nil nil 5] )\n=> (1 2 3 4)\n\n;; Nested complex data structures; \n(clojure.data/diff {:a 1 :b [1 2 3]    :c {:d 4}}\n                   {:a 2 :b [1 2 3 4]  :c {:d 3 :e 10}})\n=> ({:c {:d 4}, :a 1} {:c {:d 3, :e 10}, :b [nil nil nil 4], :a 2} {:b [1 2 3]})\n\n(undiff {:a 2  :b [1 2 3 4] :c {:d 3 :e 10}} ; State after diff \n        {:c {:d 4}, :a 1}   ; first element of diff against previous state\n        {:c {:d 3, :e 10}, :b [nil nil nil 4], :a 2}) ; second element of diff \n                                                      ; against previous state \n=> {:b [1 2 3], :c {:d 4}, :a 1}\n"], :notes nil, :arglists ["a b"], :doc "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.", :library-url "https://github.com/clojure/clojure", :href "/clojure.data/diff"}, :clojure.core.async/fn-handler {:ns "clojure.core.async", :name "fn-handler", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 34, :examples nil, :notes nil, :arglists ["f" "f blockable"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/fn-handler"}, :clojure.main/skip-if-eol {:ns "clojure.main", :name "skip-if-eol", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 97, :examples nil, :notes nil, :arglists ["s"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/skip-if-eol"}, :clojure.core/with-precision {:added "1.0", :ns "clojure.core", :name "with-precision", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 5026, :examples [";; The \"M\" suffix denotes a BigDecimal instance\n;; http://download.oracle.com/javase/6/docs/api/java/math/BigDecimal.html\n\nuser=> (with-precision 10 (/ 1M 6))\n0.1666666667M\n\nuser=> (.floatValue 0.1666666667M)\n0.16666667\n" ";; This may come in handy for example when you use JDBC to grab data\n;; from a database, and numbers comes in as BigDecimal. Notice the\n;; following ArithmeticException, and solution:\n\n(/ 2M 3M)                    ; => ArithmeticException\n(with-precision 2 (/ 2M 3M)) ; => 0.67M\n\n;; To make this error more searchable, here's what it is, exactly:\n;;\n;; Non-terminating decimal expansion; no exact representable decimal result. \n;; java.lang.ArithmeticException: Non-terminating decimal expansion; no exact\n;; representable decimal result.\n"], :macro true, :notes nil, :arglists ["precision & exprs"], :doc "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-precision"}, :clojure.core/unchecked-long {:added "1.3", :ns "clojure.core", :name "unchecked-long", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/long], :line 3532, :examples ["(unchecked-long 1)\n;;=> 1\n(unchecked-long 1N)\n;;=> 1\n(unchecked-long 1.1)\n;;=> 1\n(unchecked-long 1.9)\n;;=> 1\n(unchecked-long 5/3)\n;;=> 1\n\n(unchecked-long -1)\n;;=> -1\n(unchecked-long -1N)\n;;=> -1\n(unchecked-long -1.1)\n;;=> -1\n(unchecked-long -1.9)\n;;=> -1\n(unchecked-long -5/3)\n;;=> -1\n\n;;;; Note that (unchecked-long) does not range check its argument\n;;;; so integer overflow or rounding may occur. \n;;;; Use (long) if you want to throw an exception in such cases.\n\n(unchecked-long 9223372036854775808N)\n;;=> -9223372036854775808\n(unchecked-long -9223372036854775809N)\n;;=> 9223372036854775807\n\n(long 9223372036854775808N)\n;;=> IllegalArgumentException Value out of range for long: 922337203685477580\n(long -9223372036854775809N)\n;;=> IllegalArgumentException Value out of range for long: -9223372036854775809\n\n(unchecked-long 1.0E18)\n;;=> 1000000000000000000\n(unchecked-long 1.0E19)\n;;=> 9223372036854775807\n(unchecked-long 1.0E20)\n;;=> 9223372036854775807\n\n(long 1.0E18)\n;;=> 1000000000000000000\n(long 1.0E19)\n;;=> IllegalArgumentException Value out of range for long: 1.0E19\n(long 1.0E20)\n;;=> IllegalArgumentException Value out of range for long: 1.0E20"], :notes nil, :arglists ["x"], :doc "Coerce to long. Subject to rounding or truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-long"}, :clojure.spec.alpha/* {:ns "clojure.spec.alpha", :name "*", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 586, :examples nil, :macro true, :notes nil, :arglists ["pred-form"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*"}, :clojure.core/mapcat {:added "1.0", :ns "clojure.core", :name "mapcat", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map :clojure.core/concat], :line 2775, :examples ["user=> (mapcat reverse [[3 2 1 0] [6 5 4] [9 8 7]])\n(0 1 2 3 4 5 6 7 8 9)\n" "user=> (mapcat (fn [[k v]] \n                 (for [[k2 v2] v] \n                   (concat [k k2] v2)))\n         '{:a {:x (1 2) :y (3 4)}\n           :b {:x (1 2) :z (5 6)}})\n\n((:a :x 1 2) (:a :y 3 4) (:b :x 1 2) (:b :z 5 6))" "user=> (require '[clojure.string :as cs])\nnil\n\n;; Suppose you have a fn in a `map` that itself returns\n;; multiple values.\nuser=> (map #(cs/split % #\"\\d\") [\"aa1bb\" \"cc2dd\" \"ee3ff\"])\n([\"aa\" \"bb\"] [\"cc\" \"dd\"] [\"ee\" \"ff\"])\n\n;; Now, if you want to concat them all together, you *could*\n;; do this:\nuser=> (apply concat (map #(cs/split % #\"\\d\") [\"aa1bb\" \"cc2dd\" \"ee3ff\"]))\n(\"aa\" \"bb\" \"cc\" \"dd\" \"ee\" \"ff\")\n\n;; But `mapcat` can save you a step:\nuser=> (mapcat #(cs/split % #\"\\d\") [\"aa1bb\" \"cc2dd\" \"ee3ff\"])\n(\"aa\" \"bb\" \"cc\" \"dd\" \"ee\" \"ff\")\n" ";; Suppose you've got a function that takes a value\n;; and returns a list of things from it, for example:\n(defn f1\n  [n]\n  [(- n 1) n (+ n 1)])\n\n(f1 1)\n;=> [0 1 2]\n\n;; Perhaps you'd like to map it onto each item in a collection:\n(map f1 [1 2 3])\n;=> ([0 1 2] [1 2 3] [2 3 4])\n\n;; But suppose you wanted them all concatenated? You could do this:\n(apply concat (map f1 [1 2 3]))\n;=> (0 1 2 1 2 3 2 3 4)\n\n;; Or you could get the same thing with `mapcat`:\n(mapcat f1 [1 2 3])\n;=> (0 1 2 1 2 3 2 3 4)\n" "; Flatten a map, consing keys on to each nested vector \n(mapcat (fn [[k vs]] (map (partial cons k) vs)) {:foo [[1 2] [3 2]] :bar [[3 1]]})\n;=> ((:foo 1 2) (:foo 3 2) (:bar 3 1))\n" ";; A very useful feature of mapcat is that it allows function f to produce no result\n;; by returning nil or an empty collection:\n(mapcat #(remove even? %) [[1 2] [2 2] [2 3]])\n;; => (1 3)\n\n;; note that applying (remove even?) to [2 2] produced () which was \"eaten\"\n;; and ignored by mapcat." ";; map vs. mapcat -\n;; For duplicating each item in a sequence\n\n;; Using map:\n(map #(repeat 2 %) [1 2])\n;; => ((1 1) (2 2))\n\n;; Using mapcat:\n(mapcat #(repeat 2 %) [1 2])\n;; => (1 1 2 2)\n"], :notes ["<pre>\n;; mapcat always evaluates the first 4 arguments.\n(def a (mapcat range (map #(do (print \".\") %) (into () (range 10)))))\n;; ....\n\n;; it can be solved avoiding 'apply' to handle varargs\n(defn mapcat* [f & colls]\n  (letfn [(step [colls]\n            (lazy-seq\n              (when-first [c colls]\n                (concat c (step (rest colls))))))]\n    (step (apply map f colls))))\n\n(def a (mapcat* range (map #(do (print \".\") %) (into () (range 10)))))\n;; nothing prints\n</pre>"], :arglists ["f" "f & colls"], :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/mapcat"}, :clojure.core/set-agent-send-executor! {:added "1.5", :ns "clojure.core", :name "set-agent-send-executor!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 2081, :examples nil, :notes nil, :arglists ["executor"], :doc "Sets the ExecutorService to be used by send", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set-agent-send-executor!"}, :clojure.core/to-array {:added "1.0", :ns "clojure.core", :name "to-array", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/alength :clojure.core/char-array :clojure.core/int-array :clojure.core/long-array :clojure.core/into-array :clojure.core/make-array :clojure.core/to-array-2d], :line 338, :examples ["user=> (to-array [1 2 3])\n#<Object[] [Ljava.lang.Object;@b2bb14>" "(def hello (to-array \"Hello World!\"))\n\n(aget hello 1)\n;; => \\e\n\n(aset hello 1 \\b) ;;Mutability! Watch out!\n;; => \\b\n\n(dotimes [n (alength hello)] (print (aget hello n)))\n;; => Hbllo World!\n\n;; Calling `to-array` on array returns the original, not a copy\n(identical? (to-array hello) hello)\n;; => true"], :notes nil, :tag "[Ljava.lang.Object;", :arglists ["coll"], :doc "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/to-array"}, :clojure.core/cycle {:added "1.0", :ns "clojure.core", :name "cycle", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/lazy-seq :clojure.core/map], :line 2971, :examples ["user=> (take 5 (cycle [\"a\" \"b\"]))\n(\"a\" \"b\" \"a\" \"b\" \"a\")\n\nuser=> (take 10 (cycle (range 0 3)))\n(0 1 2 0 1 2 0 1 2 0)\n\n" ";; Typically map works through its set of collections\n;; until any one of the collections is consumed.\n;; 'cycle' can be used to repeat the shorter collections\n;; until the longest collection is consumed.\n(mapv #(vector %2 %1) (cycle [1 2 3 4]) [:a :b :c :d :e :f :g :h :i :j :k :l])\n;;=> [[:a 1] [:b 2] [:c 3] [:d 4] [:e 1] [:f 2] [:g 3] [:h 4] [:i 1] [:j 2] [:k 3] [:l 4]]"], :notes nil, :arglists ["coll"], :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cycle"}, :clojure.reflect/reflect {:added "1.3", :ns "clojure.reflect", :name "reflect", :file "clojure/reflect.clj", :type "function", :column 1, :see-alsos [:clojure.pprint/print-table :clojure.reflect/type-reflect], :line 115, :examples ["(use 'clojure.reflect 'clojure.pprint)\n;;=> nil\n(def r (reflect *in*))\n;;=> #'user/r\n(count (:members r))\n;;=> 9\n(pprint (map class (:members r)))\n;;  (clojure.reflect.Constructor\n;;   clojure.reflect.Method\n;;   clojure.reflect.Field\n;;   clojure.reflect.Field\n;;   clojure.reflect.Method\n;;   clojure.reflect.Method\n;;   clojure.reflect.Method\n;;   clojure.reflect.Method\n;;   clojure.reflect.Field)\n;;=> nil\n(pprint r)\n;;   {:bases #{java.io.PushbackReader},\n;;    :flags #{:public},\n;;    :members\n;;     #{{:name clojure.lang.LineNumberingPushbackReader,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [java.io.Reader],\n;;        :exception-types [],\n;;        :flags #{:public}}\n;;       {:name read,\n;;        :return-type int,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [],\n;;        :exception-types [java.io.IOException],\n;;        :flags #{:public}}\n;;       {:name _atLineStart,\n;;        :type boolean,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :flags #{:private}}\n;;       {:name newline,\n;;        :type int,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :flags #{:private :static :final}}\n;;       {:name unread,\n;;        :return-type void,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [int],\n;;        :exception-types [java.io.IOException],\n;;        :flags #{:public}}\n;;       {:name readLine,\n;;        :return-type java.lang.String,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [],\n;;        :exception-types [java.io.IOException],\n;;        :flags #{:public}}\n;;       {:name atLineStart,\n;;        :return-type boolean,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [],\n;;        :exception-types [],\n;;        :flags #{:public}}\n;;       {:name getLineNumber,\n;;        :return-type int,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :parameter-types [],\n;;        :exception-types [],\n;;        :flags #{:public}}\n;;       {:name _prev,\n;;        :type boolean,\n;;        :declaring-class clojure.lang.LineNumberingPushbackReader,\n;;        :flags #{:private}}}}\n;;=> nil\n" "(require '[clojure.reflect :as cr])\n(require '[clojure.pprint :as pp])\n\n;; Here we have a simple function that prints the\n;; important bits of the class definition in a table.\n(->> String \n     cr/reflect \n     :members \n     pp/print-table))\n;;=> [produces a large table the next example filters it down.\n\n;; In order to reduce the rows to just :public methods a filter can be used.\n(->> String \n     cr/reflect \n     :members \n     (filter #(contains? (:flags %) :public)) \n     pp/print-table)\n;;=> |                  :name |     :return-type | :declaring-class | <etc.> \n;;   |------------------------+------------------+------------------+------->\n;;   |             replaceAll | java.lang.String | java.lang.String | \n;;   | CASE_INSENSITIVE_ORDER |                  | java.lang.String | \n;;   |         codePointCount |              int | java.lang.String |\n;;   |               getChars |             void | java.lang.String | \n;; etc.\n\n;; Print methods that contain \"to\", as a way of code completion.\n;; Combine with above example ``#(contains? (:flags %) :public)`` to get \n;; matching callable methods (public & with \"to\")\n(->> String \n     cr/reflect \n     :members \n     (filter #(.contains (str (:name %)) \"to\"))\n     pp/print-table)\n\n;; => |       :name |     :return-type | :declaring-class | <etc.>  \n;;    |-------------+------------------+------------------+---\n;;    |    toString | java.lang.String | java.lang.String |   \n;;    | toLowerCase | java.lang.String | java.lang.String |   \n;;    | toUpperCase | java.lang.String | java.lang.String |   \n;;    | toUpperCase | java.lang.String | java.lang.String | \n;;    | toCharArray |           char<> | java.lang.String | \n;;    | toLowerCase | java.lang.String | java.lang.String | " "(require '[clojure.reflect :as cr])\n(import  '(clojure.reflect.JavaReflector))\n\n;; Let us see what is available in the JavaReflector\n(->> clojure.reflect.JavaReflector \n     cr/reflect\n     :members\n     (sort-by :name)\n     (pp/print-table [:name :flags :parameter-types])\n;; |                         :name |                    :flags |   :parameter-types |\n;; |-------------------------------+---------------------------+--------------------|\n;; |             __cached_class__0 |       #{:private :static} |                    |\n;; |                   classloader |         #{:public :final} |                    |\n;; | clojure.reflect.JavaReflector |                #{:public} | [java.lang.Object] |\n;; |                      const__0 | #{:public :static :final} |                    |\n;; |                      const__1 | #{:public :static :final} |                    |\n;; |                     const__10 | #{:public :static :final} |                    |\n;; |                      const__5 | #{:public :static :final} |                    |\n;; |                      const__7 | #{:public :static :final} |                    |\n;; |                      const__9 | #{:public :static :final} |                    |\n;; |                    do_reflect |                #{:public} | [java.lang.Object] |\n;; |                      getBasis |        #{:public :static} |                 [] |\n;;=> nil"], :notes nil, :arglists ["obj & options"], :doc "Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. ", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/reflect"}, :clojure.core/with-bindings {:added "1.1", :ns "clojure.core", :name "with-bindings", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-bindings* :clojure.core/with-local-vars :clojure.core/binding :clojure.core/with-redefs], :line 1978, :examples ["(def ^:dynamic x 1)\n;;=> #'user/x\n\nx\n;;=> 1\n\n(with-bindings {#'x 2}\n   x)\n;;=> 2"], :macro true, :notes nil, :arglists ["binding-map & body"], :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-bindings"}, :clojure.core.logic/trace-lvar {:ns "clojure.core.logic", :name "trace-lvar", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1302, :examples nil, :notes nil, :arglists ["a lvar"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/trace-lvar"}, :clojure.template/apply-template {:ns "clojure.template", :name "apply-template", :file "clojure/template.clj", :type "function", :column 1, :see-alsos [:clojure.template/do-template], :line 30, :examples ["user=> (apply-template '[a b c d e] '[d a b e c e b a d] '(1 2 3 4 5))\n[4 1 2 5 3 5 2 1 4]  \n\nuser=> (apply-template '[a b c d e] '[d a b e c e b a d] '(1 [2 3] [4 5]))\n[d 1 [2 3] e [4 5] e [2 3] 1 d]"], :notes nil, :arglists ["argv expr values"], :doc "For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)", :library-url "https://github.com/clojure/clojure", :href "/clojure.template/apply-template"}, :clojure.walk/stringify-keys {:added "1.1", :ns "clojure.walk", :name "stringify-keys", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/keywordize-keys], :line 101, :examples ["(use 'clojure.walk)\n\n(stringify-keys {:a 1 :b 2})\n;=> {\"a\" 1, \"b\" 2}" "(use 'clojure.walk)\n\n(stringify-keys {:a 1 :b {:c {:d 2}}})\n;=> {\"a\" 1, \"b\" {\"c\" {\"d\" 2}}}"], :notes nil, :arglists ["m"], :doc "Recursively transforms all map keys from keywords to strings.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/stringify-keys"}, :clojure.core/unquote-splicing {:ns "clojure.core", :name "unquote-splicing", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/unquote], :line 14, :examples ["user=> (let [x `(2 3)] \n         `(1 ~x))\n(1 (2 3))\n\nuser=> (let [x `(2 3)] \n         `(1 ~@x)) \n(1 2 3)\n" "user=> `(1 2 ~(list 3 4))\n\n(1 2 (3 4))\n\nuser=> `(1 2 ~@(list 3 4))\n\n(1 2 3 4)\n\n; borrowed from StackOverflow: \n; http://stackoverflow.com/questions/4571042/can-someone-explain-clojures-unquote-splice-in-simple-terms"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unquote-splicing"}, :clojure.core/biginteger {:added "1.0", :ns "clojure.core", :name "biginteger", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bigint], :line 3625, :examples ["user=> (def x (biginteger 19931029))\n#'user/x\nuser=> (class x)\njava.math.BigInteger\n\n\n\n" ";; There is a difference between `BigInt` and `BigInteger`. The first is from\n;; Clojure and should be better for performace, because less unboxing is\n;; necessary. The second is from Java and has more functionality.\n;; https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html\n\n(type 123N)\n;; => clojure.lang.BigInt\n\n(type (bigint 123))\n;; => clojure.lang.BigInt\n\n(type (biginteger 123))\n;; => java.math.BigInteger\n\n(.modInverse (bigint 123) (bigint 4))\n;; IllegalArgumentException No matching method found: modInverse for class\n;; clojure.lang.BigInt\n\n(.modInverse (biginteger 123) (biginteger 4))\n;; => 3" "; It also works for strings\n(biginteger \"12345\") => 12345   ; java.math.BigInteger\n"], :notes nil, :tag "java.math.BigInteger", :arglists ["x"], :doc "Coerce to BigInteger", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/biginteger"}, :clojure.core/some? {:added "1.6", :ns "clojure.core", :name "some?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/nil? :clojure.core/some], :line 531, :examples ["user> (some? nil)\n;; => false\n\nuser> (some? 42)\n;; => true\nuser> (some? false)\n;; => true\nuser> (some? [])\n;; => true\nuser> (some? {})\n;; => true\nuser> (some? '())\n;; => true" ";; equivalent to implementing not-nil?\n(some? :kw)\n;; => true\n(not (nil? :kw))\n;; => true\n\n(some? nil)\n;; => false\n(not (nil? nil))\n;; => false"], :notes nil, :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true if x is not nil, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/some_q"}, :clojure.java.shell/sh {:added "1.2", :ns "clojure.java.shell", :name "sh", :file "clojure/java/shell.clj", :type "function", :column 1, :see-alsos [:clojure.java.shell/with-sh-dir :clojure.java.shell/with-sh-env :clojure.core/future], :line 79, :examples ["user=> (use '[clojure.java.shell :only [sh]])\n\n;; Note: The actual output you see from a command like this will look messier.\n;; The output below has had all newline characters replaced with line\n;; breaks.  You would see a big long string with \\n characters in the middle.\nuser=> (sh \"ls\" \"-aul\")\n\n{:exit 0, \n :out \"total 64\ndrwxr-xr-x  11 zkim  staff    374 Jul  5 13:21 .\ndrwxr-xr-x  25 zkim  staff    850 Jul  5 13:02 ..\ndrwxr-xr-x  12 zkim  staff    408 Jul  5 13:02 .git\n-rw-r--r--   1 zkim  staff     13 Jul  5 13:02 .gitignore\n-rw-r--r--   1 zkim  staff  12638 Jul  5 13:02 LICENSE.html\n-rw-r--r--   1 zkim  staff   4092 Jul  5 13:02 README.md\ndrwxr-xr-x   2 zkim  staff     68 Jul  5 13:15 classes\ndrwxr-xr-x   5 zkim  staff    170 Jul  5 13:15 lib\n-rw-r--r--@  1 zkim  staff   3396 Jul  5 13:03 pom.xml\n-rw-r--r--@  1 zkim  staff    367 Jul  5 13:15 project.clj\ndrwxr-xr-x   4 zkim  staff    136 Jul  5 13:15 src\n\", :err \"\"}" "user=> (use '[clojure.java.shell :only [sh]])\n\nuser=> (println (:out (sh \"cowsay\" \"Printing a command-line output\")))\n\n _________________________________ \n< Printing a command-line output. >\n --------------------------------- \n        \\   ^__^\n         \\  (oo)\\_______\n            (__)\\       )\\/\\\n                ||----w |\n                ||     ||\n\nnil" "user=> (use '[clojure.java.shell :only [sh]])\nnil\n\n;; note that the options, like :in, have to go at the end of arglist\n;; advantage of piping-in thru stdin is less need for quoting/escaping\nuser=> (println (:out (sh \"cat\" \"-\" :in \"Printing input from stdin with funny chars like ' \\\" $@ & \")))\nPrinting input from stdin with funny chars like ' \" $@ & \nnil" ";; sh is implemented using Clojure futures.  See examples for 'future'\n;; for discussion of an undesirable 1-minute wait that can occur before\n;; your standalone Clojure program exits if you do not use shutdown-agents." "(sh \"pwd\" :dir \"/home/ics/icsdev\")\n{:exit 0, :out \"/home/ics/icsdev\\n\", :err \"\"}" "(require '[clojure.java.shell :as shell])\n(shell/sh \"sh\" \"-c\" \"cd /etc; pwd\")\n{:exit 0, :out \"/etc\\n\", :err \"\"}" ";; note that you have to split you script by whitespace \n;; that was confusing for me \n;; for example script: \n;; \"terraform plan -var param1=value1 -var param2=value2 -var-file=/etc/var.tfvars\"\n\n(shell/sh \"terraform\" \"plan\" \"-var\" \"param=value\" \"-var\" \"param2=value2\" \"-var-file=/etc/var.tfvars\")" ";; feed the sh with environment variables\n;; (note that $HELLO in our command line wouldn't work since we act as the shell here)\n\n(require '[clojure.java.shell :as shell])\n(shell/sh \"printenv\" \"HELLO\" :env {\"HELLO\" \"Hello, World!\"})\n{:exit 0, :out \"Hello, World!\\n\", :err \"\"}\n\n" ";; override environment variables\n;; BAD EXAMPLE since i guess lein uses a lot of env vars for coordination\n;; but anyway\n\n(require '[clojure.java.shell :as shell])\n\n(sh/sh \"lein\" \"compile\")\n{:exit 0,\n :out\n \"WARNING: You have $CLASSPATH set, probably by accident.\n  It is strongly recommended to unset this before proceeding.\",\n :err \"\"}\n\n;; note that\n(sh/sh \"lein\" \"compile\" :env {})\n;; will make lein quite confused.\n\n;; we better modify the current env:\n\n(let [current-env (into {} (System/getenv))]\n  (sh/sh \"lein\" \"compile\" :env (dissoc current-env \"CLASSPATH\"))\n{:exit 0, :out \"\", :err \"\"}\n\n\n;; (into {} ...) is needed because System/getenv returns a map of type\n;; java.util.Collections$UnmodifiableMap"], :notes ["It's worth noting that sh begins interpreting arguments starting with the first non-string (not just keywords!) as key-value pairs, as in the example above with pwd.  This means that even if an argument's type has a trivial conversion to a string, such as an integer or boolean, it must be stringified.  If not, it'll be passed as an argument to hash-map, and you might see an IllegalArgumentException if there are an odd number of arguments beginning with the first non-string."], :arglists ["& args"], :doc "Passes the given strings to Runtime.exec() to launch a sub-process.\n\n  Options are\n\n  :in      may be given followed by any legal input source for\n           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],\n           or String, to be fed to the sub-process's stdin.\n  :in-enc  option may be given followed by a String, used as a character\n           encoding name (for example \"UTF-8\" or \"ISO-8859-1\") to\n           convert the input string specified by the :in option to the\n           sub-process's stdin.  Defaults to UTF-8.\n           If the :in option provides a byte array, then the bytes are passed\n           unencoded, and this option is ignored.\n  :out-enc option may be given followed by :bytes or a String. If a\n           String is given, it will be used as a character encoding\n           name (for example \"UTF-8\" or \"ISO-8859-1\") to convert\n           the sub-process's stdout to a String which is returned.\n           If :bytes is given, the sub-process's stdout will be stored\n           in a byte array and returned.  Defaults to UTF-8.\n  :env     override the process env with a map (or the underlying Java\n           String[] if you are a masochist).\n  :dir     override the process dir with a String or java.io.File.\n\n  You can bind :env or :dir for multiple operations using with-sh-env\n  and with-sh-dir.\n\n  sh returns a map of\n    :exit => sub-process's exit code\n    :out  => sub-process's stdout (as byte[] or String)\n    :err  => sub-process's stderr (String via platform default encoding)", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.shell/sh"}, :clojure.repl/set-break-handler! {:ns "clojure.repl", :name "set-break-handler!", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 277, :examples nil, :notes nil, :arglists ["" "f"], :doc "Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/set-break-handler!"}, :clojure.core/bigdec {:added "1.0", :ns "clojure.core", :name "bigdec", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/decimal? :clojure.core/with-precision], :line 3639, :examples ["user=> (bigdec 3.0)\n3.0M\n\nuser=> (bigdec 5)\n5M\n\nuser=> (bigdec -1)\n-1M\n\nuser=> (bigdec -1.0)\n-1.0M\n\n" "; It also works for strings:\n(bigdec \"123.45\") => 123.45M\n"], :notes nil, :tag "java.math.BigDecimal", :arglists ["x"], :doc "Coerce to BigDecimal", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bigdec"}, :clojure.core.logic/!= {:ns "clojure.core.logic", :name "!=", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2458, :examples ["(!= 1 2) ; => true"], :notes nil, :arglists ["u v"], :doc "Disequality constraint. Ensures that u and v will never\n   unify. u and v can be complex terms.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/!="}, :clojure.core.logic/-inc {:ns "clojure.core.logic", :name "-inc", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1077, :examples nil, :macro true, :notes nil, :arglists ["& rest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-inc"}, :clojure.core/future {:added "1.1", :ns "clojure.core", :name "future", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/future-cancel :clojure.core/shutdown-agents :clojure.core/promise :clojure.core/realized? :clojure.core/delay :clojure.core/future? :clojure.core/future-call :clojure.core/future-done? :clojure.core/locking], :line 6910, :examples [";; A future's calculation is started here and it runs in another thread\nuser=> (def f (future (Thread/sleep 10000) (println \"done\") 100))\n#'user/f\n;;if you wait 10 seconds before dereferencing it you'll see \"done\"\n\n;; When you dereference it you will block until the result is available.\nuser=> @f\ndone\n100\n\n;; Dereferencing again will return the already calculated value.\n=> @f\n100\n" ";; save the example in a script (e.g. test-future.clj) then run it in the console\n;;\n;; > clojure test-future.clj\n\n(println \"[Main] calculate the answer to life the universe and everything\")\n\n;; Used Thread/sleep to simulate long running process\n(def what-is-the-answer-to-life\n    (future \n        (println \"[Future] started computation\")\n        (Thread/sleep 3000) ;; running for 3 seconds\n        (println \"[Future] completed computation\")\n        42))\n        \n(println \"[Main] created future\")\n\n(Thread/sleep 1000)\n(println \"[Main] do other things while waiting for the answer\")\n(println \"[Main] get the answer\")\n(println \"[Main] the result\" @what-is-the-answer-to-life)\n(shutdown-agents)\n\n\n;; You may get something like this\n;;\n;; [Main] calculate the answer to life, the universe and everything\n;; [Future] started computation\n;; [Main] created future\n;; [Main] do other things while waiting for the answer\n;; [Main] get the answer\n;; [Future] completed computation\n;; [Main] the result 42\n\n\n;; Note: If you leave out the call to (shutdown-agents), the program\n;; will on most (all?) OS/JVM combinations \"hang\" for 1 minute before\n;; the process exits.  It is waiting for a thread created by the\n;; future call to be shut down.  shutdown-agents will shut them down\n;; immediately, or (System/exit <exit-status>) will exit immediately\n;; without waiting for them to shut down.\n\n;; This wait occurs even if you use futures indirectly through some other Clojure\n;; functions that use them internally, such as pmap or clojure.java.shell/sh\n\n;; http://dev.clojure.org/jira/browse/CLJ-124 is a ticket opened against Clojure,\n;; as this 1-minute wait is not considered desirable behavior." ";; Futures will not raise their exceptions...\n=> (def my-future (future (/ 1 0))\n\n;; ...until dereferenced!\n=> @my-future\nArithmeticException Divide by zero  clojure.lang.Numbers.divide"], :macro true, :notes nil, :arglists ["& body"], :doc "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future"}, :clojure.core/pop! {:added "1.1", :ns "clojure.core", :name "pop!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc! :clojure.core/dissoc!], :line 3384, :examples [";; Note how we always use the return value of pop! in these examples\n;; for all future modifications, rather than (incorrectly) ignoring the return\n;; value and continuing to modify the original transient set.  See examples for\n;; assoc! and dissoc! for more discussion and examples of this.\n\nuser=> (def foo (transient [1 2 3]))\n#'user/foo\nuser=> (count foo)\n3\nuser=> (def foo (pop! foo))\n#'user/foo\nuser=> foo\n#<TransientVector clojure.lang.PersistentVector$TransientVector@1638fff7>\nuser=> (count foo)\n2\nuser=> (def foo (pop! foo))\n#'user/foo\nuser=> (count foo)\n1\nuser=> (def foo (persistent! foo))\n#'user/foo\nuser=> (count foo)\n1\nuser=> foo\n[1]\n"], :notes nil, :arglists ["coll"], :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pop!"}, :clojure.repl/demunge {:added "1.3", :ns "clojure.repl", :name "demunge", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 208, :examples ["user=> (-> + class str demunge)\n\"class clojure.core/+\""], :notes nil, :arglists ["fn-name"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/demunge"}, :clojure.core.logic/-featurec {:ns "clojure.core.logic", :name "-featurec", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2549, :examples nil, :notes nil, :arglists ["x fs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-featurec"}, :clojure.core.logic.fd/domain {:ns "clojure.core.logic.fd", :name "domain", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 155, :examples nil, :notes nil, :arglists ["& args"], :doc "Construct a domain for assignment to a var. Arguments should \n   be integers given in sorted order. domains may be more efficient \n   than intervals when only a few values are possible.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/domain"}, :clojure.core/*suppress-read* {:ns "clojure.core", :name "*suppress-read*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*suppress-read*"}, :clojure.core.logic/normalize-store {:ns "clojure.core.logic", :name "normalize-store", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 2407, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/normalize-store"}, :clojure.core/into {:added "1.0", :ns "clojure.core", :name "into", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/conj :clojure.core/concat], :line 6807, :examples ["; Maps can be constructed from a sequence of 2-vectors or a sequence \n; of maps\nuser=> (into (sorted-map) [ [:a 1] [:c 3] [:b 2] ] )\n{:a 1, :b 2, :c 3}\nuser=> (into (sorted-map) [ {:a 1} {:c 3} {:b 2} ] )\n{:a 1, :b 2, :c 3}\n\n; When maps are the input source, they convert into an unordered sequence \n; of key-value pairs, encoded as 2-vectors\nuser=> (into [] {1 2, 3 4})\n[[1 2] [3 4]]\n" "; Items are conj'ed one at a time, which puts them at the head of \n; the destination list\nuser=> (into () '(1 2 3))\n(3 2 1)\n\n; This does not happen for a vector, however, due to the behavior of conj:\nuser=> (into [1 2 3] '(4 5 6))\n[1 2 3 4 5 6]\n" "(defn test-key-inclusion-cols\n  \"return all values in column1 that aren't in column2\"\n  [column1 column2]\n  (filter (complement (into #{} column2)) column1))\n" "; Change from one type of map to another\nuser=> (into (sorted-map) {:b 2 :c 3 :a 1})\n{:a 1, :b 2, :c 3}" "; Convert a nested ordering map to hash-map (or another)\nuser=> (use 'flatland.ordered.map)\nuser=> (def ord-map (ordered-map :a \"a\" :b \"b\" :c {:d \"d\" :e \"e\"}))\nuser=> ord-map\n#ordered/map ([:a \"a\"] [:b \"b\"] [:c {:d \"d\", :e \"e\"}]) \n\nuser=> (use 'clojure.walk)\nuser=> (defn disorder [ordering-map map-fn] \n  (postwalk #(if (map? %) (into map-fn %) %) ordering-map))\n\nuser=> (disorder ord-map {})\n{:a \"a\", :b \"b\", :c {:d \"d\", :e \"e\"}}" ";impl apply merge\nuser=> (into {:x 4} [{:a 1} {:b 2} {:c 3}])\n\n{:x 4, :a 1, :b 2, :c 3}" ";; How do we use a transducer?\n\n; Define the transducer with `comp` but in `->` order:\n(def xform (comp (map #(+ 2 %))\n                 (filter odd?)))\n; adds 2, then omits if result is even.\n\n(into [-1 -2] xform (range 10))\n; => [-1 -2 3 5 7 9 11]\n\n\n; Alternatively, using `transduce` directly:\n(transduce xform conj [-1 -2] (range 10))\n; => [-1 -2 3 5 7 9 11]\n\n; Alternatively, using reduce and explicitly calling `map` and `filter`:\n(reduce conj [-1 -2] (->> (range 10)\n                          (map #(+ 2 %))\n                          (filter odd?)))\n; => [-1 -2 3 5 7 9 11]\n\n\n;; Let's benchmark, using Criterium (https://github.com/hugoduncan/criterium)\n(require '[criterium.core :refer [quick-bench]])\n(quick-bench (into [-1 -2] xform (range 1000000)))\n;   Execution time lower quantile : 54.368948 ms ( 2.5%)\n;   Execution time upper quantile : 55.976303 ms (97.5%)\n\n(quick-bench (transduce xform conj [-1 -2] (range 1000000)))\n;   Execution time lower quantile : 77.738505 ms ( 2.5%)\n;   Execution time upper quantile : 87.088016 ms (97.5%): 1.5x slower than into\n\n(quick-bench (reduce conj [-1 -2] (->> (range 1000000) \n                                       (map #(+ 2 %))\n                                       (filter odd?))))\n;   Execution time lower quantile : 92.607522 ms ( 2.5%)\n;   Execution time upper quantile : 100.426780 ms (97.5%): 1.8x slower than into" ";; Interesting case you can't directly convert list or sequence into map (due performance reasons). One should use vector instead.\n\n;; This is ok:\n(into {} [[:a \"a\"] [:b \"b\"]])\n;;=> {:a \"a\", :b \"b\"}\n\n;; But this isn't:\n(into {} ['(:a \"a\") '(:b \"b\")])\n;;=> ClassCastException clojure.lang.Keyword cannot be cast to java.util.Map$Entry clojure.lang.ATransientMap.conj (ATransientMap.java:44)" ";; merging two arrays using the transducer `cat`\n(into [] cat [[1 2 3 ] [4 5 6 ]])\n;=> [1 2 3 4 5 6]\n\n(into '() cat [[1 2 3 ] [4 5 6 ]])\n;=> (6 5 4 3 2 1)\n\n(into '() [1 2 3 4 5 6])\n;=> (6 5 4 3 2 1)"], :notes nil, :arglists ["" "to" "to from" "to xform from"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/into"}, :clojure.core/map? {:added "1.0", :ns "clojure.core", :name "map?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/hash-map :clojure.core/set? :clojure.core/vector?], :line 167, :examples ["(map? {:a 1 :b 2 :c 3})\n;;=> true\n\n(map? (hash-map :a 1 :b 2))\n;;=> true\n\n(map? (sorted-map :a 1 :b 2))\n;;=> true\n\n(map? (array-map :a 1 :b 2))\n;;=> true\n\n(map? '(1 2 3))\n;;=> false\n\n(map? #{:a :b :c})\n;;=> false" "\"Note that Records also implement `clojure.lang.IPersistentMap`:\"\n\n(defrecord XRec [])\n(map? (->XRec))\n;; => true"], :notes nil, :arglists ["x"], :doc "Return true if x implements IPersistentMap", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/map_q"}, :clojure.reflect/->Constructor {:ns "clojure.reflect", :name "->Constructor", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 109, :examples nil, :notes nil, :arglists ["name declaring-class parameter-types exception-types flags"], :doc "Positional factory function for class clojure.reflect.Constructor.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/->Constructor"}, :clojure.core/defstruct {:added "1.0", :ns "clojure.core", :name "defstruct", :file "clojure/core.clj", :static true, :type "macro", :column 1, :see-alsos [:clojure.core/struct :clojure.core/create-struct :clojure.core/defrecord :clojure.core/deftype :clojure.core/defprotocol], :line 4011, :examples ["user=> (defstruct person :name :age :height)\n#'user/person\n\nuser=> (struct person \"george\" 22 115)\n{:name \"george\", :age 22, :height 115}"], :macro true, :notes ["Structs are obsolete.  Use records instead.  See `defrecord`." "Are structs obsolete ? Or will become obsolete ? The docs for 'defrecord' have 'Alpha - Subject To Change' ?" "The doc string for defrecord has been changed in Clojure 1.6 to remove the 'alpha' designation, along with many other Clojure functions: https://github.com/clojure/clojure/commit/93d13d0c0671130b329863570080c72799563ac7"], :arglists ["name & keys"], :doc "Same as (def name (create-struct keys...))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defstruct"}, :clojure.spec.alpha/rep-impl {:ns "clojure.spec.alpha", :name "rep-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1356, :examples nil, :notes nil, :arglists ["form p"], :doc "Do not call this directly, use '*'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/rep-impl"}, :clojure.core.logic/lvar? {:ns "clojure.core.logic", :name "lvar?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 726, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lvar_q"}, :clojure.core/flush {:added "1.0", :ns "clojure.core", :name "flush", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3697, :examples nil, :notes nil, :arglists [""], :doc "Flushes the output stream that is the current value of\n  *out*", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/flush"}, :clojure.set/difference {:added "1.0", :ns "clojure.set", :name "difference", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/union :clojure.set/intersection :clojure.set/superset? :clojure.set/project :clojure.core/disj], :line 49, :examples ["user=> (difference #{1 2 3})\n#{1 2 3}\nuser=> (difference #{1 2} #{2 3})\n#{1}\nuser=> (difference #{1 2 3} #{1} #{1 4} #{3})\n#{2}" "user=> (difference (set (keys {:1 1 :2 2 :3 3})) (set (keys {:1 1 :2 2})))\n#{:3}\nuser=> (difference (set (keys {:1 1 :2 2})) (set (keys {:1 1 :2 2 :3 3})))\n#{}" "user=> (difference #{:a :b :c :d} (difference #{:a :b :c :d} #{:c :e :a :f :d}))\n#{:a :c :d}" ";; Advice: Do not call difference with non-set arguments.  If you are\n;; concerned that you may be unintentionally doing so, and want an\n;; exception to be thrown if you do, consider using the library\n;; funjible (https://github.com/jafingerhut/funjible) which provides\n;; its own definition of difference that is identical to Clojure's,\n;; except it checks the types of its arguments.\n\n;; difference might or might not return what you expect if you give it\n;; values that are not sets.  The implementation of difference _does not\n;; check_ whether you are actually giving it values that are sets.  It\n;; _assumes_ so.\n\n;; This looks like what someone might expect.  It _happens_ to give\n;; back the same answer as if you coerced the second argument to a\n;; set.\nuser=> (difference #{1 3 5} [1 2 3 4 5 6])\n#{}\n\n;; This is not the difference between the two collections (if they\n;; were both sets) at all!\nuser=> (difference #{1 3 5} [2 4 6 8 10 12])\n#{}\n\n;; Give it only sets, and it returns the correct answer.\nuser=> (set/difference #{1 3 5} #{2 4 6 8 10 12})\n#{1 3 5}\n\n;; Also not the correct set difference, because the second arg is a\n;; vector, not a set.\nuser=> (difference #{-1 10 20 30} [-1 10 20 30 40])\n#{20 -1 30 10}\n\n;; This is correct.\nuser=> (difference #{-1 10 20 30} #{-1 10 20 30 40})\n#{}\n\n;; Why not change the definition of difference so it throws an exception if\n;; you give it a non-set argument?  I would guess that the primary\n;; reason is that the extra run-time type checks would slow difference down\n;; by an amount that the Clojure core team does not want everyone to\n;; have to pay on every such call.\n\n;; Related Clojure tickets: \n;; https://dev.clojure.org/jira/browse/CLJ-1953\n;; https://dev.clojure.org/jira/browse/CLJ-2287\n"], :notes nil, :arglists ["s1" "s1 s2" "s1 s2 & sets"], :doc "Return a set that is the first set without elements of the remaining sets", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/difference"}, :clojure.core/< {:added "1.0", :ns "clojure.core", :name "<", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/= :clojure.core/not= :clojure.core/> :clojure.core/<= :clojure.core/>=], :line 892, :examples ["user=> (< 1 2)\ntrue\nuser=> (< 2 1)\nfalse\nuser=> (< 1.5 2)\ntrue\nuser=> (< 2 3 4 5 6)\ntrue"], :notes ["I think the docstring for < should say \"strictly increasing\" instead of \"monotonically increasing.\"  In contrast, I think <= is the function that tests for \"monotonically  increasing.\"\r\n\r\nHere's a quote from wikitionary...\r\n\r\nmonotonic increasing: (mathematics, of a function) always increasing or remaining constant, and never decreasing; contrast this with strictly increasing\r\n"], :arglists ["x" "x y" "x y & more"], :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/<"}, :clojure.core/take-while {:added "1.0", :ns "clojure.core", :name "take-while", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/drop-while :clojure.core/split-with :clojure.core/some :clojure.core/take], :line 2880, :examples [";; Calculate the sum of all numbers under 1000:\nuser=> (reduce + (take-while (partial > 1000) (iterate inc 0)))\n499500" "user=> (take-while neg? [-2 -1 0 1 2 3])\n(-2 -1)\n\nuser=> (take-while neg? [-2 -1 0 -1 -2 3]) ; note: `take-while' stops traversing the collection when the predicate is false, as is different from `filter'.\n(-2 -1)\n\nuser=> (take-while neg? [ 0 1 2 3])\n()\n\nuser=> (take-while neg? [])\n()\n\nuser=> (take-while neg? nil)\n()" ";;take the item while it's included in the set  \nuser=> (take-while #{[1 2][3 4]} #{[1 2]})\n([1 2])\nuser=> (take-while #{[1 2][3 4]} #{[3 4]})\n([3 4])\nuser=> (take-while #{[1 2][3 4]} #{[4 5]})\n()\nuser=>(take-while #{[1 2][3 4]} #{[5 6] [1 2]}); return nil while any item is not included in the set\n()" ";;take-while practical example\n\n(def entries [{:month 1 :val 12}\n              {:month 2 :val 3}\n              {:month 3 :val 32}\n              {:month 4 :val 18}\n              {:month 5 :val 32}\n              {:month 6 :val 62}\n              {:month 7 :val 12}\n              {:month 8 :val 142}\n              {:month 9 :val 52}\n              {:month 10 :val 18}\n              {:month 11 :val 23}\n              {:month 12 :val 56}])\n\n(defn get-result\n  [coll m]\n  (take-while\n   #(<= (:month %) m) coll))\n\n(get-result entries 3)\n;;({:m 1, :val 12} {:m 2, :val 3} {:m 3, :val 32})\n" ";; Note that usually more items are realized than needed.\n;; In the example below the first 32 items are calculated,\n;; though the first 2 would be enough.\n;; This can be especially important when this extra realization\n;; leads to an exception (see example at 'take') or requires a lot of\n;; resources (CPU, time, memory, etc.) and at the end not needed at all.\n\nuser=> (let [x (map (fn [i]\n                      (println i)\n                      (Thread/sleep 100)\n                      i)\n                    (range 50))]\n         (take-while #(< % 1) x))\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n(0)"], :notes nil, :arglists ["pred" "pred coll"], :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/take-while"}, :clojure.core.logic/membero {:ns "clojure.core.logic", :name "membero", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1755, :examples [";; Usage: (membero x l)\n\n(run* [q]\n  (membero :a [q :b :c])) ;; :a\n(run* [q]\n  (membero q [:a :b :c])) ;; [:a :b :c]\n"], :notes nil, :arglists ["x l"], :doc "A relation where l is a collection, such that l contains x.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/membero"}, :clojure.core.logic/-run {:ns "clojure.core.logic", :name "-run", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1218, :examples nil, :macro true, :notes nil, :arglists ["opts [x :as bindings] & goals"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-run"}, :clojure.core/str {:added "1.0", :ns "clojure.core", :name "str", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pr :clojure.core/prn :clojure.core/pr-str :clojure.core/prn-str :clojure.core/print-str :clojure.core/println-str], :line 544, :examples ["user=> \"some string\"\n\"some string\"\n\nuser=> (str)\n\"\"\nuser=> (str nil)\n\"\"\nuser=> (str 1)\n\"1\"\nuser=> (str 1 2 3)\n\"123\"\nuser=> (str 1 'symbol :keyword)\n\"1symbol:keyword\"\n\n;; A very common usage of str is to apply it to an existing collection:\nuser=> (apply str [1 2 3])\n\"123\"\n\n;; compare it with:\nuser=> (str [1 2 3])\n\"[1 2 3]\"\n\n" ";; Destructuring with a string, getting just a few characters from it\nuser=> (let [[first-char second-char] \"abcde\"] \n         (prn 'first= first-char) \n         (prn 'second= second-char))\nfirst= \\a\nsecond= \\b\nnil\n\n;; More destructuring with a string\nuser=> (let [[first-char second-char & rest-of-chars] \"abcde\"] \n         (prn 'first= first-char) \n         (prn 'second= second-char) \n         (prn 'rest= rest-of-chars))\nfirst= \\a\nsecond= \\b\nrest= (\\c \\d \\e)\nnil\n\n;; Destructuring, getting the first character of a string\n;; and then a reference to the entire string\nuser=> (let [[first-char :as all-the-string] \"abcde\"] \n         (prn 'first= first-char) \n         (prn 'all= all-the-string))\nfirst= \\a\nall= \"abcde\"\nnil" "user=> (str \"L\" \"a\")\n\"La\"\n\nuser=> (str \"L\" 5 \"a\")\n\"L5a\"" ";; sometimes when printing lazy sequences you do not get what you want.\n(str (take 5 (range 10)))\n;=> \"clojure.lang.LazySeq@1b554e1\"\n\n;; in those cases `pr-str` to the rescue.\n(pr-str (take 5 (range 10)))\n;=> \"(0 1 2 3 4)\"" ";; be careful with java.lang.Double to java.lang.String conversion\n(str -128004972.0)\n;=> \"-1.28004972E8\"\n"], :notes nil, :tag "java.lang.String", :arglists ["" "x" "x & ys"], :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/str"}, :clojure.core/pmap {:added "1.0", :ns "clojure.core", :name "pmap", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map :clojure.core/future :clojure.core/pcalls :clojure.core/pvalues :clojure.core/partition], :line 6932, :examples [";; This function operates just like map.  See\n;; clojure.core/map for more details.\nuser=> (pmap inc [1 2 3 4 5])\n(2 3 4 5 6)" ";; A function that simulates a long-running process by calling Thread/sleep:\n(defn long-running-job [n]\n    (Thread/sleep 3000) ; wait for 3 seconds\n    (+ n 10))\n\n;; Use `doall` to eagerly evaluate `map`, which evaluates lazily by default.\n\n;; With `map`, the total elapsed time is just under 4 * 3 seconds:\nuser=> (time (doall (map long-running-job (range 4))))\n\"Elapsed time: 11999.235098 msecs\"\n(10 11 12 13)\n\n;; With `pmap`, the total elapsed time is just over 3 seconds:\nuser=> (time (doall (pmap long-running-job (range 4))))\n\"Elapsed time: 3200.001117 msecs\"\n(10 11 12 13)" ";; pmap is implemented using Clojure futures.  See examples for 'future'\n;; for discussion of an undesirable 1-minute wait that can occur before\n;; your standalone Clojure program exits if you do not use shutdown-agents." ";; Parallel application (of 'f') does NOT mean that the result collection would\n;; be sorted according to calculation time. The result collection is sorted\n;; in the same way as for map, i.e. it \"preserves\" the items' order in the 'coll'\n;; (or 'colls') parameter(s) of pmap. In other words: calculation is done parallel,\n;; but the result is delivered in the order the input came (in 'coll'/'colls').\n\n;; So, e.g. if the first item of 'coll' takes 1 hour to be processed (by 'f'), and\n;; the rest requires 1 sec, nothing is delivered by pmap during the 1st hour:\n;; the 1st item \"blocks\" the appearence of the others in the result of pmap,\n;; even if the others are already calculated. E.g. (take 5 (pmap ...) will not \n;; return in 5 secs (but in 1 hour), even if we calculated 5 items in 5 secs\n;; -- we wait for the calculations of the first five in 'coll'.\n\n;; In contrast, side effects of 'f' (if any) are coming in \"random\" order (due to\n;; parallelism): in the example above, we might see the side effects (e.g. swap!-s)\n;; of many appliactions of 'f' to different elements of 'coll', long before we \n;; get the result of (take 1 (pmap ...)).\n\n;; To illustrate the statements above, run this:\n(defn proc\n  [i]\n  (println \"processing: \" i \"(\" (System/currentTimeMillis) \")\")\n  (Thread/sleep\n   (if (= i 0)\n     5000\n     10)))\n\n(take 1 (pmap proc (range 5)))\n;; output:\n(processing: processing: processing: processing: processing:     3 42  ( ((1 \n 1539007947561(  1539007947561 ) )1539007947561 0 )\n\n1539007947561( ) 1539007947561 )\n\nnil)\n;; We can see that 5 threads are started at the same time, immediately, in parallel.\n;; 4 of them must be finished in 10 msecs, but we get back the REPL prompt\n;; only after 5 secs, because we wait for the result of the i=0 item." ";; pmap is implemented using Clojure futures. Futures run in threads. \n;; These threads of a pmap's evaluation run independently from each other.\n;; This means that even if one of these threads already determined the result\n;; of the whole pmap*, all the other, already started threads keep running\n;; until they finish their own calculations. (Although these calcualtions might\n;; already be absolutely unnecessary.)\n;; This can be especially important, when these threads have side effects:\n;; these side effects (e.g. swap!-s) might happen later, when they are not\n;; expected anymore.\n;; Moreover, these \"cowboy\" threads keep occuping the resources (CPU, memory...)\n;; they need.\n;; *: this is the case e.g. when one of the threads throws an exception."], :notes ["for insight into how pmap does stuff see this presentation: \"From Concurrency to Parallelism\", by David Edgar Liebke @ http://incanter.org/downloads/fjclj.pdf"], :arglists ["f coll" "f coll & colls"], :doc "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pmap"}, :clojure.core/conj {:added "1.0", :ns "clojure.core", :name "conj", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/cons :clojure.core/into :clojure.core/peek :clojure.core/pop :clojure.core/concat :clojure.core/conj!], :line 75, :examples [";; notice that conjoining to a vector is done at the end\n(conj [1 2 3] 4)\n;;=> [1 2 3 4]\n\n;; notice conjoining to a list is done at the beginning\n(conj '(1 2 3) 4)\n;;=> (4 1 2 3)\n\n(conj [\"a\" \"b\" \"c\"] \"d\")\n;;=> [\"a\" \"b\" \"c\" \"d\"]\n\n;; conjoining multiple items is done in order\n(conj [1 2] 3 4)               \n;;=> [1 2 3 4]\n\n(conj '(1 2) 3 4)               \n;;=> (4 3 1 2)\n\n(conj [[1 2] [3 4]] [5 6])       \n;;=> [[1 2] [3 4] [5 6]]\n\n;; conjoining to maps only take items as vectors of length exactly 2\n(conj {1 2, 3 4} [5 6])\n;;=> {5 6, 1 2, 3 4}\n\n(conj {:firstname \"John\" :lastname \"Doe\"} {:age 25 :nationality \"Chinese\"})\n;;=> {:nationality \"Chinese\", :age 25, :firstname \"John\", :lastname \"Doe\"}\n\n;; conj on a set\n(conj #{1 3 4} 2)\n;;=> #{1 2 3 4}\n\n" ";; conjoin shows similar behaviour to cons\n;; The main difference being that conj works on collections\n;; but cons works with seqs. \n(conj [\"a\" \"b\" \"c\"] [\"a\" \"b\" \"c\"] )\n;;=> [\"a\" \"b\" \"c\" [\"a\" \"b\" \"c\"]]" ";; conjoin nil with x or xs\n(conj nil 3)\n;;=> (3)\n\n(conj nil 3 4)\n;;=> (4 3)" ";; maps and sets are treated differently\n(conj {1 2} {3 4})\n;;=> {3 4, 1 2}   ; the contents of {3 4} are added to {1 2}\n\n(conj #{1 2} #{3})\n;;=> #{1 2 #{3}}  ; the whole set #{3} is added to #{1 2}\n\n(clojure.set/union #{1 2} #{3})\n;;=> #{1 2 3}  ; must use (clojure.set/union) to merge sets, not conj\n" ";; When conjoining into a map, vector pairs may be provided:\n(conj {:a 1} [:b 2] [:c 3])\n;;=> {:c 3, :b 2, :a 1}\n\n;; Or maps may be provided, with multiple pairings:\n(conj {:a 1} {:b 2 :c 3} {:d 4 :e 5 :f 6})\n;;=> {:f 6, :d 4, :e 5, :b 2, :c 3, :a 1}\n\n;; But multiple pairings cannot appear in vectors:\n(conj {:a 1} [:b 2 :c 3])\n;;=> IllegalArgumentException Vector arg to map conj must be a pair...\n\n;; And pairs may not be provided in lists:\n(conj {:a 1} '(:b 2))\n;;=> ClassCastException ...Keyword cannot be cast to ...Map$Entry...\n" ";; Useful snippet: \"merge\" two or more vectors with `(comp vec flatten conj)`\n(let [a [{:a \"hi\"} {:b \"hey\"}]\n      b [{:c \"yo\"} {:d \"hiya\"}]\n      c [{:e \"bonjour\"}]]\n  ((comp vec flatten conj) a b c))\n;;=> [{:a \"hi\"} {:b \"hey\"} {:c \"yo\"} {:d \"hiya\"} {:e \"bonjour\"}]" "(conj nil 1)\n;=>(1)\n(conj nil [1 2])\n;=>([1 2])\n" ";; Conj new-element into nested structures \"conj-in\"\n\n(def db {:users [{:name \"Eduardo\"}]})\n(def new-element {:name \"Eva\"})\n\n(assoc db :users (conj (:users db) new-element))\n;; => {:users [{:name \"Eduardo\"} {:name \"Eva\"}]}" ";; implement stack semantics with conj, peek and pop.\n\n;; we start with a list\n(def stack '(2 1 0))\n\n(peek stack)\n;; => 2\n(pop stack)\n;; => (1 0)\n(type (pop stack))\n;; => cljs.core/List\n;; push = conj\n(conj stack 3)\n;; => (3 2 1 0)\n(type (conj stack 3))\n;; => cljs.core/List\n\n;; now let us try a vector\n(def stack [0 1 2])\n\n(peek stack)\n;; => 2\n(pop stack)\n;; => [0 1]\n(type (pop stack))\n;; => clojure.lang.PersistentVector\n;; push = conj\n(conj stack 3)\n;; => [0 1 2 3]\n(type (conj stack 3))\n;; => clojure.lang.PersistentVector\n"], :notes ["list prepend\nvector append"], :arglists ["coll x" "coll x & xs"], :doc "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/conj"}, :clojure.core.async/Mux {:ns "clojure.core.async", :name "Mux", :file "clojure/core/async.clj", :type "var", :column 1, :see-alsos nil, :line 661, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/Mux"}, :clojure.core.logic/merge-doms {:ns "clojure.core.logic", :name "merge-doms", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 558, :examples nil, :notes nil, :arglists ["s x doms"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/merge-doms"}, :clojure.java.javadoc/*local-javadocs* {:ns "clojure.java.javadoc", :name "*local-javadocs*", :file "clojure/java/javadoc.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 19, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/*local-javadocs*"}, :clojure.core/defmulti {:added "1.0", :ns "clojure.core", :name "defmulti", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/defmethod :clojure.core/remove-method :clojure.core/remove-all-methods :clojure.core/prefers :clojure.core/methods :clojure.core/get-method :clojure.core/defprotocol :clojure.core/make-hierarchy :clojure.spec/multi-spec], :line 1717, :examples [";; Define the multimethod\n(defmulti service-charge (fn [acct] [(account-level acct) (:tag acct)]))\n\n;; Handlers for resulting dispatch values\n(defmethod service-charge [::acc/Basic   ::acc/Checking] [_] 25)\n(defmethod service-charge [::acc/Basic   ::acc/Savings]  [_] 10)\n(defmethod service-charge [::acc/Premium ::acc/Account]  [_] 0)" ";this example illustrates that the dispatch type\n;does not have to be a symbol, but can be anything (in this case, it's a string)\n\n(defmulti greeting\n  (fn[x] (x \"language\")))\n\n;params is not used, so we could have used [_]\n(defmethod greeting \"English\" [params]\n \"Hello!\")\n\n(defmethod greeting \"French\" [params]\n \"Bonjour!\")\n\n;;default handling\n(defmethod greeting :default [params]\n (throw (IllegalArgumentException. \n          (str \"I don't know the \" (params \"language\") \" language\"))))\n\n;then can use this like this:\n(def english-map {\"id\" \"1\", \"language\" \"English\"})\n(def  french-map {\"id\" \"2\", \"language\" \"French\"})\n(def spanish-map {\"id\" \"3\", \"language\" \"Spanish\"})\n\n=>(greeting english-map)\n\"Hello!\"\n=>(greeting french-map)\n\"Bounjour!\"\n=>(greeting spanish-map)\n java.lang.IllegalArgumentException: I don't know the Spanish language" ";; Implementing factorial using multimethods Note that factorial-like function \n;; is best implemented using `recur` which enables tail-call optimization to avoid \n;; a stack overflow error. This is a only a demonstration of clojure's multimethod\n\n;; identity form returns the same value passed\n(defmulti factorial identity)\n\n(defmethod factorial 0 [_]  1)\n(defmethod factorial :default [num] \n    (* num (factorial (dec num))))\n\n(factorial 0) ; => 1\n(factorial 1) ; => 1\n(factorial 3) ; => 6\n(factorial 7) ; => 5040" ";; defmulti/defmethods support variadic arguments and dispatch functions.\n\n(defmulti bat \n  (fn ([x y & xs] \n       (mapv class (into [x y] xs)))))\n(defmethod bat [String String] [x y & xs] \n  (str \"str: \" x \" and \" y))\n(defmethod bat [String String String] [x y & xs] \n  (str \"str: \" x \", \" y \" and \" (first xs)))\n(defmethod bat [String String String String] [x y & xs] \n  (str \"str: \" x \", \" y \", \" (first xs) \" and \" (second xs)))\n(defmethod bat [Number Number] [x y & xs] \n  (str \"number: \" x \" and \" y))\n\n;; you call it like this...\n\n(bat \"mink\" \"stoat\")\n;; => \"str: mink and stoat\"\n\n(bat \"bear\" \"skunk\" \"sloth\")\n;; => \"str: bear, skunk and sloth\"\n\n(bat \"dog\" \"cat\" \"cow\" \"horse\")\n;; => \"str: dog, cat, cow and horse\"\n\n(bat 1 2)\n;; => \"number: 1 and 2\"" ";; defmulti - custom hierarchy\n\n(def h (-> (make-hierarchy)\n           (derive :foo :bar)))\n\n(defmulti f identity :hierarchy #'h) ;; hierarchy must be a reference type\n\n(defmethod f :default [_] \"default\")\n(defmethod f :bar [_] \"bar\")\n\n(f :unknown) ;; \"default\"\n(f :bar) ;; \"bar\"\n(f :foo) ;; \"bar\"\n\n;; Note that any deref'able type is fine. \n;; Using an atom instead of (var h) is preferable in clojurescript \n;; (which adds a lot of meta information to vars)" ";; If you're REPLing you might want to re-define the defmulti dispatch function \n;; (which defmulti won't allow you to do). For this you can use `ns-unmap`:\n\n(defmulti x (fn[_] :inc))\n(defmethod x :inc [y] (inc y))\n(defmethod x :dec [y] (dec y))\n(x 0) ;; => 1\n(defmulti x (fn[_] :dec)) ;; Can't redefine :(\n(x 0) ;; => 1 ;; STILL :(\n(ns-unmap *ns* 'x) ;; => unmap the var from the namespace\n(defmulti x (fn[_] :dec))\n(x 0) ;; => Exception, we now need to redefine our defmethods.\n\n;; So in your file while developing you'd put the ns-unmap to the top of the file\n" ";; It's nice for multimethods to have arglists metadata so that calling `doc`\n;; prints the arglist, instead of just the docstring. For example:\n\n(defmulti f \"Great function\" (fn [x] :blah))\n(doc f)\n;; -------------------------\n;; user/f\n;;  Great function\n\n;; However, we can add `:arglists` metadata via a third (optional) argument to `defmulti` (`attr-map?` in the docstring for `defmulti`):\n\n(defmulti g \"Better function\" {:arglists '([x])} (fn [x] :blah))\n(doc g)\n;; -------------------------\n;; user/f\n;; ([x])\n;;  Better function\n" "(defmulti compact map?)\n\n(defmethod compact true [map]\n  (into {} (remove (comp nil? second) map)))\n\n(defmethod compact false [col]\n  (remove nil? col))\n\n; Usage:\n\n(compact [:foo 1 nil :bar])\n; => (:foo 1 :bar)\n\n(compact {:foo 1 :bar nil :baz \"hello\"})\n; => {:foo 1, :baz \"hello\"}\n" ";; This show how to do a wildcard match to a dispatch value:\n(defmulti xyz (fn [x y] [x y]))\n\n;; We don't care about the first argument:\n(defmethod xyz [::default :b]\n  [x y]\n  :d-b)\n\n;; We have to implement this manually:\n(defmethod xyz :default\n  [x y]\n  (let [recover (get-method xyz [::default y])]\n    ;; Prevent infinite loop:\n    (if (and recover (not (= (get-method xyz :default) recover)))\n      (do\n        (println \"Found a default\")\n        ;; Add the default to the internal cache:\n        ;; Clojurescript will want (-add-method ...)\n        (.addMethod ^MultiFn xyz [x y] recover)\n        (recover ::default y))\n      :default)))\n\n(xyz nil :b) ;; => :d-b\n;; only prints \"Found a default\" once!" ";; Extremely simple example, dispatching on a single field of the input map.\n;; Here we have a polymorphic map that looks like one of these two examples:\n\n;;  {:name/type :split :name/first \"Bob\" :name/last \"Dobbs\"}\n;;  {:name/type :full :name/full \"Bob Dobbs\"}\n\n(defmulti full-name :name/type)\n\n(defmethod full-name :full [name-data] \n  (:name/full name-data))\n\n(defmethod full-name :split [name-data] \n  (str (:name/first name-data) \" \" (:name/last name-data)))\n\n(defmethod full-name :default [_] \"???\")\n\n(full-name {:name/type :full :name/full \"Bob Dobbs\"})\n;; => \"Bob Dobbs\"\n\n(full-name {:name/type :split :name/first \"Bob\" :name/last \"Dobbs\"})\n;; => \"Bob Dobbs\"\n\n(full-name {:name/type :oops :name/full \"Bob Dobbs\"})\n;; => \"???\"\n" ";;polymorphism classic example\n\n;;defmulti\n(defmulti draw :shape)\n\n;;defmethod\n(defmethod draw :square [geo-obj] (str \"Drawing a \" (:clr geo-obj) \" square\"))\n(defmethod draw :triangle [geo-obj] (str \"Drawing a \" (:clr geo-obj) \" triangle\"))\n\n(defn square [color] {:shape :square :clr color})\n(defn triangle [color] {:shape :triangle :clr color})\n\n(draw (square \"red\"))\n(draw (triangle \"green\"))" ";;defmulti with dispatch function\n(defmulti salary (fn[amount] (amount :t)))\n\n;;defmethod provides a function implementation for a particular value\n(defmethod salary \"com\" [amount] (+ (:b amount) (/ (:b amount) 2)))\n(defmethod salary \"bon\" [amount] (+ (:b amount) 99))\n\n(salary {:t \"com\" :b 1000}) ;;1500\n(salary {:t \"bon\" :b 1000}) ;;1099 "], :macro true, :notes ["See also\r\n\r\nhttp://clojure.org/runtime_polymorphism\r\n\r\nhttp://clojure.org/multimethods\r\n\r\n"], :arglists ["name docstring? attr-map? dispatch-fn & options"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defmulti"}, :clojure.core/set-error-mode! {:added "1.2", :ns "clojure.core", :name "set-error-mode!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 2204, :examples nil, :notes nil, :arglists ["a mode-keyword"], :doc "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set-error-mode!"}, :clojure.spec.alpha/map-spec-impl {:ns "clojure.spec.alpha", :name "map-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 774, :examples nil, :notes nil, :arglists ["{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn], :as argm}"], :doc "Do not call this directly, use 'spec' with a map argument", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/map-spec-impl"}, :clojure.core.async/to-chan {:ns "clojure.core.async", :name "to-chan", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 648, :examples ["user=> (def c (to-chan (range 10)))\n#'user/c\nuser=> (<!! c)\n0\nuser=> (<!! c)\n1\nuser=> (<!! c)\n2\nuser=> (<!! c)\n3\n"], :notes nil, :arglists ["coll"], :doc "Creates and returns a channel which contains the contents of coll,\n  closing when exhausted.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/to-chan"}, :clojure.core/pop-thread-bindings {:added "1.1", :ns "clojure.core", :name "pop-thread-bindings", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/push-thread-bindings :clojure.core/binding], :line 1923, :examples nil, :notes nil, :arglists [""], :doc "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pop-thread-bindings"}, :clojure.core.async/onto-chan {:ns "clojure.core.async", :name "onto-chan", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 633, :examples ["user=> (def c (chan))\n#'user/c\n\nuser=> (onto-chan c (range 100))\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@2e68de5>\n\nuser=> (<!! c)\n0\nuser=> (<!! c)\n1\nuser=> (<!! c)\n2\n" "\n;; `onto-chan` does not return the `ch` param channel, instead it returns a\n;; new channel indicating when the coll was added to the channel.\n(def coll (range 10))\n(def in-ch (chan))\n(def out-ch (onto-chan in-ch coll))\n\n(= in-ch out-ch)\n;; => false\n(identical? in-ch out-ch)\n;; => false\n"], :notes nil, :arglists ["ch coll" "ch coll close?"], :doc "Puts the contents of coll into the supplied channel.\n\n  By default the channel will be closed after the items are copied,\n  but can be determined by the close? parameter.\n\n  Returns a channel which will close after the items are copied.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/onto-chan"}, :clojure.core/make-hierarchy {:added "1.0", :ns "clojure.core", :name "make-hierarchy", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/isa? :clojure.core/derive :clojure.core/underive :clojure.core/parents :clojure.core/descendants :clojure.core/ancestors], :line 5468, :examples [";; use make-hierarchy to build your own local hierarchy for derive, isa?, etc. \n;; instead of using the global hierarchy\n;; note that the first ancestors call returns a nil since that type does not \n;; exist in the global hierarchy\n\nuser=> (def h (make-hierarchy))\n#'user/h\nuser=> (def h (derive h ::rect ::shape))\n#'user/h\nuser=> (def h (derive h ::square ::rect))\n#'user/h\nuser=> h\n{:parents {:user/square #{:user/rect}, :user/rect #{:user/shape}}, :ancestors {:\nuser/square #{:user/shape :user/rect}, :user/rect #{:user/shape}}, :descendants\n{:user/rect #{:user/square}, :user/shape #{:user/square :user/rect}}}\nuser=> (ancestors ::square)\nnil\nuser=> (ancestors h ::square)\n#{:user/shape :user/rect}\nuser=>" ";; the above hierarchy can be built together with a thread macro:\n\nuser=> (def h (-> (make-hierarchy) (derive ::rect ::shape) (derive ::square ::rect)))\n#'user/h\nuser=> h\n{:parents {:user/square #{:user/rect}, :user/rect #{:user/shape}}, :ancestors {:user/square #{:user/rect}, :user/rect #{:user/shape}}, :descendants {:user/rect #{:user/square}, :user/shape #{:user/rect}}}\n\n" ";; hierarchy can be stored in atom for more flexibility\n(def service-types (atom (make-hierarchy)))\n\n(defn add-local! [service-type]\n  (swap! service-types derive service-type ::local)\n\n(defn add-remote! [service-type]\n  (swap! service-types derive service-type ::remote)\n\n(defmulti connect :service-type :hierarchy service-types)\n(defmethod connect ::remote [service] \"Connecting to remote service\")\n(defmethod connect ::local [service] \"Connecting to local service\")\n  \n(add-remote! ::rest)\n(add-local! ::com+)\n\n(connect {:service-type ::rest}) \n;; => \"Connecting to remote service\"\n\n(connect {:service-type ::com+}) \n;; => \"Connecting to local service\""], :notes nil, :arglists [""], :doc "Creates a hierarchy object for use with derive, isa? etc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/make-hierarchy"}, :clojure.core/keyword {:added "1.0", :ns "clojure.core", :name "keyword", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/name :clojure.core/keyword? :clojure.core/namespace :clojure.core/find-keyword :clojure.core/symbol], :line 606, :examples [";; (keyword name): name can be string, symbol, or keyword.\n;; \n;; (keyword ns name): ns and name must both be string.\n;; \n;; A keyword string, like a symbol, begins with a non-numeric\n;; character and can contain alphanumeric characters and *, +, !, -,\n;; _, and ?.  (see http://clojure.org/reader for details).\n;; \n;; keyword does not validate input strings for ns and name, and may\n;; return improper keywords with undefined behavior for non-conformant\n;; ns and name.\n\nuser=> (keyword 'foo)\n:foo\n\nuser=> (keyword \"foo\")       \n:foo\n\nuser=> (keyword \"user\" \"foo\")\n:user/foo\n\n;; keyword in current namespace\nuser=> (keyword (str *ns*) \"foo\")\n:user/foo" ";; some gotchas to be aware of:\n\nuser=> (keyword \"user\" 'abc)\nClassCastException clojure.lang.Symbol cannot be cast to java.lang.String  clojure.core/keyword (core.clj:558)\n\nuser=> (keyword *ns* \"abc\")\nClassCastException clojure.lang.Namespace cannot be cast to java.lang.String  clojure.core/keyword (core.clj:558)\n\nuser=> (keyword 'user \"abc\")\nClassCastException clojure.lang.Symbol cannot be cast to java.lang.String  clojure.core/keyword (core.clj:558)\n\n\n;; Warning - the following generated keywords are non-conformant and may wreak\n;; serious havoc in the near/far future when least expected...\n\nuser=> (keyword \"abc def\")\n:abc def\n\nuser=> (keyword \"123def\")\n:123def\n\nuser=> (keyword \"/abc/def/ghi\")\n:/abc/def/ghi" ";; You can define namespaced keywords using '::'\nuser=> (def a :foo)\n#'user/a\n\nuser=> (def b ::foo)\n#'user/b\n\nuser=> (ns foo)\nfoo=> user/a\n:foo\n\nfoo=> user/b\n:user/foo\n\nfoo=> ::foo\n:foo/foo\n\nfoo=> (= user/a :foo)\ntrue\n\nfoo=> (= user/b ::foo)\nfalse\n\nfoo=> (= user/b :user/foo)\ntrue" ";;only convert strings\nuser=> (keyword 1)\nnil\n\n\nuser=> (keyword '1)\nnil\n" "(keyword \"my.key\")\n;=> :my.key\n(qualified-keyword? :my.key)\n;=> nil ;; \"my.key\" is just name, dot does not count\n(keyword \"my.namespace\" \"my.key\") \n;=> :my.namespace/my.key\n(qualified-keyword? :my.namespace/my.key)\n;=> true \n(namespace :my.namespace/my.key) \n;=> \"my.namespace\"\n(name :my.namespace/my.key) \n;=> \"my.key\"\n" ";; let's make an illustrative namespace\n(create-ns  'my.arbitrary.long.namespace)\n(alias 'maln 'my.arbitrary.long.namespace)\n;; more typically loaded and aliased with require\n;; (require '[my.arbitrary.long.namespace :as maln])\n\n;; Qualified keywords may be specified with the namespace or the alias.\n;; But unlike with symbols where the bare alias is used \n;; you need to prefix the alias with '::' \n:my.arbitrary.long.namespace/foo\n;=> :my.arbitrary.long.namespace/foo\n::maln/bar\n;=> :my.arbitrary.long.namespace/bar" ";; You can use existing keywords\n(keyword :namespace :keyword)\n;=> :namespace/keyword\n(keyword \"namespace\" :keyword)\n;=> :namespace/keyword\n(keyword :namespace \"keyword\")\n;=> :namespace/keyword\n(keyword :meta-namespace/namespace :meta-keyword/keyword)\n;=> :namespace/keyword\n"], :notes nil, :tag "clojure.lang.Keyword", :arglists ["name" "ns name"], :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/keyword"}, :clojure.reflect/map->Constructor {:ns "clojure.reflect", :name "map->Constructor", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 109, :examples ["(require '[clojure.reflect :as cr])\n\n;; I have no idea what this is for but here is what it does.\n(cr/map->Constructor {:name \"do_reflect\" \n                      :declaring-class \"clojure.reflect.JavaReflector\"\n                      :parameter-types [\"java.lang.Object\"]\n                      :exception-types []\n                      :flags #{:public}}) \n;=> #clojure.reflect.Constructor{:name \"do_reflect\", \n;;                               :declaring-class \"clojure.reflect.JavaReflector\",\n;;                               :parameter-types [\"java.lang.Object\"],\n;;                               :exception-types [],\n;;                               :flags #{:public}}"], :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.reflect.Constructor, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/map->Constructor"}, :clojure.core.logic/nonlvaro {:ns "clojure.core.logic", :name "nonlvaro", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1456, :examples nil, :macro true, :notes nil, :arglists ["v"], :doc "A goal that succeeds if the argument is not fresh. v must be a\n  logic variable. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/nonlvaro"}, :clojure.core.async/map {:ns "clojure.core.async", :name "map", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 918, :examples ["user=> (def cx\n         (to-chan\n          (range 10)))\n#'user/cx\n\nuser=> (def cy\n         (to-chan\n          (range -10 0)))\n#'user/cy\n\nuser=> (def mapped-chans\n         (clojure.core.async/map + [cx cy]))\n#'user/mapped-chans\n\n;;\nuser=> (<!! mapped-chans)\n-10\nuser=> (<!! mapped-chans)\n-8\nuser=> (<!! mapped-chans)\n-6\nuser=> (<!! mapped-chans)\n-4\nuser=> (<!! mapped-chans)\n-2\nuser=> (<!! mapped-chans)\n0\nuser=> (<!! mapped-chans)\n2\nuser=> (<!! mapped-chans)\n4\nuser=> (<!! mapped-chans)\n6\nuser=> (<!! mapped-chans)\n8\nuser=> (<!! mapped-chans)\nnil\n"], :notes nil, :arglists ["f chs" "f chs buf-or-n"], :doc "Takes a function and a collection of source channels, and returns a\n  channel which contains the values produced by applying f to the set\n  of first items taken from each source channel, followed by applying\n  f to the set of second items from each channel, until any one of the\n  channels is closed, at which point the output channel will be\n  closed. The returned channel will be unbuffered by default, or a\n  buf-or-n can be supplied", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/map"}, :clojure.java.io/as-file {:added "1.2", :ns "clojure.java.io", :name "as-file", :type "function", :see-alsos [:clojure.java.io/file], :examples ["; It returns a java.io.File object\n> (require '[clojure.java.io :as io] )\n> (class (io/as-file \".\"))\njava.io.File\n\n; You can call java methods such as File/exists\n> (.exists (io/as-file \"dummy.txt\"))\nfalse\n> (.exists (io/as-file \"project.clj\"))\ntrue\n"], :notes ["This is a low-level function for getting a file object from a single string.\nIn contrast, `(clojure.java.io/file)` is a higher-level API that will let you do \nthings like construct paths to files using strings and other file objects, \nas in `(io/file root-dir \"subdir\" \"filename.ext\")`."], :tag "java.io.File", :arglists ["x"], :doc "Coerce argument to a file.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/as-file"}, :clojure.xml/attrs {:ns "clojure.xml", :name "attrs", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :line 23, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/attrs"}, :clojure.core/printf {:added "1.0", :ns "clojure.core", :name "printf", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/format :clojure.pprint/cl-format :clojure.core/println], :line 5686, :examples ["(printf \"1 + 2 is %s%n\" 3)" ";; Click the link to clojure.core/format under See also for\n;; more extensive examples.  printf and format take the same\n;; arguments -- the difference is that format returns a formatted\n;; string, whereas printf sends the formatted string to *out*.\n\n;; Also note that printf output is buffered, and does not automatically\n;; flush at any time, not even when printing newlines.  Thus the last few lines\n;; of output may never appear if your program exits before the buffer is\n;; flushed.  Use (flush) or a (println ...) call to force flushing of the buffer."], :notes nil, :arglists ["fmt & args"], :doc "Prints formatted output, as per format", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/printf"}, :clojure.spec.alpha/describe* {:ns "clojure.spec.alpha", :name "describe*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/describe*"}, :clojure.core.logic.fd/interval {:ns "clojure.core.logic.fd", :name "interval", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 357, :examples nil, :notes nil, :arglists ["ub" "lb ub"], :doc "Construct an interval for an assignment to a var. intervals may\n   be more efficient that the domain type when the range of possiblities\n   is large.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval"}, :clojure.core/->VecNode {:ns "clojure.core", :name "->VecNode", :file "clojure/gvec.clj", :type "function", :column 1, :see-alsos nil, :line 17, :examples nil, :notes nil, :arglists ["edit arr"], :doc "Positional factory function for class clojure.core.VecNode.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->VecNode"}, :clojure.core/unchecked-float {:added "1.3", :ns "clojure.core", :name "unchecked-float", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/float], :line 3538, :examples ["(unchecked-float 1)\n;;=> 1.0\n(unchecked-float 1.11)\n;;=> 1.11\n(unchecked-float 1.111111111111111111111111111M)\n;;=> 1.1111112\n\n;;;; Note that (unchecked-float) doesn't range check its argument.\n;;;; Use (float) instead if you want an exception to be thrown in such a case.\n\n(unchecked-float Double/MAX_VALUE)\n;;=> Infinity\n(float Double/MAX_VALUE)\n;;=> IllegalArgumentException Value out of range for float: 1.7976931348623157E308"], :notes nil, :arglists ["x"], :doc "Coerce to float. Subject to rounding.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-float"}, :clojure.zip/next {:added "1.0", :ns "clojure.zip", :name "next", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 230, :examples nil, :notes nil, :arglists ["loc"], :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/next"}, :clojure.reflect/->Field {:ns "clojure.reflect", :name "->Field", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 148, :examples nil, :notes nil, :arglists ["name type declaring-class flags"], :doc "Positional factory function for class clojure.reflect.Field.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/->Field"}, :clojure.core/compile {:added "1.0", :ns "clojure.core", :name "compile", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 6048, :examples ["user=> (compile (symbol \"clojure.java.io\")\nclojure.java.io\n\nuser=> (compile (symbol \"nonexistent.namespace\")\nFileNotFoundException Could not locate unexistent/namespace__init.class or unexistent/namespace.clj on classpath:   clojure.lang.RT.load (RT.java:432)"], :notes nil, :arglists ["lib"], :doc "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/compile"}, :clojure.edn/read {:added "1.5", :ns "clojure.edn", :name "read", :file "clojure/edn.clj", :type "function", :column 1, :see-alsos nil, :line 14, :examples [";; See one of the examples for clojure.core/pr for some uncommon Clojure values\n;; that cannot be printed then read back to get the original values (or in\n;; some cases, cannot be read back at all).\n\n;; If you wish to transmit data that may contain such values, one suggestion\n;; is to use the transit library: https://github.com/cognitect/transit-format" ";; Note that it is not possible to pass the result of (clojure.java.io/reader) \n;; directly to (clojure.edn/read):\n(require '[clojure.java.io :as io] '[clojure.edn :as edn])\n=> nil\n(edn/read (io/reader (.getBytes \":edn\")))\nClassCastException java.io.BufferedReader cannot be cast to java.io.PushbackReader\n\n;; Instead, you need to construct a java.io.PushbackReader instance\n;; and pass that to (edn/read):\n(edn/read (java.io.PushbackReader. (io/reader (.getBytes \":edn\"))))\n=> :edn\n" ";; If you need to distinguish between I/O errors (permission denied, etc)\n;; and syntax errors in the EDN itself (eg, unbalanced parentheses), you'll\n;; want to catch different exceptions from (edn/read):\n\n(defn load-edn\n  \"Load edn from an io/reader source (filename or io/resource).\"\n  [source]\n  (try\n    (with-open [r (io/reader source)]\n      (edn/read (java.io.PushbackReader. r)))\n\n    (catch java.io.IOException e\n      (printf \"Couldn't open '%s': %s\\n\" source (.getMessage e)))))\n    (catch RuntimeException e\n      (printf \"Error parsing edn file '%s': %s\\n\" source (.getMessage e)))))))\n"], :notes ["For everyone struggling to provide custom reader functions to\n`clojure.edn/read`: _you cannot do that through `data_readers.clj`_.\n`data_readers.clj` can be used to provide custom reader functions for\n`clojure.core/read` and `clojure.core/read-string`, but not `clojure.edn/read`\nand `clojure.edn/read-string`.\n\nYou look carefully and you'll find that the official documentation does say so:\nif you don't supply a map of `:readers`, ‘only the `default-data-readers` will\nbe used’. But the information from `data_readers.clj` ends up in\n`*data-readers*` not `default-data-readers`. However, you'd have to look\n_very_ carefully to find this out.\n\n(If you're not interested in silly stories, you can skip the following two\nparagraphs and continue with the last.)\n\nNow you might think: ‘then I'll just say `(edn/read-string {:readers\n*data-readers*} <a stream>)`’. On the first try this will probably fail, because\nyou forgot to `require` the namespaces where the reader functions live. Okay,\nyou've fixed that………\n\nBrowsing from your smartphone now? I know, your home directory just got wiped.\nAnd the external drive with the backups that's always plugged in to your machine\nas well. Why's that? Well, the procedures from `clojure.edn` are supposed to be\nsafe, to not execute any code, so that you can use them with data from untrusted\nsources. If you do want to have code executed (only from trusted sources, of\ncourse), you use the corresponding procedures from `clojure.core`. Now, there\nare people who know about `data_readers.clj` only being used by\n`clojure.core/read` and `clojure.core/read-string`, which aren't safe. So they\ndon't make their reader functions safe either. `guten-tag.core/read-tagged-val`\nis such an example. It calls `eval` on the data it is passed. That means, if you\nuse it with `clojure.edn/read` or `clojure.edn/read-string`, those will become\nas unsafe as their `clojure.core` counterparts.\n\nSorry for the long story. The moral is: have a very careful look at the reader\nfunctions you provide to the procedures from `clojure.edn`. If they execute code\nthat's passed to them, all safety is lost.\n"], :arglists ["" "stream" "opts stream"], :doc "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map that can include the following keys:\n  :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n  :default - A function of two args, that will, if present and no reader is found for a tag,\n             be called with the tag and the value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.edn/read"}, :clojure.core/catch {:ns "clojure.core", :name "catch", :type "var", :see-alsos [:clojure.core/try :clojure.core/finally :clojure.core/throw :clojure.core/ex-data :clojure.core/ex-info :clojure.stacktrace/print-stack-trace], :examples ["=> (try\n     (/ 1 0)\n     (catch Exception e (str \"caught exception: \" (.getMessage e))))\n\n\"caught exception: Divide by zero\"" ";; multiple catch clauses which handle different exceptions\n\n=>  (let [divisor [2 0 \"clojure\"]]\n      (try\n        (/ 4 (rand-nth divisor))\n        (catch ArithmeticException e\n          (println \"Probably trying to divide by zero...\")\n          111)\n        (catch ClassCastException e\n          (println \"Did you try to do math with a string?\")\n          222)\n        (catch Exception e\n          (println \"Some other exception, won't be caught in this case...\")\n          333)\n        (finally\n          (println \"Always executed but won't return a value!\"))))\n\n;; first case\nAlways executed but won't return a value!\n=> 2\n\n;; second case\nProbably trying to divide by zero...\nAlways executed but won't return a value!\n=> 111\n\n;; third case\nDid you try to do math with a string?\nAlways executed but won't return a value!\n=> 222" ";; Note that in ClojureScript, one can use (catch :default e ...) to catch any \n;; type of value, roughly equivalent to (catch Exception e ...) in JVM Clojure.\n\n(try\n  (/ 2 (rand-nth [0 \"oops\"]))\n  (catch :default e             ; Note: ClojureScript only!\n    (println \"Error!\" e)))\n\n;; This is not currently possible in JVM Clojure, though the ticket CLJ-1293 \n;; proposes adding the same behavior there and has some background info."], :notes nil, :arglists [], :doc "The exprs are evaluated and, if no exceptions occur, the value of the last\nis returned. If an exception occurs and catch clauses are provided, each is\nexamined in turn and the first for which the thrown exception is an instance\nof the named class is considered a matching catch clause. If there is a\nmatching catch clause, its exprs are evaluated in a context in which name is\nbound to the thrown exception, and the value of the last is the return value\nof the function. If there is no matching catch clause, the exception\npropagates out of the function. Before returning, normally or abnormally,\nany finally exprs will be evaluated for their side effects. See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/catch"}, :clojure.core/resolve {:added "1.0", :ns "clojure.core", :name "resolve", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-resolve :clojure.core/symbol], :line 4338, :examples ["user=> ((-> \"first\" symbol resolve) [1 2 3])\n1" ";; See also http://clojure.org/namespaces for information on namespaces in Clojure and how to inspect and manipulate them" "user=> (resolve 'x)\nnil\nuser=> (def x 1)\n#'user/x\nuser=> (resolve 'x)\n#'user/x\n\nuser=> (resolve 'join)\nnil\nuser=> (use '[clojure.string :only [join]])\nnil\nuser=> (resolve 'join)\n#'clojure.string/join\n\nuser=> (join \", \" [\"a\" \"b\"])\n\"a, b\"\nuser=> ((resolve 'join) \", \" [\"a\" \"b\"])\n\"a, b\"" "user=> (resolve 'Exception)\njava.lang.Exception\n\nuser=> (type (resolve 'Exception))\njava.lang.Class\n"], :notes nil, :arglists ["sym" "env sym"], :doc "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/resolve"}, :clojure.pprint/pp {:added "1.2", :ns "clojure.pprint", :name "pp", :file "clojure/pprint/pprint_base.clj", :type "macro", :column 1, :see-alsos [:clojure.pprint/pprint], :line 254, :examples ["user=> (zipmap \n        [:a :b :c :d :e] \n        (repeat \n          (zipmap \n            [:a :b :c :d :e] \n            (take 5 (range)))))\n{:e {:e 4, :d 3, :c 2, :b 1, :a 0}, :d {:e 4, :d 3, :c 2, :b 1, :a 0}, :c {:e 4, :d 3, :c 2, :b 1, :a 0}, :b {:e 4, :d 3, :c 2, :b 1, :a 0}, :a {:e 4, :d 3, :c 2, :b 1, :a 0}}\n\nuser=> (clojure.pprint/pp)\n{:e {:e 4, :d 3, :c 2, :b 1, :a 0},\n :d {:e 4, :d 3, :c 2, :b 1, :a 0},\n :c {:e 4, :d 3, :c 2, :b 1, :a 0},\n :b {:e 4, :d 3, :c 2, :b 1, :a 0},\n :a {:e 4, :d 3, :c 2, :b 1, :a 0}}\nnil\n"], :macro true, :notes ["When using Clojure from the REPL, you don't need to specify `clojure.pprint` to use `pp` or `pprint`. So at the REPL `(clojure.pp)` is equivalent to `(pp)`."], :arglists [""], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pp"}, :clojure.main/skip-whitespace {:ns "clojure.main", :name "skip-whitespace", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 111, :examples nil, :notes nil, :arglists ["s"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/skip-whitespace"}, :clojure.core.logic.fd/!= {:ns "clojure.core.logic.fd", :name "!=", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 786, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u and v must not be equal. u and v\n   must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/!="}, :clojure.core/xml-seq {:added "1.0", :ns "clojure.core", :name "xml-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 4898, :examples [";; data.xml from https://github.com/clojure/data.xml/\n(use '[clojure.data.xml :only [parse-str]])\n\nuser=> (let [xml-text \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n                      <foo key=\\\"val\\\">1<bar>2</bar>3</foo>\"]\n         (let [root (parse-str xml-text)]\n           (xml-seq root)))\n\n({:tag :foo,                                                   \n  :attrs {:key \"val\"},                                         \n  :content (\"1\" {:tag :bar, :attrs {}, :content (\"2\")} \"3\")}   \n \"1\"                                                           \n {:tag :bar, :attrs {}, :content (\"2\")}                        \n \"2\"                                                           \n \"3\")                                                          \n" "(use '[clojure.data.xml :only [parse]])\n\n;; clojure.xml/parse requires string to be ByteArrayInputStream\nuser-> (let [xml-text \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n                      <foo key=\\\"val\\\">1<bar>2</bar>3</foo>\"]\n         (let [input (java.io.ByteArrayInputStream. \n                        (.getBytes xml-text))]\n           (let [root (parse input)]\n             (xml-seq root))))\n\n({:tag :foo,                                                   \n  :attrs {:key \"val\"},                                         \n  :content (\"1\" {:tag :bar, :attrs {}, :content (\"2\")} \"3\")}   \n \"1\"                                                           \n {:tag :bar, :attrs {}, :content (\"2\")}                        \n \"2\"                                                           \n \"3\")" ";; Any breaking news today?\n(require '[clojure.java.io :as io])\n(require '[clojure.xml :as xml])\n\n(def feeds\n [[:guardian  \"https://www.theguardian.com/world/rss\"]\n  [:wash-post \"http://feeds.washingtonpost.com/rss/rss_blogpost\"]\n  [:nytimes \"http://rss.nytimes.com/services/xml/rss/nyt/World.xml\"]\n  [:wsj \"http://www.wsj.com/xml/rss/3_7085.xml\"]\n  [:reuters \"http://feeds.reuters.com/reuters/UKTopNews\"]])\n\n(pmap\n  (fn [[feed url]]\n    (let [content (comp first :content)]\n      [feed\n       (sequence\n         (comp\n           (filter (comp string? content))\n           (filter (comp #{:title} :tag))\n           (filter #(re-find #\"(?i)breaking\" (content %)))\n           (map content))\n         (xml-seq (xml/parse url)))]))\n  feeds)\n\n;; Only a false positive...\n;;([:guardian (\"Climate change 'will push European cities towards breaking point'\")]\n;; [:wash-post ()]\n;; [:nytimes ()]\n;; [:wsj ()]\n;; [:reuters ()])"], :notes nil, :arglists ["root"], :doc "A tree seq on the xml elements as per xml/parse", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/xml-seq"}, :clojure.core/namespace-munge {:added "1.2", :ns "clojure.core", :name "namespace-munge", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 13, :examples [";;; replace \"-\" to \"_\"\nuser=> (namespace-munge \"hello-world\")\n\"hello_world\""], :notes nil, :arglists ["ns"], :doc "Convert a Clojure namespace name to a legal Java package name.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/namespace-munge"}, :clojure.repl/find-doc {:added "1.0", :ns "clojure.repl", :name "find-doc", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 116, :examples ["user=> (find-doc \"data structure\")\n\n-------------------------\nclojure.core/eval\n([form])\n  Evaluates the form data structure (not text!) and returns the result.\n-------------------------\nclojure.core/ifn?\n([x])\n  Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn\n"], :notes nil, :arglists ["re-string-or-pattern"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/find-doc"}, :clojure.core/keyword? {:added "1.0", :ns "clojure.core", :name "keyword?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/simple-keyword? :clojure.core/qualified-keyword?], :line 568, :examples ["<pre>user=> (keyword? x)\r\nfalse\r\nuser=> (keyword? :x)\r\ntrue\r\nuser=> (keyword? true)\r\nfalse</pre>"], :notes nil, :arglists ["x"], :doc "Return true if x is a Keyword", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/keyword_q"}, :clojure.core/> {:added "1.0", :ns "clojure.core", :name ">", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/= :clojure.core/not= :clojure.core/<], :line 1062, :examples ["user=> (> 1 2)\nfalse\nuser=> (> 2 1)\ntrue\nuser=> (> 2 2)\nfalse\nuser=> (> 6 5 4 3 2)\ntrue\nuser=> (sort > (vals {:foo 5, :bar 2, :baz 10}))\n(10 5 2)"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/>"}, :clojure.core.logic/subst-val? {:ns "clojure.core.logic", :name "subst-val?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 202, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/subst-val_q"}, :clojure.core.logic/->Pair {:ns "clojure.core.logic", :name "->Pair", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 43, :examples nil, :notes nil, :arglists ["lhs rhs"], :doc "Positional factory function for class clojure.core.logic.Pair.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->Pair"}, :clojure.core.logic/->LCons {:ns "clojure.core.logic", :name "->LCons", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 755, :examples nil, :notes nil, :arglists ["a d cache meta"], :doc "Positional factory function for class clojure.core.logic.LCons.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->LCons"}, :clojure.set/superset? {:added "1.2", :ns "clojure.set", :name "superset?", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/subset? :clojure.core/set], :line 150, :examples ["(use '[clojure.set :only [superset?]])\n\nuser=> (superset? #{0} #{0})\ntrue\n\nuser=> (superset? #{0 1} #{0})\ntrue\n\nuser=> (superset? #{0} #{0 1}) \nfalse\n" ";; Advice: Do not call superset? with non-set arguments.  If you are\n;; concerned that you may be unintentionally doing so, and want an\n;; exception to be thrown if you do, consider using the library\n;; funjible (https://github.com/jafingerhut/funjible) which provides\n;; its own definition of superset? that is identical to Clojure's,\n;; except it checks the types of its arguments.\n\n;; superset? might or might not return what you expect if you give it\n;; values that are not sets.  The implementation of superset? _does not\n;; check_ whether you are actually giving it values that are sets.  It\n;; _assumes_ so.\n\n;; If the first argument were a set with the same elements, you would\n;; expect the return value false here.\nuser=> (superset? [2 4 6 8] #{1 3})\ntrue\n\n;; Here, if the first argument were a set with the same elements as\n;; the vector, you would expect the return value true.\nuser=> (superset? [1 3 5] #{1 3 5})\nfalse\n\n;; And similarly here:\nuser=> (superset? [\"1\" \"3\" \"5\"] #{\"1\" \"3\"})\nfalse\n\n;; Why not change the definition of superset? so it always throws\n;; an exception if you give it a non-set argument?  I would guess that\n;; the primary reason is that the extra run-time type checks would\n;; slow superset? down by an amount that the Clojure core team does\n;; not want everyone to have to pay on every such call.\n\n;; Related Clojure tickets: \n;; https://dev.clojure.org/jira/browse/CLJ-1953\n;; https://dev.clojure.org/jira/browse/CLJ-2287\n"], :notes nil, :tag "java.lang.Boolean", :arglists ["set1 set2"], :doc "Is set1 a superset of set2?", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/superset_q"}, :clojure.core/*print-dup* {:added "1.0", :ns "clojure.core", :name "*print-dup*", :type "var", :see-alsos nil, :examples [";; `*print-dup*` is very handy when we want to write clojure code/data\n;; to a file to read it in later.\n\n(defn serialize\n  \"Print a data structure to a file so that we may read it in later.\"\n  [data-structure #^String filename]\n  (with-out-writer\n    (java.io.File. filename)\n    (binding [*print-dup* true] (prn data-structure))))\n\n\n;; This allows us to then read in the structure at a later time, like so:\n(defn deserialize [filename]\n  (with-open [r (PushbackReader. (FileReader. filename))]\n    (read r)))\n\n\nuser=> (deserialize \"config.clj\")\n{:name \"Fred\", :age \"23\"}\n"], :notes ["It is sometimes preferable (depending on the size of the structure you're serializing) to wrap the `(with-out-writer ...)` inside a `(dorun (with-out-writer ...) nil)` in order to suppress the output at your REPL." "Note, I'm making changes to deserialize, there are a few typos."], :arglists [], :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-dup*"}, :clojure.core/when {:added "1.0", :ns "clojure.core", :name "when", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/when-not :clojure.core/when-let :clojure.core/if], :line 493, :examples ["user=> (when (= 1 1) true)\ntrue\n\nuser=> (when (not= 1 1) true)\nnil" "user=> (def has-value (when true\n                            (println \"Hello World\")\n                            \"Returned Value\"))\nHello World\n#'user/has-value\n\nuser=> has-value\n\"Returned Value\"\n\n" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";; When is a macro of (if .. do ..)\n\nuser=> (macroexpand '(when 1 2 3 4))\n(if 1 (do 2 3 4))\n\n;; if 1 is true, do will evaluate 2 3 4, but return values of 2 and 3 would be \n;; ignored. Value of 4 (last value) would always be returned. \n;; See https://clojuredocs.org/clojure.core/do for details\n\nuser=> (if 1 (do 2 3 4))\n4\n\n"], :macro true, :notes nil, :arglists ["test & body"], :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/when"}, :clojure.zip/prev {:added "1.0", :ns "clojure.zip", :name "prev", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 246, :examples nil, :notes nil, :arglists ["loc"], :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/prev"}, :clojure.test/test-ns {:added "1.1", :ns "clojure.test", :name "test-ns", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 742, :examples nil, :notes nil, :arglists ["ns"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/test-ns"}, :clojure.core.logic/partial-map? {:ns "clojure.core.logic", :name "partial-map?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2542, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/partial-map_q"}, :clojure.core.logic/umi {:ns "clojure.core.logic", :name "umi", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 741, :examples nil, :macro true, :notes nil, :arglists ["& args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/umi"}, :clojure.core/bound-fn* {:added "1.1", :ns "clojure.core", :name "bound-fn*", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bound-fn], :line 1986, :examples ["(def ^:dynamic *some-var* nil)\n\n(defn f [] (println *some-var*))\n\n;; run f without a new binding\nuser=> (f)\nnil\nnil\n\n;; run f with a new binding\nuser=> (binding [*some-var* \"hello\"]\n         (f))\nhello\nnil\n\n;; run f in a thread with a new binding\nuser=> (binding [*some-var* \"goodbye\"]\n         (.start (Thread. f)))\nnil\nnil\n\n;; run a bound f in a thread with a new binding\nuser=> (binding [*some-var* \"goodbye\"]\n         (.start (Thread. (bound-fn* f))))\ngoodbye\nnil\n"], :notes nil, :arglists ["f"], :doc "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bound-fn*"}, :clojure.core.logic.fd/interval? {:ns "clojure.core.logic.fd", :name "interval?", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 351, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval_q"}, :clojure.core.reducers/reduce {:ns "clojure.core.reducers", :name "reduce", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 71, :examples nil, :notes nil, :arglists ["f coll" "f init coll"], :doc "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/reduce"}, :clojure.core.logic/succeed {:ns "clojure.core.logic", :name "succeed", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1140, :examples nil, :notes nil, :arglists ["a"], :doc "A goal that always succeeds.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/succeed"}, :clojure.core.logic/assoc-meta {:ns "clojure.core.logic", :name "assoc-meta", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 24, :examples nil, :notes nil, :arglists ["x k v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/assoc-meta"}, :clojure.core.logic/run* {:ns "clojure.core.logic", :name "run*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1242, :examples nil, :macro true, :notes nil, :arglists ["bindings & goals"], :doc "Executes goals until results are exhausted.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run*"}, :clojure.core/Throwable->map {:added "1.7", :ns "clojure.core", :name "Throwable->map", :file "clojure/core_print.clj", :type "function", :column 1, :see-alsos [:clojure.core/ex-data], :line 471, :examples ["(def trace (try (/ 1 0) (catch Throwable t (Throwable->map t))))\n(keys trace)\n;; (:cause :via :trace)\n(:cause trace)\n;; \"Divide by zero\"\n(count (:trace trace))\n;; 33 (this stack trace is 33 invocations deep) "], :notes nil, :arglists ["o"], :doc "Constructs a data representation for a Throwable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/Throwable->map"}, :clojure.core/pr-str {:added "1.0", :ns "clojure.core", :name "pr-str", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pr :clojure.core/read-string :clojure.core/prn-str :clojure.core/str], :line 4702, :examples ["user=> (def x [1 2 3 4 5])\n#'user/x\nuser=> x\n[1 2 3 4 5]\n\n\n;; Turn that data into a string...\nuser=> (pr-str x)\n\"[1 2 3 4 5]\"\n\n\n;; ...and turn that string back into data!\nuser=> (read-string (pr-str x))\n[1 2 3 4 5]\n" ";; you can think of pr-str as the inverse of read-string\n;; turn string into symbols\nuser=> (read-string \"(a b foo :bar)\")\n(a b foo :bar)\n\n;;turn symbols into a string\nuser=> (pr-str '(a b foo :bar))\n\"(a b foo :bar)\"" "(defn write-object\n  \"Serializes an object to disk so it can be opened again later.\n   Careful: It will overwrite an existing file at file-path.\"\n  [obj file-path]\n    (with-open [wr (writer file-path)]\n      (.write wr (pr-str obj)))))" ";; Be careful with side-effects that are part of lazy sequences.\n;; Especially printing can yield unexpected results.\nuser=> (->> (range 10)\n            (map #(do (println %) %))\n            (pr-str))\n\n\"(0\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n0 1 2 3 4 5 6 7 8 9)\"\n" ";; sometimes when printing lazy sequences you do not get what you want.\n(str (take 5 (range 10)))\n;=> \"clojure.lang.LazySeq@1b554e1\"\n\n;; in those cases `pr-str` to the rescue.\n(pr-str (take 5 (range 10)))\n;=> \"(0 1 2 3 4)\"" ";; Be aware that pr-str and friends are influenced by a couple global variables\n;; such as *print-length*:\n\n(set! *print-length* 10)\n(pr-str (range 15))\n;=> \"(0 1 2 3 4 5 6 7 8 9 ...)\"\n\n(set! *print-length* -1)\n(pr-str (range 15))\n;=> \"(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\""], :notes nil, :tag "java.lang.String", :arglists ["& xs"], :doc "pr to a string, returning it", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pr-str"}, :clojure.core.async/ioc-alts! {:ns "clojure.core.async", :name "ioc-alts!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 378, :examples nil, :notes nil, :arglists ["state cont-block ports & {:as opts}"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/ioc-alts!"}, :clojure.core.async/pipeline {:ns "clojure.core.async", :name "pipeline", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/pipeline-async :clojure.core.async/pipeline-blocking], :line 536, :examples [";; SIMPLE EXAMPLE -----------------------\n\n(def ca (chan 1))\n(def cb (chan 1))\n\n(pipeline\n 4               ; thread count, i prefer egyptian cotton\n cb              ; to\n (filter even?)  ; transducer\n ca              ; from\n )\n\n(doseq [i (range 10)]\n  (go (>! ca i)))\n(go-loop []\n  (println (<! cb))\n  (recur))\n\n;; => prints even numbers in 0-10, note: not necessarily in order\n\n\n\n" ";; EXTENDED EXAMPLE ---------------------------\n\n(def ca (chan 1))\n(def cb (chan 1))\n\n(pipeline\n 4               \n cb             \n (filter (fn [x]\n           (if (> x 100)\n             (throw (Throwable. \"too big!\"))\n             (even? x))))           \n ca              \n false           ; should it close when `from` runs out?\n (fn [error] (println \"ahhh: \" (.getMessage error))))\n\n\n(doseq [i (range 10)]\n  (go (>! ca i)))\n(go-loop []\n  (println (<! cb))\n  (recur))\n; (go (>! ca 101)) ; this one throws an error\n"], :notes nil, :arglists ["n to xf from" "n to xf from close?" "n to xf from close? ex-handler"], :doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the transducer xf, with parallelism n. Because\n  it is parallel, the transducer will be applied independently to each\n  element, not across elements, and may produce zero or more outputs\n  per input.  Outputs will be returned in order relative to the\n  inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. Note this\n  should be used for computational parallelism. If you have multiple\n  blocking operations to put in flight, use pipeline-blocking instead,\n  If you have multiple asynchronous operations to put in flight, use\n  pipeline-async instead.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/pipeline"}, :clojure.core.async/mapcat< {:ns "clojure.core.async", :name "mapcat<", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1102, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["f in" "f in buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/mapcat<"}, :clojure.core.logic/solutions {:ns "clojure.core.logic", :name "solutions", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1279, :examples nil, :notes nil, :arglists ["s g" "s q g"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/solutions"}, :clojure.test/get-possibly-unbound-var {:added "1.1", :ns "clojure.test", :name "get-possibly-unbound-var", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 415, :examples nil, :notes nil, :arglists ["v"], :doc "Like var-get but returns nil if the var is unbound.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/get-possibly-unbound-var"}, :clojure.string/re-quote-replacement {:added "1.5", :ns "clojure.string", :name "re-quote-replacement", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/replace], :line 54, :examples [";; Special characters are escaped\n\n(use '[clojure.string :only (re-quote-replacement)])\n\nuser=> (re-quote-replacement \"string \\\\ $\")\n\"string \\\\\\\\ \\\\$\"" ";; Use with s/replace to prevent unwanted reference\n;; to matching groups (i.e. $1, $2 etc.)\n\n(require '[clojure.string :as s])\n(def s \"May 2018, June 2019\")\n(s/replace s #\"May|June\" \"10$\") ;; IllegalArgumentException\n(s/replace s #\"May|June\" (s/re-quote-replacement \"10$ in\"))\n;; \"1$ in 2018, 1$ in 2019\""], :notes nil, :tag "java.lang.String", :arglists ["replacement"], :doc "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/re-quote-replacement"}, :clojure.zip/insert-left {:added "1.0", :ns "clojure.zip", :name "insert-left", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/insert-right], :line 183, :examples [";;; zip is not default required in clj\n(require '[clojure.zip :as zip])\n\n(def root-tree (zip/seq-zip '(:root (:1st-left-child ) (:1st-right-child\n))))\n\n;;; get the location , in this case is the root of the tree\n(def location (-> root-tree zip/next))\n\n\n(zip/insert-left location :inserted)\n\n;;; then the :inserted is on the left of the original tree\n;;;=>[:root\n;;; {:changed? true,\n;;;  :l [:inserted],\n;;;  :pnodes [(:root (:1st-left-child) (:1st-right-child))],\n;;;  :ppath nil,\n;;;  :r ((:1st-left-child) (:1st-right-child))}]"], :notes nil, :arglists ["loc item"], :doc "Inserts the item as the left sibling of the node at this loc,\n without moving", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/insert-left"}, :clojure.core/drop-while {:added "1.0", :ns "clojure.core", :name "drop-while", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/take-while :clojure.core/split-with :clojure.core/some], :line 2944, :examples [";; Note: Documentation should be \"starting from the first item for which\n;; (pred item) returns logical false, i.e. either of the values false or nil.\n\nuser=> (drop-while neg? [-1 -2 -6 -7 1 2 3 4 -5 -6 0 1])\n(1 2 3 4 -5 -6 0 1)\n" "(def my-vec [1 2 3 4 5 6])\n\n(drop-while #(> 3 %) my-vec)\n;;(3 4 5 6)\n\n(drop-while #(>= 3 %) my-vec)\n;;(4 5 6)\n\n;;Returns a lazy sequence of the items in coll starting from the\n;;first item for which (pred item) returns logical FALSE"], :notes ["The description of this function is throwing me off. I think it should say: returns a sequence of items from `coll` dropping the initial items that evaluate to true when passed to `pred`, once a non-true value is encountered, the rest of the list is returned."], :arglists ["pred" "pred coll"], :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/drop-while"}, :clojure.core/use {:added "1.0", :ns "clojure.core", :name "use", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/refer :clojure.core/require :clojure.core/ns :clojure.core/import], :line 6013, :examples [";; Use the namespace clojure.java.io:\nuser=> (use '(clojure.java io))\n\n" ";; Imports only the split function from clojure.string.\nuser=> (use '[clojure.string :only (split)])\nnil\n\n;; split is now available without a namespace qualification.\nuser=> (split \"hello world\" #\" \")\n[\"hello\" \"world\"]\n\n;; You can also add the :as keyword to import the rest of clojure.string\n;; with a namespace qualification.\nuser=> (use '[clojure.string :as s :only (split)])\nnil\n\n;; Now we can access any function in clojure.string using s.\nuser=> (s/replace \"foobar\" \"foo\" \"squirrel\")\n\"squirrelbar\"\n\n;; And we can still call split with or without the s qualification.\nuser=> (split \"hello world\" #\" \")\n[\"hello\" \"world\"]\nuser=> (s/split \"hello world\" #\" \")\n[\"hello\" \"world\"]" "(ns some.namespace\n  (:require [clojure.contrib.json :as json])\n  (:use [clojure.string :only [trim lower-case split]]\n        [clojure.contrib.shell-out]\n        [clojure.pprint]\n        [clojure.test]))\n" ";; use accepts other keywords from require that aren't listed in the docstring.\n\n;; If you try to load a namespace, and it fails to load due to an error in\n;; the source code, when you load it again after fixing the problem, you\n;; can get a \"namespace not found\" exception.  Use :reload to avoid this:\n(use '[my.namespace] :reload)\n\n;; However, if the error was in source for a namespace required or used\n;; from my.namespace, you'll get the \"namespace not found\" exception\n;; after fixing the problem, even using :reload.  Use :reload-all to avoid this:\n(use '[my.namespace] :reload-all)\n\n;; You can also use :verbose, which does what you would think it would do:\n(use '[my.namespace] :verbose)"], :notes ["Good description of use/require/import here:\r\n\r\nhttp://blog.8thlight.com/articles/2010/12/6/clojure-libs-and-namespaces-require-use-import-and-ns" "http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html"], :arglists ["& args"], :doc "Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/use"}, :clojure.core.logic/->SuspendedStream {:ns "clojure.core.logic", :name "->SuspendedStream", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1849, :examples nil, :notes nil, :arglists ["cache ansv* f"], :doc "Positional factory function for class clojure.core.logic.SuspendedStream.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->SuspendedStream"}, :clojure.core/rational? {:added "1.0", :ns "clojure.core", :name "rational?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3604, :examples ["user=> (rational? 1)\ntrue\nuser=> (rational? 1.0)\nfalse\nuser=> (class 1.0)\njava.lang.Double\n\n;; Note that decimal? only returns true if n is a BigDecimal." ";; Both True\nuser=> (ratio? 22/7) \n;; => true\nuser=> (rational? 22/7)\n;; => true\n\n;; Different\nuser=> (ratio? 22)\n;; => false\nuser=> (rational? 22)\n;; => true\n\n;; Both False\nuser=> (ratio? 0.5)\n;; => false\nuser=> (rational? 0.5)\n;; => false"], :notes nil, :arglists ["n"], :doc "Returns true if n is a rational number", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rational_q"}, :clojure.repl/pst {:added "1.3", :ns "clojure.repl", :name "pst", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos [:clojure.core/*e], :line 241, :examples ["user=> (pst)\nnil\n\nuser=> (/ 1 0)\nArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:156)\n\nuser=> (pst)\nArithmeticException Divide by zero\n\tclojure.lang.Numbers.divide (Numbers.java:156)\n\tclojure.lang.Numbers.divide (Numbers.java:3691)\n\tuser/eval13 (NO_SOURCE_FILE:7)\n\tclojure.lang.Compiler.eval (Compiler.java:6619)\n\tclojure.lang.Compiler.eval (Compiler.java:6582)\n\tclojure.core/eval (core.clj:2852)\n\tclojure.main/repl/read-eval-print--6588/fn--6591 (main.clj:259)\n\tclojure.main/repl/read-eval-print--6588 (main.clj:259)\n\tclojure.main/repl/fn--6597 (main.clj:277)\n\tclojure.main/repl (main.clj:277)\n\tclojure.main/repl-opt (main.clj:343)\n\tclojure.main/main (main.clj:441)\nnil\n"], :notes nil, :arglists ["" "e-or-depth" "e depth"], :doc "Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/pst"}, :clojure.core.async/alts!! {:ns "clojure.core.async", :name "alts!!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/alts! :clojure.core.async/alt! :clojure.core.async/alt!!], :line 265, :examples ["user> (let [chans (partition-all 2\n                                 (interleave\n                                  [\"Bob\"\n                                   \"Jane\"\n                                   \"GuyGirl22\"]\n                                  (for [_ (range 3)]              \n                                    (chan))))\n            [owner port] (rand-nth chans)\n            chans-only (mapv second chans)]\n        \n        (go\n          (<! (timeout 1500))\n          (>! port\n              (str owner \": First!!!\")))\n\n        (let [[v p] (alts!! chans-only)]\n          (println \"Message: \" v \"\\nFrom Object: \" p)))\n\n;; Message:  Bob: First!!! \n;; From Object:  #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@70c61ad7>\n;; nil\n" "(require '[clojure.core.async :as async])\n\n;; n.b. alts!! returns a *pair* of [value channel-where-value-came-from]\n\n; a channel with a single value ready in the queue\n(def c (async/chan))\n(async/put! c \"foo\")\n\n(println (async/alts!! [(async/timeout 2000) c]))\n;; => [\"foo\" <c-channel>]\n\n; no more values, so we will timeout\n(println (async/alts!! [(async/timeout 2000) c]))\n;; => [nil <timeout-channel>]\n"], :notes nil, :arglists ["ports & {:as opts}"], :doc "Like alts!, except takes will be made as if by <!!, and puts will\n  be made as if by >!!, will block until completed, and not intended\n  for use in (go ...) blocks.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/alts!!"}, :clojure.instant/parse-timestamp {:ns "clojure.instant", :name "parse-timestamp", :file "clojure/instant.clj", :type "var", :column 1, :see-alsos nil, :line 50, :examples nil, :notes nil, :arglists [], :doc "Parse a string containing an RFC3339-like like timestamp.\n\nThe function new-instant is called with the following arguments.\n\n                min  max           default\n                ---  ------------  -------\n  years          0           9999      N/A (s must provide years)\n  months         1             12        1\n  days           1             31        1 (actual max days depends\n  hours          0             23        0  on month and year)\n  minutes        0             59        0\n  seconds        0             60        0 (though 60 is only valid\n  nanoseconds    0      999999999        0  when minutes is 59)\n  offset-sign   -1              1        0\n  offset-hours   0             23        0\n  offset-minutes 0             59        0\n\nThese are all integers and will be non-nil. (The listed defaults\nwill be passed if the corresponding field is not present in s.)\n\nGrammar (of s):\n\n  date-fullyear   = 4DIGIT\n  date-month      = 2DIGIT  ; 01-12\n  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                            ; month/year\n  time-hour       = 2DIGIT  ; 00-23\n  time-minute     = 2DIGIT  ; 00-59\n  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                            ; rules\n  time-secfrac    = '.' 1*DIGIT\n  time-numoffset  = ('+' / '-') time-hour ':' time-minute\n  time-offset     = 'Z' / time-numoffset\n\n  time-part       = time-hour [ ':' time-minute [ ':' time-second\n                    [time-secfrac] [time-offset] ] ]\n\n  timestamp       = date-year [ '-' date-month [ '-' date-mday\n                    [ 'T' time-part ] ] ]\n\nUnlike RFC3339:\n\n  - we only parse the timestamp format\n  - timestamp can elide trailing components\n  - time-offset is optional (defaults to +00:00)\n\nThough time-offset is syntactically optional, a missing time-offset\nwill be treated as if the time-offset zero (+00:00) had been\nspecified.\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.instant/parse-timestamp"}, :clojure.core/float {:added "1.0", :ns "clojure.core", :name "float", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-float], :line 3478, :examples ["(float 1)\n;;=> 1.0\n(float 1.11)\n;;=> 1.11\n(float 1.111111111111111111111111111M)\n;;=> 1.1111112\n\n;;;; Note that (float) range checks its argument and throws an exception\n;;;; if the value is out of range.\n;;;; Use (unchecked-float) instead if you want to skip the range checks.\n\n(float Double/MAX_VALUE)\n;;=> IllegalArgumentException Value out of range for float: 1.7976931348623157E308\n(unchecked-float Double/MAX_VALUE)\n;;=> Infinity\n"], :notes nil, :arglists ["x"], :doc "Coerce to float", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/float"}, :clojure.core/ns {:added "1.0", :ns "clojure.core", :name "ns", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/use :clojure.core/require :clojure.core/refer :clojure.core/import :clojure.core/ns-publics :clojure.core/in-ns :clojure.core/remove-ns :clojure.core/ns-map :clojure.core/*ns*], :line 5704, :examples [";; Generate a Java class\n(ns org.clojuredocs.test\n      (:gen-class))\n\n(defn -main [] (println \"Hello, World!\"))\n\n\n;; After compilation:\nsh$ java -cp classes org.clojuredocs.test\nHello, World!\n" ";; Let's create a namespace and then assign it as the current namespace\nuser=> (create-ns 'my-new-namespace)\n#namespace[my-new-namespace]\n\nuser=> (ns 'my-new-namespace)\njava.lang.ClassCastException: clojure.lang.PersistentList cannot be cast to\n clojure.lang.Symbol (NO_SOURCE_FILE:26)\n;; oops, this is not the way to do it; if create-ns needs a symbol, ns does not\n\nuser=> (ns my-new-namespace)\nnil\n\nmy-new-namespace=>\n;; it worked as the current namespace is our newly created one\n\n" ";; Generating a class so we can call Clojure from Java \n(ns com.domain.tiny\n  (:gen-class\n    :name com.domain.tiny\n    :methods [#^{:static true} [binomial [int int] double]]))\n\n(defn binomial\n  \"Calculate the binomial coefficient.\"\n  [n k]\n  (let [a (inc n)]\n    (loop [b 1\n           c 1]\n      (if (> b k)\n        c\n        (recur (inc b) (* (/ (- a b) b) c))))))\n\n(defn -binomial\n  \"A Java-callable wrapper around the 'binomial' function.\"\n  [n k]\n  (binomial n k))\n\n(defn -main []\n  (println (str \"(binomial 5 3): \" (binomial 5 3)))\n  (println (str \"(binomial 10042 111): \" (binomial 10042 111))))\n\n\n;; Calling from Java\nimport com.domain.tiny;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"(binomial 5 3): \" + tiny.binomial(5, 3));\n        System.out.println(\"(binomial 10042, 111): \" + tiny.binomial(10042, 111));\n    }\n}\n\n\n;; The result was:\n(binomial 5 3): 10.0\n(binomial 10042, 111): 4.9068389575068143E263\n\n\n;; Example was borrowed from clartaq @ Stack Overflow" ";; Create a namespace named demo.namespace.\n(ns demo.namespace)\n\n;; Clojure recommends namespaces be at least \"two segments\" (ie, they should\n;; have at least one '.') otherwise it will create a class in the \"default\n;; package\", which is discouraged.\n\n;; If this declaration appears in a file named \"demo/namespace.clj\" present\n;; in your classpath, it is known as a \"lib\", \"demo/namespace.clj\" is the lib's\n;; \"root resource\". See http://clojure.org/libs\n\n;; From a clean repl you can load the lib using\nuser=>(require 'demo.namespace) \n; or\nuser=>(use 'demo.namespace)" ";; This example will illustrate changing between namespaces at the repl\n\n;; At the repl, the ns macro can be used to create a namespace, but it is\n;; used to change the current namespace (be careful of typos)\nuser=>(ns demo.namespace)\nnil\ndemo.namespace=> ; The prompt at the repl is now \"demo.namespace\" reflecting\n                 ; that the current namespace is no longer \"user\".\n\n;; Add a new function to demo.namespace\ndemo.namespace=>(defn foo [] (prn \"Hello from demo.namespace\"))\n#'demo.namespace/foo\n\n;; From within \"demo.namespace\" we can use foo without qualifying it\ndemo.namespace=>(foo)\n\"Hello from demo.namespace\"\nnil\n\n;; Switch back to the \"user\" namespace\ndemo.namespace=>(ns user)\nnil\n\n;; We can no longer use \"foo\" without qualification\nuser=> (foo)\njava.lang.Exception: Unable to resolve symbol: foo in this context\n (NO_SOURCE_FILE:4)\n\nuser=> (demo.namespace/foo)\n\"Hello from demo.namespace\"\nnil\n\n;; The public symbols of \"demo.namespace\" can be \"referred into\" the \"user\"\n;; namespace if desired\nuser=> (refer 'demo.namespace)\nnil\n\n;; foo is now an alias in the \"user\" namespace which refers to the\n;; \"demo.namespace/foo\" symbol\nuser=> (foo)\n\"Hello from demo.namespace\"\nnil" "(ns rosettacode.24game\n  (:require [clojure.string :as str])\n  (:use clojure.test))\n\n(deftest test\n (is (= \"ABC\" (str/capitalize \"abc\")))" ";; Multiple required namespaces with aliases\n(ns demo.namespace\n  (:require [com.example.httplib :as httplib]\n            [com.example.otherlib :as otherlib]))\n" ";; In clojure 1.4 and higher you can use the refer function from within\n;; a require which is equivalent to (:use foo only [...]) but still \n;; allows you to reference the required namespace:\n(ns my.ns.example\n    (:require [my.lib :refer [function1 function2]]))\n\n;; And :refer :all is equivalent to :use :\n(ns my.ns.example\n    (:require [my.lib :refer :all]))\n" "(ns foo.bar\n  (:refer-clojure :exclude [ancestors printf])\n  (:require [clojure.contrib sql sql.tests])\n  (:use [my.lib this that])\n  (:import [java.util Date Timer Random]\n    (java.sql Connection Statement)))" "; Gotchas\n(ns newns1 [:require clojure.string])\n; newns1=> nil ; Success\n; Note use of vector instead of list - ns macro successfuly processes it \n; but some tools that read this code might not recognize this dependency.\n; Always write ns as per documentation.\n\n(in-ns 'newns2)\n; newns2=> #object[clojure.lang.Namespace 0x29a8c1fb \"newns2\"]\n; New namespace was successfully created\n(first [])\n; newns2=> CompilerException java.lang.RuntimeException: \n;          Unable to resolve symbol: first in this context, \n;          compiling:(NO_SOURCE_PATH:7:1) \n; Although \"first\" is in core library, it's name is not available here. \n; To fix this do\n(clojure.core/refer-clojure)\n; newns2=> nil\n(first [])\n; newns2=> nil ; Success\n\n; \"ns\" macro both switches to a namespace and refers default library, \n; \"in-ns\" just switches to given namespace\n(ns newns3)\n; newns3=> nil\n(first [])\n; newns3=> nil\n" ";; Shows how to use an attr-map\n;; These are arbitrary key-value pairs\n(ns cljdocs.example.core\n  \"This is a doc string, FYI :D\"\n  {:author \"John Doe\"\n   :last-update-date \"23-10-2017\"})\n=> nil\n\n;; The keys in the attr-map are merged with the compiler-generated attr-map\n(meta *ns*)\n=> {:doc \"This is a doc string, FYI :D\", :author \"John Doe\", :last-update-date \"23-10-2017\"}\n"], :macro true, :notes ["Good description of use/require/import here:\r\n\r\nhttp://blog.8thlight.com/articles/2010/12/6/clojure-libs-and-namespaces-require-use-import-and-ns"], :arglists ["name docstring? attr-map? references*"], :doc "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns"}, :clojure.core.reducers/take-while {:added "1.5", :ns "clojure.core.reducers", :name "take-while", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 222, :examples nil, :notes nil, :arglists ["pred" "pred coll"], :doc "Ends the reduction of coll when (pred val) returns logical false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/take-while"}, :clojure.core.logic.fd/multi-interval {:ns "clojure.core.logic.fd", :name "multi-interval", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 573, :examples nil, :notes nil, :arglists ["" "i0" "i0 i1" "i0 i1 & ir"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/multi-interval"}, :clojure.core.logic/dissoc-dom {:ns "clojure.core.logic", :name "dissoc-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 33, :examples nil, :notes nil, :arglists ["x k"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/dissoc-dom"}, :clojure.main/load-script {:ns "clojure.main", :name "load-script", :file "clojure/main.clj", :type "function", :column 1, :see-alsos [:clojure.core/read-string :clojure.edn/read-string], :line 271, :examples [";; In file /some/path/to-script.clj\n;; (ns test)\n;; \n;; (defn greet [name]\n;;    (str \"Hello \" name))\n\n;; from repl\nuser=> (clojure.main/load-script \"/some/path/to-script.clj\")\n#'test/greet\nuser=> (greet \"Peter\")\n\"Hello Peter\"\n\n;; to load hello.clj from current directory\nuser=> (clojure.main/load-script \"hello.clj\")\n\n;; to load some-code.clj from class path\nuser=> (clojure.main/load-script \"@some-code.clj\")\n"], :notes nil, :arglists ["path"], :doc "Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/load-script"}, :clojure.core.logic/stopcg {:ns "clojure.core.logic", :name "stopcg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2057, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/stopcg"}, :clojure.core/apply {:added "1.0", :ns "clojure.core", :name "apply", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map :clojure.core/eval :clojure.template/apply-template :clojure.core/reduce], :line 652, :examples ["(def *strings* [\"str1\" \"str2\" \"str3\"])\n;; #'user/*strings*\n\n;; Oops!\n(str *strings*)\n;;=> \"[\\\"str1\\\" \\\"str2\\\" \\\"str3\\\"]\"\n\n;; Yay!\n(apply str *strings*)\n;;=> \"str1str2str3\"\n\n;; Note the equivalence of the following two forms\n(apply str [\"str1\" \"str2\" \"str3\"])  ;;=> \"str1str2str3\"\n(str \"str1\" \"str2\" \"str3\")          ;;=> \"str1str2str3\"\n" ";; If you were to try\n(max [1 2 3])\n;;=> [1 2 3]\n\n;; You would get '[1 2 3]' for the result. In this case, 'max' has received one\n;; vector argument, and the largest of its arguments is that single vector.\n\n;; If you would like to find the largest item **within** the vector, you would need\n;; to use `apply`\n\n(apply max [1 2 3])\n;;=> 3\n\n;; which is the same as \n(max 1 2 3)\n;;=> 3\n" ";; Here's an example that uses the optional second argument, args:\n\n(apply map vector [[:a :b] [:c :d]])\n;;=> ([:a :c] [:b :d])\n\n;; In this example, 'f' = 'map', 'args' = 'vector', and argseq = '[:a :b] [:c :d]',\n;; making the above code equivalent to\n\n(map vector [:a :b] [:c :d])\n;;=> ([:a :c] [:b :d]) ;Same answer as above\n\n;; It might help to think of 'map' and 'vector' as \"slipping inside\" the argument\n;; list ( '[[:a :b] [:c :d]]' ) to give '[map vector [:a :b] [:c :d]]' , which \n;; then becomes the executable form '(map vector [:a :b] [:c :d])' ." ";; only functions can be used with apply.  'and' is a macro\n;; because it needs to evaluate its arguments lazily and so\n;; does not work with apply.\n(apply and (list true true false true)\n;; RuntimeException : cannot take value of a macro\n\n;; This can be circumvented with another macro.\n;; But understand what is happening\n;; http://stackoverflow.com/questions/5531986/treat-clojure-macro-as-a-function\n(defmacro make-fn [m] \n `(fn [& args#]\n    (eval \n      (cons '~m args#))))\n\n(apply (make-fn and) '(true true false true))\n;;=> false\n\n" ";; 'apply' is used to apply an operator to its operands. \n(apply + '(1 2))  ; equivalent to (+ 1 2)\n;;=> 3\n\n\n;; You can also put operands before the list of \n;; operands and they'll be consumed in the list of operands\n\n(apply + 1 2 '(3 4))  ; equivalent to (apply + '(1 2 3 4))\n;;=> 10" ";; You can use map and apply together to drill one level deep in a collection\n;; of collections, in this case returning a collection of the max of each\n;; nested collection\n\n(map #(apply max %) [[1 2 3][4 5 6][7 8 9]])\n;;=> (3 6 9)" ";; Using `apply` with optional keyword parameters:\n\n(defn add2 [a & {:keys [plus] :or {plus 0}}]\n  (+ 2 plus a))\n\n(add2 4)                    ; => 6\n(add2 4 :plus 1)            ; => 7\n(apply add2 [4])            ; => 6\n(apply add2 [4 {:plus 1}])  ; => IllegalArgumentException\n(apply add2 [4 :plus 1])    ; => 7\n" ";; Transpose a matrix\n(def A [[1 2]\n        [3 4]])\n\n(apply map vector A) ;  ([1 3] [2 4])\n" ";; Use apply to map a function over a collection of pairs of arguments\n\n(map (partial apply +) [[1 2] [3 4]]) ; => (3 7)\n\n;; this is equivalent to '((+ 1 2) (+ 3 4))" "; Remove elements from a set with disj\n\n(disj #{1 2 3} 2 3) \n=> #{1}\n\n; Relative complement of two sets (difference)\n\n(apply disj #{2 3 4} #{1 2 3})\n=> #{4}\n\n; the above is same as calling\n(disj #{2 3 4} 1 2 3)" ";;practical example\n\n(def entries [{:month 1 :val 12}\n              {:month 2 :val 3}\n              {:month 3 :val 32}\n              {:month 4 :val 18}\n              {:month 5 :val 32}\n              {:month 6 :val 62}\n              {:month 7 :val 12}\n              {:month 8 :val 142}\n              {:month 9 :val 52}\n              {:month 10 :val 18}\n              {:month 11 :val 23}\n              {:month 12 :val 56}])\n\n(apply max (map\n            #(:val %)\n            entries))\n;;return 142\n;;this translates into (max 12 3 32 18 32 62 12 142 52 18 23 56)" "(apply + [2 3 4])\n;;9\n\n(apply + 1 [2 3 4])\n;;10\n\n(apply max [1 3 2])\n;;3\n\n(apply max 4 [1 3 2])\n;;4\n\n(apply str [\"a\" \"b\" \"c\"])\n;;\"abc\"\n\n(apply str \"d\" [\"a\" \"b\" \"c\"])\n;;\"dabc\"" "(reduce #(apply assoc %1 %2) {} [[:a 1] [:b 2]])\n\n;;{:a 1, :b 2}"], :notes ["The first example on the page, does not work on the REPL. It gives the following error: \n<pre> (def *strings* [\"str1\" \"str2\" \"str3\"])\" </pre>\n\n*Warning: *strings* not declared dynamic and thus is not dynamically rebindable, but its name suggests otherwise. Please either indicate ^:dynamic *strings* or change the name.*\n\nShould this be prefixed by - \"^:dynamic\"?\n" "It looks like apply when used with a lazy sequence forces the realization of the first four elements.\n\n```\n(take 1\n      (apply concat\n             (repeatedly #(do\n                            (println \"called\")\n                            (range 1 10)))))\n\n=> \"called\"\n=> \"called\"\n=> \"called\"\n=> \"called\"\n```\n\nSee: https://stackoverflow.com/questions/51959298/clojure-apply-that-does-not-realize-the-first-four-elements-of-a-lazy-sequence"], :arglists ["f args" "f x args" "f x y args" "f x y z args" "f a b c d & args"], :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/apply"}, :clojure.spec.alpha/every-impl {:ns "clojure.spec.alpha", :name "every-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1192, :examples nil, :notes nil, :arglists ["form pred opts" "form pred {conform-into :into, describe-form :clojure.spec.alpha/describe, :keys [kind :clojure.spec.alpha/kind-form count max-count min-count distinct gen-max :clojure.spec.alpha/kfn :clojure.spec.alpha/cpred conform-keys :clojure.spec.alpha/conform-all], :or {gen-max 20}, :as opts} gfn"], :doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/every-impl"}, :clojure.core/re-matcher {:added "1.0", :ns "clojure.core", :name "re-matcher", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-find], :line 4789, :examples ["user=> (def *matcher* (re-matcher #\"\\d+\" \"abc12345def\"))\n#'user/*matcher*\n\nuser=> (re-find *matcher*)\n\"12345\""], :notes ["17:44 < mearnsh> tsdh: re-matcher should be avoided because the Matcher object it returns mutates in a non-thread-safe way" "It's fine to use from a controlled context. For instance, if you have a let that creates a Matcher, pulls out groups, and returns the data, you're working in a single-threaded context and the mutable object never even escapes.\n"], :tag "java.util.regex.Matcher", :arglists ["re s"], :doc "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-matcher"}, :clojure.xml/tag {:ns "clojure.xml", :name "tag", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :line 22, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/tag"}, :clojure.core.logic.fd/-ub {:ns "clojure.core.logic.fd", :name "-ub", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-ub"}, :clojure.core.logic/onceo {:ns "clojure.core.logic", :name "onceo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1434, :examples nil, :notes nil, :arglists ["g"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/onceo"}, :clojure.core.async/do-alts {:ns "clojure.core.async", :name "do-alts", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 236, :examples nil, :notes nil, :arglists ["fret ports opts"], :doc "returns derefable [val port] if immediate, nil if enqueued", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/do-alts"}, :clojure.spec.alpha/coll-of {:ns "clojure.spec.alpha", :name "coll-of", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos [:clojure.spec.alpha/map-of :clojure.spec.alpha/every], :line 558, :examples ["(def suit? #{:heart :diamond :club :spade})\n(def rank?\n  (into #{:ace :king :queen :jack} (range 2 11)))\n\n(def deck (for [s suit? r rank?] [s r])) \n\n(s/def ::card (s/tuple suit? rank?)) \n(s/def ::deck (s/coll-of ::card :distinct true :into [] :count 52)))\n"], :macro true, :notes nil, :arglists ["pred & opts"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  'every', coll-of will exhaustively conform every value.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  See also - every, map-of", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/coll-of"}, :clojure.core/underive {:added "1.0", :ns "clojure.core", :name "underive", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/derive], :line 5604, :examples [";; create a simple hierarchy using the global hierarchy\n;; and demonstrate how underive is used\n\nuser=> (derive ::dog ::animal)\nnil\nuser=> (derive ::spaniel ::dog)\nnil\nuser=> (derive ::tabby ::dog)\nnil\nuser=> (ancestors ::tabby)\n#{:user/dog :user/animal}\nuser=> (underive ::tabby ::dog)\nnil\nuser=> (ancestors ::tabby)\nnil"], :notes nil, :arglists ["tag parent" "h tag parent"], :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/underive"}, :clojure.core.logic.fd/+ {:ns "clojure.core.logic.fd", :name "+", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 900, :examples nil, :notes nil, :arglists ["x y sum"], :doc "A finite domain constraint for addition and subtraction.\n   x, y & sum must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/+"}, :clojure.core/lazy-cat {:added "1.0", :ns "clojure.core", :name "lazy-cat", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/lazy-seq :clojure.core/concat :clojure.core/conj], :line 4580, :examples ["user=> (lazy-cat [1 2 3] [4 5 6])\n(1 2 3 4 5 6)\n" ";; N.B. this example holds onto the head of a lazy seq which should generally be avoided\n(def fib-seq\n     (lazy-cat [0 1] (map + (rest fib-seq) fib-seq)))\n\n(take 10 fib-seq)" ";; When the producer function produces a collection, not an element,\n;; lazy-cat is usable.\nuser=> (defn n-repeat [n] (lazy-cat (repeat n n) (n-repeat (inc n))))\n#'user/n-repeat\n\nuser=> (take 6 (n-repeat 1))\n(1 2 2 3 3 3)\n\nuser=> (take 12 (n-repeat 1))\n(1 2 2 3 3 3 4 4 4 4 5 5)\n" "(lazy-cat (seq [\"lazy-cat\" \"is\" \"my\" \"favorite\" \"function\"]))" "user=> (defn loop-endlessly\n         \"Block thread with endless loop when evaluated\"\n         []\n         (while true))\n#'user/loop-endlessly\n\nuser=> (take 3 (lazy-cat [\"will\" \"it\" \"return?\"] (loop-endlessly)))\n(\"will\" \"it\" \"return?\")\n\nuser=> (take 4 (lazy-cat [\"will\" \"it\" \"return?\"] (loop-endlessly)))\n;; This gets stuck on loop-endlessly and never returns" ";; Prefer lazy-cat to build a lazy seq out of \n;; non-lazy collections with different creation costs\n\n(time (first (concat (sort > (range 10)) (sort > (range 1e7)))))\n;; \"Elapsed time: 17442.084309 msecs\"\n(time (first (lazy-cat (sort > (range 10)) (sort > (range 1e7)))))\n;; \"Elapsed time: 0.458283 msecs\""], :macro true, :notes ["It looks like `lazy-cat` is on deprecation path in favor of `lazy-seq`."], :arglists ["& colls"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/lazy-cat"}, :clojure.core/aset-char {:added "1.0", :ns "clojure.core", :name "aset-char", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3947, :examples [";; create an array of 10 characters (initially set to blank by default)\n;; and set one of the elements to the character \"a\"\n\nuser=> (def cs (char-array 10))\n#'user/cs\nuser=> (vec cs)\n[\\  \\  \\  \\  \\  \\  \\  \\  \\  \\ ]\nuser=> (aset-char cs 3 \\a)\n\\a\nuser=> (vec cs)\n[\\  \\  \\  \\a \\  \\  \\  \\  \\  \\ ]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of char. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-char"}, :clojure.core/locking {:added "1.0", :ns "clojure.core", :name "locking", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/future], :line 1639, :examples ["(def o (Object.))\n(future (locking o \n          (Thread/sleep 5000) \n          (println \"done1\")))\n\n;; Now run this before 5 seconds is up and you'll \n;; find the second instance waits for the first instance to print done1\n;; and release the lock, and then it waits for 1 second and prints done2\n\n(Thread/sleep 1000) ; give first instance 1 sec to acquire the lock\n(locking o \n  (Thread/sleep 1000)\n  (println \"done2\"))\n;; => done1\n;; => done2\n;; => nil\n\n;; locking operates like the synchronized keyword in Java.\n"], :macro true, :notes nil, :arglists ["x & body"], :doc "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/locking"}, :clojure.core.logic/suspended-stream? {:ns "clojure.core.logic", :name "suspended-stream?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1857, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/suspended-stream_q"}, :clojure.core/construct-proxy {:added "1.0", :ns "clojure.core", :name "construct-proxy", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos [:clojure.core/get-proxy-class :clojure.core/proxy], :line 290, :examples [";; Compared to \"proxy\" you have the option to pick different \n;; constructors on the same proxy class.\n\n(def MyThread (get-proxy-class Thread))\n\n(defn t\n  ([clazz f] (construct-proxy clazz f))\n  ([clazz id f] (construct-proxy clazz f id)))\n\n(str (t MyThread #()))\n;; \"Thread[Thread-2,5,main]\"\n\n(str (t MyThread \"***MYTHREAD***\" #()))\n;; \"Thread[***MYTHREAD***,5,main]\"\n"], :notes nil, :arglists ["c & ctor-args"], :doc "Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/construct-proxy"}, :clojure.core/count {:added "1.0", :ns "clojure.core", :name "count", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/counted?], :line 866, :examples ["(count nil)\n;;=> 0\n\n(count [])\n;;=> 0\n\n(count [1 2 3])\n;;=> 3\n\n(count {:one 1 :two 2})\n;;=> 2\n\n(count [1 \\a \"string\" [1 2] {:foo :bar}])\n;;=> 5\n\n(count \"string\")\n;;=> 6" "(count '(1 2 3 3 1))\n;;=> 5\n\n;; and as a koan\n(= (count '(1 2 3 3 1)) 5)\n;;=> true"], :notes nil, :arglists ["coll"], :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/count"}, :clojure.core/deref {:added "1.0", :ns "clojure.core", :name "deref", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/atom :clojure.core/agent :clojure.core/ref :clojure.core/realized? :clojure.core/future], :line 2298, :examples ["user=> (def a (atom 0))\n#'user/a\nuser=> @a\n0\nuser=> (deref a)\n0\n\nuser=> (def b (ref 1))\n#'user/b\nuser=> @b\n1\nuser=> (deref b)\n1\n\nuser=> (def c (agent 2))\n#'user/c\nuser=> @c\n2\nuser=> (deref c)\n2\n\nuser=> (def d (future 3))\n#'user/d\nuser=> @d\n3\nuser=> (deref d)\n3" "user=> (def a (promise))\n#'user/a\nuser=> (deref a) ;; blocking until a delivery occurs <ctrl-c>\n\nuser=> (deref a 100 :timeout) ;; block for at most 100ms\n:timeout" "user=> (def b 1)\n#'user/b\nuser=> (var b)\n#'user/b\nuser=> (deref (var b))\n1"], :notes nil, :arglists ["ref" "ref timeout-ms timeout-val"], :doc "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/deref"}, :clojure.core/longs {:added "1.0", :ns "clojure.core", :name "longs", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/long-array], :line 5323, :examples nil, :notes nil, :arglists ["xs"], :doc "Casts to long[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/longs"}, :clojure.core.logic/defnc {:ns "clojure.core.logic", :name "defnc", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/defnu :clojure.core.logic/defna :clojure.core.logic/defne], :line 2653, :examples [";; I'm not exactly sure what `defnc` is, but I know a little how to use it\n;; The following gets all multiples of 3 in the `(range 50)`\n\n(defnc dev3c [x]\n  (zero? (mod x 3)))\n\n(run* [x]\n  (membero x (range 50))\n  (dev3c x))"], :macro true, :notes nil, :arglists ["name args & body"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/defnc"}, :clojure.core/do {:ns "clojure.core", :name "do", :type "var", :see-alsos nil, :examples [";; do is used to evaluate multiple expressions in order, usually for the\n;; purpose of evaluating exprs that have side-effects (such as printing\n;; or I/O).  do returns the value of its last expression.\n;;\n;; do w/o args returns nil.\n\n=> (do\n     (println \"LOG: Computing...\")\n     (+ 1 1))\nLOG: Computing...\n2\n\n=> (do)\nnil\n" ";; `fn` (`defn` by extension) and `let` have an implicit `do`\n\n=> ((fn []\n    (println \"Something\") ; printed in stdout\n    (str \"Return this\")))\n\"Return this\"\n\n=> (defn do-example []\n    (println \"Something\") ; printed in stdout\n    (str \"Return this\")))\n=> (do-example)\n\"Return this\"\n\n=> (let [name \"John\"]\n    (println \"Something\") ; printed in stdout\n    (str \"Hello \" name))\n\"Hello John\"" "user=> (if (> 2 1)\n            (do\n            (print \"2 greater than 1\") ; with 'do' you can extend if block\n            true))\n\n;;=>\"2 greater than 1\"\n;;=>true" ";; Print the result of time without the output of (range 1000)\n\n=> (do (time (range 1000)) nil)"], :notes nil, :arglists [], :doc "Evaluates the expressions in order and returns the value of the last. If no\nexpressions are supplied, returns nil. See http://clojure.org/special_forms\nfor more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/do"}, :clojure.instant/read-instant-date {:ns "clojure.instant", :name "read-instant-date", :file "clojure/instant.clj", :type "var", :column 1, :see-alsos nil, :line 273, :examples [";; Parse a string with RFC3339-like timestamp to get a java.util.Date object\n\n(use 'clojure.instant)\n(read-instant-date \"2017-08-23T10:22:22\")\n;; #inst \"2017-08-23T10:22:22.000-00:00\"\n\n;; If no timezone info is included in the input string, GMT is assumed.\n;; See clojure.instant/parse-timestamp for the timestamp pattern supported."], :notes nil, :arglists [], :doc "To read an instant as a java.util.Date, bind *data-readers* to a map with\nthis var as the value for the 'inst key. The timezone offset will be used\nto convert into UTC.", :library-url "https://github.com/clojure/clojure", :href "/clojure.instant/read-instant-date"}, :clojure.core.logic/run {:ns "clojure.core.logic", :name "run", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1237, :examples nil, :macro true, :notes nil, :arglists ["n bindings & goals"], :doc "Executes goals until a maximum of n results are found.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run"}, :clojure.core/if {:ns "clojure.core", :name "if", :type "var", :see-alsos [:clojure.core/cond :clojure.core/when :clojure.core/if-let :clojure.core/if-not], :examples ["(defn is-small? [number]\n  (if (< number 100) \"yes\" \"no\"))\n\nuser=> (is-small? 50)\n\"yes\"\n\nuser=> (is-small? 500)\n\"no\"" ";; Be aware that the only two values considered \"logical false\" in Clojure\n;; are nil and false, where Clojure's \"false\" is the Java value Boolean/FALSE\n;; under the hood.  Everything else is \"logical true\".  Particularly surprising\n;; may be that the Java Object with class Boolean and value (Boolean. false) is\n;; considered logical true.\n\n;; This notion of logical true and logical false holds for at least the following\n;; conditional statements in Clojure: if, cond, when, if-let, when-let.\n;; It also applies to functions like filter, remove, and others that use\n;; these conditional statements in their implementation.\n\n;; nil and false are logical false\nuser=> (if nil \"logical true\" \"logical false\")\n\"logical false\"\nuser=> (if false \"logical true\" \"logical false\")\n\"logical false\"\n;; Boolean/FALSE is how Clojure's \"false\" is represented internally.\nuser=> (if Boolean/FALSE \"logical true\" \"logical false\")\n\"logical false\"\n\n;; Everything else that is the value of the condition, including numbers (even 0),\n;; characters, strings (even the empty string), vectors, maps, _and_ a freshly\n;; constructed Boolean class object (Boolean. false), is logical true.\n\nuser=> (if 0 \"logical true\" \"logical false\")\n\"logical true\"\n;; A vector containing nil is not the same as nil.\nuser=> (if [nil] \"logical true\" \"logical false\")\n\"logical true\"\nuser=> (if (first [nil]) \"logical true\" \"logical false\")\n\"logical false\"\n\n;; Bad idea even in Java.  See below for more details.\nuser=> (if (Boolean. false) \"logical true\" \"logical false\")\n\"logical true\"\n\n;; Java documentation itself warns:\n;; Note: It is rarely appropriate to use this constructor. Unless a new instance\n;; is required, the static factory valueOf(boolean) is generally a better choice.\n;; It is likely to yield significantly better space and time performance.\n\n;; (boolean x) converts a value to a primitive boolean.  It converts nil, false,\n;; and (Boolean. false) to primitive false.\nuser=> (if (boolean (Boolean. false)) \"logical true\" \"logical false\")\n\"logical false\"\n\n;; (Boolean/valueOf <val>) is similar:\nuser=> (if (Boolean/valueOf (Boolean. false)) \"logical true\" \"logical false\")\n\"logical false\"\n"], :notes ["```\nuser=> (doc if)\n-------------------------\nif\n  (if test then else?)\nSpecial Form\n  Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil.\n\n  Please see http://clojure.org/special_forms#if\n```\nhttp://clojure.org/special_forms#if"], :arglists [], :doc "Evaluates test.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/if"}, :clojure.core/. {:ns "clojure.core", :name ".", :type "var", :see-alsos [:clojure.core/..], :examples ["(def date (java.util.Date.))\n;; => #'date\n(. date getMonth)\n;; => 11    ; 0-based, so this indicates \"December\"" "user=> (. \"abc\" (toUpperCase)) \n;;=> \"ABC\"\n\nuser=> (. \"abc\" toUpperCase) \n;;=> \"ABC\"\n;;if function has one arg you can use non-parenthesis form\n\n"], :notes nil, :arglists [], :doc "The '.' special form is the basis for access to Java. It can be considered\na member-access operator, and/or read as 'in the scope of'. See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/_."}, :clojure.core.logic/fix-constraints {:ns "clojure.core.logic", :name "fix-constraints", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2088, :examples nil, :notes nil, :arglists ["a"], :doc "A goal to run the constraints in cq until it is empty. Of\n   course running a constraint may grow cq so this function\n   finds the fixpoint.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fix-constraints"}, :clojure.core.logic.fd/map-sum {:ns "clojure.core.logic.fd", :name "map-sum", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 658, :examples nil, :notes nil, :arglists ["f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/map-sum"}, :clojure.core/hash-map {:added "1.0", :ns "clojure.core", :name "hash-map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/merge :clojure.core/assoc :clojure.core/dissoc :clojure.core/array-map :clojure.core/sorted-map :clojure.core/into :clojure.core/zipmap :clojure.core/keys :clojure.core/vals], :line 379, :examples [";; create hash map the long way\nuser=> (hash-map)\n{}\n\n;; create hash map the short way\nuser=> {}\n{}\n\n;; sending a key more times, will remap it to the last value\nuser=> (hash-map :key1 1, :key1 2) \n{:key1 2} \n\nuser=> {:key1 1, :key1 2}\nIllegalArgumentException Duplicate key: :key1  clojure.lang.PersistentArrayMap.createWithCheck (PersistentArrayMap.java:70)\n\n\nuser=> (hash-map :key1 'val1, 'key2 :val2, [:compound :key] nil)\n{[:compound :key] nil, :key1 val1, key2 :val2} \n\n" "user=> (map #(hash-map % 0) (seq \"abcdefgh\"))\n({\\a 0} {\\b 0} {\\c 0} {\\d 0} {\\e 0} {\\f 0} {\\g 0} {\\h 0}) \n\nuser=> (apply hash-map (.split \"a 1 b 2 c 3\" \" \"))\n{\"a\" \"1\", \"b\" \"2\", \"c\" \"3\"}" "; a hash map can be stored in a var by using `def`\nuser=> (def person {:name \"Steve\" :age 24 :salary 7886 :company \"Acme\"})\n#'user/person\nuser=> person\n{:age 24, :name \"Steve\", :salary 7886, :company \"Acme\"}" ";; Take a sequence of sequences (vector of vectors), and create a map\n;; using date as the map key.\n(def csv1 [[\"01/01/2012\" 1 2 3 4][\"06/15/2012\" 38 24 101]])\n\n(map #(hash-map (keyword (first %1)) (vec (rest %1))) csv1)\n;;=> ({:01/01/2012 [1 2 3 4]} {:06/15/2012 [38 24 101]})\n\n;; merge the list of maps into a single map\n(apply merge '({\"01/01/2012\" [1 2 3 4]} {\"06/15/2012\" [38 24 101]}))\n;;=> {\"06/15/2012\" [38 24 101], \"01/01/2012\" [1 2 3 4]}\n\n" "(apply hash-map [:a 1 :b 2])\n;;=> {:b 2 :a 1}\n\n;;is the same as\n(def build-map (partial assoc {}))\n(apply build-map [:a 1 :b 2])\n;;=> {:b 2 :a 1}"], :notes nil, :arglists ["" "& keyvals"], :doc "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash-map"}, :clojure.core.logic/firsto {:ns "clojure.core.logic", :name "firsto", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic/resto], :line 1665, :examples nil, :notes nil, :arglists ["l a"], :doc "A relation where l is a collection, such that a is the first of l", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/firsto"}, :clojure.core/unchecked-double {:added "1.3", :ns "clojure.core", :name "unchecked-double", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3544, :examples ["\n;; the function taking a BigDecimal with limited decimal places\n(unchecked-double 1.77M)\n=> 1.77\n\n;; the function taking a double with limited decimal places\n(unchecked-double 1.22)\n=> 1.22\n\n;; the function taking '0'\n(unchecked-double 0)\n=> 0.0\n\n;; the function does (eventually) round up...:\n(unchecked-double 1.000000000123456789)\n=> 1.0000000001234568\n;;...or down:\n(unchecked-double 1.000000000123456489)\n=> 1.0000000001234566"], :notes nil, :arglists ["x"], :doc "Coerce to double. Subject to rounding.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-double"}, :clojure.core/*assert* {:ns "clojure.core", :name "*assert*", :type "var", :see-alsos [:clojure.core/assert], :examples ["user=> (set! *assert* true)\n\nuser=> (defn str->int\n        [x]\n        {:pre  [(string? x)]}\n        (Integer/valueOf x))\n\nuser=> (str->int 12.2)\n;;=> AssertionError Assert failed: (string? x)  user/str->int..."], :notes ["A little digging through the RT.java code confirms that this is dynamic, and defaults to true."], :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*assert*"}, :clojure.spec.alpha/cat {:ns "clojure.spec.alpha", :name "cat", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 621, :examples nil, :macro true, :notes nil, :arglists ["& key-pred-forms"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/cat"}, :clojure.core/unchecked-dec {:added "1.0", :ns "clojure.core", :name "unchecked-dec", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-add :clojure.core/unchecked-dec :clojure.core/unchecked-inc :clojure.core/unchecked-negate :clojure.core/unchecked-divide :clojure.core/unchecked-subtract :clojure.core/unchecked-multiply :clojure.core/unchecked-remainder :clojure.core/dec :clojure.core/dec'], :line 1162, :examples ["user=> (unchecked-dec 4)\n3\n\nuser=> (unchecked-dec Integer/MIN_VALUE)\n2147483647\n\n" ";; Illustrates the difference between (dec), (dec') and (unchecked-dec)\n\n;; The \"N\" suffix denotes a BigInt instance\n;; https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/BigInt.java\n\nLong/MIN_VALUE\n;;=> -9223372036854775808\n\n(dec Long/MIN_VALUE)\n;;=> ArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1501)\n\n(dec' Long/MIN_VALUE)\n;;=> -9223372036854775809N \n\n;; Notice how the resulting number becomes POSITIVE:\n(unchecked-dec Long/MIN_VALUE)\n;;=> 9223372036854775807 \n\n\n"], :notes nil, :arglists ["x"], :doc "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-dec"}, :clojure.core/Inst {:ns "clojure.core", :name "Inst", :file "clojure/core.clj", :type "var", :column 1, :see-alsos nil, :line 6700, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core/Inst"}, :clojure.string/last-index-of {:added "1.8", :ns "clojure.string", :name "last-index-of", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/index-of], :line 339, :examples [";; 1. Just find index of char\n\nuser=> (last-index-of \"aaaaaa\" \"a\")\n5\nuser=> (last-index-of \"abcde\" \"c\")\n2\n\n;; 2. Optionally searching example\n\nuser=> (last-index-of \"abcde\" \"e\" 0)\n;;=> nil\nuser=> (last-index-of \"abcde\" \"e\" 1)\n;;=> nil\nuser=> (last-index-of \"abcde\" \"e\" 2)\n;;=> nil\nuser=> (last-index-of \"abcde\" \"e\" 3)\n;;=> nil\nuser=> (last-index-of \"abcde\" \"e\" 4)\n;;=> 4\nuser=> (last-index-of \"abcde\" \"e\" 5)\n;;=> 4\n"], :notes nil, :arglists ["s value" "s value from-index"], :doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/last-index-of"}, :clojure.core/aset {:added "1.0", :ns "clojure.core", :name "aset", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3889, :examples ["user=> (def my-array (into-array Integer/TYPE [1 2 3]))\n#'user/my-array\n\nuser=> (aset my-array 1 10) ; Set the element with index 1 to 10\n10\n\nuser=> (into [] my-array)\n[1 10 3]" "; Two dimensional example\n(use 'clojure.pprint)\n(let [the-array (make-array Long/TYPE 2 3) ]\n  (dotimes [nn 6]\n    (let [ii    (quot nn 3)\n          jj    (rem  nn 3) ]\n      (aset the-array ii jj nn)\n    ))\n  (pprint the-array)\n)\n;=> [[0, 1, 2], [3, 4, 5]]\n\n; Types are defined in clojure/genclass.clj:\n;    Boolean/TYPE\n;    Character/TYPE\n;    Byte/TYPE\n;    Short/TYPE\n;    Integer/TYPE\n;    Long/TYPE\n;    Float/TYPE\n;    Double/TYPE\n;    Void/TYPE\n\n" ";; Simple 2D example:\n(def a (to-array-2d [[1 2] [3 4]]))\n;=> #'expt.core/a\n(aset a 0 1 \"foo\")\n;=> \"foo\"\nexpt.core=> (map vec a)\n;=> ([1 \"foo\"] [3 4])"], :notes nil, :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset"}, :clojure.core/defn {:added "1.0", :ns "clojure.core", :name "defn", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/def :clojure.core/defn- :clojure.core/defmacro :clojure.core/fn :clojure.core/declare], :line 283, :examples ["user=> (defn foo [a b c]\n\t    (* a b c))\n#'user/foo\nuser=> (foo 1 2 3)\n6\n\nuser=> (defn bar [a b & [c]]\n         (if c\n           (* a b c)\n           (* a b 100)))\n#'user/bar\nuser=> (bar 5 6)\n3000\nuser=> (bar 5 6 2)\n60\n\nuser=> (defn baz [a b & {:keys [c d] :or {c 10 d 20}}]\n         (* a b c d))\n#'user/baz\nuser=> (baz 2 3)\n1200\nuser=> (baz 2 3 :c 5)\n600\nuser=> (baz 2 3 :c 5 :d 6)\n180\n\nuser=> (defn boo [a b & {:keys [c d] :or {c 10 d 20} :as all-specified}]\n          (println all-specified)\n          (* a b c d))\n#'user/boo\nuser=> (boo 2 3)\nnil\n1200\nuser=> (boo 2 3 :c 5)\n{:c 5}\n600\nuser=> (boo 1 2 :d 3 :c 4)\n{:c 4, :d 3}\n24\n" "user=> (defn bar\n         ([a b]   (bar a b 100))\n         ([a b c] (* a b c)))\n#'user/bar\nuser=> (bar 5 6)\n3000\nuser=> (bar 5 6 2)\n60\n" ";; You can use destructuring to have keyword arguments. This would be a\n;; pretty verbose version of map (in an example a bit more verbose than\n;; the first above):\n\n(defn keyworded-map [& {function :function sequence :sequence}]\n  (map function sequence))\n\n;; You can call it like this:\n\nuser=> (keyworded-map :sequence [1 2 3] :function #(+ % 2))\n(3 4 5)\n\n\n;; The declaration can be shortened with \":keys\" if your local variables \n;; should be named in the same way as your keys in the map:\n\n(defn keyworded-map [& {:keys [function sequence]}]\n  (map function sequence))\n" "(defn somefn\n  [req1 req2 ;required params\n   & {:keys [a b c d e] ;optional params\n      :or {a 1 ;optional params with preset default values other than the nil default\n                  ; b takes nil if not specified on call\n            c 3 ; c is 3 when not specified on call\n            d 0 ; d is 0 --//--\n                  ; e takes nil if not specified on call\n           }\n      :as mapOfParamsSpecifiedOnCall ;takes nil if no extra params(other than the required ones) are specified on call\n      }]\n  (println req1 req2 mapOfParamsSpecifiedOnCall a b c d e)\n  )\n\n=> (somefn 9 10 :b 2 :d 4)\n;9 10 {:b 2, :d 4} 1 2 3 4 nil\nnil\n=> (somefn)\n;ArityException Wrong number of args (0) passed to: funxions$somefn  ;clojure.lang.AFn.throwArity (AFn.java:437)\n=> (somefn 9 10)\n;9 10 nil 1 nil 3 0 nil\nnil\n=> (somefn 9 10 :x 123)\n;9 10 {:x 123} 1 nil 3 0 nil\nnil\n=> (somefn 9 10 123)\n;IllegalArgumentException No value supplied for key: 123  ;clojure.lang.PersistentHashMap.create (PersistentHashMap.java:77)\n=> (somefn 9 10 123 45)\n;9 10 {123 45} 1 nil 3 0 nil\nnil\n=> (try \n     (somefn 9 10 123)\n     (catch IllegalArgumentException e (println \"caught:\" e)))\n;caught: #<IllegalArgumentException java.lang.IllegalArgumentException: No value supplied for key: 123>\nnil" ";; :as only include parameters provided, not the default (:or) ones.\n;; This is some boilerplate code to get around this. \n;; Hopefully not needed in the future revisions of Clojure.\n\n(defn bar [f g h & {:keys [override]}]\n  (let [default {:a 1 :b 2 :c 3}\n        args (merge default override)]\n    (conj '() f g h args)))\n\n(bar 1 2 3 :override {:a 9 :z 5}) ; returns -> ({:z 5, :a 9, :b 2, :c 3} 3 2 1)\n" ";;defn basic examples\n(defn say-hi [name]\n  (str \"Hi \" name))\n\n(say-hi \"Jack\")\n;;\"Hi Jack\"\n\n;;the same result using def\n(def say-hello (fn [name]\n                 (str \"Hello \" name)))\n\n(say-hello \"Bob\")\n;;\"Hello Bob\"\n\n;;the same result using def and an anonymous function\n(def say-bye #(str \"Bye Bye \" %))\n\n(say-bye \"Mark\")\n;;\"Bye Bye Mark\"" ";;define a function with metadata\n(defn hello {:awesome true} [] nil)\n\n(meta #'hello)\n=>\n{:arglists ([]),\n :awesome true,\n ...\n}\n\n;; define a function with a return value type hint\n(defn hinted ^long [] 42)\n\n(-> #'hinted meta :arglists first meta :tag)\n=> long\n\n;; both metadata on the fn and return type hint (on the argument vector)\n(defn hinted+meta {:awesome true} ^long [] 42)"], :macro true, :notes nil, :arglists ["name doc-string? attr-map? [params*] prepost-map? body" "name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?"], :doc "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defn"}, :clojure.core.reducers/filter {:added "1.5", :ns "clojure.core.reducers", :name "filter", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 187, :examples nil, :notes nil, :arglists ["pred" "pred coll"], :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/filter"}, :clojure.test/function? {:added "1.1", :ns "clojure.test", :name "function?", :file "clojure/test.clj", :type "function", :column 1, :see-alsos [:clojure.core/fn?], :line 423, :examples ["user> (defn foo [] (println \"foo\"))\n#'user/foo\n\nuser> (def bar \"bar\")\n#'user/bar\n\nuser> (clojure.test/function? foo)\ntrue\n\nuser> (clojure.test/function? bar)\nfalse"], :notes nil, :arglists ["x"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/function_q"}, :clojure.spec.alpha/abbrev {:ns "clojure.spec.alpha", :name "abbrev", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 165, :examples nil, :notes nil, :arglists ["form"], :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/abbrev"}, :clojure.core.logic/ext {:ns "clojure.core.logic", :name "ext", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 220, :examples nil, :notes nil, :arglists ["s u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ext"}, :clojure.walk/postwalk {:added "1.1", :ns "clojure.walk", :name "postwalk", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/prewalk :clojure.walk/postwalk-demo :clojure.walk/postwalk-replace], :line 52, :examples ["(require '[clojure.walk :refer [postwalk]])\n(let [counter (atom -1)\n      line-counter (atom 0)\n      print-touch (fn [x]\n                    (print (swap! line-counter inc) \":\" (pr-str x) \"→ \"))\n      change (fn [x]\n               (let [new-x (swap! counter inc)]\n                 (prn new-x)\n                 [new-x x]))]\n  (postwalk (fn [x]\n              (print-touch x)\n              (change x))\n            {:a 1 :b 2}))\n\n;; printed output:\n\n1 : :a → 0\n2 : 1 → 1\n3 : [[0 :a] [1 1]] → 2\n4 : :b → 3\n5 : 2 → 4\n6 : [[3 :b] [4 2]] → 5\n7 : {2 [[0 :a] [1 1]], 5 [[3 :b] [4 2]]} → 6\n\n;; returned value:\n\n[6 {2 [[0 :a] [1 1]], 5 [[3 :b] [4 2]]}]" ";;example of removing namespaces from all keys in a nested data structure\n(def thing {:page/tags [{:tag/category \"lslsls\"}]})\n(postwalk #(if(keyword? %)(keyword (name %)) %) thing)\n{:tags [{:category \"lslsls\"}]}" "(use 'clojure.walk)\n\n;;example of evaluating an expression tree, starting at the leaves\n(def expression-tree\n  {:function +\n   :children\n    [1 {:function *\n        :children [2 6]}]})\n\n(defn evaluate [node]\n  (if-let [f (:function node)]\n    (apply f (:children node))\n    node))\n\n(postwalk evaluate expression-tree)\n\n=> 13" ";; an example to show the differences between postwalk and prewalk\n;; (see the counterpart at prewalk)\n\n(let [counter     (atom 0)\n      print-touch (fn [x]\n                    (print (swap! counter inc) \":\" (pr-str x) \"→ \"))\n      change-type (fn [x]\n                    (let [new-x (if (vector? x)\n                                  (apply list x)\n                                  (str x))]\n                      (prn new-x)\n                      new-x))]\n  (clojure.walk/postwalk (fn [x]\n                           (print-touch x)\n                           (change-type x))\n                         [:a [:ba :bb] :c]))\n\n;; printed output:\n\n1 : :a → \":a\"\n2 : :ba → \":ba\"\n3 : :bb → \":bb\"\n4 : [\":ba\" \":bb\"] → (\":ba\" \":bb\")\n5 : :c → \":c\"\n6 : [\":a\" (\":ba\" \":bb\") \":c\"] → (\":a\" (\":ba\" \":bb\") \":c\")\n\n;; returned value:\n\n=> (\":a\" (\":ba\" \":bb\") \":c\")"], :notes ["As of 1.9.0, postwalk passes the k/v pairs of a map to `f` not, as one might expect, as type `clojure.lang.MapEntry` but as `clojure.lang.PersistentVector` ([JIRA](https://dev.clojure.org/jira/browse/CLJ-2031)). As a result, `f` cannot distinguish k/v pairs from other two-element vectors." "Alex Miller's article [\"Tree visitors in Clojure\"](https://www.ibm.com/developerworks/library/j-treevisit/index.html) might be helpful in understanding general tree traversal and the usage of `clojure.walk/postwalk`.\n"], :arglists ["f form"], :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/postwalk"}, :clojure.core/agent-errors {:added "1.0", :ns "clojure.core", :name "agent-errors", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 2228, :examples nil, :deprecated "1.2", :notes nil, :arglists ["a"], :doc "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/agent-errors"}, :clojure.pprint/set-pprint-dispatch {:added "1.2", :ns "clojure.pprint", :name "set-pprint-dispatch", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos nil, :line 260, :examples nil, :notes nil, :arglists ["function"], :doc "Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/set-pprint-dispatch"}, :clojure.core/extend {:added "1.2", :ns "clojure.core", :name "extend", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos [:clojure.core/satisfies? :clojure.core/extends? :clojure.core/extenders :clojure.core/extend-type :clojure.core/extend-protocol], :line 746, :examples ["; From Sean Devlin's talk on protocols at Clojure Conj\n(defprotocol Dateable\n  (to-ms [t]))\n\n(extend java.lang.Number\n  Dateable\n  {:to-ms identity})\n\n(extend java.util.Date\n  Dateable\n  {:to-ms #(.getTime %)})\n\n(extend java.util.Calendar\n  Dateable\n  {:to-ms #(to-ms (.getTime %))})" ";; \"extend\" enables the definition of concrete implementations\n;; after declaration time. This provides \n;; a lightweight version of abstract methods/classes.\n\n(defprotocol IBaz\n  (foo [_])\n  (bar [_])\n  (baz [_]))\n\n;; DefaultBaz contains some default implementations.\n(def DefaultBaz\n  {:foo (fn [_] (str \"DefaultBaz::foo\"))\n   :bar (fn [_] (str \"DefaultBaz::bar\"))})\n\n(defrecord MyBaz [])\n\n;; MyBaz accepts \"bar\" as default from the \"super-class\"\n;; but overrides \"foo\". \"baz\" is provided without override.\n(extend MyBaz\n  IBaz\n  (assoc DefaultBaz \n    :foo (fn [this] (str \"MyBaz::foo\"))\n    :baz (fn [this] (str \"MyBaz::baz\"))))\n\n(def my-baz (->MyBaz))\n(foo my-baz)\n;; \"MyBaz::foo\"\n\n;; Note: additional \"extend-*\" calls will change all instances\n;; created so far.\n\n(extend-type MyBaz\n  IBaz\n  (foo [this] (str \"NEW\")))\n\n(foo my-baz)\n;; \"NEW\""], :notes nil, :arglists ["atype & proto+mmaps"], :doc "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/extend"}, :clojure.core/unquote {:ns "clojure.core", :name "unquote", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/unquote-splicing :clojure.core/quote], :line 13, :examples ["user=> (let [x 2]\n         `(1 x 3))\n(1 user/x 3)\n\nuser=> (let [x 2]\n         `(1 ~x 3))\n(1 2 3)\n" "user=> `(1 (dec 3) 3)\n\n(1 (clojure.core/dec 3) 3)\n\nuser => `(1 ~(dec 3) 3)\n\n(1 2 3)"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unquote"}, :clojure.core/float-array {:added "1.0", :ns "clojure.core", :name "float-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5217, :examples ["user=> (float-array [1 2 3])\n#<float[] [F@4d8dfa76>"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of floats", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/float-array"}, :clojure.core.logic.fd/dom {:ns "clojure.core.logic.fd", :name "dom", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 631, :examples nil, :notes nil, :arglists ["x dom"], :doc "Assign a var x a domain.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/dom"}, :clojure.core.async/map> {:ns "clojure.core.async", :name "map>", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1031, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["f ch"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/map>"}, :clojure.spec.alpha/*compile-asserts* {:ns "clojure.spec.alpha", :name "*compile-asserts*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 1887, :examples nil, :notes nil, :arglists [], :doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\n\nInitially set to boolean value of clojure.spec.compile-asserts\nsystem property. Defaults to true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*compile-asserts*"}, :clojure.zip/remove {:added "1.0", :ns "clojure.zip", :name "remove", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 264, :examples nil, :notes nil, :arglists ["loc"], :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/remove"}, :clojure.pprint/with-pprint-dispatch {:added "1.2", :ns "clojure.pprint", :name "with-pprint-dispatch", :file "clojure/pprint/pprint_base.clj", :type "macro", :column 1, :see-alsos nil, :line 274, :examples nil, :macro true, :notes nil, :arglists ["function & body"], :doc "Execute body with the pretty print dispatch function bound to function.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/with-pprint-dispatch"}, :clojure.zip/xml-zip {:added "1.0", :ns "clojure.zip", :name "xml-zip", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.xml/parse], :line 53, :examples ["(def xmlzipper (clojure.zip/xml-zip (clojure.xml/parse \"resources/somedata.xml\")))\n\n;;make a zippper pointing at the children to the topnode in somedata.xml\n(clojure.zip/children xmlzipper)\n\n \n\n\n\n\n" "(require '[clojure.zip :as z])\n\n;; The following example make use of an xml-tree ...\n;; <root><any>foo bar</any>bar</root>\n;; Notice that the xml-parse will not produce the exact \n;; xml object as the \"foo\" and \"bar\" strings are combined.\n\n;; Travel over the zipper in classic lisp style\n(z/right\n  (z/down\n    (z/xml-zip \n      {:tag :root :content [{:tag :any :content [\"foo\" \"bar\"]} \"bar\"]})))\n\n;;=> [\"bar\" {:l [{:content [\"foo\" \"bar\"], :tag :any}], \n;;+>         :pnodes [{:content [{:content [\"foo\" \"bar\"], :tag :any} \"bar\"], :tag :root}],\n;;+>         :ppath nil, :r nil}]\n\n;; The above can also be written like this using the thread macro style\n(->{:tag :root :content [{:tag :any :content [\"foo\" \"bar\"]} \"bar\"]}\n   z/xml-zip \n   z/down \n   z/right)\n\n;;=> [\"bar\" {:l [{:content [\"foo\" \"bar\"], :tag :any}], \n;;+>         :pnodes [{:content [{:content [\"foo\" \"bar\"], :tag :any} \"bar\"], :tag :root}],\n;;+>         :ppath nil, :r nil}]\n" "(require '[clojure.xml :as xml]\n         '[clojure.zip :as zip])\n\n;; Looking at the whole zipper is usually not the goal.\n;; Here is a case where the \"bar\" element is extracted.\n;; The following is derived from the following xml.\n;; <root><any>foo</any>bar</root>\n(->{:tag :root :content [{:tag :any :content [\"foo\"]} \"bar\"]}\n   zip/xml-zip\n   zip/down\n   zip/right\n   zip/node)\n;;=> \"bar\"\n\n;; The following shows a slightly larger example including the parser.\n(def data\n  \"<constraint name=\\\"a\\\">\n    <pair name=\\\"ab\\\">\n      <feature name=\\\"ab1\\\">\n        <geom name=\\\"ab1x\\\"/> \n      </feature>\n      <feature name=\\\"ab2\\\">\n        <geom name=\\\"ab2y\\\"/>\n      </feature>\n    </pair>\n    <pair name=\\\"ac\\\">\n      <feature name=\\\"ac1\\\">\n        <geom name=\\\"ac1z\\\"/>\n      </feature>\n      <feature name=\\\"ac2\\\"/>\n    </pair>\n  </constraint>\" )\n\n;; Here is an example of the parser in action\n(def xml-tree\n  (-> data \n    .getBytes \n    java.io.ByteArrayInputStream. \n    xml/parse  ))\n\n;; Traversing the xml using a zipper\n(-> xml-tree\n    zip/xml-zip \n    zip/down\n    zip/down\n    zip/down\n    zip/node\n    )\n;;=> {:tag :geom, :attrs {:name \"ab1x\"}, :content nil}"], :notes ["There are also other libraries for processing xml that provide additional features.\nhttps://github.com/clojure/data.xml"], :arglists ["root"], :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/xml-zip"}, :clojure.java.browse/browse-url {:added "1.2", :ns "clojure.java.browse", :name "browse-url", :file "clojure/java/browse.clj", :type "function", :column 1, :see-alsos [:clojure.java.browse/*open-url-script*], :line 66, :examples ["user=> (use 'clojure.java.browse)\n\nuser=> (browse-url \"http://clojuredocs.org\")\n" ";;It's funny.... Open bash\n\n(browse-url \"/bin/bash\")"], :notes nil, :arglists ["url"], :doc "Open url in a browser", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.browse/browse-url"}, :clojure.pprint/print-table {:added "1.3", :ns "clojure.pprint", :name "print-table", :file "clojure/pprint/print_table.clj", :type "function", :column 1, :see-alsos [:clojure.pprint/pprint :clojure.inspector/inspect-table], :line 11, :examples ["(use 'clojure.pprint)\n;=> nil\n\n;; By default, columns are in the order returned by (keys (first rows))\n(print-table [{:a 1 :b 2 :c 3} {:b 5 :a 7 :c \"dog\"}])\n;; =============\n;; :a | :c  | :b\n;; =============\n;; 1  | 3   | 2 \n;; 7  | dog | 5 \n;; =============\n;=> nil\n\n;; If there are keys not in the first row, and/or you want to specify only\n;; some, or in a particular order, give the desired keys as the first arg.\n(print-table [:b :a] [{:a 1 :b 2 :c 3} {:b 5 :a 7 :c \"dog\"}])\n;; =======\n;; :b | :a\n;; =======\n;; 2  | 1 \n;; 5  | 7 \n;; =======\n;=> nil\n" "(use 'clojure.pprint 'clojure.reflect)\n;=> nil\n(def x (:members (reflect clojure.lang.BigInt)))\n;=> #'user/x\n(print-table [:name :type :flags] (sort-by :name x))\n;; ======================================================================\n;; :name               | :type                | :flags                   \n;; ======================================================================\n;; ONE                 | clojure.lang.BigInt  | #{:static :public :final}\n;; ZERO                | clojure.lang.BigInt  | #{:static :public :final}\n;; add                 |                      | #{:public}               \n;; bipart              | java.math.BigInteger | #{:public :final}        \n;; bitLength           |                      | #{:public}               \n;; byteValue           |                      | #{:public}               \n;; clojure.lang.BigInt |                      | #{:private}              \n;; doubleValue         |                      | #{:public}               \n;; equals              |                      | #{:public}               \n;; floatValue          |                      | #{:public}               \n;; fromBigInteger      |                      | #{:static :public}       \n;; fromLong            |                      | #{:static :public}       \n;; hashCode            |                      | #{:public}               \n;; intValue            |                      | #{:public}               \n;; longValue           |                      | #{:public}               \n;; lpart               | long                 | #{:public :final}        \n;; lt                  |                      | #{:public}               \n;; multiply            |                      | #{:public}               \n;; quotient            |                      | #{:public}               \n;; remainder           |                      | #{:public}               \n;; shortValue          |                      | #{:public}               \n;; toBigInteger        |                      | #{:public}               \n;; toString            |                      | #{:public}               \n;; valueOf             |                      | #{:static :public}       \n;; ======================================================================\n;=> nil\n"], :notes nil, :arglists ["ks rows" "rows"], :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/print-table"}, :clojure.spec.alpha/explain-str {:ns "clojure.spec.alpha", :name "explain-str", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 252, :examples nil, :notes nil, :arglists ["spec x"], :doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain-str"}, :clojure.core/*math-context* {:ns "clojure.core", :name "*math-context*", :type "var", :see-alsos nil, :examples nil, :notes nil, :tag "java.math.MathContext", :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*math-context*"}, :clojure.core/filter {:added "1.0", :ns "clojure.core", :name "filter", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove :clojure.core/keep :clojure.core/filterv :clojure.core/group-by], :line 2785, :examples ["(filter even? (range 10))\n;;=> (0 2 4 6 8)\n\n(filter (fn [x]\n  (= (count x) 1))\n  [\"a\" \"aa\" \"b\" \"n\" \"f\" \"lisp\" \"clojure\" \"q\" \"\"])\n;;=> (\"a\" \"b\" \"n\" \"f\" \"q\")\n\n(filter #(= (count %) 1)\n  [\"a\" \"aa\" \"b\" \"n\" \"f\" \"lisp\" \"clojure\" \"q\" \"\"])\n;;=> (\"a\" \"b\" \"n\" \"f\" \"q\")\n\n; When coll is a map, pred is called with key/value pairs.\n(filter #(> (second %) 100)\n       {:a 1\n        :b 2\n        :c 101\n        :d 102\n        :e -1})\n;;=> ([:c 101] [:d 102])\n\n(into {} *1)\n;;=> {:c 101, :d 102}\n" ";; Used without a collection, filter will create a transducer:\n(def xf (filter odd?))\n\n;; We can now apply this transducer to a sequence:\n(transduce xf conj (range 10))\n;; => [1 3 5 7 9]\n" ";;When filtering a map, the predicate takes a _list_ of length 2\n(filter (fn [[k v]] (even? k))\n    {1 \"a\", 2 \"b\", 3 \"c\", 4 \"d\"}\n)\n;;output:: ([2 \"b\"] [4 \"d\"])\n\n;;A function of arity two will cause an error\n(comment will fail!) \n(filter (fn [k v] (even? k))\n    {1 \"a\", 2 \"b\", 3 \"c\", 4 \"d\"}\n)\n;;output:: clojure.lang.ArityException: Wrong number of args (1) passed to: ..." "; remove empty vectors from the root vector\n(def vector-of-vectors [[1 2 3] [] [1] []])\n\n(def populated-vector? \n  (fn \n    [item] \n    (not= item [])))\n\n(filter populated-vector? vector-of-vectors)\n\n; => ([1 2 3] [1])" ";;filter a map on its values\n(filter (comp #{2 3} last) {:x 1 :y 2 :z 3})\n;;=> ([:y 2] [:z 3])" ";;filter a map on its values\n(filter (comp #{2 3} last) {:x 1 :y 2 :z 3})\n;;=> ([:y 2] [:z 3])\n\n;;extract keys for certain values\n(map first (filter (comp #{2 3} last) {:x 1 :y 2 :z 3}))\n=> (:y :z)" ";; You can use set as a filter predicate. In this case it is sets intersection\n(filter #{0 1 2 3} #{2 3 4 5})\n=> (3 2) " ";; That's how to get everything from a seq that is not nil;\n(filter some? '(1 nil [] :a nil))\n=> (1 [] :a)" ";;practical example using an anonymous function \n;;which return a boolean value\n(def entries [{:month 1 :val 12 :s1 true :s2 false}\n              {:month 2 :val 3 :s1 false :s2 true}\n              {:month 3 :val 32 :s1 true :s2 false}\n              {:month 4 :val 18 :s1 true :s2 false}\n              {:month 5 :val 32 :s1 false :s2 true}\n              {:month 6 :val 62 :s1 false :s2 true}\n              {:month 7 :val 12 :s1 false :s2 true}\n              {:month 8 :val 142 :s1 true :s2 false}\n              {:month 9 :val 52 :s1 true :s2 false}\n              {:month 10 :val 18 :s1 true :s2 false}\n              {:month 11 :val 23 :s1 false :s2 true}\n              {:month 12 :val 56 :s1 false :s2 true}])\n\n(filter #(:s2 %) entries)\n\n(filter #(and (:s2 %) (> (:val %) 30)) entries)\n" ";; given users\n;; [\"pinisi\" \"sikad\" \"zenius\" \"teacher\" \"law\" \"calvin\" \"ijul\"]\n;; \n;; kick \"law\" and \"teacher\"\n\n(filter #(not (some (fn [u] (= u %)) \n                    [\"law\" \"teacher\"])) \n        [\"pinisi\" \"sikad\" \"zenius\" \"teacher\" \"law\" \"calvin\" \"ijul\"]" ";; if you want to apply multiple predicates, use every-pred\n;; in conjunction with filter\n;; output: (2, 4)\n\n(filter\n (apply every-pred [even? #(< % 5)]) [1, 2, 3, 4, 5])\n\n;; if you want to apply any predicate, use some-fn\n;; output: (0 2 4 6 7 8 9)\n\n(filter\n (some-fn even? #(> % 5))\n (range 10))"], :notes ["Although the documentation states that the predicate must be free of side effects, it would be more accurate to say that you should not rely on filter to induce side effects that may be caused by the predicate, nor on the timing of when the predicate will be evaluated, because of the lazy and chunked nature of filter." "Note that filtering a map will not create a map. If you want to do a lookup on the result, you need to surround the call to filter with (into {} (filter ...))"], :arglists ["pred" "pred coll"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/filter"}, :clojure.string/replace {:added "1.2", :ns "clojure.string", :name "replace", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.core/subs :clojure.string/split :clojure.string/replace-first :clojure.string/re-quote-replacement], :line 75, :examples ["(clojure.string/replace \"The color is red\" #\"red\" \"blue\")\n;=> \"The color is blue\"" "clojure.string/replace \"The color is red.\" #\"[aeiou]\"  #(str %1 %1))\n;=> \"Thee cooloor iis reed.\"\n" ";; Note: When replace-first or replace have a regex pattern as their\n;; match argument, dollar sign ($) and backslash (\\) characters in\n;; the replacement string are treated specially.\n\n;; Example: first substring that the pattern matches is \"fodder\", with\n;; (o+) matching \"o\" and (\\S+) matching \"dder\".  Replacement string\n;; says to replace the entire match \"fodder\" with $2, the string\n;; matched by the second parenthesized group, \"dder\", followed by $1,\n;; \"o\".\n(str/replace \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" \"$2$1\")\n;=> \"fabulous ddero oo doo\"\n\n;; To avoid this special treatment of $ and \\, you must escape them with\n;; \\.  Because it is in a Clojure string, to get one \\ we must escape\n;; *that* with its own \\.\n(str/replace \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" \"\\\\$2\\\\$1\")\n;=> \"fabulous $2$1 $2$1 $2$1\"\n\n;; To ensure the replacement is treated literally, call\n;; java.util.regex.Matcher/quoteReplacement on it.  A shorter name\n;; like re-qr can be handy.\n(import '(java.util.regex Matcher))\n;=> java.util.regex.Matcher\n\n(defn re-qr [replacement]\n    (Matcher/quoteReplacement replacement))\n;=> #'user/re-qr\n\n(str/replace \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" (re-qr \"$2$1\"))\n;=> \"fabulous $2$1 $2$1 $2$1\"\n\n;; Since 1.5, re-qr can be replaced by clojure.string/re-quote-replacement\n(str/replace \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" (str/re-quote-replacement \"$2$1\"))\n;=> \"fabulous $2$1 $2$1 $2$1\"" ";; replaces all a's with 1 and all b's with 2\n(clojure.string/replace \"a b a\" #\"a|b\" {\"a\" \"1\" \"b\" \"2\"})\n;=> \"1 2 1\"" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases." ";; To title case\n(clojure.string/replace \"hello world\" #\"\\b.\" #(.toUpperCase %1))\n\"Hello World\"\n\n;; Note that a vector is passed to your replacement function\n;; when pattern contains capturing groups (see re-groups)\n(clojure.string/replace \"hello world\" #\"\\b(.)\" #(.toUpperCase (%1 1)))\n\"Hello World\"\n" ";; Note that the s \"Vegeta\" is returned as is, because there is no matching.\n(clojure.string/replace \"Vegeta\" #\"Goku\" \"Gohan\")\n\"Vegeta\""], :notes ["How can i replace \".\" with #\"\\s\""], :tag "java.lang.String", :arglists ["s match replacement"], :doc "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/replace"}, :clojure.repl/stack-element-str {:added "1.3", :ns "clojure.repl", :name "stack-element-str", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 228, :examples nil, :notes nil, :arglists ["el"], :doc "Returns a (possibly unmunged) string representation of a StackTraceElement", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/stack-element-str"}, :clojure.core/keys {:added "1.0", :ns "clojure.core", :name "keys", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vals :clojure.core/hash-map :clojure.core/key :clojure.core/select-keys], :line 1547, :examples ["(keys {:keys :and, :some :values})\n;;=> (:keys :some)\n\n(keys {})\n;;=> nil\n\n(keys nil)\n;;=> nil" ";; although doc says it only takes a map, this still works:\n(keys (filter (fn [[_ v]] (-> v :t)) {:a {:t true} :b {:t false} :c {:t true}}))\n;;=> (:a :c)"], :notes ["Functions keys and vals return sequences such that\r\n<pre>\r\n(= (zipmap (keys m) (vals m)) m)\r\n</pre>" "I noticed that the keys are not always returned in the same order. Usually they are, but not always." "Map with 8 or more keys order are unexpected."], :arglists ["map"], :doc "Returns a sequence of the map's keys, in the same order as (seq map).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/keys"}, :clojure.core/group-by {:added "1.2", :ns "clojure.core", :name "group-by", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partition-by :clojure.core/frequencies], :line 7066, :examples [";; group strings by their length\n(group-by count [\"a\" \"as\" \"asd\" \"aa\" \"asdf\" \"qwer\"])\n;;=> {1 [\"a\"], 2 [\"as\" \"aa\"], 3 [\"asd\"], 4 [\"asdf\" \"qwer\"]}\n\n;; group integers by a predicate\n(group-by odd? (range 10))\n;;=> {false [0 2 4 6 8], true [1 3 5 7 9]}\n" ";; group by a primary key\n(group-by :user-id [{:user-id 1 :uri \"/\"} \n                    {:user-id 2 :uri \"/foo\"} \n                    {:user-id 1 :uri \"/account\"}])\n\n;;=> {1 [{:user-id 1, :uri \"/\"} \n;;       {:user-id 1, :uri \"/account\"}],\n;;    2 [{:user-id 2, :uri \"/foo\"}]}\n" ";; group by multiple criteria\n(def words [\"Air\" \"Bud\" \"Cup\" \"Awake\" \"Break\" \"Chunk\" \"Ant\" \"Big\" \"Check\"])\n(group-by (juxt first count) words)\n\n;;{[\\A 3] [\"Air\" \"Ant\"], \n;;[\\B 3] [\"Bud\" \"Big\"], \n;;[\\C 3] [\"Cup\"], \n;;[\\A 5] [\"Awake\"], \n;;[\\B 5] [\"Break\"], \n;;[\\C 5] [\"Chunk\" \"Check\"]}" "user=> (group-by :category [{:category \"a\" :id 1}\n                            {:category \"a\" :id 2}\n                            {:category \"b\" :id 3}])\n;;{\"a\" [{:category \"a\", :id 1} {:category \"a\", :id 2}], \n;; \"b\" [{:category \"b\", :id 3}]}\n\nuser=> (group-by #(get % :category) [{:category \"a\" :id 1}\n                                     {:category \"a\" :id 2}\n                                     {:category \"b\" :id 3}])\n;;{\"a\" [{:category \"a\", :id 1} {:category \"a\", :id 2}], \n;; \"b\" [{:category \"b\", :id 3}]}\n\nuser=> (defn my-category [item] (get item :category))\n;;#'user/my-category\n\nuser=> (group-by my-category [{:category \"a\" :id 1}\n                              {:category \"a\" :id 2}\n                              {:category \"b\" :id 3}])\n;;{\"a\" [{:category \"a\", :id 1} {:category \"a\", :id 2}], \n;; \"b\" [{:category \"b\", :id 3}]}\n" "(require '[ultra-csv.core :refer [read-csv]])\n \n(def ds (read-csv \"/home/liuwensui/Downloads/nycflights.csv\"))\n \n(map\n  (fn [x] {:year (first (key x))\n           :month (last (key x))\n           :flights (count (val x))})\n    (group-by (juxt :year :month) ds))"], :notes nil, :arglists ["f coll"], :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/group-by"}, :clojure.zip/seq-zip {:added "1.0", :ns "clojure.zip", :name "seq-zip", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/xml-zip :clojure.zip/vector-zip], :line 35, :examples ["user=> (require '[clojure.zip :as zip])\r\nnil\r\nuser=> (def zz (zip/seq-zip '(a b (c d e) (f (g h) i) j)))\r\n#'user/zz\r\nuser=> zz\r\n[(a b (c d e) (f (g h) i) j) nil]"], :notes nil, :arglists ["root"], :doc "Returns a zipper for nested sequences, given a root sequence", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/seq-zip"}, :clojure.core.logic/entangle {:ns "clojure.core.logic", :name "entangle", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 609, :examples nil, :notes nil, :arglists ["s x y"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/entangle"}, :clojure.core/new {:ns "clojure.core", :name "new", :type "var", :see-alsos [:clojure.core/.], :examples [";; Create a Java ArrayList using the 0 argument constructor\nuser=> (def a  (new java.util.ArrayList))\n#'user/a\nuser=> (.add a \"aaa\")\ntrue\nuser=> (.add a \"bbb\")\ntrue\nuser=> a\n#<ArrayList [aaa, bbb]>\n" ";; Create another ArrayList and add integers using the doto macro\nuser=> (def ai (doto (new java.util.ArrayList) (.add 1) (.add 2) (.add 0)))\n#'user/ai\nuser=> ai\n#<ArrayList [1, 2, 0]>"], :notes nil, :arglists [], :doc "Instantiate a class. See http://clojure.org/java_interop#new for\nmore information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/new"}, :clojure.core/ns-refers {:added "1.0", :ns "clojure.core", :name "ns-refers", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-map], :line 4220, :examples ["user> (ns-refers 'clojure.main)\n{sorted-map #'clojure.core/sorted-map, read-line #'clojure.core/read-line, re-pattern #'clojure.core/re-pattern, keyword? #'clojure.core/keyword?, val #'clojure.core/val, chunked-seq? #'clojure.core/chunked-seq?, *compile-path* #'clojure.core/*compile-path*, ...chop...}"], :notes nil, :arglists ["ns"], :doc "Returns a map of the refer mappings for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-refers"}, :clojure.core/load-file {:added "1.0", :ns "clojure.core", :name "load-file", :type "function", :see-alsos [:clojure.core/load :clojure.core/spit :clojure.core/load-string], :examples [";; Very useful from a REPL\n;; Paths are specified as strings using canonical file path notation \n;; (rather than clojure-style namespaces dependent on the JVM classpath).\n;; The working directory is set to wherever you invoked the JVM from, \n;; likely the project root.\n\n(load-file \"src/mylib/core.clj\")\n\n;; now you can go and evaluate vars defined in that file." ";; file located at src/address_book/core.clj\n;; current dir is src/..\n\n(load-file \"src/address_book/core.clj\")" ";; create a clojure file on the fly using spit\n;; then load it into the REPL and use its function\n\nuser=> (spit \"mycode.clj\" \"(defn doub [x] (* x 2))\")\nnil\nuser=> (load-file \"mycode.clj\")\n#'user/doub\nuser=> (doub 23)\n46\n\n;; Note this is equivalent to using load-string:\nuser=> (load-string \"(defn doub [x] (* x 2))\")\n#'user/doub"], :notes ["<p>Be aware that this function is intended to load code only. If your data structures or a string in them grow bigger than around 65,535 it crashes.</p>\r\n\r\n<p>Exception similar to:</p>\r\n<pre>java.lang.ClassFormatError: Unknown constant tag 49 in class file parse$eval13</pre>\r\n\r\n<p>Please use <a href=\"/clojure_core/clojure.core/read-string\">read-string</a> instead.</p>\r\n\r\nExample: <pre>(read-string (slurp \"data.clj\"))</pre>\r\n\r\nSource: <a href=\"http://groups.google.com/group/clojure/browse_thread/thread/e556434a382de814/f8183c88db8fa257?lnk=gst&q=string+size#f8183c88db8fa257\">Google Groups</a>" "<p>The following marginally helpful error will be thrown if you have a typo in your file:</p>\r\n\r\n<pre>CompilerException java.lang.RuntimeException: Unable to resolve symbol: load-file in this context, compiling:(NO_SOURCE_PATH:1:1)</pre>\r\n\r\n<p>Fix the syntax error(s) in and you'll be able to use load-file again.</p>\r\n\r\n\r\n"], :arglists ["name"], :doc "Sequentially read and evaluate the set of forms contained in the file.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/load-file"}, :clojure.core/prn {:added "1.0", :ns "clojure.core", :name "prn", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/println :clojure.core/pr], :line 3706, :examples ["user=> (prn \"fred\" 1)\n\"fred\" 1\nnil\n\nuser=> (def items [ \"hello\" :a 1 (list :b 2) \\c {:d 4} #{5 6 7} ])\n#'user/items\n\n; prn outputs items in a machine-readable format, such as in a source\n; file. Note the double-quotes around the string \"hello\" and the escaped letter \"c\".\nuser=> (prn items)\n[\"hello\" :a 1 (:b 2) \\c {:d 4} #{5 6 7}]\nnil\n\n; println is for human-readable output, like a report. Note the lack of quotes around the string \"hello\", and the unescaped letter \"c\". \nuser=> (println items)\n[hello :a 1 (:b 2) c {:d 4} #{5 6 7}]\nnil\n\n; pr-str produces a string with escaped punctuation, so that println yields the same result as the original prn call.\nuser=> (println (pr-str items))\n[\"hello\" :a 1 (:b 2) \\c {:d 4} #{5 6 7}]\nnil\n\n"], :notes nil, :arglists ["& more"], :doc "Same as pr followed by (newline). Observes *flush-on-newline*", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/prn"}, :clojure.core/set-agent-send-off-executor! {:added "1.5", :ns "clojure.core", :name "set-agent-send-off-executor!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 2087, :examples nil, :notes nil, :arglists ["executor"], :doc "Sets the ExecutorService to be used by send-off", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set-agent-send-off-executor!"}, :clojure.core/int? {:added "1.9", :ns "clojure.core", :name "int?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/integer? :clojure.core/number? :clojure.core/pos-int? :clojure.core/neg-int? :clojure.core/nat-int?], :line 1392, :examples [";; Note that this will return true for things which aren't strictly Java ints:\n(int? 42)                       \n;; => true\n\n(int? (java.lang.Integer. 42))  \n;; => true\n\n(int? (java.lang.Long. 42))     \n;; => true\n\n(int? 42.0)\n;; => false\n\n(int? (bigdec 42))\n;; => false\n\n;; The distinction between int? and integer? is that integer? will return true \n;; for BigInts:\n\n(int? (bigint 42))        \n;; => false\n\n(integer? (bigint 42))    \n;; => true\n\n(int? java.math.BigInteger/ONE)\n;; => false\n\n(integer? java.math.BigInteger/ONE)\n;; => true\n"], :notes nil, :arglists ["x"], :doc "Return true if x is a fixed precision integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/int_q"}, :clojure.core/qualified-symbol? {:added "1.9", :ns "clojure.core", :name "qualified-symbol?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/symbol? :clojure.core/simple-symbol? :clojure.core/namespace], :line 1624, :examples ["(qualified-symbol? 'clojure.core/symbol)\n;;=> true\n\n(qualified-symbol? 'symbol)\n;;=> nil\n\n(qualified-symbol? \"string\")\n;;=> false\n(qualified-symbol? 42)\n;;=> false\n(qualified-symbol? nil)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a symbol with a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/qualified-symbol_q"}, :clojure.core/rand {:added "1.0", :ns "clojure.core", :name "rand", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rand-int :clojure.core/rand-nth :clojure.core/shuffle], :line 4851, :examples [";; Test `rand` never returns `n`:\nuser=> (some (partial <= 10) (take 100000 (repeatedly (fn [] (int (rand 10))))))\nnil\n" "user=> (rand)\n0.17469201779243182\n\nuser=> (rand 100)\n49.542391492950834"], :notes nil, :arglists ["" "n"], :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rand"}, :clojure.core.logic/composeg {:ns "clojure.core.logic", :name "composeg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1053, :examples nil, :notes nil, :arglists ["" "g0 g1"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/composeg"}, :clojure.core/proxy {:added "1.0", :ns "clojure.core", :name "proxy", :file "clojure/core_proxy.clj", :type "macro", :column 1, :see-alsos [:clojure.core/gen-class :clojure.core/gen-interface :clojure.core/reify], :line 329, :examples [";; adding a mouse-pressed callback to a Swing component:\n\n(defn add-mousepressed-listener\n  [component f & args]\n  (let [listener (proxy [MouseAdapter] []\n                        (mousePressed [event]\n                                      (apply f event args)))]\n    (.addMouseListener component listener)\n    listener))\n" ";; BUG: proxy dispatches *only* on name, not arity:\nuser=> (let [p (proxy [java.io.InputStream] [] (read [] -1))]\n         (println (.read p))\n         (println (.read p (byte-array 3) 0 3)))\n\n-1\nArityException Wrong number of args (4) passed to: core$eval213$fn  clojure.lang.AFn.throwArity (AFn.java:437)\n" ";; You can, however, provide multiple-arity functions to get some support \n;; for overloading\nuser> (let [p (proxy [java.io.InputStream] []\n          (read ([] 1)\n            ([^bytes bytes] 2)\n            ([^bytes bytes off len] 3)))]\n  (println (.read p))\n  (println (.read p (byte-array 3)))\n  (println (.read p (byte-array 3) 0 3)))\n\n1\n2\n3\nnil"], :macro true, :notes nil, :arglists ["class-and-interfaces args & fs"], :doc "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/proxy"}, :clojure.xml/*sb* {:ns "clojure.xml", :name "*sb*", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 18, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/*sb*"}, :clojure.core/map-entry? {:added "1.8", :ns "clojure.core", :name "map-entry?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1470, :examples ["user=> (class {:a 1 :b 2})\nclojure.lang.PersistentArrayMap\n\nuser=> (class (first {:a 1 :b 2}))\nclojure.lang.MapEntry\n;; A map entry is treated as an ordered collection of key and value.\n;; https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/MapEntry.java\n\nuser=> (map-entry? (first {:a 1 :b 2}))\ntrue"], :notes nil, :arglists ["x"], :doc "Return true if x is a map entry", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/map-entry_q"}, :clojure.core.async/admix {:ns "clojure.core.async", :name "admix", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/unmix :clojure.core.async/unmix-all :clojure.core.async/mix], :line 806, :examples ["user=> (def ch-out (chan))\n#'user/ch-out\n\nuser=> (def mix-out (mix ch-out))\n#'user/mix-out\n\nuser=> (def ch-example1 (chan))\n#'user/ch-example1\n\nuser=> (def ch-example2 (chan))\n#'user/ch-example2\n\nuser=> (admix mix-out ch-example1)\ntrue\n\nuser=> (admix mix-out ch-example2)\ntrue\n\nuser=> (put! ch-example1 \"sent to chan 1\")\ntrue\n\nuser=> (put! ch-example2 \"sent to chan 2\")\ntrue\n\nuser=> (<!! ch-out)\n\"sent to chan 1\"\n\nuser=> (<!! ch-out)\n\"sent to chan 2\"\n\n"], :notes nil, :arglists ["mix ch"], :doc "Adds ch as an input to the mix", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/admix"}, :clojure.core/fnext {:added "1.0", :ns "clojure.core", :name "fnext", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ffirst :clojure.core/second :clojure.core/next :clojure.core/nnext :clojure.core/nfirst :clojure.core/first], :line 112, :examples ["user=> (fnext ['(a b c) '(b a c)])\n(b a c) \n\nuser=> (fnext '([a b c] [b a c]))\n[b a c] \n\nuser=> (fnext {:a 1 :b 2 :c 3})\n[:b 2] \n\nuser=> (fnext [])\nnil \n\nuser=> (fnext [1])\nnil"], :notes ["Synonym of `second`."], :arglists ["x"], :doc "Same as (first (next x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/fnext"}, :clojure.core/set! {:ns "clojure.core", :name "set!", :type "var", :see-alsos [:clojure.core/reset! :clojure.core/binding :clojure.core/alter-var-root], :examples ["(set! var-symbol expr)" "(set! *warn-on-reflection* true)"], :notes ["As of Clojure 1.2, the basic info for set! has moved to http://clojure.org/vars."], :arglists [], :doc "Assignment special form. When the first operand is a field member access\nform, the assignment is to the corresponding field. If it is an instance\nfield, the instance expr will be evaluated, then the expr. In all cases\nthe value of expr is returned. Note - you cannot assign to function params\nor local bindings. Only Java fields, Vars, Refs and Agents are mutable in\nClojure. See http://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set!"}, :clojure.pprint/pprint-logical-block {:added "1.2", :ns "clojure.pprint", :name "pprint-logical-block", :file "clojure/pprint/pprint_base.clj", :type "macro", :column 1, :see-alsos nil, :line 302, :examples nil, :macro true, :notes nil, :arglists ["options* body"], :doc "Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pprint-logical-block"}, :clojure.core.async/take! {:ns "clojure.core.async", :name "take!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/put! :clojure.core.async/<! :clojure.core.async/<!!], :line 122, :examples ["user=> (def c (chan 1))\n#'user/c\n\nuser=> (take! c\n              (fn [x]\n                (println \"Clojure callback value \" x)))\nnil\n\nuser=> (put! c \"XYZ\")\nClojure callback value  XYZ\ntrue\n\nuser=> (put! c \"XYZ\")\ntrue\n" "(require '[clojure.core.async :refer [chan take! put!]])\n\n(def input-channel (chan 1))\n\n;; Take the first message from a channel and print it\n(take! input-channel println)\n\n(put! input-channel \"A\")\n;; => \"A\"\n\n(put! input-channel \"B\")\n;; Does not output anything because take only takes the first message\n"], :notes nil, :arglists ["port fn1" "port fn1 on-caller?"], :doc "Asynchronously takes a val from port, passing to fn1. Will pass nil\n   if closed. If on-caller? (default true) is true, and value is\n   immediately available, will call fn1 on calling thread.\n   Returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/take!"}, :clojure.core/->ArrayChunk {:ns "clojure.core", :name "->ArrayChunk", :file "clojure/gvec.clj", :type "function", :column 1, :see-alsos nil, :line 36, :examples nil, :notes nil, :arglists ["am arr off end"], :doc "Positional factory function for class clojure.core.ArrayChunk.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->ArrayChunk"}, :clojure.core.logic/walk-record-term {:ns "clojure.core.logic", :name "walk-record-term", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 969, :examples nil, :notes nil, :arglists ["v f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/walk-record-term"}, :clojure.spec.alpha/every {:ns "clojure.spec.alpha", :name "every", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 499, :examples nil, :macro true, :notes nil, :arglists ["pred & {:keys [into kind count max-count min-count distinct gen-max gen], :as opts}"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred/spec that the collection type must satisfy, e.g. vector?\n        (default nil) Note that if :kind is specified and :into is\n        not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default: empty coll as generated by :kind pred if supplied, else [])\n  \n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/every"}, :clojure.core.logic/*locals* {:ns "clojure.core.logic", :name "*locals*", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 17, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/*locals*"}, :clojure.core.logic/fna {:ns "clojure.core.logic", :name "fna", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1718, :examples nil, :macro true, :notes nil, :arglists ["& rest"], :doc "Define an anonymous soft cut goal. See conda.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fna"}, :clojure.core/vector-of {:added "1.2", :ns "clojure.core", :name "vector-of", :file "clojure/gvec.clj", :type "function", :column 1, :see-alsos [:clojure.core/vec :clojure.core/vector :clojure.core/vector?], :line 484, :examples ["user=> (conj (vector-of :int) 1 2 3)\n[1 2 3]  ; <-- note, these are unboxed internally\n\nuser=> (vector-of :int 1 2 3)\n[1 2 3]  ; same here\n\nuser=> (type (conj (vector-of :int) 1 2 3))\nclojure.core.Vec\n"], :notes nil, :arglists ["t" "t & elements"], :doc "Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vector-of"}, :clojure.core/unchecked-char {:added "1.3", :ns "clojure.core", :name "unchecked-char", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3520, :examples nil, :notes nil, :arglists ["x"], :doc "Coerce to char. Subject to rounding or truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-char"}, :clojure.spec.alpha/alt {:ns "clojure.spec.alpha", :name "alt", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos [:clojure.spec.alpha/or], :line 604, :examples ["(require '[clojure.spec.alpha :as s])\n\n(let [spec (s/alt :n number? :b boolean?)]\n  [(s/conform spec [1])\n   (s/conform spec [true])\n   (s/conform spec [\"str\"])])\n;; => [[:n 1] [:b true] :clojure.spec.alpha/invalid]"], :macro true, :notes nil, :arglists ["& key-pred-forms"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/alt"}, :clojure.core.logic/conjo {:ns "clojure.core.logic", :name "conjo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2802, :examples ["(use 'clojure.core.logic)\n\n;; Like conj, but result is the last argument\n\n(run* [q] (conjo [1 2 3] 4 q))\n;;=> ([1 2 3 4])\n(run* [q] (conjo [1 2 3] 4 5 6 q))\n;;=> ([1 2 3 4 5 6])\n(run* [q] (conjo {:a 0} {:a 123 :b 345} q))\n;;=> ({:a 123, :b 345})\n\n;; Partially relational:\n(run* [q] (conjo [1 2] q [1 2 3]))\n;;=> (3)\n\n;; but the same doesn't work for maps\n(run* [q] (conjo {} q {:a 1}))\n;; java.lang.IllegalArgumentException: Don't know how to create ISeq from: clojure.core.logic.LVar\n\n;; This case works:\n(run* [q] (conjo {} {:a q} {:a 12345}))\n;;=> (12345)"], :notes nil, :arglists ["coll & args"], :doc "A constraint version of conj", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/conjo"}, :clojure.core/re-matches {:added "1.0", :ns "clojure.core", :name "re-matches", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-find :clojure.core/subs :clojure.core/re-groups :clojure.core/re-pattern], :line 4826, :examples [";; The distinction is that re-find tries to find _any part_ of the string\n;; that matches the pattern, but re-matches only matches if the _entire_\n;; string matches the pattern.\nuser=> (re-matches #\"hello\" \"hello, world\")\nnil\n\nuser=> (re-matches #\"hello.*\" \"hello, world\")\n\"hello, world\"\n\nuser=> (re-matches #\"hello, (.*)\" \"hello, world\")\n[\"hello, world\" \"world\"]\n" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases." "; Regex match flags can be embedded in the regex string.  So, we can convert the normal case-sensitive matching into case-insensitive matching.\n\nuser=> (re-matches #\"hello\" \"HELLO\")       ; case-sensitive\nnil\n\nuser=> (re-matches #\"(?i)hello\" \"hello\")   ; case-insensitive\n\"hello\"\nuser=> (re-matches #\"(?i)hello\" \"HELLO\")   ; case-insensitive\n\"HELLO\"\nuser=> (re-matches #\"(?i)HELLO\" \"heLLo\")   ; case-insensitive\n\"heLLo\"\n"], :notes nil, :arglists ["re s"], :doc "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-matches"}, :clojure.core/array-map {:added "1.0", :ns "clojure.core", :name "array-map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc :clojure.core/hash-map :clojure.core/sorted-map], :line 4345, :examples ["user=> (array-map [1 2] [3 4 5])\n{[1 2] [3 4 5]}" "user=> (array-map :a 10)\n{:a 10}\n\nuser=> (array-map :a 10 :b 20)\n{:a 10 :b 20}\n\nuser=> (apply array-map [:a 10 :b 20 :c 30])\n{:a 10 :b 20 :c 30}\n\nuser=> (apply assoc {} [:a 10 :b 20 :c 30]) ;same result using assoc\n{:a 10 :b 20 :c 30}\n" "user=> (keys (assoc (array-map :foo 10 :bar 20) :baz 30))\n(:baz :foo :bar)\n; baz is first; :foo and :bar follow the order given to array-map\n\n\n;; My results have consistently been different from what's listed above.\nuser=> (keys (assoc (array-map :foo 10 :bar 20) :baz 30))\n; => (:foo :bar :baz)\nuser=> (assoc (array-map :foo 10 :bar 20) :baz 30)\n; => {:foo 10, :bar 20, :baz 30}\nuser=> *clojure-version*\n; => {:major 1, :minor 8, :incremental 0, :qualifier nil}\n;; As long as I have an array map, new items get added to the end, not\n;; the beginning." ";; Sometimes Clojure will automatically choose between a hash map and\n;; an array map.  What's the rule?  Let's try a few experiments.\n\n;; Start with a quick way to make a map with N items.\nuser=> (defn make-map [count] (zipmap (range count) (range count)))\n;; => #'user/make-map\nuser=> (make-map 3)\n;; => {0 0, 1 1, 2 2}\n\n;; Try a few maps.  The cutoff seems to be 9.5.  If you have fewer than\n;; 9.5 items you get an array map.  If you have more than 9.5 items you\n;; get a hash map.\nuser=> (type (make-map 8))\n;; => clojure.lang.PersistentArrayMap\nuser=> (type (make-map 9))\n;; => clojure.lang.PersistentArrayMap\nuser=> (type (make-map 10))\n;; => clojure.lang.PersistentHashMap\nuser=> (type (make-map 11))\n;; => clojure.lang.PersistentHashMap\n\n;; Using assoc we get similar results.  9 or fewer items yields an array\n;; map.  10 or more yields a hash map.\nuser=> (type (assoc (make-map 9) :x 1))  ; 10 items -> hash map.\n;; => clojure.lang.PersistentHashMap\nuser=> (type (assoc (make-map 8) :x 1))  ; 9 items -> array map.\n;; => clojure.lang.PersistentArrayMap\nuser=> (type (assoc (make-map 8) :x 1 :y 2))  ; 10 items -> hash map.\n;; => clojure.lang.PersistentHashMap\nuser=> (type (assoc (assoc (make-map 8) :x 1) :y 2))  ; 10 items -> hash map.\n;; => clojure.lang.PersistentHashMap\n\n;; But when we use { and } to create a map, the cutoff seems to move to 8.5.\n;; A map with 9 items created with assoc or zipmap would be an array map,\n;; but a map with 9 items created by { } is a hash map.\nuser=> (type {0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7})  ; 8 items -> array map.\n;; => clojure.lang.PersistentArrayMap\nuser=> (type {0 0, 1 1, 2 2, 3 3, 4 4, 5 5, 6 6, 7 7, 8 8})  ; 9 items -> hash\n;; => clojure.lang.PersistentHashMap\n\n;; Calling dissoc on an array map always yields an array map, regardless of\n;; the size of the map.\n;; Let's start by making a large array map then remove a few items.  This will\n;; give us array maps larger than you could create with assoc.\nuser=> (def array20 (apply array-map (range 40)))\n;; => #'user/array20\nuser=> (type array20)\n;; => clojure.lang.PersistentArrayMap\nuser=> (type (dissoc array20 6))\n;; => clojure.lang.PersistentArrayMap\nuser=> (count (dissoc array20 6))\n;; => 19\nuser=> (type (dissoc array20 6 2))\n;; => clojure.lang.PersistentArrayMap\nuser=> (count (dissoc array20 6 2))\n;; => 18\n\n;; Calling dissoc on a hash map always yields another hash map, regardless\n;; of the size of the map.\n;; Let's start by making a large hash map then remove a lot of items.  This\n;; will give us hash maps smaller than you could create with assoc.\nuser=> (type (make-map 40))\n;; => clojure.lang.PersistentHashMap\nuser=> (type (apply dissoc (make-map 40) (range 1 80)))\n;; => clojure.lang.PersistentHashMap\nuser=> (count (apply dissoc (make-map 40) (range 1 80)))\n;; => 1\nuser=> (apply dissoc (make-map 40) (range 1 80))\n;; => {0 0}\nuser=> (type (apply dissoc (make-map 40) (range 0 80)))\n;; => clojure.lang.PersistentHashMap\nuser=> (count (apply dissoc (make-map 40) (range 0 80)))\n;; => 0\nuser=> (apply dissoc (make-map 40) (range 0 80))\n;; => {}\n"], :notes ["The definition is kind of short, IMO. More descriptively, `array-map` creates a mapping with arrays being the keys and the values. It doesn't seem like `array-map` cares whether or not the keys/values are arrays, although it doesn't seem to like sequences." "An <code>array-map</code> maintains the insertion order of the keys. Look up is linear, which is not a problem for small maps (say less than 10 keys). If your map is large, you should use <code>hash-map</code> instead. \r\n\r\nWhen you <code>assoc</code> onto an existing array-map, the result is a new array-map with the new key as the first key.  The rest of the keys are in the same order as the original. Functions such as <code>seq</code> and <code>keys</code> will respect the key order. \r\n\r\nNote that <code>assoc</code> will decide to return a hash-map if the result is too big to be efficient.</p>\r\n"], :arglists ["" "& keyvals"], :doc "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/array-map"}, :clojure.spec.alpha/nilable-impl {:ns "clojure.spec.alpha", :name "nilable-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1782, :examples nil, :notes nil, :arglists ["form pred gfn"], :doc "Do not call this directly, use 'nilable'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/nilable-impl"}, :clojure.core/partial {:added "1.0", :ns "clojure.core", :name "partial", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/comp :clojure.core/juxt], :line 2606, :examples ["user=> (def to-english (partial clojure.pprint/cl-format nil \"~@(~@[~R~]~^ ~A.~)\"))\n#'user/to-english\n\nuser=> (to-english 1234567890)\n\"One billion, two hundred thirty-four million, five hundred sixty-seven thousand, eight hundred ninety\"\n" "user=> (def hundred-times (partial * 100))\n#'user/hundred-times\n\nuser=> (hundred-times 5)\n500\n\nuser=> (hundred-times 4 5 6)\n12000\n\nuser=> (def add-hundred (partial + 100))\n#'user/add-hundred\n\nuser=> (add-hundred 5)\n105\n" "(def subtract-from-hundred (partial - 100))\n\nuser=> (subtract-from-hundred 10)      ; same as (- 100 10)\n90\n\nuser=> (subtract-from-hundred 10 20)   ; same as (- 100 10 20)\n70" "; Maps exponent to coefficient\n; x^3 + 2x + 1\n(def poly (fn [n]\n  (cond\n    (= 0 n) 1\n    (= 1 n) 2\n    (= 3 n) 1\n    :else 0)\n  )\n)\n\n; Differentiates input by returning a polynomial that is curried\n; 3x^2 + 2\n(defn diff [p]\n  (partial (fn [p n] (* (+ 1 n) (p (+ 1 n)))) p)\n)\n\n(poly 3)\n;=> 1\n((diff poly) 3)\n;=> 0\n((diff poly) 2)\n;=> 3\n" "user=> (defn fun-full [x y] (+ x y))\n;=> #<function user$fun_full(x,y){ ...\n\nuser=> (fun-full 2 3)\n;=> 5\n\nuser=> (def fun-half (partial fun-full 2))\n;=> #<function (x,y,z,var_args){ ...\n\nuser=> (fun-half 3)\n;=> 5\n" ";;Takes a function f and the normal full arguments is allowed\n\nuser=> (defn add [x y] (+ x y))\n#'user/add\nuser=> (partial add 1 1 )\n#object[clojure.core$partial$fn__4529 0x5eb8fe04 \"clojure.core$partial$fn__4529@5eb8fe04\"]\nuser=> (apply (partial add 1 1 ) nil)\n2\nuser=> ((partial add 1 1 ))\n2\nuser=> ((partial add 1 1 1))\nArityException Wrong number of args (3) passed to: user/add  clojure.lang.AFn.throwArity (AFn.java:429)\n\nuser=>" "user=> (def add1 (partial + 1))\n#'user/add1\nuser=> (add1)\n;=> 1\nuser=> (add1 2)\n;=> 3\nuser=> (add1 2 3 4)\n;=> 10\nuser=> (= (add1 2 3 4) (+ 1 2 3 4))\n;=> true" "(def times (partial *))\n\n(times 1) ; -> 1\n\n(times 1 2 3) ; -> 6\n\n(* 1 2 3) ; -> 6\n\n\n(def add-hundred (partial + 100))\n\n(add-hundred 1) ; -> 101\n\n(add-hundred 1 2 3) ; -> 106\n\n(+ 100 1 2 3) ; -> 106" ";; Check if a character is vowel\n\n(def vowel? #(some (partial = %) \"aiueo\"))\n\n(vowel? \\e)\n;;=> true\n\n(vowel? \\c)\n;;=> nil" ";; apply feeds sequence items as variable args to the conj function\n;; variable args gets converted to list in the function arg and hence conj \n;; adds them as a list\n(apply #(conj [0 1] %&) [2 3 4 5])\n;;=> [0 1 (2 3 4 5)]\n\n;; Partial offers are mechanism to feed the variable args as is to the conj \n;; function effectively  like (conj [] 2 3 4 5)\n(apply (partial conj [0 1]) [2 3 4 5])\n;;=> [0 1 2 3 4 5]" ";;practical example\n\n(def add-domain\n  (partial (str \"@clojure.com\")))\n\n(str \"info\" add-domain )\n;;\"info@clojure.com\"" "(defn email-struct\n  [username domain]\n  (str username \"@\" domain))\n\n(def build-email\n  #(partial email-struct %))\n\n((build-email \"info\") \"example.com\")\n;;\"info@example.com\""], :notes ["This function implements the concept of â€œ[currying](http://en.wikipedia.org/wiki/Currying)â€�."], :arglists ["f" "f arg1" "f arg1 arg2" "f arg1 arg2 arg3" "f arg1 arg2 arg3 & more"], :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/partial"}, :clojure.core/chunk-rest {:ns "clojure.core", :name "chunk-rest", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-first :clojure.core/chunk-next], :line 696, :examples ["(let [chunked-cons (seq (range 1 42))\n      rest-chunk (chunk-rest chunked-cons)]\n\n  (class rest-chunk)\n  ;; => clojure.lang.LazySeq\n\n  (first rest-chunk)\n  ;; => 33\n\n  (last rest-chunk)\n  ;; => 41\n)"], :notes nil, :tag "clojure.lang.ISeq", :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-rest"}, :clojure.spec.alpha/Spec {:ns "clojure.spec.alpha", :name "Spec", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :line 37, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/Spec"}, :clojure.spec.alpha/unform {:ns "clojure.spec.alpha", :name "unform", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos [:clojure.spec.alpha/conform], :line 152, :examples nil, :notes nil, :arglists ["spec x"], :doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n  destructuring undone.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/unform"}, :clojure.core.logic.pldb/with-dbs {:ns "clojure.core.logic.pldb", :name "with-dbs", :file "clojure/core/logic/pldb.clj", :type "macro", :column 1, :see-alsos nil, :line 8, :examples nil, :macro true, :notes nil, :arglists ["dbs & body"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/with-dbs"}, :clojure.core/create-ns {:added "1.0", :ns "clojure.core", :name "create-ns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove-ns :clojure.core/find-ns :clojure.core/intern], :line 4098, :examples [";; This won't work because the symbol my-new-namespace isn't defined yet\nuser=> (create-ns my-new-namespace)\njava.lang.Exception: Unable to resolve symbol: my-new-namespace in this context (NO_SOURCE_FILE:2)\n\n\n;; This won't work because create-ns expects a symbol, not a string \nuser=> (create-ns \"my-new-namespace\")\njava.lang.ClassCastException: java.lang.String cannot be cast to clojure.lang.Symbol (NO_SOURCE_FILE:0)\n\n\n;; Here my-new-namespace is quoted and passed literally to create-ns\n;; without being looked up. It works as documented.\nuser=> (create-ns 'my-new-namespace)\n#<Namespace my-new-namespace>\n" ";; Let's create a namespace and check for our result\n;; the new namespace will be \"my-new-namespace\"\n\n;; it does not exist yet, so looking for it, finds nothing\nuser=> (find-ns 'my-new-namespace) \nnil\n\n;; let's create it\nuser=> (create-ns 'my-new-namespace)\n#&lt;Namespace my-new-namespace&gt;\n\n;; now searching for it again will have a result\nuser=> (find-ns 'my-new-namespace)\n#&lt;Namespace my-new-namespace&gt;\n" ";; You can create a namespace, not switch to it and still work in, by storing it\n\n;; create the namespace\nuser=> (def for-later-use (create-ns 'my-namespace))\n#'user/for-later-use\n\n;; assign a value for a variable\nuser=> (intern for-later-use 'my-var \"some value\")\n#'my-namespace/my-var\n;; notice how the \"for-later-use\" symbol has been evaluated to the namespace it represents\n\n;; check the new variable\nuser=> my-namespace/my-var\n\"some value\"\n\n;; you can also work on a namespace by using the its name\n;; (but quoting it) instead of the return of \"create-ns\"\nuser=> (intern 'my-namespace 'my-var \"some other value\")\n#'my-namespace/my-var\n\n;; check the new assignment and see what's changed\nuser=> my-namespace/my-var\n\"some other value\"\n"], :notes nil, :arglists ["sym"], :doc "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/create-ns"}, :clojure.core.async/tap {:ns "clojure.core.async", :name "tap", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/mult :clojure.core.async/untap], :line 712, :examples ["user=> (def sz 20)\n#'user/sz\n\nuser=> (def c (chan sz))\n#'user/c\n\nuser=> (def mult-c (mult c))\n#'user/mult-c\n\nuser=> (def cx (chan sz))\n#'user/cx\n\nuser=> (def cy (chan sz))\n#'user/cy\n\nuser=> (def cz (chan sz))\n#'user/cz\n\nuser=> (tap mult-c cx)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@63942268>\n\nuser=> (tap mult-c cy)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@1f025346>\n\nuser=> (tap mult-c cz)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@29d4cd91>\n\nuser=> (put! c \"sent to all\")\ntrue\n\nuser=> (<!! cx)\n\"sent to all\"\n\nuser=> (<!! cy)\n\"sent to all\"\n\nuser=> (<!! cz)\n\"sent to all\"\n\n"], :notes nil, :arglists ["mult ch" "mult ch close?"], :doc "Copies the mult source onto the supplied channel.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/tap"}, :clojure.core/with-in-str {:added "1.0", :ns "clojure.core", :name "with-in-str", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-out-str], :line 4693, :examples [";; Given you have a function that will read from *in*\n(defn prompt [question]\n  (println question)\n  (read-line))\n\nuser=> (prompt \"How old are you?\")\nHow old are you?\n34                   ; <== This is what you enter\n\"34\"                 ; <== This is returned by the function\n\n;; You can now simulate entering your age at the prompt by using with-in-str\n\nuser=> (with-in-str \"34\" (prompt \"How old are you?\"))\nHow old are you?\n\"34\"                 ; <== The function now returns immediately \n"], :macro true, :notes nil, :arglists ["s & body"], :doc "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-in-str"}, :clojure.core.reducers/take {:added "1.5", :ns "clojure.core.reducers", :name "take", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 234, :examples nil, :notes nil, :arglists ["n" "n coll"], :doc "Ends the reduction of coll after consuming n values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/take"}, :clojure.spec.alpha/*coll-error-limit* {:ns "clojure.spec.alpha", :name "*coll-error-limit*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 33, :examples nil, :notes nil, :arglists [], :doc "The number of errors reported by explain in a collection spec'ed with 'every'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*coll-error-limit*"}, :clojure.core/into-array {:added "1.0", :ns "clojure.core", :name "into-array", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/to-array :clojure.core/make-array], :line 3435, :examples [";; Array's component type is set to (class 2), cannot add Strings.\n;; This will result in an IllegalArgumentException\nuser=> (into-array [2 \"4\" \"8\" 5])\n;; Evaluation aborted.\n\n;; However, if the common type is specified, aforementioned values can be put into an array\nuser=> (into-array Object [2 \"4\" \"8\" 5])\n#<Object[] [Ljava.lang.Object;@3aa6d0a4>\n\nuser=> (into-array (range 4))\n#<Integer[] [Ljava.lang.Integer;@63d6dc46>\n\n;; if you assign a type, you still have to coerce values\nuser=> (into-array Byte/TYPE (range 4))\n;; Evaluation aborted.\n\nuser=> (into-array Byte/TYPE (map byte (range 4)))\n#<byte[] [B@68ffefc9>" ";; java.nio.file.Paths#get takes (String, String...)\nuser=> (java.nio.file.Paths/get \"/Users\" (into-array [\"username\" \"dev\" \"clojure\"]))\n#<UnixPath /Users/username/dev/clojure>" ";; Creating an empty array defaults to Object[]\nuser=> (into-array [])\n#<Object[] [Ljava.lang.Object;@21f1151f>\n\n;; However, the type of an empty array can be coerced\nuser=> (into-array String [])\n#<String[] [Ljava.lang.String;@578baf24>\n"], :notes nil, :arglists ["aseq" "type aseq"], :doc "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/into-array"}, :clojure.core/promise {:added "1.1", :ns "clojure.core", :name "promise", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/realized? :clojure.core/future :clojure.core/deliver], :line 7016, :examples ["user=> (def x (promise))\n#'user/x\n;; Trying to deref at this point will make your repl wait forever\n\n\nuser=> (deliver x 100)\n#&lt;core$promise$reify__5534@4369a50b: 100&gt;\n\n;; the promise has been delivered, deref x will return immediately\nuser=> @x\n100\n\n" ";; Create a promise\nuser> (def p (promise))\n#'user/p ; p is our promise\n\n;; Check if was delivered/realized\nuser> (realized? p)\nfalse ; No yet\n\n;; Delivering the promise\nuser> (deliver p 42)\n#<core$promise$reify__5727@47122d: 42>\n\n;; Check again if it was delivered\nuser> (realized? p)\ntrue ; Yes!\n\n;; Deref to see what has been delivered\nuser> @p\n42\n\n;; Note that @ is shorthand for deref\nuser> (deref p)\n42\n" ";; Illustrates how threads can work together via promises\n;; First, an example to show a future that delivers\n\nuser=> (def p (promise))\n#'user/p\n\n;; future that will deliver the promise from another thread after 10 sec delay\nuser=> (future\n         (Thread/sleep 10000)\n         (deliver p 123))\n#future[{:status :pending, :val nil} 0x9a51df1]\n\n;; within 10 seconds dereference p, and wait for delivery of the value\nuser=> @p\n123\n\n\n;; Now, an example to show a future that blocks while waiting for a promise\n;; to be delivered -- this is used to achieve callback-style functionality\n\n;; redefine p\nuser=> (def p (promise))\n#'user/p\n\n;; create a new callback thread that will wait for a promise to be delivered\nuser=> (future\n         (println \"About to block while waiting for 'p'\")\n         (println \"Now I can do some work with the value \" @p))\nAbout to block while waiting for 'p'\n#future[{:status :pending, :val nil} 0x1737df29]\n\n;; deliver the promise, triggering the blocking callback thread\nuser=> (deliver p 123)\nNow I can do some work with the value  123\n#promise[{:status :ready, :val 123} 0x674a4c4a]"], :notes nil, :arglists [""], :doc "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/promise"}, :clojure.core/not-any? {:added "1.0", :ns "clojure.core", :name "not-any?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/some :clojure.core/every?], :line 2695, :examples ["user=> (not-any? odd? '(2 4 6))\ntrue\nuser=> (not-any? odd? '(1 2 3))\nfalse"], :notes ["Why is there a `not-any?` but no `any?`?" "You can use this for any?:\n\n(def any?\n  (complement not-any?))" "You can also use <code>some</code> for <code>any?</code>" "`some` is not quite the same as `any?` because the latter returns a Boolean\n\n```\nuser> (def any? (complement not-any?))\n#'user/any?\nuser> (some #{:a} [:a :b :c])\n:a\nuser> (any? #{:a} [:a :b :c])\ntrue\nuser> (some #{:d} [:a :b :c])\nnil\nuser> (any? #{:d} [:a :b :c])\nfalse\n```\n\nI also find `one-of?` handy:\n\n```\n(defn one-of? [x coll]\n  (any? #{x} coll))\n```" "<pre> \n(not-any?   #(= \"query\"  %)   (list \"hola\" \"query\" \"fin\"))   ;false\n(not-any?   #(= \"query\"  %)   (list \"hola\" \"fin\"))           ;true\n(not-any?   #(= \"query\"  %)   (list))                        ;true\n(not-any?   #(= \"query\"  %)   nil)                           ;true\n(not-any?   #(= \"query\"  %)   '())                           ;true\n"], :tag "java.lang.Boolean", :arglists ["pred coll"], :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/not-any_q"}, :clojure.core/ifn? {:added "1.0", :ns "clojure.core", :name "ifn?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/fn?], :line 6150, :examples [";; An anonymous function is a function as you'd expect\nuser=> (ifn? #(\"my anonymous function\"))\ntrue\n\n;; Is a vector a function?\nuser=> (ifn? [1 2 3])\ntrue\n\n;; Sure is, lets call it.\nuser=> ([1 2 3] 0)\n1\n\n;; Maps and sets are functions, too.\n\n;; a number is definitely not a function\nuser=> (ifn? 1)\nfalse\n\n;; but a symbol is\nuser=> (ifn? 'foo)\ntrue\n\n;; and so is a keyword\nuser=> (ifn? :foo)\ntrue"], :notes nil, :arglists ["x"], :doc "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ifn_q"}, :clojure.core/default-data-readers {:added "1.4", :ns "clojure.core", :name "default-data-readers", :file "clojure/core.clj", :type "var", :column 1, :see-alsos nil, :line 7670, :examples nil, :notes nil, :arglists [], :doc "Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/default-data-readers"}, :clojure.reflect/->Method {:ns "clojure.reflect", :name "->Method", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 128, :examples nil, :notes nil, :arglists ["name return-type declaring-class parameter-types exception-types flags"], :doc "Positional factory function for class clojure.reflect.Method.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/->Method"}, :clojure.core/some-> {:added "1.5", :ns "clojure.core", :name "some->", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/some->> :clojure.core/-> :clojure.core/cond-> :clojure.core/cond->> :clojure.core/as-> :clojure.core/->>], :line 7504, :examples ["user=> (-> {:a 1} :b inc)\n;; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:942)\n\nuser=> (some-> {:a 1} :b inc)\n;; nil\n" ";; Often used to \"short-circuit out\" of a series of steps:\n\n(some-> val\n        step1\n        step2\n        step3)\n\n;; When nil is returned by any step, the further steps are not executed. Thus\n;; the nil case need be handled only once, at the end."], :macro true, :notes nil, :arglists ["expr & forms"], :doc "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/some->"}, :clojure.core.async/go {:ns "clojure.core.async", :name "go", :file "clojure/core/async.clj", :type "macro", :column 1, :see-alsos [:clojure.core.async/go-loop], :line 403, :examples ["user=> (doseq [n (range 10)\n               :let [i (-> n\n                           inc\n                           range\n                           rand-nth)]]                    \n         (go\n           (<! (timeout (* i 1000)))\n           (println n)))\nnil\n5\n3\n0\n6\n4\n7\n1\n2\n9\n8\n\n" "(require '[clojure.core.async :as async])\n\n; create channel\n(def c (async/chan))\n\n; create promise\n(def d (promise))\n\n; record high-res timestamp;\n; place value (1) on channel;\n; in a callback, record duration of time between enqueueing and dequeueing;\n; resolve promise with that value\n(let [t (. System (nanoTime))]\n (async/put! c 1\n  (fn [_]\n   (deliver d (- (. System (nanoTime)) t)))))\n\n; do a blocking take from the channel, do a blocking resolve of the promise\n(println \"taken value, delivery time\" [(async/<!! c) @d])\n\n; same as above but with go block\n(def tc\n (let [t (. System (nanoTime))]\n  (async/put! c 2)\n  (async/go [(async/<! c) (- (. System (nanoTime)) t)])))\n\n; go blocks return a channel immediately, \n; the actual return value of the go block gets placed on the channel when ready\n(println \"taken value, delivery time\" (async/<!! tc))\n\n;; taken value, delivery time [1 1191935]\n;; taken value, delivery time [2 1668001]"], :macro true, :notes nil, :arglists ["& body"], :doc "Asynchronously executes the body, returning immediately to the\n  calling thread. Additionally, any visible calls to <!, >! and alt!/alts!\n  channel operations within the body will block (if necessary) by\n  'parking' the calling thread rather than tying up an OS thread (or\n  the only JS thread when in ClojureScript). Upon completion of the\n  operation, the body will be resumed.\n\n  Returns a channel which will receive the result of the body when\n  completed", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/go"}, :clojure.core/->VecSeq {:ns "clojure.core", :name "->VecSeq", :file "clojure/gvec.clj", :type "function", :column 1, :see-alsos nil, :line 58, :examples nil, :notes nil, :arglists ["am vec anode i offset"], :doc "Positional factory function for class clojure.core.VecSeq.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->VecSeq"}, :clojure.spec.alpha/*recursion-limit* {:ns "clojure.spec.alpha", :name "*recursion-limit*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 19, :examples nil, :notes nil, :arglists [], :doc "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*recursion-limit*"}, :clojure.core/unchecked-negate-int {:added "1.0", :ns "clojure.core", :name "unchecked-negate-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1169, :examples ["user=> (unchecked-negate-int 4)\n-4\nuser=> (unchecked-negate-int 0)\n0\nuser=> (unchecked-negate-int -7)\n7\nuser=> (unchecked-negate-int Integer/MAX_VALUE)\n-2147483647\nuser=> (unchecked-negate-int Integer/MIN_VALUE) ;overflow\n-2147483648"], :notes nil, :arglists ["x"], :doc "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-negate-int"}, :clojure.set/subset? {:added "1.2", :ns "clojure.set", :name "subset?", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.core/set? :clojure.core/set :clojure.set/superset? :clojure.core/every?], :line 142, :examples ["user> (clojure.set/subset? #{2 3} #{1 2 3 4})\ntrue\n\nuser> (clojure.set/subset? #{2 4} #{1 2 3 4})\ntrue\n\nuser> (clojure.set/subset? #{2 5} #{1 2 3 4})\nfalse" ";; Advice: Do not call subset? with non-set arguments.  If you are\n;; concerned that you may be unintentionally doing so, and want an\n;; exception to be thrown if you do, consider using the library\n;; funjible (https://github.com/jafingerhut/funjible) which provides\n;; its own definition of subset? that is identical to Clojure's,\n;; except it checks the types of its arguments.\n\n;; subset? might or might not return what you expect if you give it\n;; values that are not sets.  The implementation of subset? _does not\n;; check_ whether you are actually giving it values that are sets.  It\n;; _assumes_ so.\n\n;; If the second argument were a set with the same elements, you would\n;; expect the return value false here.\nuser=> (subset? #{1 3} [2 4 6 8])\ntrue\n\n;; Here, if the second argument were a set with the same elements as\n;; the vector, you would expect the return value true.\nuser=> (subset? #{1 3 5} [1 3 5])\nfalse\n\n;; And similarly here:\nuser=> (subset? #{\"1\" \"3\"} [\"1\" \"3\" \"5\"])\nfalse\n\n;; Why not change the definition of subset? so it always throws\n;; an exception if you give it a non-set argument?  I would guess that\n;; the primary reason is that the extra run-time type checks would\n;; slow subset? down by an amount that the Clojure core team does\n;; not want everyone to have to pay on every such call.\n\n;; Related Clojure tickets: \n;; https://dev.clojure.org/jira/browse/CLJ-1953\n;; https://dev.clojure.org/jira/browse/CLJ-2287\n"], :notes ["Do note that this will only work as expected for sets.  subset? uses contains? in it's implementation.  The functionality in contains? for vectors can be slightly unintuitive at first, and causes functions like this to perform in completely unexpected ways when using vectors instead of sets.  For example,\n\n```\nuser> (clojure.set/subset?  [0 1] [2 3])\ntrue\nuser> (clojure.set/subset?  [2 3] [2 3])\nfalse\n```\n\nIt is slightly more intuitive with maps, as it checks whether every item in the first collection is a key in the map passed in as the 2nd parameter, but still is probably a bit confusing to someone reading your code.\n\n```\nuser> (clojure.set/subset? '(7 8)  {8 1 7 3})\ntrue\nuser> (clojure.set/subset? '(9 10)  {8 1 7 3})\nfalse\n```\n\nLong story short, if you're using functions from the clojure.set namespace, make sure you're passing in sets.  "], :tag "java.lang.Boolean", :arglists ["set1 set2"], :doc "Is set1 a subset of set2?", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/subset_q"}, :clojure.core/ns-aliases {:added "1.0", :ns "clojure.core", :name "ns-aliases", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/alias :clojure.core/ns-unalias], :line 4240, :examples [";; clojure.core contains an alias\n(ns-aliases 'clojure.core)\n;;=> {jio #<Namespace clojure.java.io>}\n\n;; To start with there are no namespace aliases in the user namespace.\n(ns-aliases 'user)) \n;;=> {}\n\n;; ...but we can add an alias to the user namespace.\n(alias 'string 'clojure.string) \n(ns-aliases 'user)\n;;=> {string #{Namespace clojure.string>}\n\n" ";; Suppose you want to pass a namespace as an argument...\n(ns wip (:require [clojure.string :as string]\n                  [clojure.pprint :as pp]))\n(defn foo [nspace] nspace)\n\n;; ...pretty easy to do if you use the namespace symbol.\n(foo (the-ns 'clojure.string))\n;;=> #<Namespace clojure.string>\n\n;; but, a bit of a problem if you want to pass the alias.\n(foo (the-ns 'string))\n;; java.lang.Exception: No namespace: string found...\n\n;; We can make a function that will serve using ns-aliases.\n(defn the-alias [name] (get (ns-aliases *ns*) name))\n(the-alias 'string)\n;;=> #<Namespace clojure.string>\n\n(foo (the-alias 'string))\n;;=> #<Namespace clojure.string>\n\n;; A more direct function can be written.\n;; but this uses an undocumented function.\n(defn the-alias [alias-name] (.lookupAlias *ns* (symbol alias-name)))\n(the-alias \"pp\")\n;;=> #<Namespace clojure.pprint>\n\n\n\n\n"], :notes nil, :arglists ["ns"], :doc "Returns a map of the aliases for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-aliases"}, :clojure.core/read {:added "1.0", :ns "clojure.core", :name "read", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/read-string :clojure.core/*read-eval*], :line 3733, :examples ["user=> (read)\n( + 1 1 ) ; <= User types this\n(+ 1 1)\nuser=> (eval (read))\n(+ 1 1)   ; <= User types this\n2\n" ";; WARNING: You SHOULD NOT use clojure.core/read or\n;; clojure.core/read-string to read data from untrusted sources.  They\n;; were designed only for reading Clojure code and data from trusted\n;; sources (e.g. files that you know you wrote yourself, and no one\n;; else has permission to modify them).\n\n;; Instead, either:\n\n;; (1) Use another data serialization format such as JSON, XML,\n;; etc. and a library for reading them that you trust not to have\n;; vulnerabilities, or\n\n;; (2) if you want a serialization format that can be read safely and\n;; looks like Clojure data structures, use edn\n;; (https://github.com/edn-format/edn).  For Clojure 1.3 and later,\n;; the tools.reader contrib library provides an edn reader\n;; (http://github.com/clojure/tools.reader).  There is also\n;; clojure.edn/read and clojure.edn/read-string provided in Clojure\n;; 1.5.\n\n;; You definitely should not use clojure.core/read or read-string if\n;; *read-eval* has its default value of true, because an attacker\n;; could cause your application to execute arbitrary code while it is\n;; reading.  Example:\n\nuser=> (read-string \"#=(clojure.java.shell/sh \\\"echo\\\" \\\"hi\\\")\")\n{:exit 0, :out \"hi\\n\", :err \"\"}\n\n;; It is straightforward to modify the example above into more\n;; destructive ones that remove all of your files, copy them to\n;; someone else's computer over the Internet, install Trojans, etc.\n\n;; Even if you do bind *read-eval* to false first, like so:\n\n(defn read-string-unsafely [s]\n  (binding [*read-eval* false]\n    (read-string s)))\n\n;; you may hope you are safe reading untrusted data that way, but in\n;; Clojure 1.4 and earlier, an attacker can send data that causes your\n;; system to execute arbitrary Java constructors.  Most of these are\n;; benign, but it only takes one to ruin your application's day.\n;; Examples that should scare you:\n\n;; This causes a socket to be opened, as long as the JVM sandboxing\n;; allows it.\n(read-string-unsafely \"#java.net.Socket[\\\"www.google.com\\\" 80]\")\n\n;; This causes precious-file.txt to be created if it doesn't exist, or\n;; if it does exist, its contents will be erased (given appropriate\n;; JVM sandboxing permissions, and underlying OS file permissions).\n(read-string-unsafely \"#java.io.FileWriter[\\\"precious-file.txt\\\"]\")\n\n;; The particular issue of executing arbitrary Java constructors used\n;; in the examples above no longer works in Clojure 1.5 when\n;; *read-eval* is false.  Even so, you SHOULD NEVER USE\n;; clojure.core/read or clojure.core/read-string for reading untrusted\n;; data.  Use an edn reader or a different data serialization format.\n\n;; Why should I do this, you may ask, if Clojure 1.5 closes the Java\n;; constructor hole?  Because clojure.core/read and read-string are\n;; designed to be able to do dangerous things, and they are not\n;; documented nor promised to be safe from unwanted side effects.  If\n;; you use them for reading untrusted data, and a dangerous side\n;; effect is found in the future, you will be told that you are using\n;; the wrong tool for the job.  clojure.edn/read and read-string, and\n;; the tools.reader.edn library, are documented to be safe from\n;; unwanted side effects, and if any bug is found in this area it\n;; should get quick attention and corrected.\n\n;; If you understand all of the above, and want to use read or\n;; read-string to read data from a _trusted_ source, continue on\n;; below.\n\n;; read wants its reader arg (or *in*) to be a java.io.PushbackReader.\n;; with-open closes r after the with-open body is done.  *read-eval*\n;; specifies whether to allow #=() forms when reading, and evaluate\n;; them as a side effect while reading.\n\n(defn read-from-file-with-trusted-contents [filename]\n  (with-open [r (java.io.PushbackReader.\n                 (clojure.java.io/reader filename))]\n    (binding [*read-eval* false]\n      (read r))))\n\nuser=> (spit \"testfile.txt\" \"{:a 1 :b 2 :c 3}\")\nnil\nuser=> (read-from-file-with-trusted-contents \"testfile.txt\")\n{:a 1, :b 2, :c 3}\n"], :notes ["This function is for reading clojure objects not a general input function."], :arglists ["" "stream" "stream eof-error? eof-value" "stream eof-error? eof-value recursive?" "opts stream"], :doc "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/read"}, :clojure.zip/lefts {:added "1.0", :ns "clojure.zip", :name "lefts", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/rights], :line 96, :examples ["(def vz (vector-zip [1 2 3 4 5]))\n\n;; root\n;;  |________\n;;  | | | | |\n;;  1 2[3]4 5\n\n;;go down and then right twice, what's to the left of me now?\n(-> vz down right right lefts)\n=>(1 2)\n\n;;equivalent:\n(-> vz down right right rights)\n=>(4 5)\n\n"], :notes nil, :arglists ["loc"], :doc "Returns a seq of the left siblings of this loc", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/lefts"}, :clojure.spec.alpha/+ {:ns "clojure.spec.alpha", :name "+", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 592, :examples nil, :macro true, :notes nil, :arglists ["pred-form"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/+"}, :clojure.zip/right {:added "1.0", :ns "clojure.zip", :name "right", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/zipper], :line 149, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the right sibling of the node at this loc, or nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/right"}, :clojure.core/remove-all-methods {:added "1.2", :ns "clojure.core", :name "remove-all-methods", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove-method :clojure.core/prefers :clojure.core/methods :clojure.core/get-method :clojure.core/defmulti :clojure.core/defmethod], :line 1781, :examples [";; example showing use of multi-methods before and after remove-all-methods\n;; after removing all the methods, both circle and line tos functions throw\n;; exceptions\n\nuser=> (defmulti tos :Ob)\nnil\nuser=> (defn line [p1 p2] {:Ob :line :p1 p1 :p2 p2})\n#'user/line\nuser=> (defn circle [cent rad] {:Ob :circle :cent cent :rad rad})\n#'user/circle\nuser=> (defmethod tos :line [l] (str \"Line:\" (l :p1) (l :p2)))\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (defmethod tos :circle [c] (str \"Circle:\" (c :cent) (c :rad)))\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (println (tos (circle [2 3] 3.3)))\nCircle:[2 3]3.3\nnil\nuser=> (println (tos (line [1 1][0 0])))\nLine:[1 1][0 0]\nnil\nuser=> (remove-all-methods tos)\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (println (tos (circle [2 3] 3.3)))\njava.lang.IllegalArgumentException: No method in multimethod 'tos' for dispatch\nvalue: :circle (NO_SOURCE_FILE:0)\nuser=> (println (tos (line [1 1][0 0])))\njava.lang.IllegalArgumentException: No method in multimethod 'tos' for dispatch\nvalue: :line (NO_SOURCE_FILE:0)\nuser=>"], :notes nil, :arglists ["multifn"], :doc "Removes all of the methods of multimethod.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/remove-all-methods"}, :clojure.spec.alpha/amp-impl {:ns "clojure.spec.alpha", :name "amp-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1365, :examples nil, :notes nil, :arglists ["re preds pred-forms"], :doc "Do not call this directly, use '&'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/amp-impl"}, :clojure.core.logic/s# {:ns "clojure.core.logic", :name "s#", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 1148, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/s#"}, :clojure.core.reducers/fjtask {:ns "clojure.core.reducers", :name "fjtask", :file "clojure/core/reducers.clj", :type "function", :column 4, :see-alsos nil, :line 43, :examples nil, :notes nil, :arglists ["f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/fjtask"}, :clojure.test/deftest- {:added "1.1", :ns "clojure.test", :name "deftest-", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/deftest], :line 638, :examples nil, :macro true, :notes nil, :arglists ["name & body"], :doc "Like deftest but creates a private var.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/deftest-"}, :clojure.core.logic/->Substitutions {:ns "clojure.core.logic", :name "->Substitutions", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 287, :examples nil, :notes nil, :arglists ["s vs ts cs cq cqs oc _meta"], :doc "Positional factory function for class clojure.core.logic.Substitutions.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->Substitutions"}, :clojure.core/quot {:added "1.0", :ns "clojure.core", :name "quot", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rem :clojure.core/mod :clojure.core/unchecked-divide-int :clojure.core//], :line 1253, :examples [";; (quot m n) is the value of m/n, rounded towards 0 to the nearest integer.\n;; m, n need not be integers.\n\nuser=> (quot 10 3)\n3\n\nuser=> (quot 11 3)\n3\n\nuser=> (quot 12 3)\n4\n\nuser=> (quot -5.9 3)\n-1.0\n\nuser=> (quot 10 -3)\n-3\n\nuser=> (quot 15 0)\nArithmeticException / by zero  clojure.lang.Numbers.quotient (Numbers.java:1764)\n" ";; note that the \"/\" function and the quot function are not equivalent\n\nuser=> (= (/ 4 2) (quot 4 2))\ntrue\n\nuser=> (= (/ 3 2) (quot 3 2))\nfalse\n"], :notes nil, :arglists ["num div"], :doc "quot[ient] of dividing numerator by denominator.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/quot"}, :clojure.core/monitor-enter {:ns "clojure.core", :name "monitor-enter", :type "var", :see-alsos nil, :examples nil, :notes ["\"should be avoided\". OK.  But why is it available?  How might it be used?\n\nhttp://stackoverflow.com/questions/36485155/use-locking-macro-or-monitor-enter-and-monitor-exit-in-java-from-clojure/36485607"], :arglists [], :doc "A synchronization primitive that should be avoided in user code. Use the\nlocking macro. See http://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/monitor-enter"}, :clojure.core/shorts {:added "1.1", :ns "clojure.core", :name "shorts", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/short-array], :line 5303, :examples nil, :notes nil, :arglists ["xs"], :doc "Casts to shorts[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/shorts"}, :clojure.reflect/TypeReference {:ns "clojure.reflect", :name "TypeReference", :file "clojure/reflect.clj", :type "var", :column 1, :see-alsos nil, :line 48, :examples nil, :notes nil, :arglists [], :doc "A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/TypeReference"}, :clojure.core/aset-double {:added "1.0", :ns "clojure.core", :name "aset-double", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/double-array], :line 3932, :examples [";; create an array of 10 doubles and set one of the elements to 3.1415\n\nuser=> (def ds (double-array 10))\n#'user/ds\nuser=> (vec ds)\n[0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0]\nuser=> (aset-double ds 3 3.1415)\n3.1415\nuser=> (vec ds)\n[0.0 0.0 0.0 3.1415 0.0 0.0 0.0 0.0 0.0 0.0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of double. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-double"}, :clojure.core/even? {:added "1.0", :ns "clojure.core", :name "even?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/odd?], :line 1378, :examples ["user=> (even? 2)\ntrue\n\nuser=> (even? 1)\nfalse" "user=> (filter even? (range 10))\n(0 2 4 6 8)"], :notes nil, :arglists ["n"], :doc "Returns true if n is even, throws an exception if n is not an integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/even_q"}, :clojure.core/get-validator {:added "1.0", :ns "clojure.core", :name "get-validator", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 2392, :examples nil, :notes nil, :arglists ["iref"], :doc "Gets the validator-fn for a var/ref/agent/atom.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get-validator"}, :clojure.core/*allow-unresolved-vars* {:ns "clojure.core", :name "*allow-unresolved-vars*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*allow-unresolved-vars*"}, :clojure.core.logic.fd/-difference {:ns "clojure.core.logic.fd", :name "-difference", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this that"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-difference"}, :clojure.core.logic/remcg {:ns "clojure.core.logic", :name "remcg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2049, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/remcg"}, :clojure.string/lower-case {:added "1.2", :ns "clojure.string", :name "lower-case", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/upper-case :clojure.string/capitalize], :line 213, :examples ["user=> (clojure.string/lower-case \"MiXeD cAsE\")\n\"mixed case\""], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Converts string to all lower-case.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/lower-case"}, :clojure.core/ref {:added "1.0", :ns "clojure.core", :name "ref", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/alter :clojure.core/ref-set :clojure.core/add-watch :clojure.core/dosync :clojure.core/commute :clojure.core/ensure :clojure.core/ref-history-count :clojure.core/ref-min-history :clojure.core/ref-max-history :clojure.core/set-validator!], :line 2254, :examples ["user=> (ref [])\n#<ref@5fafa486: []>\n\nuser=> (ref 1 :validator pos?)\n#<Ref@6c484c6b: 1>\n\n=> (ref 0 :validator pos?)\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n\n=> (dosync (ref-set (ref 1 :validator pos?) 0))\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n\n=> (dosync (ref-set (ref 1 :validator pos?) 2))\n2" "; create(ref)\n(def a (ref '(1 2 3)))\n\n; read(deref)\n(deref a) ; -> (1 2 3)\n\n; rewrite(ref-set)\n; (ref-set a '(3 2 1)) err!\n(dosync (ref-set a '(3 2 1)))\n\n(deref a) ; -> (3 2 1)"], :notes nil, :arglists ["x" "x & options"], :doc "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ref"}, :clojure.core/dec' {:added "1.0", :ns "clojure.core", :name "dec'", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/dec :clojure.core/inc'], :line 1127, :examples ["user=> (dec' 0.1)\n-0.9\n\nuser=> (dec' 1)\n0\n\nuser=> (dec' 1.0)\n0.0" ";;;; (dec') auto-promotes on integer overflow:\n\n(dec' (Long/MIN_VALUE))\n;;=> -9223372036854775809N\n\n;;;; Unlike (dec) which does not:\n\n(dec (Long/MIN_VALUE))\n;;=> ArithmeticException integer overflow"], :notes nil, :arglists ["x"], :doc "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dec'"}, :clojure.test/run-all-tests {:added "1.1", :ns "clojure.test", :name "run-all-tests", :file "clojure/test.clj", :type "function", :column 1, :see-alsos [:clojure.test/run-tests :clojure.core/re-matches], :line 779, :examples [";; assuming current namespace is user\n(use 'clojure.test)\n(deftest eg-tests (is (= 1 1)))\n(run-all-tests)\n;;=> ... visits very many namespaces looking for tests to run\n;;=> {:type :summary, :fail 0, :error 0, :pass 1, :test 1}\n\n(run-all-tests #\"us.*\")  ; only matches \"user\"\n;;=> Testing user\n;;=> Ran 1 tests containing 1 assertions.\n;;=> 0 failures, 0 errors.\n;;=> {:type :summary, :fail 0, :error 0, :pass 1, :test 1}\n"], :notes nil, :arglists ["" "re"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/run-all-tests"}, :clojure.repl/apropos {:ns "clojure.repl", :name "apropos", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos [:clojure.repl/source :clojure.repl/doc :clojure.repl/dir], :line 182, :examples ["user=> (apropos \"temp\")\n()\n\nuser=> (require 'clojure.template)\nnil\n\nuser=> (apropos \"temp\")\n(apply-template do-template)\n"], :notes nil, :arglists ["str-or-pattern"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/apropos"}, :clojure.core/take-nth {:added "1.0", :ns "clojure.core", :name "take-nth", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partition], :line 4254, :examples ["user=> (take-nth 2 (range 10))\n(0 2 4 6 8)\n" ";; N <= 0 is a special case\n(take 3 (take-nth 0 (range 2)))\n;;=> (0 0 0)\n\n(take 3 (take-nth -10 (range 2)))\n;;=> (0 0 0)"], :notes ["`(take-nth 0 (range 10))` will loop forever." "(take-nth 0 coll) will return an infinite sequence repeating for first item from coll.  A negative N is treated the same as 0." "<pre>\n;; In case you are searching for it, drop-nth is not in core.\n\n(defn drop-nth [n coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (concat (take (dec n) (rest s))\n              (drop-nth n (drop n s))))))\n\n(drop-nth 3 (range 10))\n;; (1 2 4 5 7 8)\n\n;; or alternatively: (keep-indexed #(when-not (zero? (rem %1 n)) %2) coll)\n</pre>"], :arglists ["n" "n coll"], :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/take-nth"}, :clojure.core/update {:added "1.7", :ns "clojure.core", :name "update", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/update-in :clojure.core/fnil :clojure.core/assoc], :line 6108, :examples ["(def p {:name \"James\" :age 26})\n#'user/p\n\n(update p :age inc)\n;;=> {:name \"James\", :age 27}\n\n;; remember, the value of p hasn't changed!\n(update p :age + 10)\n;;=> {:name \"James\", :age 36}\n\n;; Here we see that the keyed object is \n;; the first argument in the function call.\n;; i.e. :age (- 26 10) => 16\n(update p :age - 10)\n;;=> {:name \"James\", :age 16}" ";; the map in update can be nil, and f will still be applied to nil and \n;; return a value\n\n(def empty-map nil)\n#'user/empty-map\n\n(update empty-map :some-key #(str \"foo\" %))\n;;=> {:some-key \"foo\"}\n" ";; can also use in []\n\nuser=> (update [1 2 3] 0 inc)\n;;=> [2 2 3]\n\nuser=> (update [] 0 #(str \"foo\" %))\n;;=> [\"foo\"]" "(def ds [{:id 1.0 :name \"name1\"}\n         {:id 2.0 :name \"name2\"}\n         {:id 3.0 :name \"name3\"}])\n\n(map (fn [x] (update x :name #(if (= \"name2\" %) % \"not 2\"))) ds)\n\n;; ({:id 1.0, :name \"not 2\"} {:id 2.0, :name \"name2\"} {:id 3.0, :name \"not 2\"})" ";; From string to boolean\n\n(def answer {:answer \"France\" :correct \"true\"  :age 11})\n(update answer :correct #(if (= % \"true\") true false))\n\n;; {:answer \"France\", :correct true, :age 11}"], :notes nil, :arglists ["m k f" "m k f x" "m k f x y" "m k f x y z" "m k f x y z & more"], :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/update"}, :clojure.spec.alpha/every-kv {:ns "clojure.spec.alpha", :name "every-kv", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 547, :examples nil, :macro true, :notes nil, :arglists ["kpred vpred & opts"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/every-kv"}, :clojure.spec.alpha/int-in {:ns "clojure.spec.alpha", :name "int-in", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 1862, :examples nil, :macro true, :notes nil, :arglists ["start end"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/int-in"}, :clojure.core.logic/sort-by-member-count {:ns "clojure.core.logic", :name "sort-by-member-count", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2218, :examples nil, :notes nil, :arglists ["a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/sort-by-member-count"}, :clojure.reflect/map->Field {:ns "clojure.reflect", :name "map->Field", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos [:clojure.reflect/map->Constructor :clojure.reflect/map->Method], :line 148, :examples ["(require '[clojure.reflect :as cr])\n\n;; I have no idea what this is for but here is what it does.\n(cr/map->Field {}) \n;=> #clojure.reflect.Field{:name nil, :type nil, :declaring-class nil, :flags nil}"], :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.reflect.Field, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/map->Field"}, :clojure.core/ns-unmap {:added "1.0", :ns "clojure.core", :name "ns-unmap", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/remove-ns :clojure.core/ns-map :clojure.core/def :clojure.core/intern :clojure.core/ns-unalias], :line 4144, :examples ["user=> (def foo 1)\n#'user/foo\n\nuser=> foo\n1\n\nuser=> (ns-unmap 'user 'foo) ; explicit\nnil\n\nuser=> (ns-unmap *ns* 'foo) ; convenient\nnil\n\nuser=> foo\n\"Unable to resolve symbol: foo in this context\"\n"], :notes ["Note this function doesn’t work for namespaces aliases; you need to use `ns-unalias` if you want to remove one."], :arglists ["ns sym"], :doc "Removes the mappings for the symbol from the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-unmap"}, :clojure.core/alter-meta! {:added "1.0", :ns "clojure.core", :name "alter-meta!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vary-meta :clojure.core/with-meta :clojure.core/meta :clojure.core/reset-meta!], :line 2398, :examples ["(def ^{:version 1} document \"This is text\")\n;;=> #'user/document\n\n(meta #'document)\n;;=> {:version 1}\n\n(alter-meta! #'document #(update-in % [:version] inc))  ;increase version\n;;=> {:version 2}\n\n(meta #'document)  ;metadata of var was changed\n;;=> {:version 2}\n\n(alter-meta! #'document update-in [:version] inc)  ;same as above but shorter\n;;=> {:version 3}\n\n(meta #'document)  ;metadata of var was changed again\n;;=> {:version 3}\n"], :notes nil, :arglists ["iref f & args"], :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/alter-meta!"}, :clojure.core/println-str {:added "1.0", :ns "clojure.core", :name "println-str", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/println :clojure.core/print-str], :line 4729, :examples [";; Create a newline-terminated string from the items and store it in x.\nuser=> (def x (println-str 1 \"foo\" \\b \\a \\r {:a 2}))\n#'user/x\n\n;; It's a string.\nuser=> (string? x)\ntrue\n\n;; Notice that the items are separated by a space.  Also, the newline string is\n;; platform-specific. See clojure.core/newline.\nuser=> x\n\"1 foo b a r {:a 2}\\r\\n\"\n"], :notes nil, :tag "java.lang.String", :arglists ["& xs"], :doc "println to a string, returning it", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/println-str"}, :clojure.core/pop {:added "1.0", :ns "clojure.core", :name "pop", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/peek :clojure.core/rest :clojure.core/conj], :line 1459, :examples ["user=> (peek [1 2 3])\n3\nuser=> (pop [1 2 3])\n[1 2]\nuser=> (peek '(1 2 3))\n1\nuser=> (pop '(1 2 3))\n(2 3)" "user=> (peek ())\nnil\nuser=> (pop ())\nIllegalStateException Can't pop empty list\n\nuser=> (peek [])\nnil\nuser=> (pop [])\nIllegalStateException Can't pop empty vector\n\nuser=> (peek (clojure.lang.PersistentQueue/EMPTY))\nnil\nuser=> (into [] (pop (clojure.lang.PersistentQueue/EMPTY)))\n[] ;; Can pop empty Queue" ";; Use a vector as a LIFO stack to check for balanced brackets\n\n(require '[clojure.set :refer [map-invert]])\n\n(defn balance [form]\n  (let [brackets {\\[ \\] \\( \\) \\{ \\}}\n        scan (fn [q x]\n               (cond\n                 (brackets x) (conj q x)\n                 ((map-invert brackets) x)\n                 (if (= (brackets (peek q)) x)\n                   (pop q)\n                   (throw\n                     (ex-info\n                       (str \"Unmatched delimiter \" x) {})))\n                 :else q))]\n    (reduce scan [] form)))\n\n(balance \"(let [a (inc 1]) (+ a 2))\")\n;; ExceptionInfo Unmatched delimiter ]\n\n(balance \"(let [a (inc 1)] (+ a 2))\")\n;; []\n" ";;basic example on vector and list\n\n;;pop on vector returns a new vector removing the last element\n(pop [1 2 3])\n;; [1 2]\n\n;;pop on list returns a new list removing the first element\n(pop '(1 2 3)) ;; (2 3)"], :notes ["Small reminder:\r\n\r\n<br>\r\nDo not work for arbitrary seq but just for persistent types implementing clojure.lang.IPersistentStack (like clojure.lang.Persistent*).\r\n\r\n<br>\r\nExample:\r\n<pre>user&gt; (pop (cons 1 '()))\r\n; Evaluation aborted.\r\n</pre>\r\ndo not work because type is clojure.lang.Cons but\r\n\r\n<pre>user&gt; (pop (conj '() 1))\r\n()\r\n</pre>\r\nworks because type is clojure.lang.PersistentList."], :arglists ["coll"], :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pop"}, :clojure.core/run! {:added "1.7", :ns "clojure.core", :name "run!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/doseq :clojure.core/map :clojure.core/mapv], :line 7630, :examples ["(run! prn (range 5))\n; 0\n; 1\n; 2\n; 3\n; 4\n; returns nil\n\n; compared to mapv\n(mapv prn (range 5))\n; 0                                                                                                                                                                                                                                  \n; 1                                                                                                                                                                                                                                  \n; 2                                                                                                                                                                                                                                  \n; 3                                                                                                                                                                                                                                  \n; 4                                                                                                                                                                                                                                  \n; returns [nil nil nil nil nil] "], :notes nil, :arglists ["proc coll"], :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/run!"}, :clojure.core/with-meta {:added "1.0", :ns "clojure.core", :name "with-meta", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vary-meta :clojure.core/meta :clojure.core/alter-meta!], :line 211, :examples ["user=> (with-meta [1 2 3] {:my \"meta\"})\n[1 2 3]\n\nuser=> (meta (with-meta [1 2 3] {:my \"meta\"}))\n{:my \"meta\"}\n" ";; the same example above in a simplified way\nuser=> (def wm (with-meta [1 2 3] {:my \"meta\"}))\n#'user/wm\n\nuser=> wm\n[1 2 3]\n\nuser=> (meta wm)\n{:my \"meta\"}"], :notes nil, :arglists ["obj m"], :doc "Returns an object of the same type and value as obj, with\n    map m as its metadata.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-meta"}, :clojure.string/escape {:added "1.2", :ns "clojure.string", :name "escape", :file "clojure/string.clj", :type "function", :column 1, :see-alsos nil, :line 300, :examples [";; There should be no space between the \\ and the &, but I don't know how\n;; to create that in an example yet.\nuser=> (clojure.string/escape \"I want 1 < 2 as HTML, & other good things.\"\n               {\\< \"&lt;\", \\> \"&gt;\", \\& \"&amp;\"})\n\"I want 1 &lt; 2 as HTML, &amp; other good things.\"" "(ns test1.core\n  (:require [clojure.string :as str]))\n\n(def text1 \"Hello Clojure World!\")\n\n;; Escape each character '!'\n(str/escape text1 {\\! \"!!!\"})\n;; => \"Hello Clojure World!!!\"\n\n;; Escape each space character\n(str/escape text1 {\\ \"-\"})\n;; => \"Hello-Clojure-World!\"\n\n;; Escape each characters '!' or space\n(str/escape text1 {\\! \"!!!\" \\ \"-\"})\n;; => \"Hello-Clojure-World!!!\"" ";; Note it correctly handles the case where a replacement string contains\n;; a char that’s in the replacement map:\n\n(clojure.string/escape \"123\" {\\1 \"2\"  \\2 \"3\"  \\3 \"4\"})\n;; => \"234\"\n\n(clojure.string/escape \"ab\" {\\a \"b\"  \\b \"a\"})\n;; => \"ba\""], :notes nil, :tag "java.lang.String", :arglists ["s cmap"], :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/escape"}, :clojure.core/reader-conditional {:added "1.7", :ns "clojure.core", :name "reader-conditional", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reader-conditional? :clojure.core/read :clojure.core/read-string], :line 7658, :examples [";;;; The data representation for reader conditionals is used by Clojure\n;;;; when reading a string/file into Clojure data structures but choosing \n;;;; to preserve the conditionals themselves (instead of replacing them with\n;;;; the appropriate platform-specific code)\n\n;;;; Create a data representation for a NON-SPLICING reader conditional\n\n(def r-cond (reader-conditional '(:clj (Math/random)) false))\n;;=> #'user/r-cond\nr-cond\n;;=> #?(:clj (Math/random))\n(:form r-cond)\n;;=> (:clj (Math/random))\n(:splicing? r-cond)\n;;=> false\n\n;;;; Data representation is same as the one produced by (read-string)\n;;;; and (read) when provided with the option to preserve data conditionals\n\n(= r-cond (read-string {:read-cond :preserve} \"#?(:clj (Math/random))\"))\n;;=> true\n\n;;;; Create a data representation for a SPLICING reader conditional\n\n(def r-cond (reader-conditional '(:clj [Math/PI Math/E]) true))\n;;=> #'user/r-cond\n(:clj [Math/PI Math/E])\n;;=> #?@(:clj [Math/PI Math/E])\n(:form r-cond)\n;;=> (:clj [Math/PI Math/E])\n(:splicing? r-cond)\n;;=> true\n\n;;;; Data representation is same as the one produced by (read-string)\n;;;; and (read) when provided with the option to preserve data conditionals\n\n(= r-cond (read-string {:read-cond :preserve} \"#?@(:clj [Math/PI Math/E])\"))\n;;=> true"], :notes nil, :arglists ["form splicing?"], :doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reader-conditional"}, :clojure.core/identical? {:added "1.0", :ns "clojure.core", :name "identical?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/= :clojure.core/==], :line 767, :examples ["user=> (def x 1)\n#'user/x\nuser=> (identical? x x)\ntrue\nuser=> (identical? x 1)\ntrue\nuser=> (identical? x 2)\nfalse\nuser=> (identical? x ((constantly 1) 8))\ntrue\nuser=> (identical? 'a 'a)\nfalse" "user=> (def x {:foo 1, :bar -3})\n#'user/x\nuser=> (def y {:foo 1, :bar -3})\n#'user/y\n;; Values are equal, but different objects were constructed\nuser=> (= x y)\ntrue\nuser=> (identical? x y)\nfalse\n" "; Java wrapper class caching\n; details at: https://www.owasp.org/index.php/Java_gotchas#Immutable_Objects_.2F_Wrapper_Class_Caching\nuser=> (identical? 128 128)\nfalse\nuser=> (identical? 127 127)\ntrue\nuser=> (identical? -127 -127)\ntrue\nuser=> (identical? -128 -128)\ntrue\nuser=> (identical? -130 -130)\nfalse" "user=> (def a (String. \"abc\"))\n;;=> #'user/a\n\nuser=> (def b (String. \"abc\"))\n;;=> #'user/b\n\n=> (identical? a b)\n;;=> false\n;; initialised 2 new objects\n\nuser=> (def a \"abc\")\n;;=> #'user/a\n\nuser=> (def b \"abc\")\n;;=> #'user/b\n\n=> (identical? a b)\n;;=> true\n;; refers same objects(address), look String pooling\n"], :notes nil, :arglists ["x y"], :doc "Tests if 2 arguments are the same object", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/identical_q"}, :clojure.main/with-bindings {:ns "clojure.main", :name "with-bindings", :file "clojure/main.clj", :type "macro", :column 1, :see-alsos [:clojure.core/binding :clojure.core/with-local-vars :clojure.core/with-redefs-fn], :line 66, :examples nil, :macro true, :notes nil, :arglists ["& body"], :doc "Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/with-bindings"}, :clojure.test/*test-out* {:ns "clojure.test", :name "*test-out*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 271, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*test-out*"}, :clojure.core.logic.fd/<=c {:ns "clojure.core.logic.fd", :name "<=c", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 792, :examples nil, :notes nil, :arglists ["u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/<=c"}, :clojure.spec.alpha/tuple-impl {:ns "clojure.spec.alpha", :name "tuple-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 943, :examples nil, :notes nil, :arglists ["forms preds" "forms preds gfn"], :doc "Do not call this directly, use 'tuple'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/tuple-impl"}, :clojure.core/try {:ns "clojure.core", :name "try", :type "var", :see-alsos [:clojure.core/catch :clojure.core/finally :clojure.core/throw :clojure.core/ex-info :clojure.core/ex-data], :examples ["=> (try\n     (/ 1 0)\n     (catch Exception e (str \"caught exception: \" (.getMessage e))))\n\n\"caught exception: Divide by zero\"" ";; for Clojurescript use js/Object as type\n(try\n   (/ 1 0)\n   (catch js/Object e\n       (.log js/console e)))" ";; Example with multiple catch clauses and a finally clause.\n(try (f)\n    (catch SQLException se (prn (.getNextException e)))\n    (catch Exception2 e (prn \"Handle generic exception\"))\n    (finally (prn \"Release some resource)))" ";; The catch/finally clause is an implicit do.\n(try\n  (/ 1 0)\n  (catch Exception ex \n     (.printStackTrace ex)\n     (str \"caught exception: \" (.getMessage ex))))\n;; java.lang.ArithmeticException: Divide by zero\n;;\tat clojure.lang.Numbers.divide(Numbers.java:163)\n;;\tat clojure.lang.Numbers.divide(Numbers.java:3833)\n;; ...\n;;      at main.java:37)\n;;=> \"caught exception: Divide by zero\"\n"], :notes nil, :arglists [], :doc "The exprs are evaluated and, if no exceptions occur, the value of the last\nis returned. If an exception occurs and catch clauses are provided, each is\nexamined in turn and the first for which the thrown exception is an instance\nof the named class is considered a matching catch clause. If there is a\nmatching catch clause, its exprs are evaluated in a context in which name is\nbound to the thrown exception, and the value of the last is the return value\nof the function. If there is no matching catch clause, the exception\npropagates out of the function. Before returning, normally or abnormally,\nany finally exprs will be evaluated for their side effects. See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/try"}, :clojure.core/defmethod {:added "1.0", :ns "clojure.core", :name "defmethod", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/defmulti :clojure.core/remove-method :clojure.core/remove-all-methods :clojure.core/prefers :clojure.core/methods :clojure.core/get-method], :line 1775, :examples ["(defmulti service-charge (fn [acct] [(account-level acct) (:tag acct)]))\n(defmethod service-charge [::acc/Basic ::acc/Checking]   [_] 25)\n(defmethod service-charge [::acc/Basic ::acc/Savings]    [_] 10)\n(defmethod service-charge [::acc/Premium ::acc/Account] [_] 0)" ";this example illustrates that the dispatch type\n;does not have to be a symbol, but can be anything (in this case, it's a string)\n\n(defmulti greeting\n  (fn [x] (x \"language\")))\n\n;params is not used, so we could have used [_]\n(defmethod greeting \"English\" [params]\n \"Hello!\")\n\n(defmethod greeting \"French\" [params]\n \"Bonjour!\")\n\n;then can use this like this:\n(def english-map {\"id\" \"1\", \"language\" \"English\"})\n(def french-map {\"id\" \"2\", \"language\" \"French\"})\n\n=>(greeting english-map)\n\"Hello!\"\n=>(greeting french-map)\n\"Bonjour!\"\n" ";; Methods can be given a name.  Very useful in stack traces.\n(defmethod foo \"a\" name-of-method [params] \"was a\")\n"], :macro true, :notes nil, :arglists ["multifn dispatch-val & fn-tail"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defmethod"}, :clojure.core/zero? {:added "1.0", :ns "clojure.core", :name "zero?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/pos? :clojure.core/neg?], :line 859, :examples ["(zero? 0)               ;;=> true\n(zero? 0.0)             ;;=> true\n(zero? 2r000)           ;;=> true\n(zero? 0x0)             ;;=> true\n\n(zero? 1)               ;;=> false\n(zero? 3.14159265358M)  ;;=> false\n(zero? (/ 1 2))         ;;=> false\n\n(zero? nil)             ;;=> NullPointerException"], :notes ["`(zero? x)` calls `(clojure.lang.Numbers/isZero x)`, which will throw a `ClassCastException ... cannot be cast to java.lang.Number` or `NullPointerException` if `x` is anything but a number."], :arglists ["num"], :doc "Returns true if num is zero, else false", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/zero_q"}, :clojure.data/EqualityPartition {:added "1.3", :ns "clojure.data", :name "EqualityPartition", :file "clojure/data.clj", :type "var", :column 1, :see-alsos nil, :line 67, :examples nil, :notes nil, :arglists [], :doc "Implementation detail. Subject to change.", :library-url "https://github.com/clojure/clojure", :href "/clojure.data/EqualityPartition"}, :clojure.core.logic.fd/singleton-dom? {:ns "clojure.core.logic.fd", :name "singleton-dom?", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 604, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/singleton-dom_q"}, :clojure.pprint/*print-base* {:added "1.2", :ns "clojure.pprint", :name "*print-base*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 87, :examples ["(binding [clojure.pprint/*print-base* 10]\n  (clojure.pprint/pprint 42))\n; Prints:\n; 42\n\n(binding [clojure.pprint/*print-base* 2]\n  (clojure.pprint/pprint 42))\n; Prints:\n; 101010"], :notes nil, :arglists [], :doc "The base to use for printing integers and rationals.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-base*"}, :clojure.core.logic.fd/resolve-storable-dom {:ns "clojure.core.logic.fd", :name "resolve-storable-dom", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 607, :examples nil, :notes nil, :arglists ["a x dom domp"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/resolve-storable-dom"}, :clojure.core/concat {:added "1.0", :ns "clojure.core", :name "concat", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/conj :clojure.core/into :clojure.core/lazy-cat], :line 710, :examples ["\nuser=> (concat [1 2] [3 4])\n(1 2 3 4)\n\nuser=> (into [] (concat [1 2] [3 4]))\n[1 2 3 4]\n\nuser=> (concat [:a :b] nil [1 [2 3] 4])\n(:a :b 1 [2 3] 4)\n\n=> (concat [1] [2] '(3 4) [5 6 7] #{9 10 8})\n(1 2 3 4 5 6 7 8 9 10)\n;; The last three elements might appear in a different order.\n" "user=> (concat \"abc\" \"def\")\n(\\a \\b \\c \\d \\e \\f)\n" "user=> (apply concat '(([1 2]) ([3 4] [5 6]) ([7 8])))\n([1 2] [3 4] [5 6] [7 8])\n" "user=> (concat '(1 2 3) '(4 5 6))\n;; (1 2 3 4 5 6)" "user=> (concat [1 2 3] [4 5 6])\n;; (1 2 3 4 5 6)" "(concat {:a \"A\" :b \"B\" :c \"C\"} {:d \"D\" :e \"E\"})\n;; ([:a \"A\"] [:b \"B\"] [:c \"C\"] [:d \"D\"] [:e \"E\"])" "(defn padding-right [s width pad] \n  (apply str (take width (concat s (repeat pad)))))\n\n(padding-right \"Clojure\" 10 \" \")\n;; \"Clojure   \""], :notes nil, :arglists ["" "x" "x y" "x y & zs"], :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/concat"}, :clojure.core.logic/subst-val {:ns "clojure.core.logic", :name "subst-val", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 205, :examples nil, :notes nil, :arglists ["x" "x doms" "x doms _meta" "x doms eset _meta"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/subst-val"}, :clojure.core/aset-short {:added "1.0", :ns "clojure.core", :name "aset-short", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3937, :examples [";; create an array of 10 shorts and set one of the values to 31415\n\nuser=> (def ss (short-array 10))\n#'user/ss\nuser=> (vec ss)\n[0 0 0 0 0 0 0 0 0 0]\nuser=> (aset-short ss 3 31415)\n31415\nuser=> (vec ss)\n[0 0 0 31415 0 0 0 0 0 0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of short. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-short"}, :clojure.core/println {:added "1.0", :ns "clojure.core", :name "println", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/prn :clojure.core/print :clojure.core/println-str :clojure.pprint/pprint], :line 3725, :examples ["user=> (println \"Hello world.\")\nHello world.\nnil\n\nuser=> (def items [ \"hello\" :a 1 (list :b 2) \\c {:d 4} #{5 6 7} ])\n#'user/items\n\n; println is for human-readable output, like a report. Note the lack of quotes around the string \"hello\" and the unescaped letter \"c\". \nuser=> (println items)\n[hello :a 1 (:b 2) c {:d 4} #{5 6 7}]\nnil\n\n; prn outputs items in a machine-readable format, such as in a source\n; file. Note the double-quotes around the string \"hello\" and the escaped letter \"c\".\nuser=> (prn items)\n[\"hello\" :a 1 (:b 2) \\c {:d 4} #{5 6 7}]\nnil\n\n; pr-str produces a string with escaped punctuation, so that println yields the same result as the original prn call.\nuser=> (println (pr-str items))\n[\"hello\" :a 1 (:b 2) \\c {:d 4} #{5 6 7}]\nnil\n\n; Calling println w/o args outputs a newline and nothing else.\nuser=> (println)\n\nnil\n; The newline function does the same.\nuser=> (newline)\n\nnil\nuser=>" "; be careful when using println in functions like map\n; println has nil as its return value\n\nuser=> (map #(println %) (range 1 4))\n\n(1 2 3 nil nil nil)\n\n"], :notes nil, :arglists ["& more"], :doc "Same as print followed by (newline)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/println"}, :clojure.core.reducers/reducer {:added "1.5", :ns "clojure.core.reducers", :name "reducer", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 100, :examples nil, :notes [";;Beware of this bug\n\n;;These two suppose to be the same:\n\n(transduce (comp (take 10) (partition-all 3)) conj (range))\n;; => [[0 1 2] [3 4 5] [6 7 8] [9]]\n\n\n(reduce conj (r/reducer (range) (comp (take 10) (partition-all 3))))\n;; => [[0 1 2] [3 4 5] [6 7 8]]\n\n;;See https://dev.clojure.org/jira/browse/CLJ-2338\n" "As far as I can see, `clojure.core.reducers/reducer` (since 1.5) is made obsolete by `eduction` (since 1.7), which can do the same and more."], :arglists ["coll xf"], :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/reducer"}, :clojure.core/->Eduction {:ns "clojure.core", :name "->Eduction", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7602, :examples nil, :notes nil, :arglists ["xform coll"], :doc "Positional factory function for class clojure.core.Eduction.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->Eduction"}, :clojure.core.async/timeout {:ns "clojure.core.async", :name "timeout", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 101, :examples ["user=> (go-loop [seconds (atom 0)\n                 add-seconds! #(swap! seconds + %)]\n         (println \"Waiting 1 second\")\n         (<! (timeout 1000))\n         (add-seconds! 1)\n         (println \"Waiting 2 seconds\")\n         (<! (timeout 2000))\n         (add-seconds! 2)\n         (println\n          (format \"Waited %s seconds\"\n                  @seconds))) \n\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@67ddcb0e>\n\n;; Waiting 1 second\n\n;; Waiting 2 seconds\n\n;; Waited 3 seconds\n" "user=> (doseq [n (range 10)\n               :let [i (-> n\n                           inc\n                           range\n                           rand-nth)]]                    \n         (go\n           (<! (timeout (* i 1000)))\n           (println n)))\nnil\n5\n3\n0\n6\n4\n7\n1\n2\n9\n8\n\n"], :notes ["*Never* close! the channel returned by timeout -- this is an unwritten rule. \n\nThe implementation sometimes will use an existing timeout channel, if it is within a few ms of the desired timeout. Closing the channel will affect multiple otherwise unrelated CSPs that may be blocked/parked waiting for the channel to close.\n\nIn our application, we saw this as spurious \"timed out after waiting X ms\" messages when the logged timestamps didn't support this possibility.\n\nThanks to Ryan Neufeld for identifying this!" "Might be obvious but this construct is preferred in go blocks over Thread/sleep as it does not block"], :arglists ["msecs"], :doc "Returns a channel that will close after msecs", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/timeout"}, :clojure.core.async/unsub-all* {:ns "clojure.core.async", :name "unsub-all*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["p" "p v"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unsub-all*"}, :clojure.pprint/*print-miser-width* {:added "1.2", :ns "clojure.pprint", :name "*print-miser-width*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 47, :examples nil, :notes nil, :arglists [], :doc "The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-miser-width*"}, :clojure.core.logic/unify-with-sequential* {:ns "clojure.core.logic", :name "unify-with-sequential*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 893, :examples nil, :notes nil, :arglists ["u v s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unify-with-sequential*"}, :clojure.core.async/unsub* {:ns "clojure.core.async", :name "unsub*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["p v ch"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unsub*"}, :clojure.test/try-expr {:added "1.1", :ns "clojure.test", :name "try-expr", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/is], :line 537, :examples ["(try-expr \"Can I call this function?\" (= 1 1))\n;; => \"No! I said you don't call this.\" - Rich Hickey"], :macro true, :notes nil, :arglists ["msg form"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/try-expr"}, :clojure.core/qualified-keyword? {:added "1.9", :ns "clojure.core", :name "qualified-keyword?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/keyword? :clojure.core/simple-keyword?], :line 1634, :examples ["(qualified-keyword? :user/:keyword)\n;;=> true\n(qualified-keyword? ::keyword)\n;;=> true\n\n(qualified-keyword? :keyword)\n;;=> false\n\n(qualified-keyword? \"string\")\n;;=> false\n(qualified-keyword? 42)\n;;=> false\n(qualified-keyword? nil)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a keyword with a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/qualified-keyword_q"}, :clojure.core.reducers/map {:added "1.5", :ns "clojure.core.reducers", :name "map", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos [:clojure.core.reducers/mapcat], :line 161, :examples nil, :notes nil, :arglists ["f" "f coll"], :doc "Applies f to every value in the reduction of coll. Foldable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/map"}, :clojure.core.logic/update-pvars! {:ns "clojure.core.logic", :name "update-pvars!", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1492, :examples nil, :notes nil, :arglists ["x vars"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/update-pvars!"}, :clojure.pprint/formatter-out {:added "1.2", :ns "clojure.pprint", :name "formatter-out", :file "clojure/pprint/cl_format.clj", :type "macro", :column 1, :see-alsos nil, :line 1936, :examples nil, :macro true, :notes nil, :arglists ["format-in"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/formatter-out"}, :clojure.core/cast {:added "1.0", :ns "clojure.core", :name "cast", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/type], :line 346, :examples [";; Cast doesn't change the type of the input - it just throws an exception if it's the wrong type\n;; Since Long is a subclass of Number\nuser=> (cast Number 1)  \n1\nuser=> (type (cast Number 1))\njava.lang.Long\n"], :notes nil, :arglists ["c x"], :doc "Throws a ClassCastException if x is not a c, else returns x.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cast"}, :clojure.core.logic/run-db* {:ns "clojure.core.logic", :name "run-db*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1252, :examples nil, :macro true, :notes nil, :arglists ["db bindings & goals"], :doc "Executes goals until results are exhausted. Uses a specified logic database.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-db*"}, :clojure.core.async/pipe {:ns "clojure.core.async", :name "pipe", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 462, :examples ["user=> (def cx (chan 1))\n#'user/cx\n\nuser=> (def cy (chan 1))\n#'user/cy\n\nuser=> (pipe cx cy)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@5064227c>\n\nuser=> (put! cx \"Going into CX\")\ntrue\n\nuser=> (<!! cy)\n\"Going into CX\"\n" "user> (def ch-1 (async/chan 10))\n#'user/ch-1\n\nuser> (def ch-2 (async/chan 10))\n#'user/ch-2\n\n;; start a thread that takes from channel 1, sleeping after each take\nuser> (async/thread\n        (loop []\n          (when-let [v (async/<!! ch-1)]\n            (println \"ch-1 taker got \" v)\n            (Thread/sleep 1000)\n            (recur))))\n#object[clojure.core.async.impl.channels.ManyToManyChannel ...]\n\n;; start a thread that takes from channel 2 that does not sleep\nuser> (async/thread\n        (loop []\n          (when-let [v (async/<!! ch-2)]\n            (println \"ch-2 taker got \" v)\n            (recur))))\n#object[clojure.core.async.impl.channels.ManyToManyChannel ...]\n\n;; create a pipe from ch-1 to ch-2\nuser> (async/pipe ch-1 ch-2)\n#object[clojure.core.async.impl.channels.ManyToManyChannel ...]\n\n;; lets try to add a new listener to channel 1.\nuser> (async/thread\n        (loop []\n          (when-let [v (async/<!! ch-1)]\n            (println \"second ch-1 taker got \" v)\n            (Thread/sleep 1000)\n            (recur))))\n#object[clojure.core.async.impl.channels.ManyToManyChannel ...]\n\n;; put onto ch-1 and sleep after each put... we are interested in how the\n;; pipe works...\nuser> (async/thread\n        (doseq [x (range 10)]\n          (async/>!! ch-1 x)\n          (Thread/sleep 500)))\n#object[clojure.core.async.impl.channels.ManyToManyChannel ...]\n\nch-1 taker got  0\nch-2 taker got  1\nsecond ch-1 taker got  2\nch-2 taker got  3\nch-1 taker got  4\nch-2 taker got  5\nsecond ch-1 taker got  6\nch-2 taker got  7\nch-1 taker got  8\nch-2 taker got  9\n\n;; so a pipe is just a listener that tries to take from the from channel\n;; and put onto the to channel, a pipe does dot restrict the ability to \n;; *take* from the *from* channel."], :notes ["Returns the `to` channel argument."], :arglists ["from to" "from to close?"], :doc "Takes elements from the from channel and supplies them to the to\n  channel. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/pipe"}, :clojure.pprint/formatter {:added "1.2", :ns "clojure.pprint", :name "formatter", :file "clojure/pprint/cl_format.clj", :type "macro", :column 1, :see-alsos nil, :line 1916, :examples nil, :macro true, :notes nil, :arglists ["format-in"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning \noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/formatter"}, :clojure.xml/*state* {:ns "clojure.xml", :name "*state*", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 17, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/*state*"}, :clojure.core/ffirst {:added "1.0", :ns "clojure.core", :name "ffirst", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/fnext :clojure.core/nfirst :clojure.core/nnext :clojure.core/next], :line 98, :examples ["user=> (ffirst '([]))\nnil \n\nuser=> (ffirst ['(a b c) '(b a c)])\na \n\nuser=> (ffirst '([a b c] [b a c]))\na" "user=> (first {:b 2 :a 1 :c 3})\n[:b 2] \n\nuser=> (ffirst {:b 2 :a 1 :c 3})\n:b" "user=> (first [1])\n1\n\nuser=> (ffirst [[1]])\n1"], :notes nil, :arglists ["x"], :doc "Same as (first (first x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ffirst"}, :clojure.core.async/remove> {:ns "clojure.core.async", :name "remove>", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1065, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["p ch"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/remove>"}, :clojure.core.logic/verify-all-bound {:ns "clojure.core.logic", :name "verify-all-bound", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2129, :examples nil, :notes nil, :arglists ["a constrained"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/verify-all-bound"}, :clojure.core/ref-min-history {:added "1.1", :ns "clojure.core", :name "ref-min-history", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref :clojure.core/ref-max-history :clojure.core/ref-history-count], :line 2462, :examples nil, :notes nil, :arglists ["ref" "ref n"], :doc "Gets the min-history of a ref, or sets it and returns the ref", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ref-min-history"}, :clojure.core/extends? {:added "1.2", :ns "clojure.core", :name "extends?", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos [:clojure.core/defprotocol :clojure.core/defrecord :clojure.core/deftype :clojure.core/satisfies?], :line 556, :examples ["user=> (defprotocol Area (get-area [this]))\nArea\n\nuser=> (defrecord Rectangle [width height]\n                  Area\n                  (get-area [this]\n                    (* width height)))\nuser.Rectangle\n\n(extends? Area Rectangle)\ntrue\n"], :notes nil, :arglists ["protocol atype"], :doc "Returns true if atype extends protocol", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/extends_q"}, :clojure.core/load-reader {:added "1.0", :ns "clojure.core", :name "load-reader", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/load-file], :line 4048, :examples ["(load-reader (java.io.FileReader. \"filename.clj\"))"], :notes nil, :arglists ["rdr"], :doc "Sequentially read and evaluate the set of forms contained in the\n  stream/file", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/load-reader"}, :clojure.core.logic.fd/extend-to-fd {:ns "clojure.core.logic.fd", :name "extend-to-fd", :file "clojure/core/logic/fd.clj", :type "macro", :column 1, :see-alsos nil, :line 169, :examples nil, :macro true, :notes nil, :arglists ["t"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/extend-to-fd"}, :clojure.test/successful? {:added "1.1", :ns "clojure.test", :name "successful?", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 788, :examples nil, :notes nil, :arglists ["summary"], :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/successful_q"}, :clojure.core/primitives-classnames {:ns "clojure.core", :name "primitives-classnames", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos nil, :line 372, :examples ["user=> (use 'clojure.pprint)\nuser=> (pprint primitives-classnames)\n{float \"Float/TYPE\",\n int \"Integer/TYPE\",\n long \"Long/TYPE\",\n boolean \"Boolean/TYPE\",\n char \"Character/TYPE\",\n double \"Double/TYPE\",\n byte \"Byte/TYPE\",\n short \"Short/TYPE\"}"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/primitives-classnames"}, :clojure.core.logic/addcg {:ns "clojure.core.logic", :name "addcg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2036, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/addcg"}, :clojure.core/indexed? {:added "1.9", :ns "clojure.core", :name "indexed?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 6194, :examples nil, :notes nil, :arglists ["coll"], :doc "Return true if coll implements Indexed, indicating efficient lookup by index", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/indexed_q"}, :clojure.core/reductions {:added "1.2", :ns "clojure.core", :name "reductions", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduce :clojure.core/reduced], :line 7134, :examples ["user=> (reductions + [1 1 1 1])\n(1 2 3 4)\nuser=> (reductions + [1 2 3])\n(1 3 6)\n\n;; This is just like reduce except that the calculation is collected during the reduce.\nuser=> (assert (= (reduce + [1 2 3]) \n                  (last (reductions + [1 2 3]))))\nnil\n" "user=> (reductions conj [] '(1 2 3))\n([] [1] [1 2] [1 2 3])" "user=> (reductions + [1 2 3 4 5])\n(1 3 6 10 15)\n\n;;defining the function to perform the same reductions\nuser=> (reductions (fn [sum num] (+ sum num)) [1 2 3 4 5])\n;;(1 3 6 10 15)\n\n;;reductions using a init value 100\nuser=> (reductions (fn [sum num] (+ sum num)) 100 [1 2 3 4 5])\n;;(100 101 103 106 110 115)\n\n;;defining a function for the same reductions\nuser=>(defn add [sum num] \n    #_=>(+ sum num))\n;;#'user/add\n\nuser=>(reductions add [1 2 3 4 5])\n;;(1 3 6 10 15)" ";; useful for performing lazy calculations which rely on \n;; previous calculations\n\n;; e.g. Taking an infinite list of posts with some height and \n;; adding an offset to each, which is the sum of all previous \n;; heights\n\nuser=> (def posts (repeat {:height 50}))\n#'user/posts\n\nuser=> (take 3 posts)\n({:height 50} {:height 50} {:height 50})\n\nuser=> (def posts-with-offsets\n  #_=>   (map #(assoc %1 :offset %2)\n  #_=>        posts\n  #_=>        (reductions + 0 (map :height posts))))\n#'user/posts-with-offsets\n\nuser=> (take 3 posts-with-offsets)\n({:height 50, :offset 0} {:height 50, :offset 50} {:height 50, :offset 100})\n\n"], :notes ["I think the description above would be clearer if it stated that the result of reductions is equivalent to the sequence of results of applying reduce to `(take n coll)`, with `n` starting with 1, that is, equivalent to\n```clojure\n(defn my-reduce [op coll] (for [n (range (count coll))] (reduce op (take (inc n) coll)))\n```\n" "In other libraries and languages this function may be referred to as \"scan\". "], :arglists ["f coll" "f init coll"], :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reductions"}, :clojure.pprint/cl-format {:added "1.2", :ns "clojure.pprint", :name "cl-format", :file "clojure/pprint/cl_format.clj", :type "function", :column 1, :see-alsos [:clojure.core/printf :clojure.core/format], :line 27, :examples [";; Formatting integers, with options, in one of many bases.\n\n;; First arg true sends formatted output to *out*\nuser=> (cl-format true \"~5d\\n\" 3)\n    3\nnil\n\n;; First arg nil or false causes formatted output to be returned as string\nuser=> (cl-format nil \"~5d\" 3)\n\"    3\"\n\nuser=> (cl-format nil \"Pad with leading zeros ~5,'0d\" 3)\n\"Pad with leading zeros 00003\"\n\nuser=> (cl-format nil \"Pad with leading asterisks ~5,'*d\" 3)\n\"Pad with leading asterisks ****3\"\n\n;; If there is a way to specify left-justifying a number in a single\n;; format string, please add it here.  It can be done by using one\n;; cl-format invocation to get a formatted number as a string, and\n;; then use the ~<width>a specifier on the result.\nuser=> (cl-format nil \"~15a\" (cl-format nil \"~:d\" 1234567))\n\"1,234,567      \"\n\n;; To specify left-justifying a number in a single format string, you can use:\nuser=> (cl-format nil \"~15@<~:d~>\" 1234567)\n\"1,234,567      \"\n\nuser=> (cl-format nil \"Always print the sign ~5@d\" 3)\n\"Always print the sign    +3\"\n\nuser=> (cl-format nil \"Use comma group-separator every 3 digits ~12:d\" 1234567)\n\"Use comma group-separator every 3 digits    1,234,567\"\n\nuser=> (cl-format nil \"decimal ~d  binary ~b  octal ~o  hex ~x\" 63 63 63 63)\n\"decimal 63  binary 111111  octal 77  hex 3f\"\n\nuser=> (cl-format nil \"base 7  ~7r  with width and zero pad  ~7,15,'0r\" 63 63)\n\"base 7  120  with width and zero pad  000000000000120\"\n\n;; No need for you to do any conversions to use cl-format with BigInt,\n;; BigInteger, or BigDecimal.\nuser=> (cl-format nil \"cl-format handles BigInts ~15d\" 12345678901234567890)\n\"cl-format handles BigInts 12345678901234567890\"\n\nuser=> (cl-format nil \"Be aware of auto-conversion  ~8,'0d  ~8,'0d\" 2.4 -5/4)\n\"Be aware of auto-conversion  000002.4  0000-5/4\"\n\n;; This might look like a bug, but it is actually behavior specified by the\n;; Common Lisp HyperSpec mentioned in the docs above.  If you don't want that\n;; behavior (format \"%08d\" -2) might suit your purposes better.\nuser=> (cl-format nil \"~8,'0d\" -2)\n\"000000-2\"" "(let [examples [[]\n                [\"Alice\"]\n                [\"Alice\" \"Bob\"]\n                [\"Alice\" \"Bob\" \"Charlie\"]]]\n  (doseq [users examples]\n    (cljs.pprint/cl-format true \"~1{~#[none~;~a~;~a and ~a~:;~@{~#[~;and ~]~a~^, ~}~]~:} ~:*~1{~#[are~;is~:;are~]~:} online\" users)))\n\n;; Prints the following:\n\nnone are online\nAlice is online\nAlice and Bob are online\nAlice, Bob, and Charlie are online\n\n;; The following guide for Common Lisp format is available here. The examples applies to Clojure as well:\n;; http://www.gigamonkeys.com/book/a-few-format-recipes.html" ";; cl-format knows what nil should look like:\nuser=> (cl-format nil \"~s\" nil)\n\"nil\"\n;; format doesn't:\nuser=> (format \"%s\" nil)\n\"null\"\n" "(def word-wrap\n  [\"This\" \"sentence\" \"is\" \"too\" \"long\" \"for\" \"a\" \"small\" \"screen\"\n  \"and\" \"should\" \"appear\" \"in\" \"multiple\" \"lines\" \"no\" \"longer\"\n  \"than\" \"20\" \"characters\" \"each\" \".\"])\n\n(println (cl-format nil \"~{~<~%~1,20:;~A~> ~}\" word-wrap))\n;; This sentence is too\n;; long for a small\n;; screen and should\n;; appear in multiple\n;; lines no longer than\n;; 20 characters each."], :notes nil, :arglists ["writer format-in & args"], :doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It \nsupports sophisticated formatting of structured data.\n\nWriter is an instance of java.io.Writer, true to output to *out* or nil to output \nto a string, format-in is the format control string and the remaining arguments \nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives' \ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format \nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\" \n                   (count results) results))\n\nPrints to *out*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the \nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) \nand in the Common Lisp HyperSpec at \nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/cl-format"}, :clojure.core/extend-protocol {:added "1.2", :ns "clojure.core", :name "extend-protocol", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/extend :clojure.core/extend-type :clojure.core/defprotocol], :line 846, :examples ["(defprotocol XmlNode\n  (as-xml [this]))\n\n(defrecord User [^Integer id ^String name ^java.util.Date dob])\n\n;; Protocols can be extended to existing types and user defined types\n(extend-protocol XmlNode\n  Integer\n    (as-xml [this] (str this))\n  String\n    (as-xml [this] (identity this))\n  java.util.Date\n    (as-xml [this] (-> (java.text.SimpleDateFormat. \"yyyy-MM-dd HH:mm:ss\")\n                       (.format this)))\n  User\n    (as-xml [this] (str \"<user>\"\n                        \"<id>\" (as-xml (:id this)) \"</id>\"\n                        \"<name>\" (as-xml (:name this)) \"</name>\"\n                        \"<dob>\" (as-xml (:dob this)) \"</dob>\"\n                        \"</user>\")))"], :macro true, :notes nil, :arglists ["p & specs"], :doc "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/extend-protocol"}, :clojure.spec.alpha/*fspec-iterations* {:ns "clojure.spec.alpha", :name "*fspec-iterations*", :file "clojure/spec/alpha.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 25, :examples nil, :notes nil, :arglists [], :doc "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/*fspec-iterations*"}, :clojure.core/tree-seq {:added "1.0", :ns "clojure.core", :name "tree-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.walk/walk :clojure.core/file-seq], :line 4871, :examples [";; Each node is a number or a seq, \n;; so branch?==seq? and children==identity\n;; \n;;     .\n;;    / \\\n;;   .   .\n;;  /|\\  |\n;; 1 2 . 4\n;;     |  \n;;     3\n;;\n;; ... each sub-tree is serialized in depth-first order\n(tree-seq seq? identity '((1 2 (3)) (4)))\n\n;;=> (((1 2 (3)) (4)) \n;;     (1 2 (3)) \n;;        1 \n;;        2 \n;;        (3) \n;;            3 \n;;     (4) \n;;        4)\n" "(tree-seq map? #(interleave (keys %) (vals %)) {:a 1 :b {:c 3 :d 4 :e {:f 6 :g 7}}})\n;;=> ({:a 1, :b {:c 3, :d 4, :e {:f 6, :g 7}}} \n;;     :a 1 :b {:c 3, :d 4, :e {:f 6, :g 7}} \n;;              :c 3 :d 4 :e {:f 6, :g 7}  \n;;                            :f 6 :g 7)" ";; Each node is a (node-root child1 child2 ...),\n;; so branch?==next and children==rest\n;;\n;;     A\n;;    / \\\n;;   B   C\n;;  / \\  |\n;; D   E F\n;;\n(map first (tree-seq next rest '(:A (:B (:D) (:E)) (:C (:F)))))\n;;=> (:A :B :D :E :C :F)" ";; The previous example seems to be a flatten function,\n;; where every node's value is added to the returned sequence\n;; as it is visited in a depth first search.\n;; That is not the case as the following example illustrates: \n;;      *\n;;     / \\\n;;    *   4\n;;   /|\\\n;;  1 2 *\n;;      |\n;;      3\n(map first (tree-seq next rest '((1 2 (3)) (4))))\n;;=> ((1 2 (3)) 4)\n\n;; For a proper 'flatten' function see below." ";; The nodes are filtered based on their collection type, \n;; here they must be a list.\n(tree-seq seq? seq [[1 2 [3]] [4]])\n;;=> ([[1 2 [3]] [4]])\n\n;; notice the difference between seq? and sequential?\n(tree-seq sequential? seq [[1 2 [3]] [4]])\n;;=> ([[1 2 [3]] [4]] [1 2 [3]] 1 2 [3] 3 [4] 4)\n\n;; If the nodes in the tree are a specific type of collection...\n;; a vector\n(tree-seq vector? seq [[1 2 [3]] [4]])\n([[1 2 [3]] [4]] [1 2 [3]] 1 2 [3] 3 [4] 4)\n\n;; ... or a list\n(tree-seq seq? seq '((1 2 (3)) (4)))\n(((1 2 (3)) (4)) (1 2 (3)) 1 2 (3) 3 (4) 4)\n" ";; Use tree-seq to recursively find all files \n;; given a root directory (here for didactic purposes. See file-seq)\n(let [directory (clojure.java.io/file \"/path/to/directory/\")\n      dir? #(.isDirectory %)]\n    ;we want only files, therefore filter items that are not directories.\n    (filter (comp not dir?) \n          (tree-seq dir? #(.listFiles %) directory)))" "\n(def t '((1 2 (3)) (4)))\n;;=> #'user/t\n\n;; Here the tree-seq uses 'sequential?' as the 'branch?' predicate.\n;; This causes the 'children' function to run for any collection.\n;; The 'seq' ('children') function recurses on all items in the collection.\n;; This results in a sequence of sub-trees, rooted at each node.\n(tree-seq sequential? seq x)\n;;=> (((1 2 (3)) (4))\n;;    (1 2 (3)) 1 2 \n;;    (3) 3 (4) 4)\n\n;; (The following example is from 4Clojure)\n;; It returns the leaves of a tree as a sequence.\n;; \n(defn flatten [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))\n(flatten t)\n;;=> (1 2 3 4)\n" "(tree-seq seq? identity '(1 2 (3 (4))))\n;; ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)\n\n;; It's same as ...\n(tree-seq seq? seq '(1 2 (3 (4))))\n(tree-seq sequential? seq '(1 2 (3 (4))))\n;; ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)\n\n;; This processing ...\n(sequential? '(1 2 (3 (4)))) ;; returns true ... -> (1 2 (3 (4))) <--- !!!\n(sequential? 1)              ;; returns false ... -> 1\n(sequential? 2)              ;; returns false ... -> 2\n(sequential? '(3 (4))        ;; returns true  ... -> (3 (4))     <--- !!! \n(sequential? 3)              ;; returns false ... -> 3\n(sequential? '(4))           ;; returns true  ... -> (4)         <--- !!!\n(sequential? 4)              ;; return false  ... -> 4\n\n;; so, #tree-seq returns...\n;; ((1 2 (3 (4))) 1 2 (3 (4)) 3 (4) 4)"], :notes ["The 'branch?' and 'children' functions perform different types of filtering.\nThe 'branch?' function examines a node and determines whether there are children that need to be included in the processing.\nThe 'children' function selects (or generates) the children to be included in the returned sequence." "Example 5 has for the second example \n(tree-seq seq? seq [[1 2 [3]] [4]])\nwhen it should be \n(tree-seq sequential? seq [[1 2 [3]] [4]])"], :arglists ["branch? children root"], :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/tree-seq"}, :clojure.core/in-ns {:added "1.0", :ns "clojure.core", :name "in-ns", :type "function", :see-alsos [:clojure.core/ns], :examples [";; Let's create new namespace, create new variable in it, then access it from\n;; another namespace\n\n;; create the namespace and switch to it\n(in-ns 'first-namespace)\n;;=> #<Namespace first-namespace>\n\n;; create a variable and check it\n;; first-namespace=> \n(def my-var \"some value\")\n;;=> #'first-namespace/my-var\n\n;; first-namespace=> \nmy-var\n;;=> \"some value\"\n\n;; create another namespace and switch to this one\n;; first-namespace=> \n(in-ns 'second-namespace)\n;;=> #<Namespace second-namespace>\n\n;; use variable from the other namespace here\n;; second-namespace=> \nfirst-namespace/my-var\n;;=> \"some value\"\n\n;; in-ns works within top-level forms (e.g. the compiler or the REPL)\n;; It may fail when called within a function at runtime because *ns* is a Var\n;; and unless there are thread-local bindings for *ns*, it cannot be set!\nsecond.namespace=> (defn swap-ns! [ns-name] (clojure.core/in-ns ns-name))\n;; #'second.namespace/swap-ns!\n\nsecond.namespace=> (swap-ns! 'other.ns)\n;; #namespace[other.ns]\n\n;; Later, at runtime...\n;; Throws IllegalStateException(\"Can't change/establish root binding of: *ns* with set\")\n;; Remember, *ns* is a root var and in-ns calls set!, which only works after\n;; someone somewhere calls the binding macro (or Java equivalent)\n(defn -main\n  [& args]\n  (println *ns*)\n  (second.namespace/swap-ns! 'arbitrary-namespace))\n;; prints #namespace[clojure.core] and then will crash" ";; The \"in-ns\" function works almost the same as \"ns\", but does not load\n;; clojure.core \n\n;; user=>\n(in-ns 'my-namespace)\n;;=> #<Namespace my-namespace>\n\n;; the function clojure.core/inc won't just work\n;; my-namespace=> \n(inc 1)\n;; java.lang.Exception: Unable to resolve symbol: inc in this context\n;; (NO_SOURCE_FILE:15)\n\n;; my-namespace=>\n(clojure.core/inc 1)\n;;=> 2\n"], :notes nil, :arglists ["name"], :doc "Sets *ns* to the namespace named by the symbol, creating it if needed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/in-ns"}, :clojure.repl/doc {:added "1.0", :ns "clojure.repl", :name "doc", :file "clojure/repl.clj", :type "macro", :column 1, :see-alsos [:clojure.repl/source :clojure.repl/dir :clojure.repl/apropos], :line 132, :examples ["=> (doc map)\n;; prints in console:\n-------------------------\nclojure.core/map\n([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])\n  Returns a lazy sequence consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments." "user> (doc clojure.core)\n-------------------------\nclojure.core\n  Fundamental library of the Clojure language\n"], :macro true, :notes ["Note that the clojure.repl namespace which contains doc is not loaded by default in Emacs' SLIME mode, because SLIME provides its own doc function via C-c C-d d."], :arglists ["name"], :doc "Prints documentation for a var or special form given its name,\n   or for a spec if given a keyword", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/doc"}, :clojure.core/monitor-exit {:ns "clojure.core", :name "monitor-exit", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "A synchronization primitive that should be avoided in user code. Use the\nlocking macro. See http://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/monitor-exit"}, :clojure.core.logic.fd/eq* {:ns "clojure.core.logic.fd", :name "eq*", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1122, :examples nil, :notes nil, :arglists ["form vars" "form vars out"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/eq*"}, :clojure.core/bigint {:added "1.3", :ns "clojure.core", :name "bigint", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/biginteger], :line 3611, :examples ["user=> (bigint 30)\n30\n\n\n;; Actually do something BigInteger-ish... (http://download.oracle.com/javase/6/docs/api/)\n\nuser=> (def x (bigint 97))\n#'user/x\n\nuser=> (.isProbablePrime (.toBigInteger x) 100)\ntrue\n" "user> (= (bigint 42) (clojure.lang.BigInt/fromBigInteger (BigInteger. \"42\")))\ntrue\nuser> (= 42N (bigint 42))\ntrue\nuser> (= 42 (bigint 42))\ntrue\nuser> (= 42 (clojure.lang.BigInt/fromBigInteger (BigInteger. \"42\")))\ntrue\n" "user> (reduce * (repeat 20 1000))\nArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow (Numbers.java:1388)\n\nuser> (reduce * (repeat 20 (bigint 1000)))\n1000000000000000000000000000000000000000000000000000000000000N\n" ";; There is a difference between `BigInt` and `BigInteger`. The first is from\n;; Clojure and should be better for performace, because less unboxing is\n;; necessary. The second is from Java and has more functionality.\n;; https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html\n\n(type 123N)\n;; => clojure.lang.BigInt\n\n(type (bigint 123))\n;; => clojure.lang.BigInt\n\n(type (biginteger 123))\n;; => java.math.BigInteger\n\n(.modInverse (bigint 123) (bigint 4))\n;; IllegalArgumentException No matching method found: modInverse for class\n;; clojure.lang.BigInt\n\n(.modInverse (biginteger 123) (biginteger 4))\n;; => 3" "; It also works for strings\n(bigint \"12345\") => 12345N\n"], :notes ["The last example does not seem to work; there seems to be a missing coercion from Clojure BigInt to Java BigInteger. I get <pre>\r\nIllegalArgumentException No matching method found: isProbablePrime for class clojure.lang.BigInt  clojure.lang.Reflector.invokeMatchingMethod (Reflector.java:53)</pre>"], :tag "clojure.lang.BigInt", :arglists ["x"], :doc "Coerce to BigInt", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bigint"}, :clojure.core.logic.fd/==c {:ns "clojure.core.logic.fd", :name "==c", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 721, :examples nil, :notes nil, :arglists ["u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/==c"}, :clojure.core/aclone {:added "1.0", :ns "clojure.core", :name "aclone", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/aget :clojure.core/int-array], :line 3871, :examples [";; create an Java integer array, then clone it\n;; note that when you modify b, a remains the same\n;; showing that b is not just a reference to a\nuser=> (def a (int-array [1 2 3 4]))\n#'user/a\n\nuser=> (def b (aclone a))\n#'user/b\n\nuser=> (aset b 0 23)\n23\n\nuser=> (vec b)\n[23 2 3 4]\n\nuser=> (vec a)\n[1 2 3 4]"], :notes nil, :arglists ["array"], :doc "Returns a clone of the Java array. Works on arrays of known\n  types.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aclone"}, :clojure.reflect/Reflector {:ns "clojure.reflect", :name "Reflector", :file "clojure/reflect.clj", :type "var", :column 1, :see-alsos nil, :line 44, :examples nil, :notes [";; not to be confused with the Reflector class\n```\n  (import '(clojure.lang DynamicClassLoader Reflector))\n``` \n;;=> clojure.lang.Reflector\n```\n(let [class-loader (DynamicClassLoader.)  \n      a-class (.loadClass class-loader \"java.lang.Long\")] \n  (Reflector/invokeConstructor a-class (into-array String [\"2\"])))\n```\n;;=> 2"], :arglists [], :doc "Protocol for reflection implementers.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/Reflector"}, :clojure.core.logic/ground-term? {:ns "clojure.core.logic", :name "ground-term?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2590, :examples nil, :notes nil, :arglists ["x s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ground-term_q"}, :clojure.core/time {:added "1.0", :ns "clojure.core", :name "time", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 3850, :examples ["user> (time (Thread/sleep 100))\n\"Elapsed time: 100.284772 msecs\"\nnil" ";when working with lazy seqs\n(time (doall (...)))" ";; Time how long it takes to write a string to a file 100 times\n(defn time-test []\n  (with-open [w (writer \"test.txt\" :append false)]\n    (dotimes [_ 100]\n      (.write w \"I am being written to a file.\"))))\n\n\nuser=> (time (time-test))\n\"Elapsed time: 19.596371 msecs\"" "user=> (time (Thread/sleep 1000))\n\"Elapsed time: 1000.267483 msecs\"\nnil\nuser=> (with-out-str (time (Thread/sleep 1000)))\n\"\\\"Elapsed time: 1010.12942 msecs\\\"\\n\"\n\n"], :macro true, :notes nil, :arglists ["expr"], :doc "Evaluates expr and prints the time it took.  Returns the value of\n expr.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/time"}, :clojure.core.logic/recover-vars-from-term {:ns "clojure.core.logic", :name "recover-vars-from-term", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2389, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/recover-vars-from-term"}, :clojure.core.logic/reifyg {:ns "clojure.core.logic", :name "reifyg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2175, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/reifyg"}, :clojure.zip/zipper {:added "1.0", :ns "clojure.zip", :name "zipper", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/down :clojure.zip/up :clojure.zip/right :clojure.zip/left :clojure.zip/children :clojure.zip/node :clojure.zip/replace], :line 18, :examples [";; Some clojure.zip functions will overwrite clojure.core's definitions\n(use 'clojure.zip)\n\n;; You may wish to require :as in order to avoid the above\n(require '[clojure.zip :as z])\n\n;; For the purposes of keeping the examples that follow clean,\n;; assume we have taken the former route: (use 'clojure.zip)\n\n(use 'clojure.pprint)\n(def p pprint)\n\nuser> (def z [[1 2 3] [4 [5 6] 7] [8 9]])\n#'user/z\n\nuser> (def zp (zipper vector? seq (fn [_ c] c) z))\n#'user/zp\n\nuser> zp\n[[[1 2 3] [4 [5 6] 7] [8 9]] nil]\n\nuser=> (p (-> zp down))\n[[1 2 3]\n {:l [],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n  :ppath nil,\n  :r ([4 [5 6] 7] [8 9])}]\n \nuser> (first (-> zp down))\n[1 2 3]\n\nuser=> (p (-> zp down right))\n[[4 [5 6] 7]\n {:l [[1 2 3]],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n  :ppath nil,\n  :r ([8 9])}]\n\nuser> (first (-> zp down right))\n[4 [5 6] 7]\n\nuser=> (p (-> zp down right down right))\n[[5 6]\n {:l [4],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]] [4 [5 6] 7]],\n  :ppath\n  {:l [[1 2 3]],\n   :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n   :ppath nil,\n   :r ([8 9])},\n  :r (7)}]\n\nuser=> (p (-> zp down right down right down))\n[5\n {:l [],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]] [4 [5 6] 7] [5 6]],\n  :ppath\n  {:l [4],\n   :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]] [4 [5 6] 7]],\n   :ppath\n   {:l [[1 2 3]],\n    :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n    :ppath nil,\n    :r ([8 9])},\n   :r (7)},\n  :r (6)}]\n\nuser=> (p (-> zp down right down right (replace \"hello\")))\n[\"hello\"\n {:changed? true,\n  :l [4],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]] [4 [5 6] 7]],\n  :ppath\n  {:l [[1 2 3]],\n   :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n   :ppath nil,\n   :r ([8 9])},\n  :r (7)}]\n\nuser=> (p (-> zp down right down right (replace \"hello\") up))\n[(4 \"hello\" 7)\n {:changed? true,\n  :l [[1 2 3]],\n  :pnodes [[[1 2 3] [4 [5 6] 7] [8 9]]],\n  :ppath nil,\n  :r ([8 9])}]\n\nuser=> (p (-> zp down right down right (replace \"hello\") up root))\n([1 2 3] (4 \"hello\" 7) [8 9])" "(require '[clojure.zip :as zip])\n\n;; Adds zip support for maps.\n;; (Source: http://stackoverflow.com/a/15020649/42188)\n(defn map-zipper [m]\n  (zip/zipper \n    (fn [x] (or (map? x) (map? (nth x 1))))\n    (fn [x] (seq (if (map? x) x (nth x 1))))\n    (fn [x children] \n      (if (map? x) \n        (into {} children) \n        (assoc x 1 (into {} children))))\n    m))\n\n(def m {:a 3 :b {:x true :y false} :c 4})\n\n;; Note that hash-maps are not ordered:\n(-> (map-zipper m) zip/down zip/right zip/node)\n;;=> [:b {:y false, :x true}]\n\n;; Treat nodes as [key value] pairs:\n(-> (map-zipper m) \n    zip/down\n    (zip/edit (fn [[k v]] [k (inc v)]))\n    zip/root)\n;;=> {:c 5, :b {:y false, :x true}, :a 3}" ";; A version of  zipper that allows mixing maps and vectors \n;; Note that it traverses map entries too\n(require '[clojure.zip :as z])\n(defn map-vec-zipper [m]\n  (z/zipper\n    (fn [x] (or (map? x) (sequential? x)))\n    seq\n    (fn [p xs]\n      (if (isa? (type p) clojure.lang.MapEntry)\n        (into [] xs)\n        (into (empty p) xs)))\n    m))\n(-> (map-vec-zipper [{1 [21 22] 3 [4]}])\n  z/down\n  (z/edit assoc :e 99)\n  z/down\n  ;; Note that the map does not guarantee particular entries ordering.\n  z/down ;; Getting into map entry. \n  z/next\n  (z/edit conj 77)\n  z/root)\n;;=> [{1 [21 22 77], 3 [4], :e 99}]" ";; Get sequence of all visited nodes\n(require '[clojure.zip :as z])\n(->> (z/vector-zip [[1 2] 3 [[4 5]]])\n  (iterate z/next)\n  (take-while #(not (z/end? %))) ;; Zipper's \"end of iteration\" condition. \n  (map z/node))\n;;=> ([[1 2] 3 [[4 5]]] \n;;    [1 2] \n;;    1 2\n;;    3 \n;;    [[4 5]] \n;;    [4 5]\n;;    4 5)"], :notes ["For more info on zippers:\r\n\r\n* [Brian Marick](http://clojuredocs.org/profile/Brian%20Marick): [â€œEditingâ€� trees in Clojure with clojure.zip](http://www.exampler.com/blog/2010/09/01/editing-trees-in-clojure-with-clojurezip/)\r\n* Alex Miller: [Zippers with records in Clojure](http://tech.puredanger.com/2010/10/22/zippers-with-records-in-clojure/)" "Tutorials on zippers:\r\n\r\n* Brian Marick: [\"Editing\" trees in Clojure with clojure.zip](http://www.exampler.com/blog/2010/09/01/editing-trees-in-clojure-with-clojurezip)\r\n\r\n* Alex Miller: [Zippers with records in Clojure](http://tech.puredanger.com/2010/10/22/zippers-with-records-in-clojure/)" "To work with nested structures you can also use\n* clojure.core/get-in, clojure.core/assoc-in, clojure.core/update-in \n* Balagan library https://github.com/clojurewerkz/balagan\n* Specter library https://github.com/nathanmarz/specter "], :arglists ["branch? children make-node root"], :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/zipper"}, :clojure.core/rand-int {:added "1.0", :ns "clojure.core", :name "rand-int", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rand :clojure.core/int], :line 4859, :examples ["user=> (rand-int 30)\n10\n\nuser=> (rand-int 30)\n7\n\n; is equivalent to\nuser=> (int (rand 30))\n" "(require '[clojure.set :as set])\n\n; random generation of unique series of random numbers from 0 to n-1 \n\n(defn unique-random-numbers [n]\n  (let [a-set (set (take n (repeatedly #(rand-int n))))]\n    (concat a-set (set/difference (set (take n (range)))\n                                  a-set))))\n\nuser=> (unique-random-numbers 20)\n(0 1 3 6 7 8 9 12 14 16 17 19 2 4 5 10 11 13 15 18)\n\n"], :notes nil, :arglists ["n"], :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rand-int"}, :clojure.core/associative? {:added "1.0", :ns "clojure.core", :name "associative?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 6164, :examples ["user=> (associative? [1 2 3]) ; vector\ntrue\nuser=> (associative? '(1 2 3)) ; list\nfalse\nuser=> (associative? {:a 1 :b 2}) ; map\ntrue\nuser=> (associative? #{:a :b :c}) ; set\nfalse\nuser=> (associative? \"fred\") ; string\nfalse\n"], :notes nil, :arglists ["coll"], :doc "Returns true if coll implements Associative", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/associative_q"}, :clojure.core/re-find {:added "1.0", :ns "clojure.core", :name "re-find", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/re-groups :clojure.core/re-matcher :clojure.core/re-pattern :clojure.core/re-seq :clojure.core/re-matches :clojure.core/subs :clojure.string/replace], :line 4838, :examples ["user=> (def matcher (re-matcher #\"\\d+\" \"abc12345def\"))\n#'user/matcher\n\nuser=> (re-find matcher)\n\"12345\"\n\n;; If you only want the first match, it is shorter to call re-find with the\n;; pattern and the string to search, rather than explicitly creating a matcher\n;; as above.\nuser=> (re-find #\"\\d+\" \"abc12345def\")\n\"12345\"\n\n;; If you want all matches as a sequence, use re-seq.  Creating a matcher\n;; explicitly with re-matcher and passing it to re-find is only the best way\n;; if you want to write a loop that iterates through all matches, and do not\n;; want to use re-seq for some reason.\n" ";; re-find can be used to iterate through re matches in the string\n\nuser=> (def phone-number \"672-345-456-3212\")\n#'user/phone-number\n\nuser=> (def matcher (re-matcher #\"\\d+\" phone-number))\n#'user/matcher\n\nuser=> (re-find matcher)\n\"672\"\n\nuser=> (re-find matcher)\n\"345\"\n\nuser=> (re-find matcher)\n\"456\"\n\nuser=> (re-find matcher)\n\"3212\"\n\n;; when there's no more valid matches, nil is returned\nuser=> (re-find matcher)\nnil" ";; When there are parenthesized groups in the pattern and re-find\n;; finds a match, it returns a vector.  The first item is the part of\n;; the string that matches the entire pattern, and each successive\n;; item are the parts of the string that matched the 1st, 2nd,\n;; etc. parenthesized groups.  Groups are numbered by the order in\n;; which their left parenthesis occurs in the string, from left to\n;; right.\nuser=> (def line \" RX packets:1871074138 errors:5 dropped:48 overruns:9\")\n#'user/line\n\nuser=> (re-find #\"(\\S+):(\\d+)\" line)\n[\"packets:1871074138\" \"packets\" \"1871074138\"]\n\n;; groups can nest\nuser=> (re-find #\"(\\S+:(\\d+)) \\S+:\\d+\" line)\n[\"packets:1871074138 errors:5\" \"packets:1871074138\" \"1871074138\"]\n\n;; If there is no match, re-find always returns nil, whether there are\n;; parenthesized groups or not.\nuser=> (re-find #\"(\\S+):(\\d+)\" \":2 numbers but not 1 word-and-colon: before\")\nnil\n\n;; A parenthesized group can have nil as its result if it is part of\n;; an 'or' (separated by | in the regex), and another alternative is\n;; the one that matches.\nuser=> (re-find #\"(\\D+)|(\\d+)\" \"word then number 57\")\n[\"word then number \" \"word then number \" nil]\n\nuser=> (re-find #\"(\\D+)|(\\d+)\" \"57 number then word\")\n[\"57\" nil \"57\"]\n\n;; It is also possible for a group to match the empty string.\nuser=> (re-find #\"(\\d*)(\\S)\\S+\" \"lots o' digits 123456789\")\n[\"lots\" \"\" \"l\"]\n\n;; If you want to use parentheses to group a part of the regex, but\n;; have no interest in capturing the string it matches, you can follow\n;; the left paren with ?: to prevent capturing.\nuser=> (re-find #\"(?:\\S+):(\\d+)\" line)\n[\"packets:1871074138\" \"1871074138\"]\n\n;; re-matches also behaves this way, and re-seq returns a sequence of\n;; matches, where each one can be a vector like re-find returns.\n" ";;It's possible to get variables out of your string with regexp\n\nuser=> (re-find #\"(\\d\\d\\d) (USD)\" \"450 USD\")\n[\"450 USD\" \"450\" \"USD\"]\nuser=> (nth *1 1)\n\"450\"\n\n;;thanks kotarak @ stackoverflow.com for this one" ";; If your input has line delimiters you can switch on multiline with (?m)\n\nuser=> (def testcase \"Line 1\\nLine 2\\nTarget Line\\nLine 4\\nNot a target line\")\nuser=>(re-find #\"(?im)^target.*$\" testcase)\n\"Target Line\"" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases."], :notes ["the regex can't be a var?\n\n```clojure\n(let [regex \"abc\"] (re-find #a \"abc\"))\n```\nthis will get an error!" "@paomian: The regex *can* be a variable, but the variable needs to be a regex.\n\nThis works fine:\n<pre>\n(let [regex #\"abc\"] (re-find regex \"abc\"))\n</pre>\n\nbecause the **#** reader macro for declaring regexes applies to the string right after it -- without doing any kind of substitution.\n\nYou could also do\n<pre>\n(let [regex \"abc\"] (re-find (re-pattern regex) \"abc\"))\n</pre>"], :arglists ["m" "re s"], :doc "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/re-find"}, :clojure.zip/replace {:added "1.0", :ns "clojure.zip", :name "replace", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/edit], :line 203, :examples ["(use 'clojure.zip)\n\n(def vz (vector-zip [1 2 [73 88] 4]))\n\n(root (replace (-> vz down right right) 3))\n=>[1 2 3 4]"], :notes nil, :arglists ["loc node"], :doc "Replaces the node at this loc, without moving", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/replace"}, :clojure.core/memoize {:added "1.0", :ns "clojure.core", :name "memoize", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/delay], :line 6263, :examples [";; First we define a function that presumably have some expensive computation.\nuser=> (defn myfunc[a] (println \"doing some work\") (+ a 10))\n#'user/myfunc\n\n;; Next we create a memoized version of the function.\nuser=> (def myfunc-memo (memoize myfunc))\n#'user/myfunc-memo\n\n\n;; The first time we call the function with a particular argument the\n;; original function is invoked and the value is returned.  The next\n;; time the function is called with the same argument the cached result\n;; is returned and the original function is NOT called.\n\nuser=> (myfunc-memo 1)\ndoing some work\n11\nuser=> (myfunc-memo 1)\n11\nuser=> (myfunc-memo 20)\ndoing some work\n30\nuser=> (myfunc-memo 20)\n30\n" "\n;; Fibonacci number with recursion.\n(defn fib [n]\n  (condp = n\n    0 1\n    1 1\n    (+ (fib (dec n)) (fib (- n 2)))))\n\n(time (fib 30))\n;; \"Elapsed time: 8179.04028 msecs\"\n\n;; Fibonacci number with recursion and memoize.\n(def m-fib\n  (memoize (fn [n]\n             (condp = n\n               0 1\n               1 1\n               (+ (m-fib (dec n)) (m-fib (- n 2)))))))\n\n(time (m-fib 30))\n;; \"Elapsed time: 1.282557 msecs\"\n  " ";; It's possible to memoize a function with multiple arguments:\n(def times (memoize (fn [x y] (* x y))))\n\n(times 1 2) ; => 2\n\n(times 2 0) ; => 0" ";; Memoize is a simple way to make a mapping deterministic.\n(def attribute->id (memoize (fn [attr] (clojure.lang.RT/nextID))))\n\n(attribute->id :name) ; => 16305\n\n(attribute->id :age) ; => 16306\n\n(attribute->id :name) ; => 16305"], :notes ["What is the definition of \"often\" for the purposes of caching? Is there a util like this that allows for different cache eviction strategies?" "@rquinlivan The implementation of clojure.core/memoize is plain straightforward. It should be obvious that computation_cost times number_of_calls should determine whether to use it or not.  If you need more control over caching have a look at [clojure.core.cache](https://github.com/clojure/core.cache)"], :arglists ["f"], :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/memoize"}, :clojure.core/inst-ms* {:ns "clojure.core", :name "inst-ms*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["inst"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core/inst-ms*"}, :clojure.core.logic/recover-vars {:ns "clojure.core.logic", :name "recover-vars", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2398, :examples nil, :notes nil, :arglists ["p"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/recover-vars"}, :clojure.core/record? {:added "1.6", :ns "clojure.core", :name "record?", :file "clojure/core_deftype.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 405, :examples [";; Define a record R\nuser=> (defrecord R [x])\nuser.R\n\n;; Create an instance of R called r\nuser=> (def r (->R 1))\n#'user/r\n\n;; Look at r\nuser=> r\n#user.R{:x 1}\n\n;; Is r a record?\nuser=> (record? r)\ntrue\n\n;; Interestingly adding \"fields\" not defined in R keeps it a record\nuser=> (def r2 (assoc r :y 2))\n#'user/r2\n\nuser=> r2\n#user.R{:x 1, :y 2}\n\n;; r2 is still a record\nuser=> (record? r2)\ntrue\n\n;; But regular map is not a record\nuser=> (record? {:x 1})\nfalse"], :notes nil, :arglists ["x"], :doc "Returns true if x is a record", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/record_q"}, :clojure.core/last {:added "1.0", :ns "clojure.core", :name "last", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/next :clojure.core/rest :clojure.core/butlast :clojure.core/take-last :clojure.core/peek], :line 262, :examples ["user=> (last [1 2 3 4 5])\n5\nuser=> (last [\"a\" \"b\" \"c\" \"d\" \"e\"])\n\"e\"\nuser=> (last {:one 1 :two 2 :three 3})\n[:three 3]\nuser=> (last [])\nnil\n\n;; but be careful with what you expect from a map (or set):\nuser=> (last {:a 1 :b 2 :c 3 :d 4 :e 5 :f 6 :g 7 :h 8 :i 9})\n[:a 1]" ";really slow reverse\n;put the last item of the list at the start of a new list, and recur over all but the last item of the list.\n;butlast acts similar to next in that it returns null for a 1-item list.\n\n(defn my-reverse\n  ([a-list]\n     (cond (= a-list nil) nil\n           :else (cons (last a-list)\n                       (my-reverse (butlast a-list))))))" ";; Prefer clojure.core/peek over `last` for potentially large vectors.\n\nuser=> (def v (into [] (take 900900 (range))))\n#'user/v\n\nuser=> (time (last v))\n\"Elapsed time: 24.460958 msecs\"\n900899\n\nuser=> (def v2 (into [] (take 900900 (range))))\n#'user/v2\n\nuser=> (time (peek v2))\n\"Elapsed time: 0.020498 msecs\"\n900899\n\n;; For a deep dive into why Rich Hickey chose not to make `last` performant\n;; for large vectors, please see:\n;; https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f\n\n"], :notes nil, :arglists ["coll"], :doc "Return the last item in coll, in linear time", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/last"}, :clojure.core/->Vec {:ns "clojure.core", :name "->Vec", :file "clojure/gvec.clj", :type "function", :column 1, :see-alsos nil, :line 131, :examples nil, :notes nil, :arglists ["am cnt shift root tail _meta"], :doc "Positional factory function for class clojure.core.Vec.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->Vec"}, :clojure.core/bytes? {:added "1.9", :ns "clojure.core", :name "bytes?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/byte-array :clojure.core/bytes], :line 5328, :examples [";;;; Returns true for byte[] arrays:\n\n(bytes? (.getBytes \"foo\"))\n;;=> true\n(bytes? (byte-array [102 111 111]))\n;;=> true\n\n;;;; Returns false for Byte[] arrays:\n\n(bytes? (to-array (map byte [102 111 111])))\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a byte array", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bytes_q"}, :clojure.core/vreset! {:added "1.7", :ns "clojure.core", :name "vreset!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/volatile!], :line 2524, :examples nil, :notes nil, :arglists ["vol newval"], :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vreset!"}, :clojure.core/chunk {:ns "clojure.core", :name "chunk", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-buffer :clojure.core/chunk-cons :clojure.core/chunk-first :clojure.core/chunk-rest :clojure.core/chunked-seq?], :line 690, :examples ["(chunk-rest\n (chunk-cons (chunk (chunk-buffer 32))\n             (seq (range 42))))\n\n;; => (32 33 34 35 36 37 38 39 40 41)\n\n;; Or if you'd prefer to read it threaded:\n(-> (chunk-buffer 32)\n    (chunk)\n    (chunk-cons (seq (range 42)))\n    (chunk-rest))\n\n;; => (32 33 34 35 36 37 38 39 40 41)"], :notes nil, :tag "clojure.lang.IChunk", :arglists ["b"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk"}, :clojure.core.logic/fnu {:ns "clojure.core.logic", :name "fnu", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1723, :examples nil, :macro true, :notes nil, :arglists ["& rest"], :doc "Define an anonymous committed choice goal. See condu.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fnu"}, :clojure.core.logic.fd/normalize-intervals {:ns "clojure.core.logic.fd", :name "normalize-intervals", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 561, :examples nil, :notes nil, :arglists ["is"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/normalize-intervals"}, :clojure.set/union {:added "1.0", :ns "clojure.set", :name "union", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/intersection :clojure.set/difference :clojure.set/superset?], :line 20, :examples ["user=> (union)\n#{}\n\nuser=> (union #{1 2})\n#{1 2}\n\nuser=> (union #{1 2} #{2 3})\n#{1 2 3}\n\nuser=> (union #{1 2} #{2 3} #{3 4})\n#{1 2 3 4}\n" "(reduce (fn [flattened [key val]]\n          (conj flattened val))\n        #{}\n        {:e #{:m :f}, :c #{:f}, :b #{:c :f}, :d #{:m :f}, :a #{:c :f}})\n\n;;=> #{#{:m :f} #{:c :f} #{:f}}\n\n\n(reduce (fn [flattened [key val]]\n          (clojure.set/union flattened val))\n        #{}\n        {:e #{:m :f}, :c #{:f}, :b #{:c :f}, :d #{:m :f}, :a #{:c :f}})\n\n;;=> #{:m :c :f}" "(defn flatten-dpdnts [dpdnts-map]\n  (apply set/union (vals dpdnts-map)))\n\n(flatten-dpdnts {:e #{:m :f}, :c #{:f}, :b #{:c :f}, :d #{:m :f}, :a #{:c :f}})\n;;=> #{:m :c :f}" ";; Advice: Do not call union with non-set arguments.  If you are\n;; concerned that you may be unintentionally doing so, and want an\n;; exception to be thrown if you do, consider using the library\n;; funjible (https://github.com/jafingerhut/funjible) which provides\n;; its own definition of union that is identical to Clojure's, except\n;; it checks the types of its arguments.\n\n;; union might or might not return what you expect if you give it\n;; values that are not sets.  The implementation of union _does not\n;; check_ whether you are actually giving it values that are sets.  It\n;; _assumes_ so.\n\n;; This looks like what someone might expect.  It _happens_ to give\n;; back the same answer as if you coerced the second argument to a\n;; set.\nuser=> (union #{1 2 3} [4 5])\n#{1 4 3 2 5}\n\n;; Wait, this returned a vector, not a set!\nuser=> (union #{1 2} [3 4 5])\n[3 4 5 1 2]\n\n;; This also returned a vector, and some elements are duplicates of\n;; each other!\nuser=> (union #{1 2} [3 4 5] #{4 5})\n[3 4 5 1 2 4 5]\n\n;; Why not change the definition of union so it throws an exception if\n;; you give it a non-set argument?  I would guess that the primary\n;; reason is that the extra run-time type checks would slow union down\n;; by an amount that the Clojure core team does not want everyone to\n;; have to pay on every such call.\n\n;; Related Clojure tickets: \n;; https://dev.clojure.org/jira/browse/CLJ-1953\n;; https://dev.clojure.org/jira/browse/CLJ-2287\n"], :notes nil, :arglists ["" "s1" "s1 s2" "s1 s2 & sets"], :doc "Return a set that is the union of the input sets", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/union"}, :clojure.core/pr {:added "1.0", :ns "clojure.core", :name "pr", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/print :clojure.core/prn :clojure.core/pr-str :clojure.edn/read], :dynamic true, :line 3669, :examples ["user=> (pr \"foo\")\n\"foo\"nil" "user=> (pr {:foo \"hello\" :bar 34.5})\n{:foo \"hello\", :bar 34.5}nil" ";; Difference between pr and print\n\nuser=> (pr ['a :b \"\\n\" \\space \"c\"])\n[a :b \"\\n\" \\space \"c\"]nil\n\nuser=> (print ['a :b \"\\n\" \\space \"c\"])\n[a :b\n   c]nil\n" ";; WARNING: Clojure's keyword and symbol functions allow you to create\n;; values that cannot be printed then later read and recreate those same\n;; values.\n\n;; For most common symbols and keywords, they round-trip through pr\n;; then read-string, as this example shows.\nuser=> (read-string (with-out-str (pr {:a 1, :b 2})))\n{:a 1, :b 2}\n\n;; But these values do not round-trip through the same steps:\nuser=> (def kw1 (keyword \"foo bar\"))\n#'user/kw1\nuser=> kw1\n:foo bar\nuser=> (def s2 (with-out-str (pr {kw1 1, :b 2})))\n#'user/s2\nuser=> s2\n\"{:foo bar 1, :b 2}\"\nuser=> (read-string s2)\n\nRuntimeException Map literal must contain an even number of forms  clojure.lang.Util.runtimeException (Util.java:221)\n\n;; Similarly for a symbol like (symbol \"a;b\")\nuser=> (def sym1 (symbol \"a;b\"))\n#'user/sym1\nuser=> sym1\na;b\nuser=> (def s3 (with-out-str (pr sym1)))\n#'user/s3\nuser=> s3\n\"a;b\"\nuser=> (read-string s3)\na\n\n;; If you wish to transmit data that may contain such values, one suggestion\n;; is to use the transit library: https://github.com/cognitect/transit-format\n\n;; It is much faster and formally specified."], :notes ["\"Readable by the reader\" means, for example, that a string is printed with surrounding double quotes and with quotes, backslashes, and nonprinting characters being escaped via a backslash prefix."], :arglists ["" "x" "x & more"], :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pr"}, :clojure.spec.alpha/int-in-range? {:ns "clojure.spec.alpha", :name "int-in-range?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1856, :examples nil, :notes nil, :arglists ["start end val"], :doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/int-in-range_q"}, :clojure.core.logic/->Choice {:ns "clojure.core.logic", :name "->Choice", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1084, :examples nil, :notes nil, :arglists ["a f"], :doc "Positional factory function for class clojure.core.logic.Choice.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->Choice"}, :clojure.core/cond-> {:added "1.5", :ns "clojure.core", :name "cond->", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/cond->> :clojure.core/-> :clojure.core/->> :clojure.core/as-> :clojure.core/some-> :clojure.core/some->> :clojure.core/cond :clojure.core/if], :line 7458, :examples ["\n(cond-> 1          ; we start with 1\n    true inc       ; the condition is true so (inc 1) => 2\n    false (* 42)   ; the condition is false so the operation is skipped\n    (= 2 2) (* 3)) ; (= 2 2) is true so (* 2 3) => 6 \n;;=> 6\n;; notice that the threaded value gets used in \n;; only the form  and not the test part of the clause." ";; Useful when you want to conditionally evaluate expressions and thread them \n;; together. For instance, the following returns a vector containing the names \n;; (as symbols) of the implementing classes of obj.\n\n=> (defn instance->types\n     [obj]\n     (cond-> [] \n       (instance? java.util.SortedMap obj) (conj 'SortedMap)\n       (instance? java.util.AbstractMap obj) (conj 'AbstractMap)))\n#'user/instance->types\n\n=> (def hm (java.util.HashMap.))\n#'user/hm\n\n=> (instance->types hm)\n[AbstractMap]\n\n=> (def tm (java.util.TreeMap.))\n#'user/tm\n\n=> (instance->types tm)\n[SortedMap AbstractMap]" "=> (defn divisible-by? [divisor number] \n     (zero? (mod number divisor)))\n#'user/divisible-by?\n\n=> (defn say [n]\n     (cond-> nil\n       (divisible-by? 3 n) (str \"Fizz\")\n       (divisible-by? 5 n) (str \"Buzz\")\n       :always             (or (str n))))\n#'user/say\n\n=> (say 1)\n\"1\"\n\n=> (say 3)\n\"Fizz\"\n\n=> (say 5)\n\"Buzz\"\n\n=> (say 15)\n\"FizzBuzz\"" "(let [x 1 y 2]\n  (cond-> []\n          (odd? x) (conj \"x is odd\")\n          (zero? (rem y 3)) (conj \"y is divisible by 3\")\n          (even? y) (conj \"y is even\")))\n;=> [\"x is odd\" \"y is even\"]\n\n;;; IS Equivalent to \n\n(let [x 1 y 2]\n  (as-> [] <>\n        (if (odd? x)\n            (conj <> \"x is odd\")\n                         <>)\n        (if (zero? (rem y 3)) \n            (conj <> \"y is divisible by 3\") \n                         <>)\n        (if (even? y)\n            (conj <> \"y is even\")\n                         <>)))\n;=> [\"x is odd\" \"y is even\"] " ";; The following if-pass condition\n\n(let [x \"123\"] (if (string? x) (Integer. x) x))\n\n;; Can be expressed with cond-> removing one repetition of \"x\"\n\n(let [x \"123\"] (cond-> x (string? x) Integer.)) "], :macro true, :notes nil, :arglists ["expr & clauses"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cond->"}, :clojure.core.async/filter< {:ns "clojure.core.async", :name "filter<", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1071, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["p ch" "p ch buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/filter<"}, :clojure.spec.alpha/nilable {:ns "clojure.spec.alpha", :name "nilable", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 1808, :examples ["(def ::my-spec (nilable int?))\n\n(valid? ::my-spec 2)\n;;=> true\n\n(valid ::my-spec 3.3)\n;;=> false\n\n(valid? ::my-spec nil)\n;;=> true"], :macro true, :notes nil, :arglists ["pred"], :doc "returns a spec that accepts nil and values satisfying pred", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/nilable"}, :clojure.stacktrace/print-cause-trace {:added "1.1", :ns "clojure.stacktrace", :name "print-cause-trace", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos [:clojure.stacktrace/print-stack-trace], :line 66, :examples ["(clojure.stacktrace/print-cause-trace (Exception. \"foo\") 4)\n;               clojure.core/eval  core.clj: 3211\n;                             ...                \n;       boot.user$eval1731.invoke          :    1\n; boot.user$eval1731.invokeStatic          :    1\n; java.lang.Exception: foo\n;=> nil\n"], :notes nil, :arglists ["tr" "tr n"], :doc "Like print-stack-trace but prints chained exceptions (causes).", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/print-cause-trace"}, :clojure.core/defonce {:added "1.0", :ns "clojure.core", :name "defonce", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/def], :line 5768, :examples ["user> (defonce foo 5)\n#'user/foo\n\nuser> foo\n5\n\n;; defonce does nothing the second time\nuser> (defonce foo 10)\nnil\n\nuser> foo\n5" ";; Supports ^:private\nuser=> (defonce ^:private foo 3)\n#'user/foo\nuser=> foo\n3\nuser=> (in-ns 'user2)\nuser2=> user/foo\n        java.lang.IllegalStateException: var: user/foo is not public\n"], :macro true, :notes ["Note that this isn't thread safe. I.e. EXPR for the same NAME can be evaluated more than once."], :arglists ["name expr"], :doc "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defonce"}, :clojure.core.logic/run-db {:ns "clojure.core.logic", :name "run-db", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1247, :examples nil, :macro true, :notes nil, :arglists ["n db bindings & goals"], :doc "Executes goals until a maximum of n results are found. Uses a specified logic database.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-db"}, :clojure.core.logic/bind* {:ns "clojure.core.logic", :name "bind*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1067, :examples nil, :macro true, :notes nil, :arglists ["a g" "a g & g-rest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/bind*"}, :clojure.core/macroexpand-1 {:added "1.0", :ns "clojure.core", :name "macroexpand-1", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/macroexpand :clojure.walk/macroexpand-all], :line 3984, :examples ["user=> (macroexpand-1 '(defstruct mystruct[a b]))\n(def mystruct (clojure.core/create-struct [a b]))\n" "user=> (macroexpand-1 '(-> c (+ 3) (* 2)))\n(clojure.core/-> (clojure.core/-> c (+ 3)) (* 2))" "; When testing macro expansion in a file instead of at the REPL, \n; please note that it may be necessary to use a backquote\n; instead of a straight quote.\n\n(defmacro iiinc [x]\n  `(+ 3 ~x))\n\n(deftest t-stuff\n  ; This doesn't work.\n  (println (macroexpand-1 '(iiinc 2))) ;=> (iiinc 2)\n\n  ; Oddly, we can use the macro itself fine in our tests...\n  (println (iiinc 2))    ;=> 5\n  (is (= 5 (iiinc 2)))  ;=> unit test passes\n\n  ; This fixes it by resolving the symbol iiinc at compile-time.\n  (println (macroexpand-1 `(iiinc 2)))) ;=> (+ 3 2)\n\n; Also, as the previous examples show, please remember that \n; you must quote the form you are providing to `macroexpand-1`.\n"], :notes nil, :arglists ["form"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/macroexpand-1"}, :clojure.core/take {:added "1.0", :ns "clojure.core", :name "take", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/drop :clojure.core/take-while :clojure.core/take-last :clojure.core/take-nth], :line 2853, :examples [";; return a lazy seq of the first 3 items\n(take 3 '(1 2 3 4 5 6))\n;;=> (1 2 3)\n\n(take 3 [1 2 3 4 5 6])\n;;=> (1 2 3)\n\n;; returns all items if there are fewer than n\n(take 3 [1 2])\n;;=> (1 2)\n\n(take 1 [])\n;;=> ()\n\n(take 1 nil)\n;;=> ()\n\n(take 0 [1])\n;;=> ()\n\n(take -1 [1])\n;;=> ()" ";; similar to subvec but lazy and with seqs\n(take 3 (drop 5 (range 1 11)))\n;;=> (6 7 8)" ";; Used without a collection, take will create a transducer:\n(def xf (take 5))\n\n;; We can now apply this transducer to a sequence:\n(transduce xf conj (range 5))\n;; => [0 1 2 3 4]\n" ";; Note that usually more items are realized than needed.\n;; In the example below we want a lazy sequence of 1 item\n;; (the first item of the range), but actually the first 32 items are calculated.\n;; This can be especially important when this extra realization requires a lot of\n;; resources (CPU, time, memory, etc.) and at the end not needed at all.\n;; Tip: try 32 and 33 instead of 1 in the take below.\n\nuser=> (let [x (map (fn [i]\n                      (println i)\n                      (Thread/sleep 100)\n                      i)\n                    (range 50))]\n         (take 1 x))\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n(0)\n\n;; Another interesting case (especially for debugging) when\n;; an exception is thrown during this extra realization.\n\nuser=> (let [x (map (fn [i]\n                      (when (> i 40)\n                        (throw (Exception. (str i \" is not accepted!\")))))\n                    (range 50))]\n         (take 33 x))\n\n;; result: Exception 41 is not accepted!\n\n;; When pmap is used instead of map, then not only one, but many exceptions might\n;; be thrown during this extra realization. However, all of them are \"swallowed\"\n;; by pmap: they are thrown inside, but never get out:\n\nuser=> (let [x (pmap (fn [i]\n                       (when (> i 40)\n                         (println \"Exception is thrown...\")\n                         (throw (Exception. (str i \" is not accepted!\")))))\n                     (range 50))]\n         (take 33 x))\n(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil\nException is thrown...Exception is thrown...\n\nException is thrown...Exception is thrown...\n\nException is thrown...\nException is thrown...\nnil nil nil nil nil nil nil nil nil nil nil nil)\nException is thrown...\nException is thrown...Exception is thrown...\n;; Note: the REPL sees no exception!\n\n;; \"Normal\" exceptions arrive as expected:\nuser=> (let [x (pmap (fn [i]\n                       (when (> i 40)\n                         (println \"Exception is thrown...\" i)\n                         (throw (Exception. (str i \" is not accepted!\")))))\n                     (range 50))]\n         (take 42 x))\n(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil\nException is thrown... Exception is thrown...Exception is thrown...  42\n44Exception is thrown...Exception is thrown... 46 \nnilException is thrown... Exception is thrown...47 45\nException is thrown... 49\n43\n\n\n 48nil nil \nnil nil nil nil Exception is thrown...nil  nil 41nil nil \nnil Exception 41 is not accepted!  user/eval9941/fn--9942 (NO_SOURCE_FILE:337)\nnil nil nil nil nil nil\n;; We can see above, that several exceptions are thrown, but only the one for i=41\n;; arrives to the REPL.\n"], :notes nil, :arglists ["n" "n coll"], :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/take"}, :clojure.pprint/*print-suppress-namespaces* {:added "1.2", :ns "clojure.pprint", :name "*print-suppress-namespaces*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 72, :examples ["(require '[clojure.pprint :as pp])\n\n(defmacro plus [n1 n2]\n  `(+ ~n1 ~n2))\n\n(macroexpand-1 '(plus 3 4))\n;=> (clojure.core/+ 3 4)\n\n\n(alter-var-root #'pp/*print-suppress-namespaces* (constantly true))\n\n(macroexpand-1 '(plus 3 4))\n;=> (clojure.core/+ 3 4)\n\n;; comes into effect only in pprint.\n(pp/pprint (macroexpand-1 '(plus 3 4)))\n;=> (+ 3 4)\n"], :notes nil, :arglists [], :doc "Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-suppress-namespaces*"}, :clojure.core.logic.fd/-intervals {:ns "clojure.core.logic.fd", :name "-intervals", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-intervals"}, :clojure.core/remove-ns {:added "1.0", :ns "clojure.core", :name "remove-ns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/create-ns :clojure.core/find-ns], :line 4106, :examples [";; Let's create a namespace and then remove it\n\nuser=> (create-ns 'my-new-namespace)\n#<Namespace my-new-namespace>\n\n;; removing a namespace will give you the namespace you just deleted, if one existed\nuser=> (remove-ns 'my-new-namespace)\n#<Namespace my-new-namespace>\n\n;; removing a namespace that does not exist, will tell you that nothing was removed, \n;; by returning nil, and won't give any errors\nuser=> (remove-ns 'my-new-namespace)\nnil\n"], :notes nil, :arglists ["sym"], :doc "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/remove-ns"}, :clojure.core.logic/nafc {:ns "clojure.core.logic", :name "nafc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2725, :examples nil, :notes nil, :arglists ["c & args"], :doc "EXPERIMENTAL: negation as failure constraint. All arguments to the goal c\n   must be ground. If some argument is not ground the execution of this constraint\n   will be delayed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/nafc"}, :clojure.core.async/mix {:ns "clojure.core.async", :name "mix", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/merge :clojure.core.async/admix :clojure.core.async/unmix :clojure.core.async/unmix-all :clojure.core.async/toggle :clojure.core.async/solo-mode], :line 736, :examples ["user=> (def ch-out (chan))\n#'user/ch-out\n\nuser=> (def mix-out (mix ch-out))\n#'user/mix-out\n\nuser=> (def ch-example1 (chan))\n#'user/ch-example1\n\nuser=> (def ch-example2 (chan))\n#'user/ch-example2\n\nuser=> (admix mix-out ch-example1)\ntrue\n\nuser=> (admix mix-out ch-example2)\ntrue\n\nuser=> (put! ch-example1 \"sent to chan 1\")\ntrue\n\nuser=> (put! ch-example2 \"sent to chan 2\")\ntrue\n\nuser=> (<!! ch-out)\n\"sent to chan 1\"\n\nuser=> (<!! ch-out)\n\"sent to chan 2\"\n\n"], :notes nil, :arglists ["out"], :doc "Creates and returns a mix of one or more input channels which will\n  be put on the supplied out channel. Input sources can be added to\n  the mix with 'admix', and removed with 'unmix'. A mix supports\n  soloing, muting and pausing multiple inputs atomically using\n  'toggle', and can solo using either muting or pausing as determined\n  by 'solo-mode'.\n\n  Each channel can have zero or more boolean modes set via 'toggle':\n\n  :solo - when true, only this (ond other soloed) channel(s) will appear\n          in the mix output channel. :mute and :pause states of soloed\n          channels are ignored. If solo-mode is :mute, non-soloed\n          channels are muted, if :pause, non-soloed channels are\n          paused.\n\n  :mute - muted channels will have their contents consumed but not included in the mix\n  :pause - paused channels will not have their contents consumed (and thus also not included in the mix)\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/mix"}, :clojure.java.io/make-output-stream {:added "1.2", :ns "clojure.java.io", :name "make-output-stream", :type "function", :see-alsos [:clojure.java.io/writer], :examples nil, :notes nil, :arglists ["x opts"], :doc "Creates a BufferedOutputStream. See also IOFactory docs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/make-output-stream"}, :clojure.core.logic/featurec {:ns "clojure.core.logic", :name "featurec", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic/conjo], :line 2579, :examples ["user> (run 1 [q] (featurec q {1 2}) (== q {2 4}))\n() ;; {2 4} does not cointain k-v 1 2\nuser> (run 1 [q] (featurec q {1 2}) (== q {1 2 2 4}))\n({1 2, 2 4}) ;; {1 2 2 4} does contain k-v 1 2" ";; http://michaelrbernste.in/2013/05/12/featurec-and-maps.html\n;; http://stackoverflow.com/questions/15821718/how-do-i-de-structure-a-map-in-core-logic\n\n(is (= (run* [q]\n         (featurec q {:foo 1})\n         (== q {:foo 1 :bar 2}))\n       '({:foo 1 :bar 2})))"], :notes nil, :arglists ["x fs"], :doc "Ensure that a map contains at least the key-value pairs\n  in the map fs. fs must be partially instantiated - that is,\n  it may contain values which are logic variables to support\n  feature extraction.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/featurec"}, :clojure.core/reify {:added "1.2", :ns "clojure.core", :name "reify", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/proxy], :line 70, :examples ["(ns foo)\n\n;;; This is a library for the shopping result.\n\n(defrecord Banana [qty])\n(defrecord Grape  [qty])\n(defrecord Orange [qty])\n\n;;; 'subtotal' differs from each fruit.\n\n(defprotocol Fruit\n  (subtotal [item]))\n\n(extend-type Banana\n  Fruit\n  (subtotal [item]\n    (* 158 (:qty item))))\n\n(extend-type Grape\n  Fruit\n  (subtotal [item]\n    (* 178 (:qty item))))\n\n(extend-type Orange\n  Fruit\n  (subtotal [item]\n    (* 98 (:qty item))))\n\n;;; 'coupon' is the function returing a 'reify' of subtotal. This is\n;;; when someone uses a coupon ticket, the price of some fruits is \n;;; taken off 25%.\n\n(defn coupon [item]\n  (reify Fruit\n    (subtotal [_]\n      (int (* 0.75 (subtotal item))))))\n\n;;; Example: To compute the total when someone bought 10 oranges,\n;;;  15 bananas and 10 grapes, using a coupon for the grapes.\n(apply +  (map subtotal [(Orange. 10) (Banana. 15) (coupon (Grape. 10))]))\n;;; 4685            ; (apply + '(980 2370 1335))" ";; Using a reified FileFilter implementation to obtain only directory files\n(.listFiles (java.io.File. \".\")\n  (reify\n    java.io.FileFilter\n    (accept [this f]\n      (.isDirectory f))))\n" ";;;; This example shows how to reify a multi-arity protocol function\n;;;; (note the different style in defprotocol vs reify)\n\n;; define a multi-arity protocol function blah\n(defprotocol Foo\n  (blah\n    [this x]\n    [this x y]))\n\n;; define an anonymous extension via reify\n(def r (reify Foo \n         (blah [_ x] x)\n         (blah [_ x y] y)))\n\n;; invoke blah via the r instance\n(blah r 1)   ;; => 1\n(blah r 1 2)   ;; => 2\n\n\n" ";; Note that nested class is referred via '$' \n;; and 'this' is always present in parameters (see underscore in parameters list):\n(Thread/setDefaultUncaughtExceptionHandler\n    (reify java.lang.Thread$UncaughtExceptionHandler\n      (uncaughtException [_ thread throwable]\n        (println (str throwable)))))" ";;; This example is inspired by the above one and simplified\n;;; to highlight reify's returning a value/\"object\" \n;;; with protocol realization for just this one piece of value/\"object\".\n\n(ns foo)\n\n(defrecord Grape  [qty])\n\n(defprotocol Fruit\n  (subtotal [item]))\n\n(extend-type Grape\n  Fruit\n  (subtotal [item]\n    (* 178 (:qty item))))\n\n;;; 'discounted' is the function returning a 'reify' instance of fruit with modified \n;;; implementation of subtotal (with discount). That is, \n;;; when someone uses a discounted coupon, the price of the fruits is taken off 25%.\n\n(defn discounted [item]\n  (reify Fruit\n    (subtotal [_]\n      (println \"modifying subtotal with discount:\")\n      (int (* 0.75 (subtotal item))))))\n\n;;; Example:\n;;; There is 10 pieces of Grape, and the subtotal before discount is\n;;; (subtotal (Grape. 10))\n;;; => 1780\n\n;;; With discount, then\n;;; (subtotal (discounted (Grape. 10)))\n;;; => modifying subtotal with discount:\n;;; => 1335\n" "(comment\n  \"reify\n\n   verb | re·ify | \\\\ˈrā-ə-ˌfī, ˈrē-\\\\\n\n   :  to regard (something abstract) as a material or concrete thing\")\n\n(defprotocol shape\n  \"A geometric shape.\"\n\n  (area [this]\n    \"Calculates the area of the shape.\n\n     The first argument is required and corresponds to the implicit target\n     object ('this' in Java parlance).\"))\n\n\n(defn make-circle\n  \"Creates a circle (a geometric shape) object.\"\n  [radius]\n\n  (reify shape\n    (area [_]\n          (* Math/PI radius radius))))\n\n(. (make-circle 8) area)\n;;=> 201.06192982974676\n\n(def circle (make-circle 8))\n\n(satisfies? shape circle)\n;;=> true\n\n(. circle area)\n;;=> 201.06192982974676\n\n\n(defn make-triangle\n  \"Creates a triangle (a geometric shape) object.\"\n  [base height]\n\n  (reify shape\n    (area [_]\n          (* 0.5 base height))))\n\n(def triangle (make-triangle 8 8))\n\n(. triangle area)\n;;=> 32.0\n"], :macro true, :notes nil, :arglists ["& opts+specs"], :doc "reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \"foo\"] \n       (reify Object \n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reify"}, :clojure.core/bit-test {:added "1.0", :ns "clojure.core", :name "bit-test", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bit-set :clojure.core/bit-shift-left :clojure.core/bit-xor], :line 1341, :examples ["(bit-test 2r1001 0)    ;;=> true \n(bit-test 2r1001 1)    ;;=> false \n(bit-test 2r1001 7)    ;;=> false"], :notes nil, :arglists ["x n"], :doc "Test bit at index n", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-test"}, :clojure.inspector/list-provider {:ns "clojure.inspector", :name "list-provider", :file "clojure/inspector.clj", :type "var", :column 1, :see-alsos nil, :line 112, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/list-provider"}, :clojure.core/unchecked-int {:added "1.3", :ns "clojure.core", :name "unchecked-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/int], :line 3526, :examples ["(unchecked-int 1)\n;;=> 1\n(unchecked-int 1N)\n;;=> 1\n(unchecked-int 1.1)\n;;=> 1\n(unchecked-int 1.9)\n;;=> 1\n(unchecked-int 5/3)\n;;=> 1\n\n(unchecked-int -1)\n;;=> -1\n(unchecked-int -1N)\n;;=> -1\n(unchecked-int -1.1)\n;;=> -1\n(unchecked-int -1.9)\n;;=> -1\n(unchecked-int -5/3)\n;;=> -1\n\n;;;; Note that (unchecked-int) does not range check its argument\n;;;; so integer overflow or rounding may occur. \n;;;; Use (int) if you want to throw an exception in such cases.\n\n(unchecked-int 2147483648)\n;;=> -2147483648\n(unchecked-int -2147483649)\n;;=> 2147483647\n\n(int 2147483648)\n;;=> IllegalArgumentException Value out of range for int: 2147483648\n(long -2147483649)\n;;=> IllegalArgumentException Value out of range for int: -2147483649\n\n(unchecked-int 1.0E9)\n;;=> 1000000000\n(unchecked-int 1.0E10)\n;;=> 2147483647\n(unchecked-int 1.0E11)\n;;=> 2147483647\n\n(int 1.0E9)\n;;=> 1000000000\n(int 1.0E10)\n;;=> IllegalArgumentException Value out of range for int: 1.0E10\n(int 1.0E11)\n;;=> IllegalArgumentException Value out of range for int: 1.0E11"], :notes nil, :arglists ["x"], :doc "Coerce to int. Subject to rounding or truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-int"}, :clojure.test/testing-vars-str {:added "1.1", :ns "clojure.test", :name "testing-vars-str", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 294, :examples nil, :notes nil, :arglists ["m"], :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/testing-vars-str"}, :clojure.core.logic.fd/> {:ns "clojure.core.logic.fd", :name ">", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 833, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u must be greater than v. u and v\n   must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/>"}, :clojure.core.logic/map->SuspendedStream {:ns "clojure.core.logic", :name "map->SuspendedStream", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1849, :examples nil, :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.core.logic.SuspendedStream, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/map->SuspendedStream"}, :clojure.string/reverse {:added "1.2", :ns "clojure.string", :name "reverse", :file "clojure/string.clj", :type "function", :column 1, :see-alsos nil, :line 48, :examples ["user> (reverse \"foo\")\n\"oof\"" ";; clojure.string/reverse correctly treats UTF-16 surrogate pairs\n;; as a unit, and does not reverse the 2 Java chars of the pair.  Good!\nuser=> (def s \"smily \\ud83d\\ude03.\")\n#'user/s\nuser=> (def x (str/reverse s))\n#'user/x\nuser=> (map #(format \"%04X\" (int %)) s)\n(\"0073\" \"006D\" \"0069\" \"006C\" \"0079\" \"0020\" \"D83D\" \"DE03\" \"002E\")\nuser=> (map #(format \"%04X\" (int %)) x)\n(\"002E\" \"D83D\" \"DE03\" \"0020\" \"0079\" \"006C\" \"0069\" \"006D\" \"0073\")\n"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Returns s with its characters reversed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/reverse"}, :clojure.core/nth {:added "1.0", :ns "clojure.core", :name "nth", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/second :clojure.core/nthnext :clojure.core/get], :line 881, :examples ["; Note that nth uses zero-based indexing, so that\n;   (first my-seq) <=> (nth my-seq 0)\n(def my-seq [\"a\" \"b\" \"c\" \"d\"])\n(nth my-seq 0)\n; => \"a\"\n(nth my-seq 1)\n; => \"b\"\n(nth [] 0)\n; => IndexOutOfBoundsException ...\n(nth [] 0 \"nothing found\")\n; => \"nothing found\"\n(nth [0 1 2] 77 1337)\n; => 1337" "(nth [\"last\"] -1 \"this is not perl\")\n; => \"this is not perl\""], :notes ["Rather than throwing an exception, `(nth nil n)` returns `nil` for any number `n`."], :arglists ["coll index" "coll index not-found"], :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nth"}, :clojure.core.logic/!=c {:ns "clojure.core.logic", :name "!=c", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2409, :examples nil, :notes nil, :arglists ["p"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/!=c"}, :clojure.core/struct-map {:added "1.0", :ns "clojure.core", :name "struct-map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/struct], :line 4018, :examples [";; create a new struct type\n(defstruct s :1 :2)\n#'user/s\n\nuser=> (type s)\nclojure.lang.PersistentStructMap$Def\n\n;; create an instance of this new struct type\n(def s1 (struct s \"one\" \"two\"))\n#'user/s1\n\nuser=> (println s1)\n{:1 \"one\", :2 \"two\"}\n\nuser=> (type s1)\nclojure.lang.PersistentStructMap\n\n;; create a new struct instance that is based on the previous struct type\n;; with the option of supplying a new key/value pairs\n(def s2 (struct-map s :3 \"three\"))\n#'user/s2\n\nuser=> (println s2)\n{:1 nil, :2 nil, :3 \"three\"}\n\nuser=> (type s2)\nclojure.lang.PersistentStructMap\n" ";; Map -> struct\n(defstruct S :db)\n(into (struct-map S) {:db \"db\" :name \"Grut\"})"], :notes nil, :arglists ["s & inits"], :doc "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/struct-map"}, :clojure.core/nil? {:added "1.0", :ns "clojure.core", :name "nil?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/identity :clojure.core/some?], :line 436, :examples ["user=> (nil? nil)\ntrue\nuser=> (nil? 0)\nfalse\nuser=> (nil? false)\nfalse\nuser=> (nil? '())\nfalse" ";; as nil? is defined as \"Returns true if x is nil, false otherwise.\"\n;; and some? is defined as \"Returns true if x is not nil, false otherwise.\"\n\n;; (some? x) is just shorthand for (not (nil? x))\n;; this also means that nil? is the same as (not (some? x)) as this\n;; just expands into (not (not (nil? x))).\n\n(def nil?? (complement some?))\n;;#'user/nil??\n\n(for [x [nil 0 false [] '()]]\n   (= (nil? x) (nil?? x)))\n;;=> (true true true true true)"], :notes nil, :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true if x is nil, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nil_q"}, :clojure.core/sorted? {:added "1.0", :ns "clojure.core", :name "sorted?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-map :clojure.core/sorted-set], :line 6176, :examples ["user=> (sorted? (sorted-set 5 3 1 2 4))\ntrue\nuser=> (sorted? (sorted-map :a 1 :c 3 :b 2))\ntrue\n\n;; Note you can't just pass in a collection that happens to be sorted.\nuser=> (sorted? [1 2 3 4 5])\nfalse\n" "=> (sorted? (sort [1 2]))\nfalse"], :notes nil, :arglists ["coll"], :doc "Returns true if coll implements Sorted", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sorted_q"}, :clojure.string/trim {:added "1.2", :ns "clojure.string", :name "trim", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/triml :clojure.string/trimr :clojure.string/trim-newline], :line 234, :examples [";; Trim basically does what you'd expect.  What the doc string\n;; does not tell you however is that:\n;;  - null will cause an error\n;;  - non-string parameters will cause an error\n\n(use 'clojure.string)\nuser=> (trim \"     a      \")\n\"a\"\nuser=> (trim nil)  \njava.lang.NullPointerException (NO_SOURCE_FILE:0)\nuser=> (trim 1.1)\njava.lang.Double cannot be cast to java.lang.CharSequence\nuser=> (trim [1 2 3])\nclojure.lang.PersistentVector cannot be cast to java.lang.CharSequence\n" ";; trim might not do what you expect\n;; if your string starts/ends with 'separator' ascii control codes.\n\n;; This is because these characters are treated as\n;; whitespace in trim (and trimr and triml), but\n;; non-whitespace in the regex #\"\\s\" (and \\S).\n\n;; In other words either you believe they are whitespaces or not whitespaces,\n;; you can be surprised when using trim/trimr/triml or when using #\"\\s\" or #\"\\S\":\n;; \"whitespace\" for trim is NOT the same as\n;; \"whitespace\" for \\s.\n\n(use 'clojure.string)\n\n(trim \"a \\u001F\")\n=> \"a\"\n\nbut\n\n(split \"a \\u001F\" #\"\\s+\")\n=> [\"a\" \"\\u001F\"]\n;; instead of [\"a\"], that could be expected based on trim's behaviour\n\n;; The exact list of these special \"characters\":\n;; Dec Hex (UTF-8)  Unicode (UTF-16BE)  Clojure   Name             Abbreviation\n;; 28  1C           U+001C              '\\u001C'  File separator   FS\n;; 29  1D           U+001D              '\\u001D'  Group separator  GS\n;; 30  1E           U+001E              '\\u001E'  Record separator RS\n;; 31  1F           U+001F              '\\u001F'  Unit separator   US\n\n;; Background: Clojure's trim uses Java Character's isWhitespace,\n;; that has its own definition of whitespace,\n;; that differs from the definition of whitespace in the \\s\n;; \"whitespace character class\" of Java regex.\n\n;; References:\n;; Clojure trim's source: \n;; https://clojure.github.io/clojure/clojure.string-api.html#clojure.string/trim\n;; Java Character's isWhitespace: \n;; https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-\n;; Java's \\s whitespace character class: \n;; https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html\n"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Removes whitespace from both ends of string.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/trim"}, :clojure.core/*data-readers* {:added "1.4", :ns "clojure.core", :name "*data-readers*", :file "clojure/core.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 7678, :examples nil, :notes ["`clojure.edn/read` and `clojure.edn/read-string` don't look into\n`*data-readers*` in order to find the reader functions for a reader tag.\nThat's why they won't get the mappings from `data_readers.clj` either.\nSee the [note on `clojure.edn/read`](https://clojuredocs.org/clojure.edn/read)\nfor more information and a warning." "Note that if you're using `clojure.reader/read` instead of `clojure.core/read`, you have to bind `clojure.reader/*data-readers*` rather than `clojure.core/*data-readers*`."], :arglists [], :doc "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*data-readers*"}, :clojure.core/dedupe {:added "1.7", :ns "clojure.core", :name "dedupe", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/distinct], :line 7575, :examples ["user=> (dedupe [1 2 3 3 3 1 1 6])\n(1 2 3 1 6)"], :notes nil, :arglists ["" "coll"], :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dedupe"}, :clojure.core.async/unmix {:ns "clojure.core.async", :name "unmix", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/unmix-all :clojure.core.async/admix :clojure.core.async/mix :clojure.core.async/toggle :clojure.core.async/solo-mode], :line 811, :examples nil, :notes nil, :arglists ["mix ch"], :doc "Removes ch as an input to the mix", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unmix"}, :clojure.spec.alpha/explain-data* {:ns "clojure.spec.alpha", :name "explain-data*", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 197, :examples nil, :notes nil, :arglists ["spec path via in x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain-data*"}, :clojure.java.javadoc/*feeling-lucky-url* {:ns "clojure.java.javadoc", :name "*feeling-lucky-url*", :file "clojure/java/javadoc.clj", :type "var", :column 1, :see-alsos [:clojure.java.javadoc/*feeling-lucky*], :dynamic true, :line 16, :examples [";; If `clojure.java.javadoc/*feeling-lucky*` is true,\n;; clojure.java.javadoc/javadoc opens a browser with this URL if it can’t\n;; find the proper documentation URL (e.g. if it’s a custom class).\n\n;; Default value\n*feeling-lucky-url*\n; => \"http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&q=allinurl:\"\n\n;; Use DuckDuckGo instead of Google\n(binding [clojure.java.javadoc/*feeling-lucky-url* \"https://duckduckgo.com/?q=\\\\\"]\n  (clojure.java.javadoc/javadoc your-class))"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/*feeling-lucky-url*"}, :clojure.core.logic/choice {:ns "clojure.core.logic", :name "choice", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1102, :examples nil, :notes nil, :arglists ["a f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/choice"}, :clojure.spec.alpha/unform* {:ns "clojure.spec.alpha", :name "unform*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec y"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/unform*"}, :clojure.core/atom {:added "1.0", :ns "clojure.core", :name "atom", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/reset! :clojure.core/swap! :clojure.core/compare-and-set! :clojure.core/add-watch :clojure.core/remove-watch :clojure.core/set-validator! :clojure.core/swap-vals! :clojure.core/reset-vals!], :line 2319, :examples ["user=> (def my-atom (atom 0))\n#'user/my-atom\n\nuser=> @my-atom\n0\n\nuser=> (swap! my-atom inc)\n1\n\nuser=> @my-atom\n1\n\nuser=> (swap! my-atom (fn [n] (* (+ n n) 2)))\n4\n\nuser=> (reset! my-atom 0)\n0\n\nuser=> @my-atom\n0" "user=> (def a (atom #{}))\n#'user/a\n\nuser=>(swap! a conj :tag)\n#{:tag}\n\nuser=> @a\n#{:tag}" "user=> (def my-atom (atom 0 :validator even?))\n#'user/my-atom\n\nuser=> @my-atom\n0\n\nuser=> (swap! my-atom inc)\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n\nuser=> (swap! my-atom (partial + 2))\n2\n\nuser=> @my-atom\n2" "(def car\n  (atom {:make \"Audi\"\n         :model \"Q3\"}))\n\n@car\n;;{:make \"Audi\", :model \"Q3\"}\n\n(swap!\n car\n assoc :model \"Q5\")\n;;{:make \"Audi\", :model \"Q5\"}\n\n(reset! car {:make \"\" :model \"\"})\n;;{:make \"\", :model \"\"}"], :notes nil, :arglists ["x" "x & options"], :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/atom"}, :clojure.core/as-> {:added "1.5", :ns "clojure.core", :name "as->", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/-> :clojure.core/->> :clojure.core/cond-> :clojure.core/cond->> :clojure.core/some-> :clojure.core/some->>], :line 7492, :examples ["(def owners [{:owner \"Jimmy\"\n              :pets (ref [{:name \"Rex\"\n                           :type :dog}\n                          {:name \"Sniffles\"\n                           :type :hamster}])} \n              {:owner \"Jacky\" \n               :pets (ref [{:name \"Spot\" \n                            :type :mink}\n                           {:name \"Puff\" \n                            :type :magic-dragon}])}])\n\n;; This example is contrived as there are other more \n;; terse ways of expressing the idea.  It demonstrates\n;; several of the ways to extract items from a collection.\n;; Notice how the collection can be used in function or \n;; parameter position.\n(as-> owners $ (nth $ 0) (:pets $) (deref $) ($ 1) ($ :type))\n;;=> :hamster" "(as-> 0 n\n      (inc n)  ; n is 0 here passed from first parameter to as->\n      (inc n)) ; n is 1 here passed from result of previous inc expression\n;;=> 2" "; use it in the middle of a -> pipeline to sprinkle in some flexibility\n(-> [10 11]\n    (conj 12)\n    (as-> xs (map - xs [3 2 1]))\n    (reverse))\n; (11 9 7)" ";; when you want to use arbitrary positioning of your argument in a thread macro\n(as-> {:a 1 :b 2} m\n  (update m :a + 10)\n  (reduce (fn [s [_ v]] (+ s v)) 0 m))\n\n;; when you'd like an if statement in your thread\n(as-> {:a 1 :b 2} m\n  (update m :a + 10)\n  (if update-b\n    (update m :b + 10)\n    m))" ";; as-> with destructured binding\n\n(let [req {:host \"//mysite.com\" :path \"/a/123\" :x \"15.1\" :y \"84.2\"}]\n  (as-> req {:keys [host path x y] :as m}\n    (assoc m :url (str host path))\n    (assoc m :coord [(Double/valueOf x) (Double/valueOf y)])))\n\n;; {:path \"/a/123\" :x \"15.1\" :y \"84.2\" :url \"//mysite.com/a/123\" :coord [15.1 84.2]}"], :macro true, :notes nil, :arglists ["expr name & forms"], :doc "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/as->"}, :clojure.core/split-at {:added "1.0", :ns "clojure.core", :name "split-at", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/split-with :clojure.string/split], :line 2977, :examples ["user=> (split-at 2 [1 2 3 4 5])\n[(1 2) (3 4 5)]\n\nuser=> (split-at 3 [1 2])\n[(1 2) ()]"], :notes nil, :arglists ["n coll"], :doc "Returns a vector of [(take n coll) (drop n coll)]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/split-at"}, :clojure.core/require {:added "1.0", :ns "clojure.core", :name "require", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/remove-ns :clojure.core/import :clojure.core/use :clojure.core/ns :clojure.core/refer], :line 5947, :examples [";; Require clojure.java.io and call its file function:\n\nuser=> (require '(clojure.java.io))\nuser=> (clojure.java.io/file \"filename\")\n#<File filename>" ";; alias clojure.java.io as io\nuser=> (require '[clojure.java.io :as io])\nnil\n\nuser=> (io/file \"Filename\")\n#<File Filename>\n\n;; alias clojure.java.io as io using prefixes\nuser=> (require '(clojure.java [io :as io2]))\nnil\n\nuser=> (io2/file \"Filename\")\n#<File Filename>" "(ns rosettacode.24game\n  (:require [clojure.string :as str]))\n\n(defn parse-infix-data\n  \"input '1+2+3+4'\n   output (1 + 2 + 3 + 4)\n   where the numbers are clojure numbers, and the symbols are clojure operators\"\n  [string] (map read-string (next (str/split string #\"\"))))" "(require '(clojure.contrib [sql :as sql]))" "(ns myproject.core\n  (:use [clojure.core] :reload)\n  (:require [clojure.string :as str :refer [replace]] :reload-all))\n\n(str/replace \"foo\" #\"o\" \"e\")\n\"fee\"\n\n; similar but using a prefix.\n(ns myproject.core\n  (:require (clojure [core]\n                     [string :as str :refer [replace]] ))) \n\n" "; rename a function name (thanks for @noisesmith)\n; rename 'clojure.repl/doc' to 'd'\nuser=> (require '[clojure.repl :as r :refer [doc] :rename {doc d}])\nnil\nuser=> (d doc)\n-------------------------\nclojure.repl/doc\n([name])\nMacro\n  Prints documentation for a var or special form given its name\nnil\n"], :notes ["Good description of use/require/import here:\r\n\r\nhttp://blog.8thlight.com/articles/2010/12/6/clojure-libs-and-namespaces-require-use-import-and-ns"], :arglists ["& args"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/require"}, :clojure.core.logic/walk* {:ns "clojure.core.logic", :name "walk*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 227, :examples nil, :notes nil, :arglists ["s v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/walk*"}, :clojure.core/sorted-set {:added "1.0", :ns "clojure.core", :name "sorted-set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-set-by :clojure.core/subseq :clojure.core/rsubseq :clojure.core/sorted-map :clojure.core/into :clojure.core/hash-set], :line 417, :examples ["user=> (sorted-set 3 2 1)\n#{1 2 3}\n\nuser=> (sorted-set 3 2 1 1)\n#{1 2 3}\n\nuser=> #{2 1 3}\n#{1 3 2}\n\nuser=> (apply sorted-set #{2 1 3})\n#{1 2 3}" "(sorted-set :a \"A\" 1)\n\n;;Exception\n;;unable to implement java.lang.String.compareTo"], :notes nil, :arglists ["& keys"], :doc "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sorted-set"}, :clojure.core/neg-int? {:added "1.9", :ns "clojure.core", :name "neg-int?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/pos-int? :clojure.core/nat-int? :clojure.core/int?], :line 1406, :examples ["(neg-int? -1)\n;;=> true\n(neg-int? -9223372036854775808)\n;;=> true\n\n;;;; false for non-negative values\n\n(neg-int? 0)\n;;=> false\n(neg-int? 1)\n;;=> false\n\n;;;; false for decimal values\n\n(neg-int? -1.0)\n;;=> false\n(neg-int? -1/2)\n;;=> false\n\n;;;; false for BigInt values\n\n(neg-int? -1N)\n;;=> false\n(neg-int? -9223372036854775809)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a negative fixed precision integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/neg-int_q"}, :clojure.core.logic.fd/in {:ns "clojure.core.logic.fd", :name "in", :file "clojure/core/logic/fd.clj", :type "macro", :column 1, :see-alsos nil, :line 646, :examples nil, :macro true, :notes nil, :arglists ["& xs-and-dom"], :doc "Assign vars to domain. The domain must come last.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/in"}, :clojure.core/not-every? {:added "1.0", :ns "clojure.core", :name "not-every?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/every? :clojure.core/not-any? :clojure.core/some], :line 2676, :examples ["user=> (not-every? odd? '(1 2 3))\ntrue\nuser=> (not-every? odd? '(1 3))\nfalse"], :notes nil, :tag "java.lang.Boolean", :arglists ["pred coll"], :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/not-every_q"}, :clojure.core/slurp {:added "1.0", :ns "clojure.core", :name "slurp", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/reader :clojure.core/spit :clojure.java.io/resource], :line 6862, :examples ["user=> (spit \"blubber.txt\" \"test\")\nnil\nuser=> (slurp \"blubber.txt\")\n\"test\"" ";; To access web page. Note the use of http://\n;; prefix\n\nuser=> (slurp \"http://clojuredocs.org\")\n; This will return the html content of clojuredocs.org" ";; Access absolute location on Windows\n\nuser=> (slurp \"C:\\\\tasklists.xml\")\n" ";; On Linux, some JVMs have a bug where they cannot read a file in the /proc\n;; filesystem as a buffered stream or reader.  A workaround to this JVM issue\n;; is to open such a file as unbuffered:\n(slurp (java.io.FileReader. \"/proc/cpuinfo\"))" ";; You can specify what encoding to use by giving a :encoding param, and an encoding string recognized by your JVM\n\nuser=> (slurp \"/path/to/file\" :encoding \"ISO-8859-1\")" ";; you can fetch URLs\n\n(slurp \"http://www.example.com\")" ";; you can read bytes also\n\n(def arr-bytes (into-array Byte/TYPE (range 128)))\n(slurp arr-bytes)"], :notes ["Use slurp also to read an input stream into a string." "With link: â€œSee [`clojure.java.io/reader`](http://clojuredocs.org/clojure_core/clojure.java.io/reader) for a complete list of supported arguments.â€�\r\n\r\nAccording to those docs, here are the supported types for `f`, the object to read:\r\n\r\n* [`Reader`](http://docs.oracle.com/javase/7/docs/api/java/io/Reader.html)\r\n* [`BufferedReader`](http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html)\r\n* [`InputStream`](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html)\r\n* [`File`](http://docs.oracle.com/javase/7/docs/api/java/io/File.html)\r\n* [`URI`](http://docs.oracle.com/javase/7/docs/api/java/net/URI.html)\r\n* [`URL`](http://docs.oracle.com/javase/7/docs/api/java/net/URL.html)\r\n* [`Socket`](http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)\r\n* byte arrays (`byte[]`)\r\n* character arrays (`char[]`)\r\n* [`String`](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html)\r\n\r\n`slurp` can read objects of any of these types into a string." "<pre>\n(defn slurp-bytes\n  \"Slurp the bytes from a slurpable thing\"\n  [x]\n  (with-open [out (java.io.ByteArrayOutputStream.)]\n    (clojure.java.io/copy (clojure.java.io/input-stream x) out)\n    (.toByteArray out)))\n</pre>"], :tag "java.lang.String", :arglists ["f & opts"], :doc "Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/slurp"}, :clojure.core/nnext {:added "1.0", :ns "clojure.core", :name "nnext", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/next :clojure.core/fnext :clojure.core/ffirst :clojure.core/nfirst], :line 119, :examples ["<pre>user=&gt; (nnext '(1 2 3))\r\n(3)\r\n</pre>\r\n\r\n<pre>user=&gt; (nnext [])\r\nnil \r\n</pre>\r\n\r\n<pre>user=&gt; (nnext ['(a b c) '(b a c) '(c b a) '(a c b)])\r\n((c b a) (a c b)) \r\n</pre>\r\n\r\n<pre>user=&gt; (nnext {:a 1, :b 2, :c 3, :d 4})\r\n([:c 3] [:d 4]) \r\n</pre>\r\n\r\n<pre>user=&gt; (nnext #{:a :b :c})\r\n(:c)\r\n</pre>\r\n"], :notes nil, :arglists ["x"], :doc "Same as (next (next x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nnext"}, :clojure.core/persistent! {:added "1.1", :ns "clojure.core", :name "persistent!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/transient], :line 3341, :examples ["user> (def foo (transient [1 2 3]))\n#'user/foo\nuser> foo\n#<TransientVector clojure.lang.PersistentVector$TransientVector@12c9b4d1>\nuser> (persistent! foo)\n[1 2 3]\nuser> foo\n#<TransientVector clojure.lang.PersistentVector$TransientVector@12c9b4d1>\nuser> (conj! foo 4)\nâ†’ ERROR:Transient used after persistent! call\nuser> (persistent! foo)\nâ†’ ERROR: Transient used after persistent! call" ";; Use persistent! to evaluate your object,\n;; once the computation is complete\n\n(loop [large-set (transient #{})\n       i 0]\n  (if (< i 100000)\n    (recur (conj! large-set i) (inc i))\n    (persistent! large-set)))\n\n;; Returns a large set *much* faster than its\n;; persistent version. While keeping the same\n;; code structure\n"], :notes nil, :arglists ["coll"], :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/persistent!"}, :clojure.core.async/Pub {:ns "clojure.core.async", :name "Pub", :file "clojure/core/async.clj", :type "var", :column 1, :see-alsos nil, :line 838, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/Pub"}, :clojure.core/not= {:added "1.0", :ns "clojure.core", :name "not=", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/= :clojure.core/not], :line 811, :examples ["user=> (not= 1 1)\nfalse\n\nuser=> (not= 1 2)\ntrue\n\nuser=> (not= true true)\nfalse\n\nuser=> (not= true false)\ntrue\n\nuser=> (not= true true true true)\nfalse\n\nuser=> (not= true true false true)\ntrue\n"], :notes nil, :tag "java.lang.Boolean", :arglists ["x" "x y" "x y & more"], :doc "Same as (not (= obj1 obj2))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/not="}, :clojure.spec.alpha/regex? {:ns "clojure.spec.alpha", :name "regex?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 78, :examples nil, :notes nil, :arglists ["x"], :doc "returns x if x is a (clojure.spec) regex op, else logical false", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/regex_q"}, :clojure.spec.alpha/or {:ns "clojure.spec.alpha", :name "or", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos [:clojure.spec.alpha/alt], :line 455, :examples ["(require '[clojure.spec.alpha :as s])\n\n(let [spec (s/or :n number? :b boolean?)]\n  [(s/conform spec 1)\n   (s/conform spec true)\n   (s/conform spec \"str\")])\n;; => [[:n 1] [:b true] :clojure.spec.alpha/invalid]"], :macro true, :notes nil, :arglists ["& key-pred-forms"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/or"}, :clojure.main/repl {:ns "clojure.main", :name "repl", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 177, :examples nil, :notes nil, :arglists ["& options"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl"}, :clojure.core/double? {:added "1.9", :ns "clojure.core", :name "double?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/float? :clojure.core/decimal? :clojure.core/bigdec?], :line 1418, :examples [";;;; true for instances of java.lang.Double\n\n(double? 1.0)\n;;=> true\n(double? (new Double \"1\"))\n;;=> true\n\n;;;; false for instances of java.lang.Float, java.lang.BigDecimal\n\n(double? (new Float \"1\"))\n;;=> false\n(double? 1.0M)\n;;=> false\n(double? (new BigDecimal \"1\"))\n;;=> false\n"], :notes nil, :arglists ["x"], :doc "Return true if x is a Double", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/double_q"}, :clojure.pprint/pprint-indent {:added "1.2", :ns "clojure.pprint", :name "pprint-indent", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos nil, :line 341, :examples nil, :notes nil, :arglists ["relative-to n"], :doc "Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/pprint-indent"}, :clojure.pprint/*print-radix* {:added "1.2", :ns "clojure.pprint", :name "*print-radix*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 80, :examples nil, :notes nil, :arglists [], :doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-radix*"}, :clojure.core.logic/-predc {:ns "clojure.core.logic", :name "-predc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2659, :examples nil, :notes nil, :arglists ["x p" "x p pform"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-predc"}, :clojure.core/ns-resolve {:added "1.0", :ns "clojure.core", :name "ns-resolve", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/resolve], :line 4325, :examples ["user=> (defn f [n] (* n n n))\n#'user/f\nuser=> ((ns-resolve *ns* (symbol \"f\")) 10)\n1000" ";; See also http://clojure.org/namespaces for information on namespaces in Clojure and how to inspect and manipulate them"], :notes ["The appropriate value for the <code>env</code> arg is what you get from the implicit <code>&env</code> arg available to a macro."], :arglists ["ns sym" "ns env sym"], :doc "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-resolve"}, :clojure.data/diff-similar {:added "1.3", :ns "clojure.data", :name "diff-similar", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["a b"], :doc "Implementation detail. Subject to change.", :library-url "https://github.com/clojure/clojure", :href "/clojure.data/diff-similar"}, :clojure.core.async/reduce {:ns "clojure.core.async", :name "reduce", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/merge :clojure.core.async/map :clojure.core.async/into], :line 596, :examples ["(require '[clojure.core.async :as async])\n\n;; some expensive io call\n(defn expensive-call [m] \n  (Thread/sleep 2000) m)\n\n(->> [{:a 1} {:b 2} {:c 3} {:d 4}]\n     (map (fn [m] \n            (async/thread \n               (expensive-call m)))) ; creates a thread per call\n     (async/merge)                   ; merges the 4 chans returned into 1\n     (async/reduce merge {})         ; reduces items in chan with merge\n     (async/<!!))\n;;=> {:a 1, :c 3, :b 2, :d 4}" "(require '[clojure.core.async :as async])\n\n(def c \n  (async/to-chan (range 10)))\n\n(async/<!! (async/reduce + 0 c))\n;;=> 45" "(require '[clojure.core.async :as async])\n\n; define a channel which yields a predefined value after a timeout\n; (function 'f' of async/reduce won't be called)\n(def c\n  (async/reduce f :predefined-value (async/timeout 10000)))\n\n(async/<!! c)\n; wait 10 seconds\n;;=> :predefined-value"], :notes nil, :arglists ["f init ch"], :doc "f should be a function of 2 arguments. Returns a channel containing\n  the single result of applying f to init and the first item from the\n  channel, then applying f to that result and the 2nd item, etc. If\n  the channel closes without yielding items, returns init and f is not\n  called. ch must close before reduce produces a result.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/reduce"}, :clojure.core/iterate {:added "1.0", :ns "clojure.core", :name "iterate", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/cycle :clojure.core/repeatedly :clojure.core/repeat :clojure.core/take :clojure.core/nth], :line 3005, :examples [";; iterate Ad Infinitum starting at 5 using the inc (increment) function\nuser=> (iterate inc 5)\n(5 6 7 8 9 10 11 12 13 14 15 ... n\n\n;; limit results\nuser=> (take 5 (iterate inc 5))\n(5 6 7 8 9)\n\nuser=> (take 10 (iterate (partial + 2) 0))\n(0 2 4 6 8 10 12 14 16 18)\n\nuser=> (take 20 (iterate (partial + 2) 0))\n(0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38)\n\n" "user=> (def powers-of-two (iterate (partial * 2) 1))\n#'user/powers-of-two\n\nuser=> (nth powers-of-two 10)\n1024\nuser=> (take 10 powers-of-two)\n(1 2 4 8 16 32 64 128 256 512)\n" ";; demonstrating the power of iterate\n;; to generate the Fibonacci sequence\n;; uses +' to promote to BigInt\nuser=> (def fib (map first (iterate (fn [[a b]] [b (+' a b)]) [0 1])))\n#'user/fib\n\nuser=> (take 10 fib)\n(0 1 1 2 3 5 8 13 21 34)" ";; iterate (also range, repeat and cycle) have a reduce\n;; fast path. Use with reduce, transduce, eduction etc.\n\n(defn pi\n  \"Approximate Pi to the 1/n decimal with Leibniz formula\"\n  [n]\n  (transduce\n    (comp (map #(/ 4 %)) (take n))\n    +\n    (iterate #(* ((if (pos? %) + -) % 2) -1) 1.0)))\n\n(time (pi 1e8))\n\"Elapsed time: 9776.924934 msecs\"\n;; 3.141592643589326"], :notes nil, :arglists ["f x"], :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/iterate"}, :clojure.core.logic/enforceable-constrained {:ns "clojure.core.logic", :name "enforceable-constrained", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2140, :examples nil, :notes nil, :arglists ["a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/enforceable-constrained"}, :clojure.core/prefers {:added "1.0", :ns "clojure.core", :name "prefers", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/prefer-method :clojure.core/methods :clojure.core/get-method], :line 1816, :examples ["(def m {:os ::osx})\n\n(defmulti ex :os)\n\n(defmethod ex ::unix\n  [_]\n  \"unix\")\n\n(derive ::osx ::unix)\n\n(defmethod ex ::bsd\n  [_]\n  \"bsd\")\n\n(derive ::osx ::bsd)\n\n(prefer-method ex ::unix ::bsd)\n\n(prefers ex)\n;;=> {:user/unix #{:user/bsd}}"], :notes nil, :arglists ["multifn"], :doc "Given a multimethod, returns a map of preferred value -> set of other values", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/prefers"}, :clojure.string/capitalize {:added "1.2", :ns "clojure.string", :name "capitalize", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/upper-case :clojure.string/lower-case], :line 196, :examples ["user=> (require 'clojure.string)\nnil\n\nuser=> (clojure.string/capitalize \"MiXeD cAsE\")\n\"Mixed case\"\n\nuser=> (clojure.string/capitalize \"mIxEd CaSe\")\n\"Mixed case\"\n" "(defn capitalize-words \n  \"Capitalize every word in a string\"\n  [s]\n  (->> (string/split (str s) #\"\\b\") \n       (map string/capitalize)\n       string/join))\n\n(capitalize-words \"a bunch of words/text\")\n;;=> \"A Bunch Of Words/Text\"" ";; Warning: If you deal with Unicode characters often, note that some do not\n;; fit into a single 16-bit Java char.  Yes, such Unicode characters exist.\n;; The JVM encodes them in strings in memory using UTF-16, as 2 consecutive\n;; 16-bit values, each with their own separate index in the string's array\n;; of chars.\n\n;; https://en.wikipedia.org/wiki/UTF-16\n\n;; clojure.string/capitalize should not be used for such strings, as it\n;; operates by feeding the first 16-bit Java char for capitalization, and the rest\n;; of the Java chars for converting to lower case.\n\n;; I wouldn't bother filing (another) bug on Clojure for this, since it is\n;; unlikely to change in this regard.  If you are dealing with many languages\n;; in the Unicode character set on a regular basis, then you likely\n;; want to use a library like ICU4J, which is much more sophisticated in its\n;; capabilities than anything built into Clojure.\n\n;; ICU4J (also ICU4C): http://site.icu-project.org"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/capitalize"}, :clojure.core/string? {:added "1.0", :ns "clojure.core", :name "string?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 160, :examples ["user=> (string? \"abc\")\ntrue\n\nuser=> (string? \"\")\ntrue\n\nuser=> (string? \\a)\nfalse\n\nuser=> (string? 1)\nfalse\n\nuser=> (string? [\"a\" \"b\" \"c\"])\nfalse\n\nuser=> (string? nil)\nfalse"], :notes nil, :arglists ["x"], :doc "Return true if x is a String", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/string_q"}, :clojure.core/- {:added "1.2", :ns "clojure.core", :name "-", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/-' :clojure.core/unchecked-negate :clojure.core/unchecked-subtract :clojure.core/dec], :line 1035, :examples ["user=> (- 1)\n-1 \nuser=> (- 6 3)  \n3\nuser=> (- 10 3 2)  \n5" "\n(- 0 9000000000000000000 1000000000000000000)\n;; ArithmeticException: integer overflow\n\n(-' 0 9000000000000000000 1000000000000000000)\n;;=> 10000000000000000000N \n\n\n"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/-"}, :clojure.core/dissoc {:added "1.0", :ns "clojure.core", :name "dissoc", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc :clojure.core/disj :clojure.core/select-keys], :line 1496, :examples ["user=> (dissoc {:a 1 :b 2 :c 3}) ; dissoc nothing \n{:a 1, :b 2, :c 3} \n\nuser=> (dissoc {:a 1 :b 2 :c 3} :b) ; dissoc key :b\n{:a 1, :c 3} \n\nuser=> (dissoc {:a 1 :b 2 :c 3} :d) ; dissoc not existing key\n{:a 1, :b 2, :c 3} \n\nuser=> (dissoc {:a 1 :b 2 :c 3} :c :b) ; several keys at once\n{:a 1} \n" ";; There is no (dissoc-in) analogous to (get-in) or (assoc-in), but \n;; you can achieve a similar effect using (update-in):\n\n(update-in {:a {:b {:x 3} :c 1}} [:a :b] dissoc :x)\n;;=> {:a {:b {}, :c 1}}" ";; When applied to a record and one of its base fields, \n;; dissoc produces a plain map instead of a record\n\n(defrecord Widget [id])\n(def w (->Widget \"id\"))\n\n(class w)\n;; user.Widget\n\n(class (dissoc w :id))\n;; clojure.lang.PersistentArrayMap" ";; Removing multiple from nested map\n(update-in {:a {:b {:x 3 :y 5} :c 1}} [:a :b] \n       (fn [nested] (apply dissoc nested [:x :y] )) )\n=> {:a {:b {}, :c 1}} "], :notes nil, :arglists ["map" "map key" "map key & ks"], :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/dissoc"}, :clojure.repl/source-fn {:ns "clojure.repl", :name "source-fn", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos [:clojure.repl/source], :line 148, :examples ["(source-fn 'max)\n\n;;=> \"(defn max\n     \\\"Returns the greatest of the nums.\\\"\n      {:added \\\"1.0\\\"\n      :inline-arities >1?\n      :inline (nary-inline 'max)}\n      ([x] x)\n      ([x y] (. clojure.lang.Numbers (max x y)))\n      ([x y & more]\n      (reduce1 max (max x y) more)))\"\n"], :notes nil, :arglists ["x"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/source-fn"}, :clojure.core/reset! {:added "1.0", :ns "clojure.core", :name "reset!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/swap! :clojure.core/compare-and-set! :clojure.core/atom :clojure.core/swap-vals! :clojure.core/reset-vals!], :line 2368, :examples ["user=> (def x (atom 10))\n#'user/x\n\nuser=> @x\n10\n\nuser=> (reset! x 20)\n20\n\nuser=> @x\n20"], :notes nil, :arglists ["atom newval"], :doc "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reset!"}, :clojure.core/future-cancelled? {:added "1.1", :ns "clojure.core", :name "future-cancelled?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/future :clojure.core/future? :clojure.core/future-cancel :clojure.core/future-done?], :line 6926, :examples ["user=> (def f (future (inc 0)))                    \n#'user/f\n\nuser=> (future-cancel f)       \nfalse\n\nuser=> (future-cancelled? f)\nfalse\n\nuser=> (future-done? f)        \ntrue\n\nuser=> @f                                          \n1\n" "user=> (def f (future (Thread/sleep 5000) (inc 0)))\n#'user/f\n\nuser=> (future-cancel f)                           \ntrue\n\nuser=> (future-cancelled? f)                       \ntrue\n\nuser=> (future-done? f)                            \ntrue\n\nuser=> @f                                          \njava.util.concurrent.CancellationException (NO_SOURCE_FILE:0)"], :notes nil, :arglists ["f"], :doc "Returns true if future f is cancelled", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future-cancelled_q"}, :clojure.core/when-not {:added "1.0", :ns "clojure.core", :name "when-not", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/when :clojure.core/when-let :clojure.core/if], :line 499, :examples [";; build tuples over sets with the same cardinality \n(map\n  #(when-not (= %2 %3) [%1 %2 %3])\n    (iterate inc 0)   ; a lazy list of indecies\n    [:a :b :c]\n    [:a :a :a])\n;;=> (nil [1 :b :a] [2 :c :a])\n" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";; when-not is similar to unless (in other languages).\n;; An alias can be provided with a macro\n(defmacro unless [& args] `(when-not ~@args))\n\n(map #(unless (= %2 %3) [%1 %2 %3])\n  (iterate inc 0)    ; a lazy list for indecies\n  [:a :b :c]\n  [:a :a :a]) \n;;=> (nil [1 :b :a] [2 :c :a])"], :macro true, :notes nil, :arglists ["test & body"], :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/when-not"}, :clojure.core/*1 {:added "1.0", :ns "clojure.core", :name "*1", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/*2 :clojure.core/*3], :dynamic true, :line 6199, :examples ["\"Hello!\"\n;;=> \"Hello!\"\n\n*1\n;;=> \"Hello!\"\n"], :notes nil, :arglists [], :doc "bound in a repl thread to the most recent value printed", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*1"}, :clojure.core/inst? {:added "1.9", :ns "clojure.core", :name "inst?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/inst-ms], :line 6717, :examples ["(inst? (java.util.Date.))\n;;=> true\n(inst? (java.util.Calendar/getInstance))\n;;=> false\n\n(inst? (java.sql.Timestamp. 0))\n;;=> true\n(inst? (java.sql.Date. 0))\n;;=> true\n\n(inst? (java.time.Instant/now))\n;;=> true\n(inst? (java.time.LocalDateTime/now))\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x satisfies Inst", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/inst_q"}, :clojure.core/*command-line-args* {:added "1.0", :ns "clojure.core", :name "*command-line-args*", :type "var", :see-alsos nil, :examples [";; If you save this program as showargs.clj on a Unix-like system, then the\n;; following command will produce the output shown.\n\n;; % java -classpath clojure-1.2.0.jar clojure.main showargs.clj arg1 2 \"whitespace in most command shells if you quote\"\n;; arg='arg1'\n;; arg='2'\n;; arg='whitespace in most command shells if you quote'\n;; \n;; \n;; Second arg is string 2, not number 2.\n\n(ns com.demo.showargs)\n\n(doseq [arg *command-line-args*]\n  (printf \"arg='%s'\\n\" arg))\n\n(if (= \"2\" (second *command-line-args*))\n  (println \"\\n\\nSecond arg is string 2, not number 2.\"))\n"], :notes nil, :arglists [], :doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*command-line-args*"}, :clojure.core/subseq {:added "1.0", :ns "clojure.core", :name "subseq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rsubseq :clojure.core/sorted-map :clojure.core/sorted-set :clojure.core/sorted-map-by :clojure.core/sorted-set-by :clojure.core/subvec], :line 5049, :examples [";; Note, that collection passed to subseq must implement Sorted.  \n;; Just passing a collection that has been sorted is not enough.\n\nuser=> (subseq [1 2 3 4] > 2)\njava.lang.ClassCastException: clojure.lang.PersistentVector cannot be cast to clojure.lang.Sorted (NO_SOURCE_FILE:0)\n\nuser=> (subseq (sorted-set 1 2 3 4) > 2)\n(3 4)\n" ";; Example of getting a subsequence of hashmaps sorted by key :a and\n;;  secondarily :b.\n\n(defn compare-ab [x y]\n  (compare [(get x :a) (get x :b)]\n           [(get y :a) (get y :b)]))\n \n(def ss-ab (apply sorted-set-by compare-ab\n                      [{:a 42 :b 5000}\n                       {:a 1 :b 2}\n                       {:a 99 :b -1000}\n                       {:a -1 :b 7}]))\nuser=> ss-ab\n#{{:a -1, :b 7} {:a 1, :b 2} {:a 42, :b 5000} {:a 99, :b -1000}}\n\n;; Select all maps whose key :a is greater than 5. \nuser=> (subseq ss-ab > {:a 5})\n({:a 42, :b 5000} {:a 99, :b -1000})\n\n\n" ";; If you use the 6 input form of this function, start-test should be > or\n;; >= and the end-test should be < or <=.  The other forms don't give you\n;; an error, but don't give you what you expect, either.  This is all based\n;; on experimentation.  I don't see this documented.\n\n;; This suggests that there are no items in my set between 9 and 2.\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) < 9 > 2)\n;; => ()\n\n;; This correctly lists all items in my set between 2 and 9.\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) > 2 < 9)\n;; => (3 4 5 6 7 8)\n\n;; Again, this is not just the \"and\" of the two conditions.  Lots of items\n;; in my set are #(and (% > 2) (% > 6)) but this returns nothing.  \"> 2\"\n;; means skip to the first item that is #(% > 2).  So we jump directly to 3.\n;; \"> 6\" means to stop looking as soon as we find an item where #(% > 6) is\n;; false.  3 <= 6, so we get the empty sequence.\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) > 2  > 6)\n;; => ()\n\n;; This works as expected, returning everything where #(and (% >= 2) (% <= 4)).\n;; That is to say it returns everything between 2 and 4, inclusive.\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) >= 2 <= 4)\n;; => (2 3 4)\n\n;; Naïvely you might expect this to give you the same results as the previous\n;; statement.  Clearly the result is not the same.  I'm not sure what's going\n;; on under the hood here.  It's jumping directly to 4 as if I'd said \">= 4\"\n;; rather than \"<= 4\".  (Looks like a bug in Clojure to me!)  Then it\n;; continued to the end because all of the remaining items were #(% >= 2).\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) <= 4 >= 2)\n;; => (4 5 6 7 8 9)\nuser=> *clojure-version*\n;; => {:major 1, :minor 8, :incremental 0, :qualifier nil}\n\n;; This one at least makes sense.  It jumps directly to the first item that\n;; satisfies the first test and continues until the second item is false.\nuser=> (subseq (sorted-set 1 2 3 4 5 6 7 8 9 0) >= 4 >= 2)\n;; => (4 5 6 7 8 9)\n" ";; Autocomplete using local Unix dictionary.\n(require '[clojure.string :refer [split]])\n\n(def dict\n  (into (sorted-set)\n    (split (slurp \"/usr/share/dict/words\") #\"\\s+\")))\n\n;; The vector contains a few simulated keystrokes.\n(map #(take 4 (subseq dict >= %)) [\"c\" \"cl\" \"clo\" \"clos\" \"closu\"])\n;; ((\"c\" \"ca\" \"caam\" \"caama\")\n;;  (\"clabber\" \"clabbery\" \"clachan\" \"clack\")\n;;  (\"cloaca\" \"cloacal\" \"cloacaline\" \"cloacean\")\n;;  (\"closable\" \"close\" \"closecross\" \"closed\")\n;;  (\"closure\" \"clot\" \"clotbur\" \"clote\"))"], :notes nil, :arglists ["sc test key" "sc start-test start-key end-test end-key"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/subseq"}, :clojure.core/rand-nth {:added "1.2", :ns "clojure.core", :name "rand-nth", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rand :clojure.core/shuffle], :line 7151, :examples ["user=> (def food [:ice-cream :steak :apple])\n#'user/food\n\nuser=> (rand-nth food)\n:apple\nuser=> (rand-nth food)\n:ice-cream\n" "user=> (def food [:ice-cream :steak :apple])\n#'user/food\n\nuser=> (rand-nth food)\n:ice-cream\nuser=> (rand-nth food)\n:ice-cream" "user=> (rand-nth [])\nIndexOutOfBoundsException   clojure.lang.PersistentVector.arrayFor (PersistentVector.java:158)\n\nuser=>\n(let [xs []]\n  (when (not (empty? xs))\n    (rand-nth xs)))\nnil\n"], :notes nil, :arglists ["coll"], :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rand-nth"}, :clojure.test/are {:added "1.1", :ns "clojure.test", :name "are", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/is :clojure.test/deftest :clojure.template/do-template], :line 571, :examples [";; An alternate to the example in the documentation is \n\nuser=> (are [result arg-map] (= result (+ (:x arg-map) (:y arg-map)))\n             5      {:x 2 :y 3},\n             10     {:x 6 :y 4})\n\n\n"], :macro true, :notes nil, :arglists ["argv expr & args"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/are"}, :clojure.test/*testing-contexts* {:ns "clojure.test", :name "*testing-contexts*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 269, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*testing-contexts*"}, :clojure.core/send-via {:added "1.5", :ns "clojure.core", :name "send-via", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 2093, :examples nil, :notes nil, :arglists ["executor a f & args"], :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/send-via"}, :clojure.core/reader-conditional? {:added "1.7", :ns "clojure.core", :name "reader-conditional?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reader-conditional :clojure.core/read :clojure.core/read-string], :line 7652, :examples ["(reader-conditional? (read-string {:read-cond :preserve} \"#?(:clj (Math/exp 1))\"))\n;;=> true\n(reader-conditional? (reader-conditional '(:clj (Math/exp 1)) false))\n;;=> true\n\n(reader-conditional? \"#?(:clj (Math/exp 1))\")\n;;=> false\n(reader-conditional? '#?(:clj (Math/exp 1)))\n;;=> false" ";;;; Let's say we have the source code for a Clojure program:\n\n(def source-code\n  \"(defn str-to [type s]\n     (case type\n       :int #?(:clj (Integer/parseInt s) :cljs (js/parseInt s))\n       #?@(:clj [:long (Long/parseLong s)])\n       :float #?(:clj (Float/parseFloat s) :cljs (js/parseFloat s))\n       #?@(:clj [:double (Double/parseDouble s)])))\")\n\n;;;; Here's a function that finds all the reader conditionals\n;;;; in a given source code which contain a specific platform tag:\n\n(defn find-reader-conditionals [code tag]\n  (->> code\n    (read-string {:read-cond :preserve}) ;; read into Clojure data structures\n    (tree-seq seqable? identity)         ;; lazy seq of all forms\n    (filter reader-conditional?)         ;; keep only reader conditionals\n    (filter #(some #{tag} (:form %)))))  ;; keep only reader conds with tag\n\n(pprint (find-reader-conditionals source-code :clj))\n;;=> (#?(:clj (Integer/parseInt s) :cljs (js/parseInt s))\n;;    #?@(:clj [:long (Long/parseLong s)])\n;;    #?(:clj (Float/parseFloat s) :cljs (js/parseFloat s))\n;;    #?@(:clj [:double (Double/parseDouble s)]))\n\n(pprint (find-reader-conditionals source-code :cljs))\n;;=> (#?(:clj (Integer/parseInt s) :cljs (js/parseInt s))\n;;    #?(:clj (Float/parseFloat s) :cljs (js/parseFloat s)))"], :notes nil, :arglists ["value"], :doc "Return true if the value is the data representation of a reader conditional", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reader-conditional_q"}, :clojure.core.logic/waiting-stream-check {:ns "clojure.core.logic", :name "waiting-stream-check", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1863, :examples nil, :notes nil, :arglists ["w success-cont failure-cont"], :doc "Take a waiting stream, a success continuation, and a failure continuation.\n   If we don't find any ready suspended streams, invoke the failure continuation.\n   If we find a ready suspended stream calculate the remainder of the waiting\n   stream. If we've reached the fixpoint just call the thunk of the suspended\n   stream, otherwise call mplus on the result of the thunk and the remainder\n   of the waiting stream. Pass this result to the success contination.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/waiting-stream-check"}, :clojure.core/struct {:added "1.0", :ns "clojure.core", :name "struct", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/defstruct], :line 4028, :examples ["user> (defstruct mystruct :foo :bar)\n#'user/mystruct\n\nuser> (struct mystruct \"eggplant\" \"pizza\")\n{:foo \"eggplant\", :bar \"pizza\"}"], :notes ["Structs are becoming obsolete. Use records instead. See `defrecord`."], :arglists ["s & vals"], :doc "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/struct"}, :clojure.core.logic/ientailed? {:ns "clojure.core.logic", :name "ientailed?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2061, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ientailed_q"}, :clojure.reflect/->JavaReflector {:ns "clojure.reflect", :name "->JavaReflector", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 166, :examples ["(require '[clojure.reflect :as cr])\n(import  '(clojure.reflect.JavaReflector))\n\n;; Let us see what is available in the JavaReflector\n(->> clojure.reflect.JavaReflector \n     cr/reflect\n     :members\n     (sort-by :name)\n     (pp/print-table [:name :flags :parameter-types]))\n; |                         :name |                    :flags |   :parameter-types |\n; |-------------------------------+---------------------------+--------------------|\n; |             __cached_class__0 |       #{:private :static} |                    |\n; |                   classloader |         #{:public :final} |                    |\n; | clojure.reflect.JavaReflector |                #{:public} | [java.lang.Object] |\n; |                      const__0 | #{:public :static :final} |                    |\n; |                      const__1 | #{:public :static :final} |                    |\n; |                     const__10 | #{:public :static :final} |                    |\n; |                      const__5 | #{:public :static :final} |                    |\n; |                      const__7 | #{:public :static :final} |                    |\n; |                      const__9 | #{:public :static :final} |                    |\n; |                    do_reflect |                #{:public} | [java.lang.Object] |\n; |                      getBasis |        #{:public :static} |                 [] |\n;;=> nil\n"], :notes nil, :arglists ["classloader"], :doc "Positional factory function for class clojure.reflect.JavaReflector.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/->JavaReflector"}, :clojure.core/flatten {:added "1.2", :ns "clojure.core", :name "flatten", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core.reducers/flatten :clojure.core/tree-seq], :line 7056, :examples ["user=> (flatten [1 [2 3]])\n(1 2 3)\n\nuser=> (flatten '(1 2 3))\n(1 2 3)\n\nuser=> (flatten '(1 2 [3 (4 5)])) \n(1 2 3 4 5)\n\nuser=> (flatten nil)\n()\n\n; Attention with stuff which is not a sequence\n\nuser=> (flatten 5)\n()\n\nuser=> (flatten {:name \"Hubert\" :age 23})\n()\n\n; Workaround for maps\n\nuser=> (flatten (seq {:name \"Hubert\" :age 23}))\n(:name \"Hubert\" :age 23)" ";; Useful snippet: \"merge\" two or more vectors with `(comp vec flatten vector)`\n(let [a [{:a \"hi\"} {:b \"hey\"}]\n      b [{:c \"yo\"} {:d \"hiya\"}]\n      c {:e [\"hola\" \"bonjour\"]}]\n  ((comp vec flatten vector) a b c))\n;;=> [{:a \"hi\"} {:b \"hey\"} {:c \"yo\"} {:d \"hiya\"} {:e [\"hola\" \"bonjour\"]}]"], :notes ["(flatten nil) actually returns an empty sequence, not nil.  The doc string is fixed in 1.4." "As shown in the example, flatten will return an empty sequence when given any non-sequential thing.  That can sometimes hide a bug. \r\n\r\nHere's another version that doesn't have that problem, and is faster as well.\r\n\r\n\r\n    (defn flatten2\r\n      \"Like `clojure.core/flatten` but better, stronger, faster.\r\n      Takes any nested combination of sequential things (lists, vectors,\r\n      etc.) and returns their contents as a single, flat, lazy sequence.\r\n      If the argument is non-sequential (numbers, maps, strings, nil, \r\n      etc.), returns the original argument.\"\r\n      {:static true}\r\n      [x]\r\n      (letfn [(flat [coll] \r\n                      (lazy-seq \r\n                       (when-let [c (seq coll)] \r\n                         (let [x (first c)] \r\n                           (if (sequential? x) \r\n                             (concat (flat x) (flat (rest c))) \r\n                             (cons x (flat (rest c))))))))]\r\n        (if (sequential? x) (flat x) x)))\r\n" "Actually, flatten on a vector returns list, not a collection:\r\n\r\n    user=> (flatten [1 [2 3]])\r\n    (1 2 3)\r\n" "lazy version is much slower than this one:\r\n\r\n<pre>(defn my-flatten [l] \r\n  \"free of StackOverflow problem, not lazy and much faster version of flatten.\"\r\n(loop [l1 l, l2 `()]\r\n  (cond\r\n    (sequential? (first l1)) (recur (concat (first l1) (rest l1)) l2)\r\n    (empty? l1) (reverse l2)\r\n    :else (recur (rest l1) (cons (first l1) l2)))))\r\n</pre>\r\n\r\nfor complicated construction genereted by:\r\n<pre>(defn gen-list-wird [c] (reduce (fn [a b] (list a b)) (map vector (range c) (map str (range c (* 2 c))))))</pre>\r\ntimes are:\r\ncore/flatten (260 msec)\r\nsteveminer/flatten (135 msec)\r\nmy-flatten (2 msec). This version is slower than steveminder`s version for flat and very nested structures with small number of items." "For a much faster implementation, use `clojure.core.reducers/flatten` (introduced in Clojure 1.5)." "To only flatten one level, you can use (mapcat identity coll)\n\nWith flatten:\n<pre>\nuser=> (flatten [[[1]] [[2 3]]])\n(1 2 3)\n</pre>\n\nWith mapcat identity:\n<pre>\nuser=> (mapcat identity [[[1]] [[2 3]]])\n([1] [2 3])\n</pre>\n" "afhammad, i think to flatten one level it may be useful <pre>(apply concat coll)</pre>"], :arglists ["x"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/flatten"}, :clojure.core/namespace {:added "1.0", :ns "clojure.core", :name "namespace", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns :clojure.core/name :clojure.core/def], :line 1589, :examples ["user=> (def x \"Foobar\")\n#'user/x\n\nuser=> (namespace 'user/x)\n\"user\"\n"], :notes ["Note this does not try to be \"smart\"\n\n```\nuser=>(namespace 'no-such-name/no-such-var)\n\"no-such-name\"\n\nuser=>(def a-var)\n#'user-a-var\n\nuser=>(namespace 'a-var)\nnil\n```"], :tag "java.lang.String", :arglists ["x"], :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/namespace"}, :clojure.core.logic.fd/-drop-one {:ns "clojure.core.logic.fd", :name "-drop-one", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-drop-one"}, :clojure.core/print-simple {:ns "clojure.core", :name "print-simple", :file "clojure/core_print.clj", :type "function", :column 1, :see-alsos nil, :line 83, :examples nil, :notes nil, :arglists ["o w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print-simple"}, :clojure.core.logic.fd/<= {:ns "clojure.core.logic.fd", :name "<=", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 819, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u must be less than or equal to v.\n   u and v must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/<="}, :clojure.stacktrace/e {:added "1.1", :ns "clojure.stacktrace", :name "e", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos nil, :line 76, :examples ["(/ 1 0)\n\n;;ArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:156)\n\n(clojure.stacktrace/e)\n\n;;java.lang.ArithmeticException: Divide by zero\n;; at clojure.lang.Numbers.divide (Numbers.java:156)\n;;    clojure.lang.Numbers.divide (Numbers.java:3731)\n;;    user$eval11696.invoke (form-init813878306514169279.clj:1)\n;;    clojure.lang.Compiler.eval (Compiler.java:6703)\n;;    clojure.lang.Compiler.eval (Compiler.java:6666)\n;;    clojure.core$eval.invoke (core.clj:2927)\n;;    clojure.main$repl$read_eval_print__6625$fn__6628.invoke (main.clj:239)\n;;    clojure.main$repl$read_eval_print__6625.invoke (main.clj:239)\n\n;; => nil"], :notes nil, :arglists [""], :doc "REPL utility.  Prints a brief stack trace for the root cause of the\n  most recent exception.", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/e"}, :clojure.set/rename {:added "1.0", :ns "clojure.set", :name "rename", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/rename-keys], :line 89, :examples [";; Here's a relation with two keys (think \"column names\" in SQL), :a and :b\n\nuser=> (def relation #{  {:a 1, :b 1}  {:a 2, :b 2} })\n\n\n;; I decide that :a is a stupid name and that :new-a would be better. \n;; Here's how I make a new relation with the renamed key:\n\nuser=> (rename relation {:a :new-a})\n#{{:new-a 1, :b 1} {:new-a 2, :b 2}}\n\n"], :notes nil, :arglists ["xrel kmap"], :doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/rename"}, :clojure.core.logic.fd/interval-< {:ns "clojure.core.logic.fd", :name "interval-<", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 42, :examples nil, :notes nil, :arglists ["i j"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval-<"}, :clojure.core/qualified-ident? {:added "1.9", :ns "clojure.core", :name "qualified-ident?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ident? :clojure.core/simple-ident?], :line 1614, :examples nil, :notes nil, :arglists ["x"], :doc "Return true if x is a symbol or keyword with a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/qualified-ident_q"}, :clojure.core/aset-long {:added "1.0", :ns "clojure.core", :name "aset-long", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3917, :examples [";; create an array of 10 longs and set one of the values to 31415\n\nuser=> (def ls (long-array 10))\n#'user/ls\nuser=> (vec ls)\n[0 0 0 0 0 0 0 0 0 0]\nuser=> (aset-long ls 3 31415)\n31415\nuser=> (vec ls)\n[0 0 0 31415 0 0 0 0 0 0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of long. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-long"}, :clojure.walk/keywordize-keys {:added "1.1", :ns "clojure.walk", :name "keywordize-keys", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.core/keyword :clojure.walk/stringify-keys], :line 93, :examples ["(require 'clojure.walk)\n(clojure.walk/keywordize-keys {\"a\" 1 \"b\" 2})\n;;=> {:a 1 :b 2}" "(use 'clojure.walk)\n\n(keywordize-keys {\"a\" 1, \"b\" {\"c\" {\"d\" 2}}})\n;;=> {:a 1, :b {:c {:d 2}}}"], :notes nil, :arglists ["m"], :doc "Recursively transforms all map keys from strings to keywords.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/keywordize-keys"}, :clojure.xml/content {:ns "clojure.xml", :name "content", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :line 24, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/content"}, :clojure.core/partition-by {:added "1.2", :ns "clojure.core", :name "partition-by", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partition :clojure.core/partition-all :clojure.core/group-by :clojure.core/dedupe], :line 7080, :examples ["user=> (partition-by #(= 3 %) [1 2 3 4 5])\n((1 2) (3) (4 5))" "user=> (partition-by odd? [1 1 1 2 2 3 3])\n((1 1 1) (2 2) (3 3))\n\nuser=> (partition-by even? [1 1 1 2 2 3 3])\n((1 1 1) (2 2) (3 3))\n" ";; (this is part of a solution from 4clojure.com/problem 30)\nuser=> (partition-by identity \"Leeeeeerrroyyy\")\n((\\L) (\\e \\e \\e \\e \\e \\e) (\\r \\r \\r) (\\o) (\\y \\y \\y))" ";; Note that previously created 'bins' are not used when same value is seen again\nuser=> (partition-by identity \"ABBA\")\n((\\A) (\\B \\B) (\\A))\n\n;; That is why you use group-by function if you want all the the same values in the same 'bins' :) \n;; Which gives you a hash, but you can extract values from that if you need.\n\n(group-by identity \"ABBA\")\n=> {\\A [\\A \\A], \\B [\\B \\B]}" ";; Arbitrary partitioning\n(let [seen (atom true)]\n  (partition-by #(cond\n                  (#{1} %) (reset! seen (not @seen))\n                  (or (and (string? %)\n                           (< (count %) 2))\n                      (char? %)) \"letter\"\n                  (string? %) \"string\"\n                  (#{0} %) 0\n                  (vector? %) (count %)\n                  :else \"rest\")\n                [1 1 1 2 3 nil \"a\" \\l 0 4 5 {:a 1} \"bc\" \"aa\" \"k\" [0] [1 1] [2 2]]))\n;;=> ((1) (1) (1) (2 3 nil) (\"a\" \\l) (0) (4 5 {:a 1}) (\"bc\" \"aa\") (\"k\") ([0]) ([1 1] [2 2]))" "user=> (partition-by count [\"a\" \"b\" \"ab\" \"ac\" \"c\"])\n\n;;=> ((\"a\" \"b\") (\"ab\" \"ac\") (\"c\"))"], :notes ["It's worth mentioning that `(partition-by identity â€¦)` is equivalent to the `Data.List.group` function in Haskell:\r\n\r\n<pre> \r\n(defn group [coll]\r\n  (partition-by identity coll))\r\n</pre>\r\n\r\nWhich proves to be an interesting idiom:\r\n\r\n<pre>user=&gt; (apply str \r\n         (for [ch (group \"fffffffuuuuuuuuuuuu\")] \r\n           (str (first ch) (count ch))))\r\nâ‡’ \"f7u12\"\r\n</pre>" "Many other programming languages like Kotlin or Haskell define `partition` slightly different. They partition the given collection into two collections, the first containing all truthy values and the second elements all falsy elements. This function does it:\n\n```\n(defn partition-2\n  \"Partitions the collection into exactly two [[all-truthy] [all-falsy]]\n   collection.\"\n  [pred coll]\n  (mapv persistent!\n    (reduce\n      (fn [[t f] x]\n        (if (pred x)\n          [(conj! t x) f]\n          [t (conj! f x)]))\n      [(transient []) (transient [])]\n      coll)))\n(partition-2 odd? (range 5))\n\n```" "I tried this implementation of your Kotlin/Haskell `partition`, which is simpler but somewhat slower (less than 2x):\n\n```\n(defn partition-3\n  \"Partitions the collection into exactly two [[all-truthy] [all-falsy]]\n   collection.\"\n  [pred coll]\n  (let [m (group-by pred coll)]\n    [(m true) (m false)]))\n```"], :arglists ["f" "f coll"], :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/partition-by"}, :clojure.core.async/buffer {:ns "clojure.core.async", :name "buffer", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/dropping-buffer :clojure.core.async/sliding-buffer :clojure.core.async/chan], :line 49, :examples ["user=> (def c (chan (buffer 3)))\n#'user/c\n\nuser=> (go (<! (timeout 20000))\n           (println \"Unblocking buffer\")\n           (doseq [_ (range 2)]\n             (<! c)))\n\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@5c350b54>\n\nuser=> (doseq [_ (range 5)] (println (>!! c true)))\ntrue\ntrue\ntrue\nUnblocking buffer\ntrue\ntrue\nnil"], :notes nil, :arglists ["n"], :doc "Returns a fixed buffer of size n. When full, puts will block/park.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/buffer"}, :clojure.core/cond {:added "1.0", :ns "clojure.core", :name "cond", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/condp :clojure.core/case :clojure.core/if :clojure.core/cond->], :line 591, :examples ["(defn pos-neg-or-zero\n  \"Determines whether or not n is positive, negative, or zero\"\n  [n]\n  (cond\n    (< n 0) \"negative\"\n    (> n 0) \"positive\"\n    :else \"zero\"))\n\nuser=> (pos-neg-or-zero 5)\n\"positive\"\nuser=> (pos-neg-or-zero -1)\n\"negative\"\nuser=> (pos-neg-or-zero 0)\n\"zero\"\n" "user=> (let [grade 85]\n         (cond\n           (>= grade 90) \"A\"\n           (>= grade 80) \"B\"\n           (>= grade 70) \"C\"\n           (>= grade 60) \"D\"\n           :else \"F\"))\n\"B\"" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";; Generates a random number compares it to user input\n(let [rnd (rand-int 10)\n      guess (Integer/parseInt (read-line))]\n  (cond\n    (= rnd guess) (println \"You got my guess right!\")\n    :else (println \"Sorry... guess again!\")))" ";; Simple Condition Example \n\n(defn test-x [x]\n\t(cond\n\t\t(< x 10) \"less than\"\n\t\t(> x 20) \"greater than\"\n\t)\n)\n\n============test============\n(test-x 9)\n\n=> \"less than\"" "(defn print-cond [xx] \n  (cond \n    (< xx 6) \"less than 6\"\n    (< xx 8) \"less than 8\"\n    :else \"Greater than 8\"))\n=> #'aurora.system/print-cond\n(print-cond 5)\n=> \"less than 6\"\n(print-cond 7)\n=> \"less than 8\"\n(print-cond 8)\n=> \"Greater than 8\"\n(print-cond 10)\n=> \"Greater than 8\"\n" ";; If a condition is not matched `nil` will be returned\n(cond\n  false \"sumfin\")\n;;=> nil"], :macro true, :notes ["We should add a comment in the docstring for the final usage of :else." "`:else` is not special. Any keyword will do." "Actually any non-nil or true will work.  I prefer to use :default.  :else implies truthiness in evaluation rather what it really is which is a 'default' value." "It seems the documentation is not accurate. From my experiment, it seems the function decscription should be like the following:\n\nTakes a set of test/expr pairs. It evaluates each test one at a time.  \nIf a test returns logical true, cond evaluates the corresponding expr and\ncontinue to evaluate the next test/expr, until a test fails or \nno more pair of test(:else)/expr to evaluate,\nand returns the last evaluation value of the expr \nthat its corresponding test evaluated to truthy.\nIf there is no test evaluated to truthy, \nreturn the evaluation of :else clause.\nIf there is no :else clause return nil.\n\nThe above description can be supported by the following example:\n\n<pre>\n(defn pos-neg-or-zero\n  \"Determines whether or not n is positive, negative, or zero\"\n  [n]\n  (cond\n    (odd? n) \"odd\"\n    (even? n) \"even\"\n    (< n 0) \"negitive\"\n    (< 0 n) \"positive\"\n    :else \"zero\"))\n\n(odd? 3)                                ; => true\n(pos-neg-or-zero 3)                     ;=> \"positive\"\n(even? 0)                               ; => true\n(pos-neg-or-zero 0)                     ;=> \"zero\"\n(even? 4)                               ; => true\n(pos-neg-or-zero 4)                     ;=> \"positive\"\n</>\n" "yubrshen,   \n\n(pos-neg-or-zero 3) => \"odd\""], :arglists ["& clauses"], :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cond"}, :clojure.core.logic.fd/* {:ns "clojure.core.logic.fd", :name "*", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 976, :examples nil, :notes nil, :arglists ["x y product"], :doc "A finite domain constraint for multiplication and\n   thus division. x, y & product must be eventually be given \n   domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/*"}, :clojure.core.reducers/cat {:added "1.5", :ns "clojure.core.reducers", :name "cat", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos [:clojure.core/cat :clojure.core.reducers/foldcat], :line 288, :examples [";; The example showcase use of r/cat to build HashSets (instead \n;; of the default ArrayList) of distinct words in parallel \n;; and then merge all together walking the binary tree produced by r/fold.\n(require '[clojure.core.reducers :as r])\n(require '[clojure.string :refer [lower-case blank? split split-lines]])\n(import  'java.util.HashSet)\n\n(def book\n  (-> \"http://www.gutenberg.org/files/2600/2600-0.txt\"\n      slurp\n      split-lines))\n\n(def r-word (comp\n  (r/map lower-case)\n  (r/remove blank?)\n  (r/map #(re-find #\"\\w+\" %))\n  (r/mapcat #(split % #\"\\s+\"))))\n\n(def btree\n  (r/fold\n    (r/cat #(HashSet.))\n    r/append!\n    (r-word book)))\n\n(defn merge-tree [root res]\n  (cond\n    (instance? clojure.core.reducers.Cat root)\n    (do (merge-tree (.left root) res) (merge-tree (.right root) res))\n    (instance? HashSet root)\n    (doto res (.addAll root))\n    :else res))\n\n(def distinct-words (merge-tree btree (HashSet.)))\n(count distinct-words)\n;; 17200"], :notes nil, :arglists ["" "ctor" "left right"], :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/cat"}, :clojure.spec.alpha/rep+impl {:ns "clojure.spec.alpha", :name "rep+impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1360, :examples nil, :notes nil, :arglists ["form p"], :doc "Do not call this directly, use '+'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/rep+impl"}, :clojure.core/with-out-str {:added "1.0", :ns "clojure.core", :name "with-out-str", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-in-str], :line 4682, :examples [";; Instead of printing, the following will place the output normally\n;; sent to stdout into a string.\n\nuser=> (with-out-str (println \"this should return as a string\"))\n\"this should return as a string\\n\"\n" ";; `time` prints the elapsed time. `with-out-str` can put it into a variable.\n\n(def elapsed\n  (with-out-str\n    (time (last (range 10000)))))\n\nelapsed\n;=> \"\\\"Elapsed time: 49.363055 msecs\\\"\\n\"\n" "(defmacro with-out-str-data-map\n  [& body]\n  `(let [s# (new java.io.StringWriter)]\n     (binding [*out* s#]\n       (let [r# ~@body]\n         {:result r#\n          :str    (str s#)}))))\n\n(with-out-str-data-map (do\n                         (println \"Clojure is the best!\")\n                         2))\n\n;;=> {:str \"Clojure is the best!\\n\", :result 2}" "(defn pp-str [x]\n  (with-out-str (clojure.pprint/pprint x))\n\n\n(pp-str {:foo \"foo\" :bar \"bar\"})\n;;=> \"{:foo \\\"foo\\\", :bar \\\"bar\\\"}\\n\"\n"], :macro true, :notes nil, :arglists ["& body"], :doc "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-out-str"}, :clojure.core/bases {:added "1.0", :ns "clojure.core", :name "bases", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/supers :clojure.core/type], :line 5483, :examples ["<pre>user=> (import 'java.io.File)\r\n\r\nuser=> (bases java.io.File)\r\n(java.lang.Object java.io.Serializable java.lang.Comparable)</pre>" ";; what is a hash-map?\n(bases (class {}))\n;;=> (clojure.lang.APersistentMap \n;;+>  clojure.lang.IObj \n;;+>  clojure.lang.IEditableCollection)\n\n;; what is a set?\n(bases (class #{}))\n;;=> (clojure.lang.APersistentSet \n;;+>  clojure.lang.IObj \n;;+>  clojure.lang.IEditableCollection)\n\n;; what is a vector?\n(bases (class []))\n;;=> (clojure.lang.APersistentVector \n;;+>  clojure.lang.IObj \n;;+>  clojure.lang.IEditableCollection)\n\n;; what is a list? \n(bases (class ()))\n;;=> (clojure.lang.Obj \n;;+>  clojure.lang.IPersistentList \n;;+>  java.util.List \n;;+>  clojure.lang.ISeq \n;;+>  clojure.lang.Counted \n;;+>  clojure.lang.IHashEq)"], :notes nil, :arglists ["c"], :doc "Returns the immediate superclass and direct interfaces of c, if any", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bases"}, :clojure.inspector/is-leaf {:ns "clojure.inspector", :name "is-leaf", :file "clojure/inspector.clj", :type "var", :column 1, :see-alsos nil, :line 31, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/is-leaf"}, :clojure.core/gen-interface {:added "1.0", :ns "clojure.core", :name "gen-interface", :file "clojure/genclass.clj", :type "macro", :column 1, :see-alsos [:clojure.core/proxy :clojure.core/gen-class], :line 688, :examples [";; gen-interface defines the class in memory, but does not spit it to disk\n;; (unless AOT-ing). Note: this is different from gen-class (that actually does\n;; nothing unless it's AOT compiling).\n\n(gen-interface :name \"user.IFoo\" :extends [clojure.lang.IPersistentMap])\n;; user.IFoo\n\n(reify user.IFoo (seq [_]) (empty [_]))\n;; {}"], :macro true, :notes nil, :arglists ["& options"], :doc "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/gen-interface"}, :clojure.core/thread-bound? {:added "1.2", :ns "clojure.core", :name "thread-bound?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bound-fn :clojure.core/bound-fn*], :line 5460, :examples ["user=> (thread-bound? #'map)\nfalse\n\nuser=> (thread-bound? #'*warn-on-reflection*)\ntrue"], :notes nil, :arglists ["& vars"], :doc "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/thread-bound_q"}, :clojure.core/print {:added "1.0", :ns "clojure.core", :name "print", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pr :clojure.core/println :clojure.core/print-str :clojure.pprint/pprint], :line 3716, :examples [";; same as println, but without a newline\nuser> (print \"foo\") (print \"foo\")\nfoofoo"], :notes ["\"Human consumption\" means, for example, that a string is printed as-is -- without surrounding double quotes and without nonprinting characters being escaped."], :arglists ["& more"], :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print"}, :clojure.core/condp {:added "1.0", :ns "clojure.core", :name "condp", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/cond :clojure.core/if :clojure.core/case], :line 6279, :examples [";; Taken from the excellent clojure tutorial:\n;; http://java.ociweb.com/mark/clojure/article.html\n\n(print \"Enter a number: \")\n(flush) ; stays in a buffer otherwise\n(let [line (read-line)\n      value (try\n              (Integer/parseInt line)\n              (catch NumberFormatException e line))] ; use string val if not int\n  (println\n    (condp = value\n      1 \"one\"\n      2 \"two\"\n      3 \"three\"\n      (str \"unexpected value, \\\"\" value \\\")))\n  (println\n    (condp instance? value\n       Number (* value 2)\n       String (* (count value) 2))))\n" ";; (some #{4 5 9} [1 2 3 4]) \n;;  is the first matching clause, \n;;  the match value is 4 which is decremented\n(condp some [1 2 3 4]\n  #{0 6 7} :>> inc\n  #{4 5 9} :>> dec\n  #{1 2 3} :>> #(+ % 3))\n;;=> 3" ";; in this case there is no matching clause\n;; so an exception is raised.\n(condp some [1 2 3 4]\n   #{0 6 7} :>> inc\n   #{5 9}   :>> dec)\n\n;; java.lang.IllegalArgumentException: No matching clause: [1 2 3 4]" ";; a composite predicate which parses a string with \"re-seq\" \n;; producing a list which is made into a \"seq\".\n(condp (comp seq re-seq) \"foo=bar\"\n  #\"[+](\\w+)\"    :>> #(vector (-> % first (nth 1) keyword) true)\n  #\"[-](\\w+)\"    :>> #(vector (-> % first (nth 1) keyword) false)\n  #\"(\\w+)=(\\S+)\" :>> #(let [x (first %)]\n                        [(keyword (nth x 1)) (nth x 2)]))\n;;=> [:foo \"bar\"]" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";;this is with liberator\n;;branching on request method\n(defresource my-resource\n  :exists? (fn [{:keys [db] {query-params :query-params \n                             body :body \n                             method :request-method} \n                 :request}]\n             \n             (condp = method\n               :get (my-get-exists-fn)\n               :post (my-post-exists-fn))))" ";; a recursive function to calculate length\n;; same as 'count'\n(defn length [lst]\n    (condp = lst\n        (list) 0 ; if empty list result 0\n        (+ 1 (length (rest lst))))) ; default expression\n\n(length '(1 2 3))\n;;=> 3" ";; pass in the function\n;; #(%1 2 %2) < 3 \n;; is the passing condition.\n(condp #(%1 2 %2) 3\n  = \"eq\"\n  < \"lt\"\n  > \"gt\")\n;;=> \"lt\"\n\n;; test argument against various predicates\n(condp #(%1 %2) :foo\n  string? \"it's a string\"\n  keyword? \"it's a keyword\"\n  symbol? \"it's a symbol\"\n  fn? \"it's a function\"\n  \"something else!\")\n;;=> \"it's a keyword\"" "; This function is part of a great solution to the \"fizzbuzz\" interview question.\n; Let's review \n; Players take turns to count incrementally, \n; replacing any number divisible by three with the word \"fizz\",  \n; any number divisible by five with the word \"buzz\", and \n; any number divisible by both three and five with the word \"fizzbuzz\".\n(defn fizz-buzz [n]\n  (condp #(zero? (mod %2 %1)) n\n    15 \"fizzbuzz\"\n    3  \"fizz\"\n    5  \"buzz\"\n    n))\n\n(into [] (map fizz-buzz) (range 1 20))\n;;=> [1 2 \"fizz\" 4 \"buzz\" \"fizz\" 7 8 \"fizz\" \"buzz\" \n;;    11 \"fizz\" 13 14 \"fizzbuzz\" 16 17 \"fizz\" 19]" ";; Test a string against multiple regexps, and do something different\n;; with the match each time. \n(condp re-matches \"17->42\"\n  #\"(\\w+)->(\\w+)\" :>> (fn [[_ p1 p2]]\n                        {:start p1 :end p2})\n\n  #\"(\\w+)->$\" :>> (fn [[_ p1]]\n                    {:start p1})\n\n  #\"\\w+\" :>> (fn [[p]]\n               {:fixed p})\n\n  nil)\n; => {:start \"17\" :end \"42\"}" ";if you are using the function literal already and can't nest\n\n(#(condp (fn [clause expr] (clojure.string/includes? expr clause)) \"transaction-result-kafka\"\n  \"transaction-result\" 1\n  \"transaction-failure\" 4\n  (do\n    (str \"got message with nil topic\")\n    nil)))\n;=> 1"], :macro true, :notes ["A lot of these examples show the pattern:\n\n```\n(condp = value\n  :a \"a\"\n  :b \"b\"\n  ...)\n```\n\nWhich is the same as:\n\n```\n(case value\n  :a \"a\"\n  :b \"b\"\n  ...)\n```"], :arglists ["pred expr & clauses"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/condp"}, :clojure.core/derive {:added "1.0", :ns "clojure.core", :name "derive", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/parents :clojure.core/ancestors :clojure.core/descendants :clojure.core/isa? :clojure.core/make-hierarchy :clojure.core/underive], :line 5566, :examples [";; derive let you build a hierarchy but parents/ancestors/descendants and isa? let you query the hierarchy\n(derive ::rect ::shape)\n(derive ::square ::rect)\n" "user=> (derive ::Cat ::Feline)\nnil\n\nuser=> (derive ::Lion ::Feline)\nnil\n\nuser=> (isa? ::Lion ::Feline)\ntrue\n\nuser=> (isa? ::Tuna ::Feline)\nfalse" "(derive java.util.Map ::collection)\n(derive java.util.Collection ::collection)\n\n(isa? java.util.HashMap ::collection)\n-> true"], :notes nil, :arglists ["tag parent" "h tag parent"], :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/derive"}, :clojure.pprint/get-pretty-writer {:added "1.2", :ns "clojure.pprint", :name "get-pretty-writer", :file "clojure/pprint/cl_format.clj", :type "function", :column 1, :see-alsos nil, :line 1203, :examples nil, :notes nil, :arglists ["writer"], :doc "Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's \nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be \npreserved across calls, you will want to wrap them with this. \n\nFor example, when you want to generate column-aware output with multiple calls to cl-format, \ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1    \n       2      4       8    \n       3      9      27    \n       4     16      64    \n       5     25     125    \n       6     36     216    \n       7     49     343    \n       8     64     512    \n       9     81     729    \n      10    100    1000", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/get-pretty-writer"}, :clojure.core/push-thread-bindings {:added "1.1", :ns "clojure.core", :name "push-thread-bindings", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pop-thread-bindings :clojure.core/binding :clojure.core/with-bindings], :line 1905, :examples nil, :notes nil, :arglists ["bindings"], :doc "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/push-thread-bindings"}, :clojure.set/map-invert {:added "1.0", :ns "clojure.set", :name "map-invert", :file "clojure/set.clj", :type "function", :column 1, :see-alsos nil, :line 106, :examples [";; Despite being in clojure.set, this has nothing to do with sets. \n\nuser=> (map-invert {:a 1, :b 2})\n{2 :b, 1 :a}\n\n;; If there are duplicate keys, one is chosen:\n\nuser=> (map-invert {:a 1, :b 1})\n{1 :b}\n\n;; I suspect it'd be unwise to depend on which key survives the clash." ";; The inverted map of an empty map is also an empty map.\nuser=> (map-invert {})\n{}\n\n;; Using complex values (which serve as keys in the inverted map) is possible.\nuser=> ((map-invert {:a {:c 5}}) {:c 5})\n:a" ";; simple text obfuscation and back, with map-invert\n\n(def scramble-key\n  {\\a \\t \\b \\m \\c \\o \\d \\l\n   \\e \\z \\f \\i \\g \\b \\h \\u\n   \\i \\h \\j \\n \\k \\s \\l \\r\n   \\m \\a \\n \\q \\o \\d \\p \\e\n   \\q \\k \\r \\y \\s \\f \\t \\c\n   \\u \\p \\v \\w \\w \\x \\x \\j\n   \\y \\g \\z \\v \\space \\space})\n\n(defn scramble [text scramble-key]\n  (apply str (map scramble-key text)))\n\n(defn unscramble [text scramble-key]\n  (apply str (map (map-invert scramble-key) text)))\n\n(scramble \"try to read this if you can\" scramble-key)\n;; \"cyg cd yztl cuhf hi gdp otq\"\n\n(unscramble \"cyg cd yztl cuhf hi gdp otq\" scramble-key)\n;; \"try to read this if you can\""], :notes nil, :arglists ["m"], :doc "Returns the map with the vals mapped to the keys.", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/map-invert"}, :clojure.core/load-string {:added "1.0", :ns "clojure.core", :name "load-string", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/read-string :clojure.core/load-file :clojure.core/load], :line 4055, :examples ["(load-string \"(def x 1)\")\n;; => #'user/x\nx\n;; => 1" ";; Don’t use this function on untrusted input; it can have unpleasant\n;; side-effects.\n(load-string \"(clojure.java.io/delete-file \\\"my-important-file\\\")\")\n;; => true"], :notes nil, :arglists ["s"], :doc "Sequentially read and evaluate the set of forms contained in the\n  string", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/load-string"}, :clojure.core/sort {:added "1.0", :ns "clojure.core", :name "sort", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sort-by], :line 3094, :examples ["user=> (sort [3 1 2 4])\n(1 2 3 4)\n\nuser=> (sort > (vals {:foo 5, :bar 2, :baz 10}))\n(10 5 2)\n\n;; do not do this, use sort-by instead\nuser=> (sort #(compare (last %1) (last %2)) {:b 1 :c 3 :a  2})\n([:b 1] [:a 2] [:c 3])\n\n;; like this:\nuser=> (sort-by last {:b 1 :c 3 :a 2})\n([:b 1] [:a 2] [:c 3])" ";; make a struct 'goods'. it assumes that every goods has\n;; its id number and price.\n(defstruct goods :id :price)\n\n;; generate data.\n(def data (map #(struct goods %1 %2)\n\t       (shuffle (range 0 10)) (shuffle\n\t\t\t\t       (into (range 100 500 100)\n\t\t\t\t\t     (range 100 500 100)))))\n\n(defn comp-goods-price\n  \"a compare function by :price of the struct 'goods.' the sort order \n   is superior to the lower price and if the price is same, it is \n   superior to the lower id.\"\n  [el1 el2]\n  (if (or  (< (:price el1) (:price el2))\n\t  (and (= (:price el1) (:price el2))(< (:id el1) (:id el2))))\n    true\n    false))\n\nuser> data\n({:id 1, :price 300} {:id 6, :price 100} {:id 3, :price 100} {:id 4, :price 400} {:id 0, :price 300} {:id 2, :price 200} {:id 5, :price 200} {:id 8, :price 400})\nuser> (sort (comp comp-goods-price) data)\n({:id 3, :price 100} {:id 6, :price 100} {:id 2, :price 200} {:id 5, :price 200} {:id 0, :price 300} {:id 1, :price 300} {:id 4, :price 400} {:id 8, :price 400})\nuser> (sort-by :price < data) ; compare this with the above.\n({:id 6, :price 100} {:id 3, :price 100} {:id 2, :price 200} {:id 5, :price 200} {:id 1, :price 300} {:id 0, :price 300} {:id 4, :price 400} {:id 8, :price 400})\n\n\n" ";; Warning: You can sort a Java array and get back a sorted immutable Clojure\n;; data structure, but it will also change the input Java array, by sorting it.\n;; Copy the array before sorting if you want to avoid this.\n\nuser=> (def x (to-array [32 11]))\n#'user/x\n\nuser=> (seq x)\n(32 11)\n\nuser=> (def y (sort x))\n#'user/y\n\n;; Return sorted sequence\nuser=> y\n(11 32)\n\nuser=> (class y)\nclojure.lang.ArraySeq\n\n;; but also modifies x, because it used the array to do the sorting.\nuser=> (seq x)\n(11 32)\n\n;; One way to avoid this is copying the array before sorting:\nuser=> (def y (sort (aclone x)))\n#'user/y" ";; Sorting with > only works for numbers, whereas sort\n;; also works for other types such as vectors.\n;; To sort any data in reverse (descending) order,\n;; use a negated comparator:\n\nuser=> (sort (comp - compare) [[1 0] [0 0] [0 3] [2 1]])\n([2 1] [1 0] [0 3] [0 0])" ";; Reverse the collection\n\nuser=> (sort #(compare %2 %1) '(:a :b :c :d))\n(:d :c :b :a)" "(def data [{:v 12, :a 10} {:v 21, :a 113} {:v 1, :a 2} {:v 12, :a 223} {:v 100, :a 23} {:v 1, :a 113}])\n\n(defn multi-comp\n  ([fns a b]\n    (multi-comp fns < a b))\n  ([[f & others :as fns] order a b]\n    (if (seq fns)\n      (let [result (compare (f a) (f b))\n            f-result (if (= order >) (* -1 result) result)]\n        (if (= 0 f-result)\n          (recur others order a b)\n          f-result))\n      0)))\n\n(sort #(multi-comp [:a :v] > %1 %2) data)\n;;=> ({:v 12, :a 223} {:v 21, :a 113} {:v 1, :a 113} {:v 100, :a 23} {:v 12, :a 10} {:v 1, :a 2}) \n\n(sort #(multi-comp [:a :v] < %1 %2) data)\n;;=> ({:v 1, :a 2} {:v 12, :a 10} {:v 100, :a 23} {:v 1, :a 113} {:v 21, :a 113} {:v 12, :a 223})"], :notes nil, :arglists ["coll" "comp coll"], :doc "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sort"}, :clojure.spec.alpha/explain-printer {:ns "clojure.spec.alpha", :name "explain-printer", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 213, :examples nil, :notes nil, :arglists ["ed"], :doc "Default printer for explain-data. nil indicates a successful validation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain-printer"}, :clojure.core.logic/emptyo {:ns "clojure.core.logic", :name "emptyo", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1654, :examples nil, :notes nil, :arglists ["a"], :doc "A relation where a is the empty list", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/emptyo"}, :clojure.core.logic/*logic-dbs* {:ns "clojure.core.logic", :name "*logic-dbs*", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 1235, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/*logic-dbs*"}, :clojure.walk/prewalk-replace {:added "1.1", :ns "clojure.walk", :name "prewalk-replace", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/postwalk-replace :clojure.core/replace :clojure.walk/prewalk], :line 109, :examples ["user=> (clojure.walk/prewalk-replace '{a b} '(c (d a)))\n(c (d b))" "(use 'clojure.walk)\n\n(prewalk-replace {:a 1 :b 2} [:a :b])\n;=> [1 2]\n\n(prewalk-replace {:a 1 :b 2} [:a :b :c])\n;=> [1 2 :c]\n\n(prewalk-replace {:a 1 :b 2} [:a :b [:a :b] :c])\n;=> [1 2 [1 2] :c]"], :notes nil, :arglists ["smap form"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/prewalk-replace"}, :clojure.main/root-cause {:added "1.3", :ns "clojure.main", :name "root-cause", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 38, :examples nil, :notes nil, :arglists ["t"], :doc "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/root-cause"}, :clojure.core/fn? {:added "1.0", :ns "clojure.core", :name "fn?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ifn?], :line 6157, :examples ["user=> (fn? 5)\nfalse\nuser=> (fn? inc)\ntrue\nuser=> (fn? (fn []))\ntrue\nuser=> (fn? #(5))\ntrue" ";; Even though maps, sets, vectors and keywords behave as functions:\nuser=> ({:a 1} :a)\n1\n\n;; fn? still returns false for them because they are not created using fn:\nuser=> (fn? {:a 1})\nfalse\n"], :notes ["Note `fn?` only tests if something was created using `fn`, *not* if it’s a function. Use [`ifn?`](https://clojuredocs.org/clojure.core/ifn_q) for that. Some things are functions even though they weren’t created with `fn`, such as maps, vectors and keywords."], :arglists ["x"], :doc "Returns true if x implements Fn, i.e. is an object created via fn.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/fn_q"}, :clojure.core.logic.fd/!=c {:ns "clojure.core.logic.fd", :name "!=c", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 755, :examples nil, :notes nil, :arglists ["u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/!=c"}, :clojure.repl/dir-fn {:ns "clojure.repl", :name "dir-fn", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 196, :examples ["<pre>user=> (require 'clojure.repl 'clojure.string)\r\n\r\nuser=> (pprint (clojure.repl/dir-fn 'clojure.string))\r\n(blank?\r\n capitalize\r\n escape\r\n join\r\n lower-case\r\n replace\r\n replace-first\r\n reverse\r\n split\r\n split-lines\r\n trim\r\n trim-newline\r\n triml\r\n trimr\r\n upper-case)\r\nnil\r\n</pre>"], :notes nil, :arglists ["ns"], :doc "Returns a sorted seq of symbols naming public vars in\n  a namespace or namespace alias. Looks for aliases in *ns*", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/dir-fn"}, :clojure.core.logic.fd/-drop-before {:ns "clojure.core.logic.fd", :name "-drop-before", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this n"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-drop-before"}, :clojure.core/ns-map {:added "1.0", :ns "clojure.core", :name "ns-map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-interns :clojure.core/ns-publics :clojure.core/ns-refers :clojure.core/ns-imports], :line 4137, :examples ["(ns-map 'clojure.core)\n{sorted-map #'clojure.core/sorted-map, read-line #'clojure.core/read-line, re-pattern #'clojure.core/re-pattern, keyword? #'clojure.core/keyword?, ClassVisitor clojure.asm.ClassVisitor, asm-type #'clojure.core/asm-type, val #'clojure.core/val, ...chop...}" ";; See also http://clojure.org/namespaces for information on namespaces in Clojure and how to inspect and manipulate them" ";; ns-map = ns-refers + ns-interns + ns-imports\nuser=> (count (ns-imports *ns*))\n;;=> 96\n\nuser=> (count (ns-interns *ns*))\n;;=> 2\n\nuser=> (count (ns-refers *ns*))\n;;=> 590\n\nuser=> (+ *1 *2 *3)\n;;=> 688\n\nuser=> (count (ns-map *ns*))\n;;=> 688"], :notes nil, :arglists ["ns"], :doc "Returns a map of all the mappings for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-map"}, :clojure.core/bound-fn {:added "1.1", :ns "clojure.core", :name "bound-fn", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/bound-fn*], :line 1998, :examples ["(def ^:dynamic *some-var* nil)\n\n(defn f [] (println *some-var*))\n\n;; run f without a new binding\nuser=> (f)\nnil\nnil\n\n;; run f with a new binding\nuser=> (binding [*some-var* \"hello\"]\n         (f))\nhello\nnil\n\n;; run f in a thread with a new binding\nuser=> (binding [*some-var* \"goodbye\"]\n         (.start (Thread. f)))\nnil\nnil\n\n;; run a bound f in a thread with a new binding\nuser=> (binding [*some-var* \"goodbye\"]\n         (.start (Thread. (bound-fn [] (f)))))\ngoodbye\nnil\n"], :macro true, :notes nil, :arglists ["& fntail"], :doc "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bound-fn"}, :clojure.core/defprotocol {:added "1.2", :ns "clojure.core", :name "defprotocol", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/reify :clojure.core/extend-type :clojure.core/extend-protocol :clojure.core/extends? :clojure.core/satisfies? :clojure.core/definterface :clojure.core/gen-interface :clojure.core/defrecord :clojure.core/deftype], :line 692, :examples ["(defprotocol Fly\n  \"A simple protocol for flying\"\n  (fly [this] \"Method to fly\"))\n\n(defrecord Bird [name species]\n  Fly\n  (fly [this] (str (:name this) \" flies...\")))\n\n(extends? Fly Bird)\n-> true\n\n(def crow (Bird. \"Crow\" \"Corvus corax\"))\n\n(fly crow)\n-> \"Crow flies...\"" ";; from Stuart Halloway's examples:\n\n(defprotocol Player\n  (choose [p])\n  (update-strategy [p me you]))\n\n(defrecord Stubborn [choice]\n  Player\n  (choose [_] choice)\n  (update-strategy [this _ _] this))\n\n(defrecord Mean [last-winner]\n  Player\n  (choose [_]\n          (if last-winner\n            last-winner\n            (random-choice)))\n  (update-strategy [_ me you]\n                   (->Mean (when (iwon? me you) me))))\n" ";; defprotocol does NOT support interfaces with variable argument lists, \n;; like [this & args]\n;; (this is not documented anywhere... )\n\n;; The workaround is to define the interface with the variable arg list in a fn\n;; separately outside of the protocol, which then calls the protocol interface\n;; with a slightly different name and an array in place of the variable list,\n;; like:\n\n(defprotocol MyProtocol\n  (-my-fn [this args]))\n\n(defn my-fn [this & args] (-my-fn this args))" ";; Protocols allow you to add new abstractions to existing types in a clean way.\n;; Polymorphic functions are created in namespaces as opposed to\n;; having the polymorphism live on Classes as typically done in OO.\n\n;; example from: \n;; https://speakerdeck.com/bmabey/clojure-plain-and-simple?slide=230\n(ns abstraction-a)\n\n(defprotocol AbstractionA\n  (foo [obj]))\n\n(extend-protocol AbstractionA\n  nil\n  (foo [s] (str \"foo-A!\"))\n  String\n  (foo [s] (str \"foo-A-\" (.toUpperCase s))))\n\n(ns abstraction-b)\n\n(defprotocol AbstractionB\n  (foo [obj]))\n\n(extend-protocol AbstractionB\n  nil\n  (foo [s] (str \"foo-B!\"))\n  String\n  (foo [s] (str \"foo-B-\" (.toLowerCase s))))\n\n\nuser=> (require '[abstraction-a :as a])\n\nuser=> (require '[abstraction-b :as b])\n\nuser=> (a/foo \"Bar\")\n\"foo-A-BAR\"\n\nuser=> (b/foo \"Bar\")\n\"foo-B-bar\"\n\nuser=> (a/foo nil)\n\"foo-A!\"\n\nuser=> (b/foo nil)\n\"foo-B!\"\n" ";; Note these differences between defprotocol and definterface:\n\n;; defprotocol requires that methods specify a first parameter, which \n;; will be the record object, while definterface requires that this\n;; parameter be left out:\n(definterface I (fooey []))\n;=> user.I\n(defprotocol P (fooey []))\n;=> IllegalArgumentException Definition of function fooey in protocol P must take at least one arg.  clojure.core/emit-protocol/fn--5964 (core_deftype.clj:612)\n(defprotocol P (fooey [this]))\n;=> P\n\n;; However, defrecord requires that a parameter for the record object\n;; be used, even with interfaces.  (A similar point applies to deftype.)\n(defrecord Irec [stuff] I (fooey [] \"foo\"))\n;=> CompilerException java.lang.IllegalArgumentException: Must supply at least one argument for 'this' in: fooey, compiling:(NO_SOURCE_PATH:1:1) \n(defrecord Irec [stuff] I (fooey [this] \"foo\"))\n;=> user.Irec\n(defrecord Prec [stuff] P (fooey [this] \"foo\"))\n;=> user.Prec\n\n;; Using an interface, only the dot form of the method is available with \n;; defrecord, while the protocol also allows use of normal Clojure function\n;; syntax.  (Similar points apply to deftype.)\n(.fooey (Irec. 42))\n;=> \"foo\"\n(fooey (Irec. 42))\n;=> IllegalArgumentException No implementation of method: :fooey of protocol: #'user/P found for class: user.Irec  clojure.core/-cache-protocol-fn (core_deftype.clj:544)\n(.fooey (Prec. 42))\n;=> \"foo\"\n(fooey (Prec. 42))\n;=> \"foo\"\n"], :macro true, :notes nil, :arglists ["name & opts+sigs"], :doc "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defprotocol"}, :clojure.core.logic.fd/-intersection {:ns "clojure.core.logic.fd", :name "-intersection", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this that"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-intersection"}, :clojure.core/loop {:added "1.0", :ns "clojure.core", :name "loop", :special-form true, :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/recur :clojure.core/trampoline :clojure.core/when :clojure.core/while], :line 4541, :examples [";; looping is recursive in Clojure, the loop construct is a hack so that\n;; something like tail-recursive-optimization works in clojure.\n\nuser=> (defn my-re-seq [re string]\n         \"Something like re-seq\"\n         (let [matcher (re-matcher re string)]\n\n           (loop [match (re-find matcher) ;loop starts with 2 set arguments\n                  result []]\n             (if-not match\n               result\n               (recur (re-find matcher)    ;loop with 2 new arguments\n                      (conj result match))))))\n\n#'user/my-re-seq\n\nuser=> (my-re-seq #\"\\d\" \"0123456789\")\n[\"0\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\"]\n\n" ";; Read decoded MP3 data in loop (requires mp3plugin.jar on class path)\n;; http://java.sun.com/javase/technologies/desktop/media/jmf/mp3/download.html \n\n(import '(javax.sound.sampled AudioSystem AudioFormat$Encoding))\n\n(let [mp3-file (java.io.File. \"tryout.mp3\")\n      audio-in (AudioSystem/getAudioInputStream mp3-file)\n      audio-decoded-in (AudioSystem/getAudioInputStream AudioFormat$Encoding/PCM_SIGNED audio-in)\n      buffer (make-array Byte/TYPE 1024)]\n  (loop []\n    (let [size (.read audio-decoded-in buffer)]\n      (when (> size 0)\n        ;do something with PCM data\n\t(recur)))))\n" "(loop [x 10]\n  (when (> x 1)\n    (println x)\n    (recur (- x 2))))\n\n;;=> 10 8 6 4 2" "(defn find-needle [needle haystack]\n  ;loop binds initial values once,\n  ;then binds values from each recursion call\n  (loop [needle needle\n         maybe-here haystack\n         not-here '()]\n\n    (let [needle? (first maybe-here)]\n\n      ;test for return or recur\n      (if (or (= (str needle?) (str needle))\n              (empty? maybe-here))\n\n        ;return results\n        [needle? maybe-here not-here]\n\n        ;recur calls loop with new values\n        (recur needle\n               (rest maybe-here)\n               (concat not-here (list (first maybe-here))))))))\n\nuser=>(find-needle \"|\" \"hay|stack\")\n[\\| (\\| \\s \\t \\a \\c \\k) (\\h \\a \\y)]" "; makes a simple template function that can be used in mustache way: http://mustache.github.com/\n(defn template [tpl env]\n  (loop [tpl tpl\n         env env]\n    (cond (empty? env)\n          tpl\n          :else\n          (let [[key value] (first env)]\n            (recur (try (clojure.string/replace tpl \n                                                (re-pattern (str \"\\\\{\\\\{\" (name key) \"\\\\}\\\\}\")) \n                                                value)\n                        (catch Exception e tpl)) \n                   (rest env))))))" "(loop [iter 1\n       acc  0]\n  (if (> iter 10)\n    (println acc)\n    (recur (inc iter) (+ acc iter))))\n\n;; => 55\n;; sum from 1 to 10" ";; loop is the recursion point for recur. The symbols in loop's \n;; binding-forms are bound to their respective init-exprs and \n;; rebound to the values of recur's exprs before the next execution \n;; of loop's body.\n\n;; calculate the factorial of n\n\n(loop [n (bigint 5), accumulator 1]\n  (if (zero? n)\n    accumulator  ; we're done\n    (recur (dec n) (* accumulator n))))\n\n;;=> 120N\n\n\n;; square each number in the vector\n\n(loop [xs (seq [1 2 3 4 5])\n       result []]\n  (if xs\n    (let [x (first xs)]\n      (recur (next xs) (conj result (* x x))))\n    result))\n\n;; => [1 4 9 16 25]" "; A loop that sums the numbers 10 + 9 + 8 + ...\n\n; Set initial values count (cnt) from 10 and down\n(loop [sum 0 cnt 10]\n    ; If count reaches 0 then exit the loop and return sum\n    (if (= cnt 0)\n    sum\n    ; Otherwise add count to sum, decrease count and \n    ; use recur to feed the new values back into the loop\n    (recur (+ cnt sum) (dec cnt))))" "(loop [i 0]  \n  (when (< i 5)    \n    (println i)    \n    (recur (inc i)); loop i will take this value\n))" ";; Iterating over a collection using loop\n\n;; 1. First call (seq xs) on the given argument and then check for nil \n;; 2. Then call next/first and use these.\n\n(loop [xs (seq [1 2 3 4 5])\n       result []]\n  (if xs\n    (let [x (first xs)]\n      (recur (next xs) (conj result (* x x))))\n    result))\n\n;; the same loop can be written using destructing,\n;; but the compiler will generate two consecutive\n;; seq calls and is slightly less efficient.\n\n(loop [[x & r :as xs] (seq [])\n       result []]\n  (if xs\n    (recur r (conj result (* x x)))\n    result))" ";;basic loop example #1\n\n(loop [x 0\n       result []]\n  (if (< x 10)\n    (recur\n      (inc x)\n      (conj result x)) result))\n;;[0 1 2 3 4 5 6 7 8 9]\n\n;;basic loop example #2\n(def citrus-list [\"lemon\" \"orange\" \"grapefruit\"])\n\n(defn display-citrus [citruses]\n  (loop [[citrus & citruses] citruses]\n    (println citrus)\n    (if citrus (recur citruses))))\n\n(display-citrus citrus-list)" ";;loop general strategy\n;;given a collection of numbers [1 2 3 4 5],\n;;return a new collection [10 20 30 40 50]\n\n\n(def my-vector [1 2 3 4 5])\n\n(defn my-new-vector\n  [coll]\n  (loop [remain coll\n         final-vec []]\n    (if (empty? remain)\n      final-vec\n      (let [[unit & remaining] remain]\n        (recur remaining\n               (into final-vec [(* 10 unit)]))))))\n\n(my-new-vector my-vector)\n;;[10 20 30 40 50]\n\n;;to sum all the elements from the newly created collection:\n\n(reduce + (my-new-vector my-vector))\n;;150" ";; loop -> recur sample with fizzbuzz code.\n\n(defn fizzbuzz\n  [n]\n  (loop [f []\n         i 1]\n    (if (< n i)\n      f\n      (recur (conj f (cond\n                       (zero? (mod i 15)) \"fizzbuzz\"\n                       (zero? (mod i 3)) \"fizz\"\n                       (zero? (mod i 5)) \"buzz\"\n                       :else i))\n             (inc i)))))\n\n(println (fizzbuzz 100))\n;; output is \n;; [1 2 fizz 4 buzz fizz 7 8 fizz buzz 11 fizz 13 14 fizzbuzz 16 17 fizz 19 buzz fizz 22 23 fizz buzz 26 fizz 28 29 fizzbuzz 31 32 fizz 34 buzz fizz 37 38 fizz buzz 41 fizz 43 44 fizzbuzz 46 47 fizz 49 buzz fizz 52 53 fizz buzz 56 fizz 58 59 fizzbuzz 61 62 fizz 64 buzz fizz 67 68 fizz buzz 71 fizz 73 74 fizzbuzz 76 77 fizz 79 buzz fizz 82 83 fizz buzz 86 fizz 88 89 fizzbuzz 91 92 fizz 94 buzz fizz 97 98 fizz buzz]\n"], :macro true, :notes ["\"Acts as a recur target.\"\r\n\r\nWhat's a recur target? A recurring target? A recursive target? I'm not a big fan of abbreviations or ambiguous terms.\r\n\r\nWouldn't it be awesome if a script could annotate all occurrences of glossary terms? Or automatically wrap glossary terms in anchor tags linking to their definition?" "The problem `loop` is trying to solve is that recursively calling the same function on the JVM is expensive and doesn't scale. It might work if your data structure is a thousand levels deep but it will fail badly with a depth of millions of levels.\r\n\r\nWhat is not possible on the JVM is what is called \"tail-call optimization\". `loop` is like a `while` loop in java, except that if you don't call `recur` (with the correct number of arguments) the loop will exit. In while-loop terms, `recur` avoids that a `break` statement is executed.\r\n\r\n<pre>int counter = 0;\r\nwhile (true) {\r\n   if (counter &lt; 10) {\r\n      // recur\r\n      counter = inc(counter);\r\n   } else {\r\n      break;\r\n   }\r\n}\r\n</pre>\r\n\r\nIn that sense `loop` is a recur target as in \"target for recursion\"." "I wish the word recur in this document linked to the recur function. That'd be... awesome." "It really should (and will) show up in the 'vars in' section.  \r\n\r\nThe problem is that recur is a special form, and is not parsed out correctly like other vars.  This will be fixed in the future." "Majority of `loop`s that novices write can be expressed more elegantly using 3 fundamental functions `map`, `filter` and `reduce`. Or using list comprehension `for`." "To be clear, there's no *technical* reason the JVM can't support tail recursion (despite some complications to do with call stacks and security) - it just doesn't happen to support them currently.\n\nPeople have been requesting this enhancement for at least a decade - [here's one proposal](https://blogs.oracle.com/jrose/entry/tail_calls_in_the_vm), for example."], :arglists ["bindings & body"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/loop", :forms ["(loop [bindings*] exprs*)"]}, :clojure.core/max-key {:added "1.0", :ns "clojure.core", :name "max-key", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/max :clojure.core/min-key :clojure.core/min], :line 4929, :examples ["user=> (max-key count \"asd\" \"bsd\" \"dsd\" \"long word\")\n\"long word\"" "; find the key that has the highest value in a map\nuser=> (key (apply max-key val {:a 3 :b 7 :c 9}))\n:c"], :notes nil, :arglists ["k x" "k x y" "k x y & more"], :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/max-key"}, :clojure.core.reducers/remove {:added "1.5", :ns "clojure.core.reducers", :name "remove", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 200, :examples nil, :notes nil, :arglists ["pred" "pred coll"], :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/remove"}, :clojure.stacktrace/print-stack-trace {:added "1.1", :ns "clojure.stacktrace", :name "print-stack-trace", :file "clojure/stacktrace.clj", :type "function", :column 1, :see-alsos [:clojure.core/catch :clojure.core/ex-info], :line 44, :examples ["(clojure.stacktrace/print-stack-trace (Exception. \"foo\"))\n; java.lang.Exception: foo\n;  at user$eval112.invoke (NO_SOURCE_FILE:1)\n;     clojure.lang.Compiler.eval (Compiler.java:6619)\n;     clojure.lang.Compiler.eval (Compiler.java:6582)\n;     clojure.core$eval.invoke (core.clj:2852)\n;     clojure.main$repl$read_eval_print__6588$fn__6591.invoke (main.clj:259)\n;     clojure.main$repl$read_eval_print__6588.invoke (main.clj:259)\n;     clojure.main$repl$fn__6597.invoke (main.clj:277)\n;     clojure.main$repl.doInvoke (main.clj:277)\n;     clojure.lang.RestFn.invoke (RestFn.java:1096)\n;     clojure.tools.nrepl.middleware.interruptible_eval$evaluate$fn__3615.invoke (interruptible_eval.clj:56)\n;     clojure.lang.AFn.applyToHelper (AFn.java:159)\n;     clojure.lang.AFn.applyTo (AFn.java:151)\n;     clojure.core$apply.invoke (core.clj:617)\n;     clojure.core$with_bindings_STAR_.doInvoke (core.clj:1788)\n;     clojure.lang.RestFn.invoke (RestFn.java:425)\n;     clojure.tools.nrepl.middleware.interruptible_eval$evaluate.invoke (interruptible_eval.clj:41)\n;     clojure.tools.nrepl.middleware.interruptible_eval$interruptible_eval$fn__3656$fn__3659.invoke (interruptible_eval.clj:171)\n;     clojure.core$comp$fn__4154.invoke (core.clj:2330)\n;     clojure.tools.nrepl.middleware.interruptible_eval$run_next$fn__3649.invoke (interruptible_eval.clj:138)\n;     clojure.lang.AFn.run (AFn.java:24)\n;     java.util.concurrent.ThreadPoolExecutor.runWorker (:-1)\n;     java.util.concurrent.ThreadPoolExecutor$Worker.run (:-1)\n;     java.lang.Thread.run (:-1)\n;=> nil\n\n(clojure.stacktrace/print-stack-trace (Exception. \"foo\") 4)\n; java.lang.Exception: foo\n;  at user$eval124.invoke (NO_SOURCE_FILE:1)\n;     clojure.lang.Compiler.eval (Compiler.java:6619)\n;     clojure.lang.Compiler.eval (Compiler.java:6582)\n;     clojure.core$eval.invoke (core.clj:2852)\n;=> nil" ";; if you need to capture the stack trace in a string.\n(with-out-str (clojure.stacktrace/print-stack-trace (Exception. \"foo\") 4))\n;; \"\\n  clojure.core/eval  core.clj: 3211\\n  ... \\n  boot.user$eval1726.invoke          : 1\\nboot.user$eval1726.invokeStatic  :  1\\njava.lang.Exception: foo\\n\""], :notes nil, :arglists ["tr" "tr n"], :doc "Prints a Clojure-oriented stack trace of tr, a Throwable.\n  Prints a maximum of n stack frames (default: unlimited).\n  Does not print chained exceptions (causes).", :library-url "https://github.com/clojure/clojure", :href "/clojure.stacktrace/print-stack-trace"}, :clojure.core/*out* {:added "1.0", :ns "clojure.core", :name "*out*", :type "var", :see-alsos [:clojure.core/*in*], :examples nil, :notes nil, :tag "java.io.Writer", :arglists [], :doc "A java.io.Writer object representing standard output for print operations.\n\n  Defaults to System/out, wrapped in an OutputStreamWriter", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*out*"}, :clojure.core/drop-last {:added "1.0", :ns "clojure.core", :name "drop-last", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/drop :clojure.core/drop-while :clojure.core/butlast], :line 2926, :examples ["\n(drop-last [1 2 3 4])\n;=> (1 2 3) \n\n(drop-last -1 [1 2 3 4])\n;=> (1 2 3 4) \n\n(drop-last 0 [1 2 3 4])\n;=> (1 2 3 4) \n\n(drop-last 5 [1 2 3 4])\n;=> ()\n\n;; works differently with any seq.\n;; but with some the last items become ambiguous.\n(drop-last 2 (vector 1 2 3 4))\n;=> (1 2)\n(drop-last 2 (list 1 2 3 4 ))\n;=> (1 2)\n(drop-last 2 {:a 1 :b 2 :c 3 :d 4})\n;=> ([:a 1] [:b 2])"], :notes ["`drop-last` is lazy and implemented with `map`, whereas `butlast` is not lazy and implemented with `loop` and `recur`. "], :arglists ["coll" "n coll"], :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/drop-last"}, :clojure.core/juxt {:added "1.1", :ns "clojure.core", :name "juxt", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partial :clojure.core/comp], :line 2568, :examples [";; Extract values from a map, treating keywords as functions.\n((juxt :a :b) {:a 1 :b 2 :c 3 :d 4})\n;;=> [1 2]\n" ";; \"Explode\" a value.\n\n((juxt identity name) :keyword)\n;;=> [:keyword \"keyword\"]\n\n(juxt identity name)\n...is the same as:\n(fn [x] [(identity x) (name x)])\n\n;; eg. to create a map:\n\n(into {} (map (juxt identity name) [:a :b :c :d]))\n;;=> {:a \"a\" :b \"b\" :c \"c\" :d \"d\"}\n" ";; Get the first character and length of string\n\n((juxt first count) \"Clojure Rocks\")\n;;=> [\\C 13]\n" ";; sort list of maps by multiple values\n(sort-by (juxt :a :b) [{:a 1 :b 3} {:a 1 :b 2} {:a 2 :b 1}])\n;;=> [{:a 1 :b 2} {:a 1 :b 3} {:a 2 :b 1}]" ";; Create lookup maps via a specific key\n\n(defn index-by [coll key-fn]\n    (into {} (map (juxt key-fn identity) coll)))\n;; #'user/index-by\n\n(index-by [{:id 1 :name \"foo\"} \n           {:id 2 :name \"bar\"} \n           {:id 3 :name \"baz\"}] :id)\n;;=> {1 {:name \"foo\", :id 1}, \n;;    2 {:name \"bar\", :id 2}, \n;;    3 {:name \"baz\", :id 3}}\n\n(index-by [{:id 1 :name \"foo\"} \n           {:id 2 :name \"bar\"} \n           {:id 3 :name \"baz\"}] :name)\n;;=> {\"foo\" {:name \"foo\", :id 1}, \n;;    \"bar\" {:name \"bar\", :id 2}, \n;;    \"baz\" {:name \"baz\", :id 3}}\n" "((juxt + * min max) 3 4 6)\n;;=> [13 72 3 6]" ";; split a sequence into two parts\n\nuser=> ((juxt take drop) 3 [1 2 3 4 5 6])\n;; => [(1 2 3) (4 5 6)]" ";; Segregate even and odd numbers in collection.\n\n((juxt (partial filter even?) (partial filter odd?)) (range 0 9))\n;;=> [(0 2 4 6 8) (1 3 5 7)]" ";;keywords serve as getter functions to produce an ordered vector\n\n((juxt :lname :fname) {:fname \"Bill\" :lname \"Gates\"})\n=> [\"Gates\" \"Bill\"]" ";; sort by two values\n\n(sort-by (juxt :a :b) [{:a 2 :b 4} {:a 1 :b 2} {:a 2 :b 1}])\n=> ({:a 1, :b 2} {:a 2, :b 1} {:a 2, :b 4})" ";; something similar to group-by\n\n(def split-by (juxt filter remove))\n\n(split-by pos? [-1 -2 4 5 3 -9])\n=> ([4 5 3] [-1 -2 -9])\n"], :notes ["I kinda love this fn =)" "\"reduce1\" -> \"reduce\"\r\n\r\ncore sources from 33 line to 37 line"], :arglists ["f" "f g" "f g h" "f g h & fs"], :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/juxt"}, :clojure.core/map {:added "1.0", :ns "clojure.core", :name "map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map-indexed :clojure.core/pmap :clojure.core/amap :clojure.core/mapcat :clojure.core/keep :clojure.core/juxt :clojure.core/mapv :clojure.core/reduce :clojure.core/run!], :line 2719, :examples ["(map inc [1 2 3 4 5])\n;;=> (2 3 4 5 6)\n\n\n;; map can be used with multiple collections. Collections will be consumed\n;; and passed to the mapping function in parallel:\n(map + [1 2 3] [4 5 6])\n;;=> (5 7 9)\n\n\n;; When map is passed more than one collection, the mapping function will\n;; be applied until one of the collections runs out:\n(map + [1 2 3] (iterate inc 1))\n;;=> (2 4 6)\n\n\n\n;; map is often used in conjunction with the # reader macro:\n(map #(str \"Hello \" % \"!\" ) [\"Ford\" \"Arthur\" \"Tricia\"])\n;;=> (\"Hello Ford!\" \"Hello Arthur!\" \"Hello Tricia!\")\n\n;; A useful idiom to pull \"columns\" out of a collection of collections. \n;; Note, it is equivalent to:\n;; user=> (map vector [:a :b :c] [:d :e :f] [:g :h :i])\n\n(apply map vector [[:a :b :c]\n                   [:d :e :f]\n                   [:g :h :i]])\n\n;;=> ([:a :d :g] [:b :e :h] [:c :f :i])\n\n;; From http://clojure-examples.appspot.com/clojure.core/map" ";; map sends key-value pairs from a hash-map\n(map #(vector (first %) (* 2 (second %)))\n            {:a 1 :b 2 :c 3})\n;;=> ([:a 2] [:b 4] [:c 6])\n\n;; or the same thing using destructuring\n(map (fn [[key value]] [key (* 2 value)])\n            {:a 1 :b 2 :c 3})\n;;=> ([:a 2] [:b 4] [:c 6])\n\n(into {} *1)\n;;=> {:a 2, :b 4, :c 6}\n" ";; Use a hash-map as a function to translate values in a collection from the \n;; given key to the associated value\n\nuser=> (map {2 \"two\" 3 \"three\"} [5 3 2])\n(nil \"three\" \"two\")\n\n;; then use (filter identity... to remove the nils\nuser=> (filter identity (map {2 \"two\" 3 \"three\"} [5 3 2]))\n(\"three\" \"two\")" ";; mapping over a hash-map applies (into) first. \n;; need to use functions that deal with arrays (fn [[key val]] ...)\n(map pprint {:key :val :key1 :val1})\n([:key :val]\n[:key1 :val1]\nnil nil)\n\n;;above, the pprint output appears to be part of the return value but it's not:\n(hash-set (map pprint {:key :val :key1 :val1}))\n[:key :val]\n[:key1 :val1]\n#{(nil nil)}\n\n(map second {:key :val :key1 :val1})\n;;=>(:val :val1)\n\n(map last {:x 1 :y 2 :z 3})\n;;=> (1 2 3)" "(map fn [a 4 x]\n        [b 5 y]\n        [c 6])    \n;        ^ ^\n; applies fn to a b c as (fn a b c)\n; applies fn to 4 5 6 as (fn 4 5 6)\n; ignores (x y)\n; returns a list of results\n; equivalent to (list (fn a b c) (fn 4 5 6))\n\n;example\n(map list [1 2 3]\n         '(a b c)\n         '(4 5))\n\nuser=> (map list  [1 2 3] '(a b c) '(4 5))\n((1 a 4) (2 b 5))\n;same as\nuser=> (list (list 1 'a 4) (list 2 'b 5))\n((1 a 4) (2 b 5))" "; map passed two collection arguments. From 4Clojure Problem #157\n\n(def d1 [:a :b :c])\n(#(map list % (range)) d1)\n;;=> ((:a 0) (:b 1) (:c 2))" ";; Used without a collection, map will create a transducer:\n(def xf (map inc))\n\n;; We can now apply this transducer to a sequence:\n(transduce xf conj (range 5))\n;; => [1 2 3 4 5]\n" ";; Extract keyword from a collection of obj\n(map :a '({:a 1 :b 0} {:a 2 :b 0} {:a 3 :b 1} {:a 3 :b 0}))\n;; =>(1 2 3 3)" ";;get the keys from a map with entries of certain values\n(let [m {:x 1 :y 2 :z 3}\n      vset #{2 3}]\n  (map first (filter (comp vset last) m)))\n;;=> (:y :z)\n\n(filter (comp #{2 3} last) {:x 1 :y 2 :z 3})\n;;=> ([:y 2] [:z 3])\n\n" ";; deeper destructuring\n(def ds [ {:a 1 :b 2 :c [:foo :bar]}\n          {:a 9 :b 8 :c [:baz :zoo]}\n          {:a 1 :b 2 :c [:dog :cat]} ])\n\n(->> ds \n    (map (fn [{a :a, b :b, [lhs rhs] :c}] \n            [(str \"a:\" a \" c2:\" rhs)])))\n;;=> ([\"a:1 c2::bar\"] [\"a:9 c2::zoo\"] [\"a:1 c2::cat\"])" ";;map taking a collection of functions as an argument\n\n(def sum #(reduce + %))\n\n(def average #(/ (sum %) (count %)))\n\n;;apply a function to a collection\n(defn results [coll]\n  (map #(% coll) [sum average count]))\n\n(results [10 20 30 40 50])\n;;[150 30 5]" "(def my-coll [\n              {:m 1, :val 12}\n              {:m 2, :val 3}\n              {:m 3, :val 32}])\n\n(map #(:val %) my-coll)\n;;(12 3 32)\n\n;;get total:\n(reduce + (map #(:val %) my-coll))\n;;47" ";;map practical example\n\n(def months [\"jan\" \"feb\" \"mar\"])\n\n(def temps [5 7 12])\n\n(defn unify\n  [month temp]\n  {:month month\n   :temp temp})\n\n(map unify months temps)\n\n;;({:month \"jan\", :temp 5}\n;; {:month \"feb\", :temp 7}\n;; {:month \"mar\", :temp 12})\n" ";;map Function collection1 collection2\n\n(map vector '(1 2 3 4) [:a :b :c :d])\n\n;;([1 :a] [2 :b] [3 :c] [4 :d])"], :notes ["To create a *hashmap*, use the [`hash-map`](hash-map) function, or the `{...}` sugar:\r\n\r\n    (= {:a 1 :b 2 :c 3} (hash-map :a 1 :b 2 :c 3))"], :arglists ["f" "f coll" "f c1 c2" "f c1 c2 c3" "f c1 c2 c3 & colls"], :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/map"}, :clojure.core/peek {:added "1.0", :ns "clojure.core", :name "peek", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/pop :clojure.core/conj], :line 1452, :examples ["user=> (def large-vec (vec (range 0 10000)))\n#'user/large-vec\n\nuser=> (time (last large-vec))\n\"Elapsed time: 1.279841 msecs\"\n9999\n\nuser=> (time (peek large-vec))\n\"Elapsed time: 0.049238 msecs\"\n9999\n" "user=> (peek '(:a :b :c))\n:a" "user=> (peek [1 2 3 4])\n;;=> 4\n\nuser=> (peek [])\n;;=> nil\n\nuser=> (peek '(1 2 3 4))\n;;=> 1\n\nuser=> (peek '())\n;;=> nil\n\nuser=> (peek nil)\n;;=> nil" ";;peek on vector returns the last element\n(peek [1 2 3])\n;; 3\n\n;;peek on list retunrs the first element\n(peek '(1 2 3))\n;; 1"], :notes ["Small reminder:\r\n\r\n<br>\r\nDo not work for arbitrary seq but just for persistent types implementing clojure.lang.IPersistentStack (like clojure.lang.Persistent*).\r\n\r\n<br>\r\nExample:\r\n<pre>user&gt; (peek (cons 1 '()))\r\n; Evaluation aborted.\r\n</pre>\r\ndo not work because type is clojure.lang.Cons but\r\n\r\n<pre>user&gt; (peek (conj '() 1))\r\n1\r\n</pre>\r\nworks because type is clojure.lang.PersistentList."], :arglists ["coll"], :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/peek"}, :clojure.core/ns-name {:added "1.0", :ns "clojure.core", :name "ns-name", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/the-ns], :line 4130, :examples [";; get the namespace name as a symbol\n(ns-name (the-ns 'user))\n;;=> user\n\n\n"], :notes nil, :arglists ["ns"], :doc "Returns the name of the namespace, a symbol.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-name"}, :clojure.core/with-loading-context {:ns "clojure.core", :name "with-loading-context", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 5695, :examples nil, :macro true, :notes nil, :arglists ["& body"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-loading-context"}, :clojure.core.logic/fixc {:ns "clojure.core.logic", :name "fixc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2871, :examples nil, :notes nil, :arglists ["x f reifier" "x f runnable reifier"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fixc"}, :clojure.core/partition {:added "1.0", :ns "clojure.core", :name "partition", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partition-all :clojure.core/split-at :clojure.core/partition-by :clojure.core/cycle], :line 3176, :examples [";; partition a list of 20 items into 5 (20/4) lists of 4 items\n(partition 4 (range 20))\n;;=> ((0 1 2 3) (4 5 6 7) (8 9 10 11) (12 13 14 15) (16 17 18 19))\n\n;; partition a list of 22 items into 5 (20/4) lists of 4 items \n;; the last two items do not make a complete partition and are dropped.\n(partition 4 (range 22))\n;;=> ((0 1 2 3) (4 5 6 7) (8 9 10 11) (12 13 14 15) (16 17 18 19))\n\n;; uses the step to select the starting point for each partition\n(partition 4 6 (range 20))\n;;=> ((0 1 2 3) (6 7 8 9) (12 13 14 15))\n\n;; if the step is smaller than the partition size, items will be reused\n(partition 4 3 (range 20))\n;;=> ((0 1 2 3) (3 4 5 6) (6 7 8 9) (9 10 11 12) (12 13 14 15) (15 16 17 18))\n\n;; when there are not enough items to fill the last partition, a pad can be supplied.\n(partition 3 6 [\"a\"] (range 20))\n;;=> ((0 1 2) (6 7 8) (12 13 14) (18 19 \"a\"))\n\n;; when a pad is supplied, the last partition may not be of the same size as the rest\n(partition 4 6 [\"a\"] (range 20))\n;;=> ((0 1 2 3) (6 7 8 9) (12 13 14 15) (18 19 \"a\"))\n\n;; but only as many pad elements are used as necessary to fill the final partition.\n(partition 4 6 [\"a\" \"b\" \"c\" \"d\"] (range 20))\n;;=> ((0 1 2 3) (6 7 8 9) (12 13 14 15) (18 19 \"a\" \"b\"))\n" ";; a step smaller than the partition-size results in reuse.\n(partition 3 1 [:a :b :c :d :e :f])\n;;=> ((:a :b :c) (:b :c :d) (:c :d :e) (:d :e :f))\n" ";; When there are less than n items in the coll, partition's behaviour\n;; depends on whether there is a pad or not\n\n;; without pad\n(partition 10 [1 2 3 4])\n;;=> ()\n\n;; again, without pad\n(partition 10 10 [1 2 3 4])\n;;=> ()\n\n;; with a pad this time (note: the pad is an empty sequence)\n(partition 10 10 nil [1 2 3 4])\n;;=> ((1 2 3 4))\n\n;; or, explicit empty sequence instead of nil\n(partition 10 10 [] [1 2 3 4])\n;;=> ((1 2 3 4))\n" ";; Partitioning 0 elements will produce an infinite seq of empty sequences\n(partition 0 [1 2 3])\n;; *hangs*\n\n(take 5 (partition 0 [1 2 3]))\n;; => (() () () () ())" ";; Using nil as a pad will let the incomplete partition in the result\n;; Here we use it to drop every fourth emlement in an array\n(#(partition (- %2 1) %2 nil %1) [1 2 3 4 5 6 7 8 9] 4)\n;;((1 2 3) (5 6 7) (9))" ";; Here is a nice little trick to make a ring.\n(def foo [5 6 7 8])\n\n(partition 2 1 foo foo)\n;;=> ((5 6) (6 7) (7 8) (8 5))\n\n;; This will produce a part for each element of foo.\n;; Without the pad stops sooner.\n(partition 2 1 foo)\n;;=> ((5 6) (6 7) (7 8))\n\n;; Just how crazy can this get?\n(partition 4 1 foo foo)\n;;=> ((5 6 7 8) (6 7 8 5))\n;; Not too crazy, this illustrates the \n;; fact that the first use of the pad halts the partitioning.\n;; To my way of thinking this is not what I expected.\n\n;; The following alternative implementation continues \n;; until the coll has been consumed once completely.\n(defn spiral\n  ([n step coll]\n   (spiral n step coll coll))\n  ([n step pad coll]\n   (lazy-seq\n     (when-let [s (seq coll)]\n       (let [p (doall (take n s))\n             item (take n (apply concat p (repeat pad)))]\n         (if (< 1 (count p))\n           (cons item (spiral n step pad (nthrest s step)))\n           (list item)))))))\n(spiral 4 1 foo)\n;;=> ((5 6 7 8) (6 7 8 5) (7 8 5 6) (8 5 6 7))\n\n(spiral 4 2 foo)\n;;=> ((5 6 7 8) (7 8 5 6))\n\n(spiral 6 1 foo)\n;;=> ((5 6 7 8 5 6) (6 7 8 5 6 7) (7 8 5 6 7 8) (8 5 6 7 8 5))\n\n(def bar [:a :b :c])\n(spiral 6 2 bar foo)\n;;=> ((5 6 7 8 :a :b) (7 8 :a :b :c :a))\n\n;; Note that if you don’t need the padding, the function above can be\n;; simplified a lot by using cycle:\n(defn spiral\n  [n offset coll]\n  (take (/ (count coll) offset) (partition n offset (cycle coll))))" ";; In case you want behaviour similar to Ruby's each_slice, \n;; where the last sequence doesn't necessarily have the same \n;; size as the others, you can just provide an empty or nil pad value.\n(partition 3 3 nil (range 11))\n;;=> ((0 1 2) (3 4 5) (6 7 8) (9 10)))"], :notes nil, :arglists ["n coll" "n step coll" "n step pad coll"], :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/partition"}, :clojure.core/test {:added "1.0", :ns "clojure.core", :name "test", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/var :clojure.core/meta :clojure.core/assert :clojure.test/with-test], :line 4769, :examples ["(defn my-function\n  \"this function adds two numbers\"\n  {:test #(do\n            (assert (= (my-function 2 3) 5))\n            (assert (= (my-function 4 4) 8)))}\n  ([x y] (+ x y)))\n\n(test #'my-function)  ;equal to (test (var my-function))\n=> :ok\n\n-----------------------------------------------------------------------\n\n(defn my-function\n  \"this function adds two numbers\"\n  {:test #(do\n            (assert (= (my-function 2 3) 5))\n            (assert (= (my-function 99 4) 8)))}\n  ([x y] (+ x y)))\n\n(test #'my-function)\n=> java.lang.AssertionError: Assert failed: (= (my-function 99 4) 8) (NO_SOURCE_FILE:0\n\n---------------------------------------------------------------------------\n\n(defn my-function\n  \"this function adds two numbers\"\n  ([x y] (+ x y)))\n\n(test #'my-function)\n=> :no-test"], :notes nil, :arglists ["v"], :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/test"}, :clojure.spec.alpha/fspec {:ns "clojure.spec.alpha", :name "fspec", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 653, :examples nil, :macro true, :notes nil, :arglists ["& {:keys [args ret fn gen], :or {ret (quote clojure.core/any?)}}"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/fspec"}, :clojure.pprint/*print-pprint-dispatch* {:added "1.2", :ns "clojure.pprint", :name "*print-pprint-dispatch*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 34, :examples nil, :notes nil, :arglists [], :doc "The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch\nto modify.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-pprint-dispatch*"}, :clojure.pprint/*print-pretty* {:added "1.2", :ns "clojure.pprint", :name "*print-pretty*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 30, :examples ["(binding [clojure.pprint/*print-right-margin* 5]\n\n  ;; Compare the two outputs below:\n\n  (binding [clojure.pprint/*print-pretty* true]\n    (clojure.pprint/write (range 3)))\n  ; Prints:\n  ; (0\n  ;  1\n  ;  2)\n\n  (binding [clojure.pprint/*print-pretty* false]\n    (clojure.pprint/write (range 3)))\n  ; Prints:\n  ; (0 1 2)\n)"], :notes ["`clojure.pprint/pprint` always sets `*print-pretty*` to `true` internally, so changing it has no effect if you only use `pprint` and not `write`."], :arglists [], :doc "Bind to true if you want write to use pretty printing", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-pretty*"}, :clojure.core/defn- {:added "1.0", :ns "clojure.core", :name "defn-", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/defn], :line 4865, :examples ["\nuser=> (ns test)\nnil\n\ntest=> (defn- foo []\n         \"World!\")\n#'test/foo\n\ntest=> (defn bar []\n       (str \"Hello \" (foo)))\n#'test/bar\n\ntest=> (foo)\n\"World!\"\ntest=> (bar)\n\"Hello World!\"\ntest=> (ns playground)\nnil\nplayground=> (test/bar)\n\"Hello World!\"\n\n;; Error will be thrown\n;; var: #'test/foo is not public\nplayground=> (test/foo)\n"], :macro true, :notes nil, :arglists ["name & decls"], :doc "same as defn, yielding non-public def", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defn-"}, :clojure.repl/source {:ns "clojure.repl", :name "source", :file "clojure/repl.clj", :type "macro", :column 1, :see-alsos [:clojure.repl/doc :clojure.repl/dir :clojure.repl/apropos :clojure.repl/source-fn], :line 173, :examples ["user=> (source max)\n;; prints in console:\n(defn max\n  \"Returns the greatest of the nums.\"\n  {:added \"1.0\"}\n  ([x] x)\n  ([x y] (if (> x y) x y))\n  ([x y & more]\n   (reduce max (max x y) more)))\n"], :macro true, :notes nil, :arglists ["n"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/source"}, :clojure.set/join {:added "1.0", :ns "clojure.set", :name "join", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/rename], :line 111, :examples [";; This simple example shows each element of the first relation joined\n;; with each element of the second (because they have no columns in common):\n\nuser=> (def first-relation #{ {:a 1} {:a 2} })\nuser=> (def second-relation #{ {:b 1} {:b 2} })\nuser=> (join first-relation second-relation)\n#{{:b 1, :a 1} \n  {:b 2, :a 1} \n  {:b 1, :a 2} \n  {:b 2, :a 2}}\n\n\n;; Here's a larger example, in which a relation mainly about animal ownership\n;; is joined with a relation about animal personality. The join is used to \n;; produce a relation joining information about an animal's personality to \n;; that animal.\n\nuser=> (def animals #{{:name \"betsy\" :owner \"brian\" :kind \"cow\"}\n                      {:name \"jake\"  :owner \"brian\" :kind \"horse\"}\n                      {:name \"josie\" :owner \"dawn\"  :kind \"cow\"}})\n\nuser=> (def personalities #{{:kind \"cow\" :personality \"stoic\"}\n                            {:kind \"horse\" :personality \"skittish\"}})\n#'user/personalities\nuser=> (join animals personalities)\n\n#{{:owner \"dawn\",  :name \"josie\", :kind \"cow\",   :personality \"stoic\"}\n  {:owner \"brian\", :name \"betsy\", :kind \"cow\",   :personality \"stoic\"}\n  {:owner \"brian\", :name \"jake\",  :kind \"horse\", :personality \"skittish\"}}\n\n\n;; (If cows had two personalities, instead of one, each cow would have \n;; two rows in the output.)\n\n;; Suppose `personalities` used `:species` instead of `:kind`:\n\nuser=>  (def personalities #{{:species \"cow\" :personality \"stoic\"}\n                             {:species \"horse\" :personality \"skittish\"}})\n\n\n;; A simple join would produce results like this:\n\nuser=> (join animals personalities)\n#{{:kind \"horse\", :owner \"brian\", :name \"jake\", :species \"cow\", :personality \"stoic\"}\n  {:kind \"cow\", :owner \"dawn\", :name \"josie\", :species \"cow\", :personality \"stoic\"}\n  {:kind \"horse\", :owner \"brian\", :name \"jake\", :species \"horse\", :personality \"skittish\"}\n  {:kind \"cow\", :owner \"brian\", :name \"betsy\", :species \"cow\", :personality \"stoic\"}\n  {:kind \"cow\", :owner \"dawn\", :name \"josie\", :species \"horse\", :personality \"skittish\"}\n  {:kind \"cow\", :owner \"brian\", :name \"betsy\", :species \"horse\", :personality \"skittish\"}}\n\n\n;; Notice that \"Jake\" is both a horse and a cow in the first line. That's \n;; likely not what you want. You can tell `join` to only produce output \n;; where the `:kind` value is the same as the `:species` value like this:\n\nuser=> (join animals personalities {:kind :species})\n#{{:kind \"cow\", :owner \"dawn\", :name \"josie\", :species \"cow\", :personality \"stoic\"}\n  {:kind \"horse\", :owner \"brian\", :name \"jake\", :species \"horse\", :personality \"skittish\"}\n  {:kind \"cow\", :owner \"brian\", :name \"betsy\", :species \"cow\", :personality \"stoic\"}}\n\n\n;; Notice that the `:kind` and `:species` keys both appear in each output map.\n" "\n;; If you don't specify `km`, `join` has to 'guess' on which attributes to join.\n;; Sometimes, result may surprise you:\n\nuser=> (join [{:a 1 :b 2}] [{:c 3 :d 4} {:a 5 :b 6}]) \n;#{{:a 5, :b 6} {:a 1, :b 2, :c 3, :d 4}}" ";; join with rename of (otherwise clashing) keys. Note that in the following\n;; relations, we have \"user.type\" and \"account.type\"\n\n(def users\n  #{{:user-id 1 :name \"john\"   :age 22 :type \"personal\"}\n    {:user-id 2 :name \"jake\"   :age 28 :type \"company\"}\n    {:user-id 3 :name \"amanda\" :age 63 :type \"personal\"}})\n\n(def accounts\n  #{{:acc-id 1 :user-id 1 :amount 300.45 :type \"saving\"}\n    {:acc-id 2 :user-id 2 :amount 1200.0 :type \"saving\"}\n    {:acc-id 3 :user-id 1 :amount 850.1 :type \"debit\"}})\n\n(require '[clojure.set :as s])\n\n;; Clojure equivalent of the SQL:\n;; SELECT users.user-id, accounts.acc-id, \n;;        users.type as type, accounts,type as atype\n;; FROM users\n;; INNER JOIN accounts ON users.user-id = accounts.user-id;\n\n(s/project\n  (s/join users (s/rename accounts {:type :atype}))\n  [:user-id :acc-id :type :atype])\n\n;; #{{:user-id 1, :acc-id 1, :type \"personal\", :atype \"saving\"}\n;;   {:user-id 2, :acc-id 2, :type \"company\", :atype \"saving\"}\n;;   {:user-id 1, :acc-id 3, :type \"personal\", :atype \"debit\"}}\n\n"], :notes nil, :arglists ["xrel yrel" "xrel yrel km"], :doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/join"}, :clojure.core/short-array {:added "1.1", :ns "clojure.core", :name "short-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/shorts], :line 5249, :examples [";; create an array of shorts using short-array\n;; and demonstrate how it can be used with the java Arrays functions\n;; (note the needed coercions)\n\nuser=> (def ss (short-array (map short (range 3 10))))\n#'user/ss\nuser=> (type ss)\n[S\nuser=> (vec ss)\n[3 4 5 6 7 8 9]\nuser=> (java.util.Arrays/binarySearch ss (short 6))\n3\nuser=> (java.util.Arrays/fill ss (short 99))\nnil\nuser=> (vec ss)\n[99 99 99 99 99 99 99]\nuser=>"], :notes nil, :arglists ["size-or-seq" "size init-val-or-seq"], :doc "Creates an array of shorts", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/short-array"}, :clojure.core/set-validator! {:added "1.0", :ns "clojure.core", :name "set-validator!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/atom :clojure.core/agent :clojure.core/ref], :line 2381, :examples ["user=> (def atm (atom [2])\n#'user/atm\n\nuser=> (set-validator! atm #(every? even? %))\nnil\n\nuser=> (swap! atm into [5])\n#<CompilerException java.lang.IllegalStateException: Invalid reference state (NO_SOURCE_FILE:0)>\n\nuser=> (set-validator! atm nil)\nnil\n\nuser=> (swap! atm into [5]))\n[2 5]" "user=> (def a 1)\n#'user/a\n\nuser=> (set-validator! (var a) (fn [update-result] (< update-result 3)))\nnil\n\nuser=> (alter-var-root (var a) inc)\n2\n\nuser=> (alter-var-root (var a) inc)\nIllegalStateException Invalid reference state  clojure.lang.ARef.validate (ARef.java:33)\n\nuser=> a\n2"], :notes ["If you want your validator to throw an exception with a useful message, make sure it is a RuntimeException (or subclass), otherwise ARef#validate will throw an IllegalStateException with a generic message."], :arglists ["iref validator-fn"], :doc "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set-validator!"}, :clojure.core/import {:added "1.0", :ns "clojure.core", :name "import", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/require :clojure.core/use :clojure.core/ns], :line 3417, :examples ["user=> (import java.util.Date)\njava.util.Date\n\nuser=> (def *now* (Date.))\n#'user/*now*\n\nuser=> (str *now*)\n\"Tue Jul 13 17:53:54 IST 2010\"\n" ";; Multiple imports at once.\n(import (java.util Date Calendar)\n        (java.net URI ServerSocket)\n        java.sql.DriverManager)" ";; importing multiple classes in a namespace\n(ns foo.bar\n  (:import (java.util Date\n                      Calendar)\n           (java.util.logging Logger\n                              Level)))" "\n;; For cases when 'import' does not do it for you, i.e. \"live-coding\"\n;; You can use the DynamicClassLoader, ClassReader and the Resolver.\n;; https://github.com/clojure/clojure\n\n(def dcl (clojure.lang.DynamicClassLoader.))\n\n(defn dynamically-load-class! \n  [class-loader class-name]\n  (let [class-reader (clojure.asm.ClassReader. class-name)]\n    (when class-reader\n      (let [bytes (.-b class-reader)]\n        (.defineClass class-loader \n                      class-name \n                      bytes\n                      \"\")))))\n\n(dynamically-load-class! dcl \"java.lang.Long\")\n(dynamically-load-class! dcl 'org.joda.time.DateTime)\n\n;; From that point the dynamically loaded class can be\n;; used by the Reflector to invoke constructors, methods and to get fields. "], :macro true, :notes ["Good description of use/require/import here:\r\n\r\nhttp://blog.8thlight.com/articles/2010/12/6/clojure-libs-and-namespaces-require-use-import-and-ns" "`import` will also accept vectors instead of lists, but I would discourage folks from doing so:\r\n\r\n* It's undocumented.\r\n* Lists and vectors have different meanings for `require`, so there's precedent for making a distinction.\r\n* Lists have a distinguished first element, and so they indent more meaningfully here. :-P"], :arglists ["& import-symbols-or-lists"], :doc "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/import"}, :clojure.core/add-classpath {:added "1.0", :ns "clojure.core", :name "add-classpath", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5092, :examples [";; There are alternatives\n\n;; https://github.com/cemerick/pomegranate\n\n;; http://grokbase.com/p/gg/clojure/12bnhbvmpy/how-to-add-an-url-into-the-classpath\n"], :deprecated "1.1", :notes nil, :arglists ["url"], :doc "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/add-classpath"}, :clojure.core/find {:added "1.0", :ns "clojure.core", :name "find", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get :clojure.core/get-in :clojure.core/contains?], :line 1526, :examples ["(find {:a 1 :b 2 :c 3} :a)\n;;=> [:a 1]\n\n(find {:a 1 :b 2 :c 3} :d)\n;;=> nil \n" "user=> (find [:a :b :c :d] 2)\n[2 :c]\n\nuser=> (find [:a :b :c :d] 5)\nnil"], :notes nil, :arglists ["map key"], :doc "Returns the map entry for key, or nil if key not present.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find"}, :clojure.spec.alpha/multi-spec-impl {:ns "clojure.spec.alpha", :name "multi-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 893, :examples nil, :notes nil, :arglists ["form mmvar retag" "form mmvar retag gfn"], :doc "Do not call this directly, use 'multi-spec'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/multi-spec-impl"}, :clojure.spec.alpha/tuple {:ns "clojure.spec.alpha", :name "tuple", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 673, :examples nil, :macro true, :notes nil, :arglists ["& preds"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/tuple"}, :clojure.core/error-handler {:added "1.2", :ns "clojure.core", :name "error-handler", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/set-error-handler! :clojure.core/agent], :line 2196, :examples ["(def error-atom (atom []))\n\n(def a (agent \"\"\n              :validator string?\n              :error-handler (fn [agnt ex]\n                               (swap! error-atom\n                                      conj\n                                      {:agent agnt\n                                       :exception (.getMessage ex)}))))\n\n(send a 1) ;; will fail validation\n\n@error-atom\n[{:agent #<Agent@c47f284: \"\">,\n  :exception \"java.lang.Long cannot be cast to clojure.lang.IFn\"}]\n\n(error-handler a)\n#<core$fn__11922 user$fn__11922@2a6b59c>"], :notes nil, :arglists ["a"], :doc "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/error-handler"}, :clojure.core/*in* {:added "1.0", :ns "clojure.core", :name "*in*", :type "var", :see-alsos [:clojure.core/*out*], :examples nil, :notes nil, :arglists [], :doc "A java.io.Reader object representing standard input for read operations.\n\n  Defaults to System/in, wrapped in a LineNumberingPushbackReader", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*in*"}, :clojure.pprint/write {:added "1.2", :ns "clojure.pprint", :name "write", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos [:clojure.pprint/pprint], :line 197, :examples [";; Same as pprint but taking configuration directives.\n(require '[clojure.pprint :as p])\n\n;; Prints the number in binary with indication of the base as \"#b\".\n(p/write 20/3 :base 2 :radix true) \n;; #b10100/11\n\n;; Pretty looking truncation of lists longer than 3.\n(p/write (range 100) :length 3) \n;; (0 1 2 ...)\n\n;; Removes namespaces from symbols when printing.\n(p/write 'clojure.core/+ :suppress-namespaces true) \n;; +\n\n;; Avoids anything beyond 10 right margin.\n(p/write [:a :b :c :d] :right-margin 10)\n;; [:a\n;;  :b\n;;  :c\n;;  :d]\n"], :notes nil, :arglists ["object & kw-args"], :doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/write"}, :clojure.core/read-line {:added "1.0", :ns "clojure.core", :name "read-line", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/flush], :line 3762, :examples ["user=> (read-line)\nline to be read      ;Type text into console\n\"line to be read\"\n" "; (flush) is needed for displaying the prompt. Print stays in a buffer otherwise.\nuser=> (do (print \"What's your name? \") (flush) (read-line))\nWhat's your name? Clojure\n\"Clojure\"\n" "(println \"Enter something> \")\n(def x (read-line))\n(println (str \"You typed \\\"\" x \"\\\"\"))"], :notes ["Be aware that `read-line` uses Java’s `BufferedReader`’s `.readLine` method that itself uses an internal buffer of either 4k or 8k. That causes `(read-line)` to return a truncated string if you try to read a large line."], :arglists [""], :doc "Reads the next line from stream that is the current value of *in* .", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/read-line"}, :clojure.core/inst-ms {:added "1.9", :ns "clojure.core", :name "inst-ms", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/inst?], :line 6711, :examples ["(inst-ms (java.util.Date.))\n;;=> 1495636054438\n(inst-ms (java.time.Instant/now))\n;;=> 1495636054438\n\n(inst-ms (java.sql.Date. 1495636054438))\n;;=> 1495636054438\n(inst-ms (java.sql.Timestamp. 1495636054438))\n;;=> 1495636054438"], :notes nil, :arglists ["inst"], :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/inst-ms"}, :clojure.core/object-array {:added "1.2", :ns "clojure.core", :name "object-array", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 5265, :examples [";; create an array of Java Objects using object-array\n;; and demonstrate that it can be used with the Java fill function\n\nuser=> (def os (object-array [nil 23.2 \"abc\" 33]))\n#'user/os\nuser=> (vec os)\n[nil 23.2 \"abc\" 33]\nuser=> (java.util.Arrays/fill os 31415)\nnil\nuser=> (vec os)\n[31415 31415 31415 31415]\nuser=>"], :notes nil, :arglists ["size-or-seq"], :doc "Creates an array of objects", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/object-array"}, :clojure.core.logic/var-rands {:ns "clojure.core.logic", :name "var-rands", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 91, :examples nil, :notes nil, :arglists ["a c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/var-rands"}, :clojure.core/var-set {:added "1.0", :ns "clojure.core", :name "var-set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-local-vars], :line 4299, :examples ["(with-local-vars [x nil]\n  (println @x)\n  (var-set x 1)\n  (println @x))\n;;=> nil\n;;=> 1\n"], :notes nil, :arglists ["x val"], :doc "Sets the value in the var object to val. The var must be\n thread-locally bound.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/var-set"}, :clojure.spec.alpha/explain-data {:ns "clojure.spec.alpha", :name "explain-data", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 204, :examples nil, :notes nil, :arglists ["spec x"], :doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain-data"}, :clojure.zip/rightmost {:added "1.0", :ns "clojure.zip", :name "rightmost", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/leftmost], :line 157, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the rightmost sibling of the node at this loc, or self", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/rightmost"}, :clojure.data/equality-partition {:added "1.3", :ns "clojure.data", :name "equality-partition", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["x"], :doc "Implementation detail. Subject to change.", :library-url "https://github.com/clojure/clojure", :href "/clojure.data/equality-partition"}, :clojure.core/partition-all {:added "1.2", :ns "clojure.core", :name "partition-all", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/partition :clojure.core/partition-by], :line 7160, :examples ["(partition 4 [0 1 2 3 4 5 6 7 8 9])\n;;=> ((0 1 2 3) (4 5 6 7))\n\n(partition-all 4 [0 1 2 3 4 5 6 7 8 9])\n;;=> ((0 1 2 3) (4 5 6 7) (8 9))\n" "(partition-all 2 4 [0 1 2 3 4 5 6 7 8 9])\n;;=> ((0 1) (4 5) (8 9))" ";; Caution: Partitioning lazy sequence code freeze\n\n(def l [1 2 3 4 5])\n;create a simple lazy sequence function testing only\n;(rdr l) returns a lazy sequence from l\n(def rdr (fn reader[x] (cons (first x) (lazy-seq (reader  (rest x))))))\n\n;the line below will freeze\n(doall (partition-all 2 (rdr l)) )\n\n;add-in a take-while statement do exit the lazy sequence on nil\n(doall (partition-all 2 (take-while (complement nil?) (rdr l))))"], :notes nil, :arglists ["n" "n coll" "n step coll"], :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/partition-all"}, :clojure.spec.alpha/def-impl {:ns "clojure.spec.alpha", :name "def-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 309, :examples nil, :notes nil, :arglists ["k form spec"], :doc "Do not call this directly, use 'def'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/def-impl"}, :clojure.core.logic/lcons? {:ns "clojure.core.logic", :name "lcons?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 875, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lcons_q"}, :clojure.core/clear-agent-errors {:added "1.0", :ns "clojure.core", :name "clear-agent-errors", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/restart-agent], :line 2238, :examples nil, :deprecated "1.2", :notes nil, :arglists ["a"], :doc "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/clear-agent-errors"}, :clojure.core/halt-when {:added "1.9", :ns "clojure.core", :name "halt-when", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7551, :examples ["(def letters (set \"abcdefghijklmnopqrstuvwxyz\"))\n(def vowels (set \"aeiou\"))\n\n;; Remove the vowels from a string.\n(transduce (remove vowels) str \"hello\")\n;;=> \"hll\"\n\n;; Same, but halt when seeing a non-letter (and return that non-letter).\n(transduce (comp (remove vowels) (halt-when (complement letters)))\n           str \"hello\")\n;;=> \"hll\"\n(transduce (comp (remove vowels) (halt-when (complement letters)))\n           str \"hello world\")\n;;=> \\space\n" ";; \"halt-when\" can only really be used with \"transduce\", but not with other\n;; functions that support transducers like \"into\" or \"sequence\".\n\n(def v (vec (concat (range 5) [:x])))\n(def xf (comp (take 10) (halt-when keyword?) (map inc)))\n\n(transduce xf conj [] v)\n;;=> :x\n\n(into [] xf v)\n;;=> ClassCastException!\n\n(sequence xf v)\n;;=> (1 2 3 4 5), wrong result!\n"], :notes ["`halt-when` is an odd transducer in that it is supposed to be used with `transduce`, but not in other transducible contexts like `sequence` or `into`.\n\nSays Alex Miller at https://dev.clojure.org/jira/browse/CLJ-1451: ‘Yeah, halt-when is a little tricky to use in transducible contexts other than transduce.’ Some more discussion at https://groups.google.com/d/msg/clojure/6HvmJIUsXKk/gLqUsfcnAwAJ.\n"], :arglists ["pred" "pred retf"], :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/halt-when"}, :clojure.core/special-symbol? {:added "1.0", :ns "clojure.core", :name "special-symbol?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 4908, :examples ["user=> (clojure-version)\n\"1.4.0\"\n;; the set of special symbols for this clojure-version are the following:\nuser=> (keys (. clojure.lang.Compiler specials))\n(deftype* new quote & var set! monitor-enter recur . case* clojure.core/import* reify* do fn* throw monitor-exit letfn* finally let* loop* try catch if def)\n\n;; for example, \"def\" is not a function, not a macro, not even a var, but a special form:\nuser=> (fn? 'def)\nfalse\nuser=> (:macro (meta (find-var 'clojure.core/def)))\nnil\nuser=> (find-var 'clojure.core/def)\nnil\nuser=> (special-symbol? 'def)\ntrue\n\n;; while \"defn\" is not a special form but a macro:\nuser=> (special-symbol? 'defn)\nfalse\nuser=> (:macro (meta (find-var 'clojure.core/defn)))\ntrue\n"], :notes nil, :arglists ["s"], :doc "Returns true if s names a special form", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/special-symbol_q"}, :clojure.core/mapv {:added "1.4", :ns "clojure.core", :name "mapv", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/map :clojure.core/vec :clojure.core/reduce :clojure.core/pmap], :line 6823, :examples ["(mapv inc [1 2 3 4 5])\n;;=> [2 3 4 5 6]\n\n\n;; mapv can be used with multiple collections. Collections will be consumed\n;; and passed to the mapping function in parallel:\n(mapv + [1 2 3] [4 5 6])\n;;=> [5 7 9]\n\n\n;; When mapv is passed more than one collection, the mapping function will\n;; be applied until one of the collections runs out:\n(mapv + [1 2 3] (iterate inc 1))\n;;=> [2 4 6]\n\n\n\n;; mapv is often used in conjunction with the # reader macro:\n(mapv #(str \"Hello \" % \"!\" ) [\"Ford\" \"Arthur\" \"Tricia\"])\n;;=> [\"Hello Ford!\" \"Hello Arthur!\" \"Hello Tricia!\"]\n\n;; A useful idiom to pull \"columns\" out of a collection of collections. \n;; Note, it is equivalent to:\n;; (mapv vector [:a :b :c] [:d :e :f] [:g :h :i])\n\n(apply mapv vector [[:a :b :c]\n                    [:d :e :f]\n                    [:g :h :i]])\n;;=> [[:a :d :g] [:b :e :h] [:c :f :i]]"], :notes ["Like `map` but returns a vector. In most cases equivalent to calling `(into [] (map f c1 c2 ...))`. Is much faster than map (but is not lazy!) in the `(mapv f coll)` case."], :arglists ["f coll" "f c1 c2" "f c1 c2 c3" "f c1 c2 c3 & colls"], :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/mapv"}, :clojure.spec.alpha/assert {:ns "clojure.spec.alpha", :name "assert", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos [:clojure.core/assert], :line 1923, :examples nil, :macro true, :notes nil, :arglists ["spec x"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an ex-info with explain-data plus ::failure of\n:assertion-failed.\n\nCan be disabled at either compile time or runtime:\n\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto value of 'clojure.spec.compile-asserts' system property, or true if\nnot set.\n\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'clojure.spec.check-asserts' system property, or false if not\nset. You can toggle check-asserts? with (check-asserts bool).", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/assert"}, :clojure.core/set {:added "1.0", :ns "clojure.core", :name "set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/hash-set :clojure.core/sorted-set :clojure.core/conj :clojure.set/join :clojure.set/select :clojure.set/difference :clojure.set/intersection :clojure.set/union :clojure.set/index :clojure.set/project :clojure.set/rename :clojure.set/rename-keys :clojure.set/map-invert :clojure.core/disj :clojure.core/distinct], :line 4071, :examples [";; returns distinct elements\nuser=> (set '(1 1 2 3 2 4 5 5))\n#{1 2 3 4 5}\n\n;; returns distinct elements (different nomenclature)\nuser=> (set [1 1 2 3 2 4 5 5])\n#{1 2 3 4 5}\n\nuser=> (set [1 2 3 4 5])  \n#{1 2 3 4 5}\n\nuser=> (set \"abcd\")\n#{\\a \\b \\c \\d}\n\nuser=> (set '(\"a\" \"b\" \"c\" \"d\"))\n#{\"a\" \"b\" \"c\" \"d\"}\n\nuser=> (set {:one 1 :two 2 :three 3})\n#{[:two 2] [:three 3] [:one 1]}\n\nuser=> (set nil)\n#{}" "(set [1 2 3 2 1 2 3])\n-> #{1 2 3}\n\n#{:a :b :c :d}\n-> #{:d :a :b :c}\n\n(hash-set :a :b :c :d)\n-> #{:d :a :b :c}\n \n(sorted-set :a :b :c :d)\n-> #{:a :b :c :d}\n\n;------------------------------------------------\n\n(def s #{:a :b :c :d})\n(conj s :e)\n-> #{:d :a :b :e :c}\n \n(count s)\n-> 4\n \n(seq s)\n-> (:d :a :b :c)\n \n(= (conj s :e) #{:a :b :c :d :e})\n-> true\n\n(s :b)\n-> :b\n \n(s :k)\n-> nil"], :notes ["The documentation doesn't mention the order, is it undefined?\r\n\r\n#{:a :b :c :d}\r\n-> #{:d :a :b :c}\r\n" "Sets are a core data structure that by definition do not store elements in a sorted order. The actual order will ultimately be determined by the specific hashing function underpinning the data structure. "], :arglists ["coll"], :doc "Returns a set of the distinct elements of coll.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set"}, :clojure.main/with-read-known {:ns "clojure.main", :name "with-read-known", :file "clojure/main.clj", :type "macro", :column 1, :see-alsos nil, :line 170, :examples nil, :macro true, :notes nil, :arglists ["& body"], :doc "Evaluates body with *read-eval* set to a \"known\" value,\n   i.e. substituting true for :unknown if necessary.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/with-read-known"}, :clojure.core.logic/entailed? {:ns "clojure.core.logic", :name "entailed?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2064, :examples nil, :notes nil, :arglists ["c c' a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/entailed_q"}, :clojure.set/select {:added "1.0", :ns "clojure.set", :name "select", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.core/filter], :line 65, :examples ["(clojure.set/select odd? #{1 2 3})\n;;=> #{1 3}\n"], :notes nil, :arglists ["pred xset"], :doc "Returns a set of the elements for which pred is true", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/select"}, :clojure.core/true? {:added "1.0", :ns "clojure.core", :name "true?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/false? :clojure.core/boolean], :line 512, :examples ["user=> (true? true)\ntrue\nuser=> (true? 1)\nfalse\nuser=> (true? (= 1 1))\ntrue"], :notes nil, :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true if x is the value true, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/true_q"}, :clojure.core.logic.fd/->FiniteDomain {:ns "clojure.core.logic.fd", :name "->FiniteDomain", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 64, :examples nil, :notes nil, :arglists ["s min max"], :doc "Positional factory function for class clojure.core.logic.fd.FiniteDomain.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/->FiniteDomain"}, :clojure.reflect/typename {:ns "clojure.reflect", :name "typename", :type "function", :see-alsos [:clojure.reflect/reflect :clojure.reflect/do-reflect :clojure.reflect/type-reflect], :examples ["(require '[clojure.reflect :as cr])\n\n;; It returns the class name as a string. \n(->> java.lang.Integer \n     cr/typename)\n;;=> \"java.lang.Integer\""], :notes nil, :arglists ["o"], :doc "Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/typename"}, :clojure.zip/path {:added "1.0", :ns "clojure.zip", :name "path", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 90, :examples ["\n(def nested-vecs\n  [:foo\n   [:bar :baz [:bork]]])\n\n;; now let's make a zipper\n (def z\n  (zip/vector-zip nested-vecs))\n\n\n\n\n;; node and path co-relation for zippers\n\n(-> z\n    zip/down ;; :foo => [[:foo [:bar :baz [:bork]]]]\n    zip/right ;; [:bar :baz [:bork]] => [[:foo [:bar :baz [:bork]]]]\n    zip/down ;; :bar => [[:foo [:bar :baz [:bork]]] [:bar :baz [:bork]]]\n    zip/right ;; :baz => [[:foo [:bar :baz [:bork]]] [:bar :baz [:bork]]]\n    zip/right ;; [:bork] => [[:foo [:bar :baz [:bork]]] [:bar :baz [:bork]]]\n    zip/down ;; :bork => [[:foo [:bar :baz [:bork]]] [:bar :baz [:bork]] [:bork]]\n    zip/node\n    ;zip/path\n    #_pprint)\n\n\n"], :notes nil, :arglists ["loc"], :doc "Returns a seq of nodes leading to this loc", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/path"}, :clojure.core/bit-set {:added "1.0", :ns "clojure.core", :name "bit-set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bit-test :clojure.core/bit-clear], :line 1329, :examples ["user=> (bit-set 2r1011 2) ; index is 0-based\n15 \n;; 15 = 2r1111\n\n;; the same in decimal\nuser=> (bit-set 11 2) \n15" ";; Returns a long, like all Clojure bit operations\nuser=> (bit-set 0 63)\n-9223372036854775808\n; A signed 64-bit number with only the sign bit (most significant bit) on.\n; This is the most negative number representable by signed 64 bits: -(2**63).\n; Same as:\nuser=> (bit-shift-left 1 63)\n-9223372036854775808\n\n;; And in case you forget your common powers to two, here's a reference ^^\nuser=> (bit-set 0 32)\n4294967296\nuser=> (bit-set 0 16)\n65536\nuser=> (bit-set 0 8)\n256\nuser=> (bit-set 0 4)\n16"], :notes nil, :arglists ["x n"], :doc "Set bit at index n", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-set"}, :clojure.core/bit-xor {:added "1.0", :ns "clojure.core", :name "bit-xor", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-and :clojure.core/bit-or], :line 1303, :examples [";; set bits to 1 where bits of the arguments are different\nuser=> (bit-xor 2r1100 2r1001) \n5 \n;; 5 = 2r0101\n\n" ";; here is the truth table for XOR \n(Integer/toBinaryString (bit-xor 2r1100 2r1010) )\n;;=> \"110\"\n;; or 2r0110"], :notes nil, :arglists ["x y" "x y & more"], :doc "Bitwise exclusive or", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-xor"}, :clojure.core/numerator {:added "1.2", :ns "clojure.core", :name "numerator", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/denominator], :line 3574, :examples [";; note that the function always returns the numerator of the reduced fraction\n\nuser=> (map numerator [(/ 2 4) (/ 4 6) (/ 6 8)])\n(1 2 3)\n"], :notes nil, :tag "java.math.BigInteger", :arglists ["r"], :doc "Returns the numerator part of a Ratio.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/numerator"}, :clojure.spec.alpha/explain {:ns "clojure.spec.alpha", :name "explain", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 247, :examples nil, :notes nil, :arglists ["spec x"], :doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/explain"}, :clojure.core.logic/fresh {:ns "clojure.core.logic", :name "fresh", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1207, :examples nil, :macro true, :notes nil, :arglists ["[& lvars] & goals"], :doc "Creates fresh variables. Goals occuring within form a logical\n  conjunction.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fresh"}, :clojure.core/unchecked-subtract-int {:added "1.0", :ns "clojure.core", :name "unchecked-subtract-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/unchecked-add-int], :line 1197, :examples [";; Subtracting two int-range Longs works\n(unchecked-subtract-int 1 1)\n;;=> 0\n\n;; Subtracting two int-range BigInts works\n(unchecked-subtract-int 1N 1N)\n;;=> 0\n\n;; Doubles are truncated\n(unchecked-subtract-int 1 1.9)\n;;=> 0\n\n;; BigDecimals are truncated\n(unchecked-subtract-int 1 1.9M)\n;;=> 0\n\n;; Uncaught integer overflow\n(unchecked-subtract-int Integer/MAX_VALUE -1)\n;;=> -2147483648\n\n;; Uncaught integer underflow\n(unchecked-subtract-int Integer/MIN_VALUE 1)\n;;=> 2147483647\n\n;; Fails for Longs outside of int range\n(unchecked-subtract-int 2147483648 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for BigInts outside of int range\n(unchecked-subtract-int 2147483648N 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for Doubles outside of int range\n(unchecked-subtract-int 2147483648.0 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for BigDecimals outside of int range\n(unchecked-subtract-int 2147483648.0M 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)"], :notes nil, :arglists ["x y"], :doc "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-subtract-int"}, :clojure.core/unsigned-bit-shift-right {:added "1.6", :ns "clojure.core", :name "unsigned-bit-shift-right", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-shift-right], :line 1360, :examples ["user=> (format \"%016x\" -1)\n\"ffffffffffffffff\"\n\n;; bit-shift-right sign extends most significant bit while right shifting.\nuser=> (format \"%016x\" (bit-shift-right -1 10))\n\"ffffffffffffffff\"\n\n;; unsigned-bit-shift-right fills most significant bits of result with 0.\n;; No sign extension.\nuser=> (format \"%016x\" (unsigned-bit-shift-right -1 10))\n\"003fffffffffffff\"\n" ";; Warning: unsigned-bit-shift-right, like bit-shift-right, treats inputs as\n;; type Long. Smaller types like byte, short, and int will not behave as such.\n(format \"0x%x\" (byte -128))\n; => \"0x80\"\n(format \"0x%x\" (unsigned-bit-shift-right (byte -128) 1))\n; => \"0x7fffffffffffffc0\"\n(format \"0x%x\" (bit-shift-right (byte -128) 1))\n; => \"0xffffffffffffffc0\"\n\n; If you expected 0x40, you need to upcast your byte yourself, via bit-and,\n; and only then shift:\n(format \"0x%x\" (bit-shift-right (bit-and 0xff (byte -128)) 1))\n; => \"0x40\"" ";; Stein's Algorithm (Binary GCD)\n;; https://en.wikipedia.org/wiki/Binary_GCD_algorithm\n\n\n(defn gcd [a b]\n  (cond\n    (zero? a) b\n    (zero? b) a\n    (neg? a) (- a)\n    (neg? b) (- b)\n    (and (even? a) (even? b)) (* 2\n                                 (gcd (unsigned-bit-shift-right a 1)\n                                      (unsigned-bit-shift-right b 1)))\n    (and (even? a) (odd? b)) (recur (unsigned-bit-shift-right a 1) b)\n    (and (odd? a) (even? b)) (recur a (unsigned-bit-shift-right b 1))\n    (and (odd? a) (odd? b)) (recur (unsigned-bit-shift-right\n                                    (Math/abs (long (- a b))) ;; coerce to avoid reflection\n                                    1) (min a b))))\n"], :notes nil, :arglists ["x n"], :doc "Bitwise shift right, without sign-extension.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unsigned-bit-shift-right"}, :clojure.core/contains? {:added "1.0", :ns "clojure.core", :name "contains?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/some :clojure.core/get], :line 1476, :examples [";; `contains?` is straightforward for maps:\n(contains? {:a 1} :a)    ;=> true\n(contains? {:a nil} :a)  ;=> true\n(contains? {:a 1} :b)    ;=> false\n\n;; It's likely to surprise you for other sequences because it's \n;; about *indices* or *keys*, not *contents*:\n\n(contains? [:a :b :c] :b)  ;=> false\n(contains? [:a :b :c] 2)   ;=> true\n(contains? \"f\" 0)          ;=> true\n(contains? \"f\" 1)          ;=> false\n\n;; Although lists are sequences, they are not keyed sequences.\n;; `contains?` should not be used for lists.\n\n(contains? '(1 2 3) 1)   \n;; IllegalArgumentException (Clojure >=1.5)\n\n;; It also works on native arrays, HashMaps or HashSets:\n(import '[java.util HashMap HashSet])\n(contains? (doto (HashSet.) (.add 1)) 1) ;=> true\n(contains? (doto (HashMap.) (.put \"a\" 1)) \"a\") ;=> true\n(contains? (int-array [1 2 3]) 0) ;=> true" ";; Can be used to test set membership\n(def s #{\"a\" \"b\" \"c\"})\n\n;; The members of a set are the keys of those elements.\n(contains? s \"a\")   ;=> true\n(contains? s \"z\")   ;=> false" ";; When \"key\" is a number, it is expected to be an integer. \n;; Beyond that limit, lossy truncation may result in unexpected results:\n\n(contains? [1 2 3] 4294967296) ;=> true"], :notes ["If like me you wanted to find a value in a collection and read this article then you'll need to find an alternative.  So instead of:\r\n<pre>\r\n(contains (1 2 3) 1)\r\n</pre>\r\nI used:\r\n<pre>\r\n(some #(= 1 %) (1 2 3))\r\n</pre>\r\n\r\nHope that helps." "For collections I use the `java.util.Collection#contains()` method:\r\n\r\n<pre>\r\nuser=> (.contains [1 2 3] 1)\r\ntrue\r\nuser=> (.contains [1 2 3] 4)\r\nfalse\r\n</pre>" "As Rich points out on the ML: \r\n\r\n`contains?` tells you whether or not `get` will succeed. It is not a \"rummager\".\r\n\r\n`contains?` and `get` abstract over fast lookup.\r\n" "If you have a vector or list and want to check whether a *value* is contained in it, you will find that `contains?` does not work.\r\n\r\n<pre>; does not work as you might expect\r\n(contains? [:a :b :c] :b) ; = false</pre>\r\n\r\nThere are four things you can try in this case:\r\n\r\n1. Consider whether you really need a vector or list. If you use a set instead, `contains?` will work.\r\n   <pre>(contains? #{:a :b :c} :b) ; = true</pre>\r\n2. Use [`some`](http://clojuredocs.org/clojure_core/clojure.core/some) instead, wrapping the target in a set, as follows:\r\n   <pre>(some #{:b} [:a :b :c]) ; = :b, which is truthy</pre>\r\n3. The set-as-function shortcut will not work if you might be searching for a falsy value (`false` or `nil`).\r\n   <pre>; will not work\r\n(some #{false} [true false true]) ; = nil</pre>\r\n   In that case, you will have to write the predicate function the long way:\r\n   <pre>(some #(= false %) [true false true]) ; = true</pre>\r\n4. If you will need to do this kind of search a lot, write a function for it:\r\n   <pre>(defn seq-contains? [coll target] (some #(= target %) coll))\r\n(seq-contains? [true false true] false) ; = true</pre>" "In order to determine if an element is contained in the collection, it may be easiest to use the `Vector.indexOf()` function from java:\n\n    (.indexOf (range 10) 5)\n    ;=> 5\n    (.indexOf [:a :b :c] :b)\n    ;=> 1\n\n[Java API Docs are here](http://docs.oracle.com/javase/7/docs/api/java/util/Vector.html#indexOf%28java.lang.Object%29)" "You may wonder why this statement evaluates to true:<br/>\n<code>\n(contains? [1 1 1 1 1] 4)<br/>\n;=> true\n</code>\n\nLet's do some investigation to find the answer. First we start by finding out the type of <code>[1 1 1 1 1]</code>:\n<code>\n(class [1 1 1 1 1])<br/>\n;=> clojure.lang.PersistentVector\n</code>\n\nSo when the statement <code>(contains? [1 1 1 1 1] 4)</code> is evaluated, the function <code>contains?</code> in <a href=\"https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj\">core.clj</a> is called.\n\nThis function delegates to the static Java function <code>contains(Object coll, Object key)</code> in <a href=\"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/RT.java\">clojure.lang.RT</a>, which discovers that the incoming vector is an instance of Associative (<a href=\"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentVector.java\">PersistentVector</a> > <a href=\"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/APersistentVector.java\">APersistentVector</a> > <a href=\"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/IPersistentVector.java\">IPersistentVector</a> > <a href=\"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Associative.java\">Associative</a>) and exits with:<br/>\n<code>\nreturn ((Associative) coll).containsKey(key)\n</code>\n\nThis means that these two statements are equivalent, based on the current implementation of PersistentVector:<br/>\n<code>\n(contains? [1 1 1 1 1] 4) ; true<br/>\n(.containsKey [1 1 1 1 1 1] 4) ; true\n</code>\n\nThe method containsKey of APersistentVector is finally called. It checks if the vector has at least four elements (size >= 4) which it has (5) and that's why it returns true. Mystery solved!\n"], :arglists ["coll key"], :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/contains_q"}, :clojure.zip/left {:added "1.0", :ns "clojure.zip", :name "left", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 166, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the left sibling of the node at this loc, or nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/left"}, :clojure.spec.alpha/alt-impl {:ns "clojure.spec.alpha", :name "alt-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1394, :examples nil, :notes nil, :arglists ["ks ps forms"], :doc "Do not call this directly, use 'alt'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/alt-impl"}, :clojure.core.async/mapcat> {:ns "clojure.core.async", :name "mapcat>", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 1111, :examples nil, :deprecated "0.1.319.0-6b1aca-alpha", :notes nil, :arglists ["f out" "f out buf-or-n"], :doc "Deprecated - this function will be removed. Use transducer instead", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/mapcat>"}, :clojure.spec.alpha/gen* {:ns "clojure.spec.alpha", :name "gen*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec overrides path rmap"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/gen*"}, :clojure.core/unchecked-remainder-int {:added "1.0", :ns "clojure.core", :name "unchecked-remainder-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1232, :examples nil, :notes nil, :arglists ["x y"], :doc "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-remainder-int"}, :clojure.java.browse/*open-url-script* {:ns "clojure.java.browse", :name "*open-url-script*", :file "clojure/java/browse.clj", :type "var", :column 1, :see-alsos [:clojure.java.browse/browse-url], :dynamic true, :line 40, :examples [";; Sets the script used when calling browse-url\n;;\n;; It needs to be an atom because internally the browse-url function\n;; dereferences *open-url-script*\n(binding [clojure.java.browse/*open-url-script* (atom \"/usr/bin/ls\")]\n  (clojure.java.browse/browse-url \"http://google.com\"))"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.browse/*open-url-script*"}, :clojure.spec.alpha/exercise-fn {:ns "clojure.spec.alpha", :name "exercise-fn", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1823, :examples nil, :notes nil, :arglists ["sym" "sym n" "sym-or-f n fspec"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/exercise-fn"}, :clojure.core/cond->> {:added "1.5", :ns "clojure.core", :name "cond->>", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/cond-> :clojure.core/as-> :clojure.core/-> :clojure.core/->> :clojure.core/cond :clojure.core/case], :line 7475, :examples [";; useful for when you want to control doing a bunch of things to a lazy sequence \n;; based on some conditions or, commonly, keyword arguments to a function.\n\n(defn do-stuff\n  [coll {:keys [map-fn max-num-things batch-size]}]\n  (cond->> coll\n    map-fn         (map map-fn)\n    max-num-things (take max-num-things)\n    batch-size     (partition batch-size)))\n\nuser=> (do-stuff [1 2 3 4] {})\n[1 2 3 4]\nuser=> (do-stuff [1 2 3 4] {:map-fn str})\n(\"1\" \"2\" \"3\" \"4\")\nuser=> (do-stuff [1 2 3 4] {:map-fn str :batch-size 2})\n((\"1\" \"2\") (\"3\" \"4\"))\nuser=> (do-stuff [1 2 3 4] {:map-fn str :max-num-things 3})\n(\"1\" \"2\" \"3\")"], :macro true, :notes nil, :arglists ["expr & clauses"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cond->>"}, :clojure.core.logic/partial-map {:ns "clojure.core.logic", :name "partial-map", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos [:clojure.core.logic/featurec], :line 2536, :examples nil, :notes nil, :arglists ["m"], :doc "Given map m, returns partial map that unifies with maps even if it\n   doesn't share all of the keys of that map.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/partial-map"}, :clojure.core.logic/lvaro {:ns "clojure.core.logic", :name "lvaro", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1448, :examples nil, :macro true, :notes nil, :arglists ["v"], :doc "A goal that succeeds if the argument is fresh. v must be a logic\n  variable. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/lvaro"}, :clojure.core.logic/distincto {:ns "clojure.core.logic", :name "distincto", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2472, :examples nil, :notes nil, :arglists ["l"], :doc "A relation which guarantees no element of l will unify\n   with another element of l.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/distincto"}, :clojure.core/-reset-methods {:ns "clojure.core", :name "-reset-methods", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 617, :examples nil, :notes nil, :arglists ["protocol"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/-reset-methods"}, :clojure.core/when-first {:added "1.0", :ns "clojure.core", :name "when-first", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/when-let], :line 4566, :examples ["user=> (when-first [a [1 2 3]] a)\n1\nuser=> (when-first [a []] :x)\nnil\nuser=> (when-first [a nil] :x)\nnil" ";; Note that the 'when' switches on the truthiness of the sequence, not the\n;; truthiness of the elements within the sequence.\n\nuser=> (when-first [a [nil 2 3]] \n         (print (str \"Picked: \" (prn-str a))))\nPicked: nil\nnil" ";; A concise way to write the basic lazy loop.\n\n(defn dechunk [xs]\n  (lazy-seq\n    (when-first [x xs]\n      (cons x\n        (dechunk (rest xs))))))\n\n;; would print 32 dots otherwise:\n(first (map #(do (print \".\") %) (dechunk (range 100))))\n;; .0"], :macro true, :notes nil, :arglists ["bindings & body"], :doc "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/when-first"}, :clojure.core/vals {:added "1.0", :ns "clojure.core", :name "vals", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/val :clojure.core/keys :clojure.core/key :clojure.core/hash-map], :line 1553, :examples ["(vals {:a \"foo\", :b \"bar\"})\n;;=> (\"foo\" \"bar\")\n\n(vals {})\n;;=> nil\n\n(vals nil)\n;;=> nil" "(defn flatten-a-map [dpdnts-map]\n  (apply set/union (vals dpdnts-map)))\n\n(flatten-a-map {:e #{:m :f}, :c #{:f}, :b #{:c :f}, :d #{:m :f}, :a #{:c :f}}\n\n;;=> #{:m :c :f}"], :notes ["Functions keys and vals return sequences such that\r\n<pre>\r\n(= (zipmap (keys m) (vals m)) m)\r\n</pre>"], :arglists ["map"], :doc "Returns a sequence of the map's values, in the same order as (seq map).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vals"}, :clojure.test/test-vars {:added "1.6", :ns "clojure.test", :name "test-vars", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 722, :examples ["(clojure.test/test-vars [#'the-ns/the-test])\n\n;; credit to this SO answer by Alex Miller: https://stackoverflow.com/a/24974841/59439"], :notes nil, :arglists ["vars"], :doc "Groups vars by their namespace and runs test-vars on them with\n   appropriate fixtures applied.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/test-vars"}, :clojure.core/swap! {:added "1.0", :ns "clojure.core", :name "swap!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/atom :clojure.core/reset! :clojure.core/compare-and-set! :clojure.core/swap-vals!], :line 2337, :examples [";; make an atomic list\n(def players (atom ()))\n;; #'user/players\n\n;; conjoin a keyword into that list\n(swap! players conj :player1)\n;;=> (:player1)\n\n;; conjoin a second keyword into the list\n(swap! players conj :player2)\n;;=> (:player2 :player1)\n\n;; take a look at what is in the list\n(deref players)\n;;=> (:player2 :player1)" ";; how to: atomic counter \n(def counter (atom 0))\n;; #'user/counter\n\n(swap! counter inc)\n;;=> 1\n\n(swap! counter inc)\n;;=> 2" ";; swap map values\n(def m1 (atom {:a \"A\" :b \"B\"}))\n;; atom\n\n;; dereference the atom\n@m1\n;;=> {:a \"A\", :b \"B\"}\n\n;; notice that the value swapped in, is part of the returned value\n(swap! m1 assoc :a \"Aaay\")\n;;=> {:a \"Aaay\", :b \"B\"}" ";; increment a map value\n(def m1 (atom {:a \"A\" :b \"B\" :n 0}))\n;; atom\n\n;; dereference the atom\n@m1\n;;=> {:a \"A\", :b \"B\", :n 0}\n\n;; notice that the value swapped in, is part of the returned value\n(swap! m1 update-in [:n] inc)\n;;=> {:a \"A\", :b \"B\", :n 1}" "(def car\n  (atom {:make \"Audi\"\n         :model \"Q3\"}))\n\n@car\n;;{:make \"Audi\", :model \"Q3\"}\n\n(swap!\n car\n assoc :model \"Q5\")\n;;{:make \"Audi\", :model \"Q5\"}\n\n(swap!\n car\n update-in [:model] str \" Sport\")\n;;{:make \"Audi\", :model \"Q5 Sport\"}"], :notes ["If you want to swap the entire atom, user `reset!`."], :arglists ["atom f" "atom f x" "atom f x y" "atom f x y & args"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/swap!"}, :clojure.core/decimal? {:added "1.0", :ns "clojure.core", :name "decimal?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bigdec? :clojure.core/double? :clojure.core/float?], :line 3590, :examples ["user=> (decimal? 1)\nfalse\n\nuser=> (decimal? 1.0)\nfalse\n\nuser=> (decimal? 1M)\ntrue\n\nuser=> (decimal? 99999999999999999999999999999999999)\nfalse\n\nuser=> (decimal? 1.0M)\ntrue"], :notes nil, :arglists ["n"], :doc "Returns true if n is a BigDecimal", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/decimal_q"}, :clojure.core/merge-with {:added "1.0", :ns "clojure.core", :name "merge-with", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/merge], :line 3043, :examples ["(merge-with into\n\t  {\"Lisp\" [\"Common Lisp\" \"Clojure\"]\n\t   \"ML\" [\"Caml\" \"Objective Caml\"]}\n\t  {\"Lisp\" [\"Scheme\"]\n\t   \"ML\" [\"Standard ML\"]})\n;;=> {\"Lisp\" [\"Common Lisp\" \"Clojure\" \"Scheme\"], \"ML\" [\"Caml\" \"Objective Caml\" \"Standard ML\"]}" ";; merge two maps using the addition function\n\n(merge-with + \n            {:a 1  :b 2}\n            {:a 9  :b 98 :c 0})   \n;;=> {:c 0, :a 10, :b 100}" ";; 'merge-with' works with an arbitrary number of maps:\n\n(merge-with + \n           {:a 1  :b 2}\n           {:a 9  :b 98  :c 0}\n           {:a 10 :b 100 :c 10}\n           {:a 5}\n           {:c 5  :d 42})\n    \n;;=> {:d 42, :c 15, :a 25, :b 200}" ";; Use union to merge sets of elements\n(use 'clojure.set)\n(merge-with union\n            {:a #{1 2 3},   :b #{4 5 6}}\n            {:a #{2 3 7 8}, :c #{1 2 3}})\n\n;;=> {:c #{1 2 3}, :a #{1 2 3 7 8}, :b #{4 5 6}}" ";; Demonstrating difference between merge and merge-with\n\n;; For merge the value from the right-most map wins:\n(merge {:a 1} {:a 2} {:a 3})\n;;=> {:a 3}\n\n;; while for merge-with values are merged (with function + in this example):\n(merge-with + {:a 1} {:a 2} {:a 3})\n;;=> {:a 6}" ";; Use merge-with and merge to merge values that are one level deep maps.\n\n(merge-with merge {:x {:y 1}} {:x {:z 2}})\n;;=> {:x {:z 2, :y 1}}\n\n;; Deeper maps are not merged:\n(merge-with merge {:x {:y {:a 1}}} {:x {:y {:b 2}}})\n;;=>{:x {:y {:b 2}}}" ";;Use into to avoid losing the shape (i.e. a vector) of the original data:\n(merge-with into\n\t  {\"Lisp\" [\"Common Lisp\" \"Clojure\"]\n\t   \"ML\" [\"Caml\" \"Objective Caml\"]}\n\t  {\"Lisp\" [\"Scheme\"]\n\t   \"ML\" [\"Standard ML\"]})\n;;=> {\"Lisp\" [\"Common Lisp\" \"Clojure\" \"Scheme\"], \"ML\" [\"Caml\" \"Objective Caml\" \"Standard ML\"]}\n\n;;No need to use type-specific verbs such as union:\n(merge-with into\n            {:a #{1 2 3},   :b #{4 5 6}}\n            {:a #{2 3 7 8}, :c #{1 2 3}})\n;;=> {:c #{1 2 3}, :a #{1 2 3 7 8}, :b #{4 5 6}}" ";; Note that merge-with is fundamentally additive, which can have unintuitive\n;; consequences if you are using a subtractive operation.\n(require '[clojure.set :as set])\n\n;; Subtract members of one set from another with the same keys:\n\n(merge-with set/difference {:a #{1 2 3}} {:a #{1}})\n;;=> {:a #{3 2}}\n\n(merge-with set/difference {:a #{1 2 3} :b #{2}} {:a #{1} :b #{4}})\n;;=> {:a #{3 2}, :b #{2}}\n\n;; If a key in the second map doesn't occur in the first, (merge-with) will \n;; simply copy it as in (merge), and the passed-in function will not be called:\n\n(merge-with set/difference {:a #{1 2 3}} {:a #{1} :z #{4}})\n;;=> {:a #{3 2}, :z #{4}}\n\n;; The solution in this case is to ensure that both maps have the same keys:\n\n(merge-with set/difference {:a #{1 2 3} :z #{}} {:a #{1} :z #{4}})\n;;=> {:a #{3 2}, :z #{}}" "(defn deep-merge-with\n  \"Like merge-with, but merges maps recursively, applying the given fn\n  only when there's a non-map at a particular level.\n  (deep-merge-with + {:a {:b {:c 1 :d {:x 1 :y 2}} :e 3} :f 4}\n                     {:a {:b {:c 2 :d {:z 9} :z 3} :e 100}})\n  -> {:a {:b {:z 3, :c 3, :d {:z 9, :x 1, :y 2}}, :e 103}, :f 4}\"\n  [f & maps]\n  (apply\n    (fn m [& maps]\n      (if (every? map? maps)\n        (apply merge-with m maps)\n        (apply f maps)))\nmaps))\n\n(deep-merge-with + {:a {:b {:c 1 :d {:x 1 :y 2}} :e 3} :f 4}\n                   {:a {:b {:c 2 :d {:z 9} :z 3} :e 100}})\n;; {:a {:b {:z 3, :c 3, :d {:z 9, :x 1, :y 2}}, :e 103}, :f 4}\n\n(deep-merge-with + {:foo {:bar {:baz 1}}}\n                   {:foo {:bar {:baz 6 :qux 42}}})\n;; {:foo {:bar {:baz 7, :qux 42}}}\n\n;; Source: https://clojure.github.io/clojure-contrib/map-utils-api.html#clojure.contrib.map-utils/deep-merge-with"], :notes nil, :arglists ["f & maps"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/merge-with"}, :clojure.core/fnil {:added "1.2", :ns "clojure.core", :name "fnil", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 6476, :examples [";; a function that expects a non-nil value\n(defn say-hello [name] (str \"Hello \" name))\n;;=> #'user/say-hello\n\n;; fnil lets you create another function with a default\n;; arg in case it is passed a nil\n(def say-hello-with-defaults (fnil say-hello \"World\"))\n;;=> #'user/say-hello-with-defaults\n\n;; the happy path works as you would expect\n(say-hello-with-defaults \"Sir\")\n;;=> \"Hello Sir\"\n\n;; but in the case that the function is passed a nil it will use the \n;; default supplied to fnil\n(say-hello-with-defaults nil)\n;;=> \"Hello World\"\n\n;; this works with different arities too\n(defn say-hello [first other] (str \"Hello \" first \" and \" other))\n;;=> #'user/say-hello\n\n;; lets create it with defaults\n(def say-hello-with-defaults (fnil say-hello \"World\" \"People\"))\n;;=> #'user/say-hello-with-defaults\n\n;; call the function with all nil args - notice it uses the defaults\n;; supplied to fnil\n(say-hello-with-defaults nil nil)\n;;=> \"Hello World and People\"\n\n;; any of the args can be nil - the function will supply \n;; the default supplied with fnil\n(say-hello-with-defaults \"Sir\" nil)\n;;=> \"Hello Sir and People\"\n\n;; and again - notice that \"World\" is the default here\n(say-hello-with-defaults nil \"Ma'am\")\n;;=> \"Hello World and Ma'am\"\n\n;; or pass all args \n(say-hello-with-defaults \"Sir\" \"Ma'am\")\n;;=> \"Hello Sir and Ma'am\"\n" ";; Treat nil as 0 for the purposes of incrementing\n((fnil inc 0) nil)\n;;=> 1\n;; While the following would not work:\n(inc nil)\n;;=> NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)\n\n;; fnil is very useful for specifying default values when updating maps\n;; For a map containing counters of keys:\n(update-in {:a 1} [:a] inc)\n;;=> {:a 2}\n\n;; Oops, our map does not have a key :b and update-in passes nil to inc\n(update-in {:a 1} [:b] inc)\n;;=> NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)\n\n;; But if we use fnil it works:\n(update-in {:a 1} [:b] (fnil inc 0))\n;;=> {:b 1, :a 1}\n\n;; Another example is when map values are collections and we don't want\n;; default behavior of conj with nil that produces a list\n(conj nil 1)\n;;=> (1)\n;; I.e.\n(update-in {} [:a] conj 1)\n;;=> {:a (1)}\n\n;; But say we want map values to be vectors instead:\n(update-in {} [:a] (fnil conj []) 1)\n;;=> {:a [1]}"], :notes nil, :arglists ["f x" "f x y" "f x y z"], :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/fnil"}, :clojure.inspector/old-table-model {:ns "clojure.inspector", :name "old-table-model", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos nil, :line 72, :examples nil, :notes nil, :arglists ["data"], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/old-table-model"}, :clojure.core.logic/condu {:ns "clojure.core.logic", :name "condu", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1425, :examples nil, :macro true, :notes nil, :arglists ["& clauses"], :doc "Committed choice. Once the head (first goal) of a clause\n  has succeeded, remaining goals of the clause will only\n  be run once. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/condu"}, :clojure.xml/*stack* {:ns "clojure.xml", :name "*stack*", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 15, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/*stack*"}, :clojure.core/macroexpand {:added "1.0", :ns "clojure.core", :name "macroexpand", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/macroexpand-1 :clojure.walk/macroexpand-all], :line 3992, :examples [";; It is useful to combine macroexpand with pprint as the\n;; default output can be hard to read.\nuser=> (clojure.pprint/pprint (macroexpand '(time (print \"timing\"))))\n(let*\n [start__3917__auto__\n  (. java.lang.System (clojure.core/nanoTime))\n  ret__3918__auto__\n  (print \"timing\")]\n (clojure.core/prn\n  (clojure.core/str\n   \"Elapsed time: \"\n   (clojure.core//\n    (clojure.core/double\n     (clojure.core/-\n      (. java.lang.System (clojure.core/nanoTime))\n      start__3917__auto__))\n    1000000.0)\n   \" msecs\"))\n ret__3918__auto__)\n\n;; Even after pretty printing you may benefit from some\n;; manual cleanup.\n\n;; Also worth noting that most of the time macroexpand-1 is\n;; a better alternative to avoid over expanding down too \n;; many levels." "user=> (macroexpand '(-> c (+ 3) (* 2)))    \n(* (+ c 3) 2)\n"], :notes nil, :arglists ["form"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/macroexpand"}, :clojure.spec.alpha/exercise {:ns "clojure.spec.alpha", :name "exercise", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1814, :examples nil, :notes nil, :arglists ["spec" "spec n" "spec n overrides"], :doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/exercise"}, :clojure.core.logic.pldb/index-for-query {:ns "clojure.core.logic.pldb", :name "index-for-query", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 41, :examples nil, :notes nil, :arglists ["s q indexes"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/index-for-query"}, :clojure.java.shell/*sh-dir* {:ns "clojure.java.shell", :name "*sh-dir*", :file "clojure/java/shell.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 18, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.shell/*sh-dir*"}, :clojure.core.logic.fd/-distinct {:ns "clojure.core.logic.fd", :name "-distinct", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1028, :examples nil, :notes nil, :arglists ["x y* n*"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-distinct"}, :clojure.core/agent {:added "1.0", :ns "clojure.core", :name "agent", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/set-error-handler! :clojure.core/send :clojure.core/send-off :clojure.core/release-pending-sends :clojure.core/agent-error :clojure.core/restart-agent :clojure.core/add-watch :clojure.core/set-error-mode! :clojure.core/set-validator!], :line 2046, :examples [";; Agents provide shared access to mutable state. \n;; They allow non-blocking (asynchronous as opposed \n;; to synchronous atoms) and independent change of \n;; individual locations (unlike coordinated change \n;; of multiple locations through refs).\n\n;; agent creates one:\n(def counter (agent 0))\n;; #'user/counter\n\n;; send requests a change to its value:\n(send counter inc)\n\n; @ or deref provides a snapshot of the current state:\n@counter\n;;=> 1\n\n;; agents can reference any data structure:\n\n(def pulp-fiction (agent {}))\n;; #'user/pulp-fiction\n\n(send pulp-fiction assoc :act-one \"PROLOGUE\")\n@pulp-fiction\n;;=> {:act-one \"PROLOGUE\"}\n\n(send pulp-fiction assoc :act-two \"VINCENT VEGA & MARSELLUS WALLACE'S WIFE\")\n@pulp-fiction\n;;=> {:act-two \"VINCENT VEGA & MARSELLUS WALLACE'S WIFE\", :act-one \"PROLOGUE\"}\n\n; From http://clojure-examples.appspot.com/clojure.core/agent with permission."], :notes nil, :arglists ["state & options"], :doc "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/agent"}, :clojure.core.async/sliding-buffer {:ns "clojure.core.async", :name "sliding-buffer", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/buffer :clojure.core.async/dropping-buffer :clojure.core.async/chan], :line 60, :examples ["(require '[clojure.core.async :refer [go-loop <! >!! sliding-buffer chan]])\n\n;; Sliding buffers can be used to discard old values on a chan\n\n;; Define a chan with a sliding buffer of 1 (i.e. we care mainly\n;; about the latest value)\n(def sliding-chan (chan (sliding-buffer 1)))\n\n;; Print the values on the chan forever\n(go-loop []\n  (println \"Received:\" (<! sliding-chan))\n  (recur))\n\n;; Put 100 events onto the chan\n(dotimes [n 100]\n  (>!! sliding-chan n))\n\n;;=> Received: 0 ;; <-- see note below\n;;=> Received: 99\n\n;; Results may vary for values from 0 to n-1\n;; but you should ALWAYS see 'Received: <n-1>'"], :notes nil, :arglists ["n"], :doc "Returns a buffer of size n. When full, puts will complete, and be\n  buffered, but oldest elements in buffer will be dropped (not\n  transferred).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/sliding-buffer"}, :clojure.core.logic/empty-f {:ns "clojure.core.logic", :name "empty-f", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 538, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/empty-f"}, :clojure.core/file-seq {:added "1.0", :ns "clojure.core", :name "file-seq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.java.io/file :clojure.java.io/delete-file], :line 4888, :examples [";; first create a Java File object using the file function in\n;; the clojure.java.io package and use that object to create a file-seq\n;; then show the first and first 10 members of that seq\n\n(def f (clojure.java.io/file \"c:\\\\clojure-1.2.0\"))\n;;=> #'user/f\n(def fs (file-seq f))\n;;=> #'user/fs\n(first fs)\n;;=> #<File c:\\clojure-1.2.0>\n(clojure.pprint/pprint (take 10 fs))\n;; (#<File c:\\clojure-1.2.0>\n;;  #<File c:\\clojure-1.2.0\\.gitignore>\n;;  #<File c:\\clojure-1.2.0\\build.xml>\n;;  #<File c:\\clojure-1.2.0\\changes.txt>\n;;  #<File c:\\clojure-1.2.0\\cl.bat>\n;;  #<File c:\\clojure-1.2.0\\clojure.jar>\n;;  #<File c:\\clojure-1.2.0\\doc>\n;;  #<File c:\\clojure-1.2.0\\doc\\clojure>\n;;  #<File c:\\clojure-1.2.0\\doc\\clojure\\pprint>\n;;  #<File c:\\clojure-1.2.0\\doc\\clojure\\pprint\\CommonLispFormat.markdown>)\n;;=>" ";; Fill an array with the file names in a directory.\n;; Put them in an array.\n(mapv str (filter #(.isFile %) (file-seq (clojure.java.io/file \".\"))))\n\n;; Use the Path utilities to do glob filtering.\n(let [grammar-matcher (.getPathMatcher \n                          (java.nio.file.FileSystems/getDefault)\n                          \"glob:*.{g4,md}\")]\n  (->> \".\"\n       clojure.java.io/file\n       file-seq\n       (filter #(.isFile %))\n       (filter #(.matches grammar-matcher (.getFileName (.toPath %))))\n       (mapv #(.getAbsolutePath %))))\n\n;; At that point it may be better to just use the java.nio.file classes.\n;; https://github.com/ajoberstar/ike.cljj has some ideas"], :notes ["The file operations from java are https://docs.oracle.com/javase/8/docs/api/java/io/File.html"], :arglists ["dir"], :doc "A tree seq on java.io.Files", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/file-seq"}, :clojure.core.logic/matcha {:ns "clojure.core.logic", :name "matcha", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1738, :examples nil, :macro true, :notes nil, :arglists ["xs & cs"], :doc "Define a soft cut pattern match. See conda.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/matcha"}, :clojure.core.logic/constrain-tree {:ns "clojure.core.logic", :name "constrain-tree", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2839, :examples nil, :notes nil, :arglists ["t fc"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/constrain-tree"}, :clojure.core.logic/run-nc* {:ns "clojure.core.logic", :name "run-nc*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1263, :examples nil, :macro true, :notes nil, :arglists ["& goals"], :doc "Executes goals until results are exhausted. Does not occurs-check.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-nc*"}, :clojure.core/distinct {:added "1.0", :ns "clojure.core", :name "distinct", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/distinct? :clojure.core/dedupe :clojure.core/set], :line 4969, :examples ["user=> (distinct [1 2 1 3 1 4 1 5])\n(1 2 3 4 5)" "user=> (def fractions \n         (for [n (range 1 100) d (range (inc n) 100)] \n           (let [gcd (clojure.contrib.math/gcd n d)] \n             (/ (/ n gcd) (/ d gcd)))))\n;; all irreducible fractions with denominator < 100\n;; (1/2 1/3 ... 1/99 2/3 1/2 2/5 1/3 ...)\n\nuser=> (count fractions)\n4851\n\nuser=> (count (distinct fractions))\n3003\n"], :notes ["If you do not need the lazyness of distinct, set can be faster. Like: (count (set some-coll))." "Use this function if you want to remove only consequtive duplicates\r\n\r\n    (defn distinct-consequtive [sequence] (map first (partition-by identity sequence)))\r\n\r\n    (distinct-consequtive [1 1 2 3 3 2 2 3])\r\n    ;=> (1 2 3 2 3)" "Use [`dedupe`](https://clojuredocs.org/clojure.core/dedupe) if you want to remove consecutive duplicates, available since Clojure 1.7."], :arglists ["" "coll"], :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/distinct"}, :clojure.main/repl-read {:ns "clojure.main", :name "repl-read", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 129, :examples nil, :notes nil, :arglists ["request-prompt request-exit"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl-read"}, :clojure.core.logic/to-s {:ns "clojure.core.logic", :name "to-s", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 543, :examples nil, :notes nil, :arglists ["v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/to-s"}, :clojure.core/get-thread-bindings {:added "1.1", :ns "clojure.core", :name "get-thread-bindings", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/bound-fn :clojure.core/bound-fn*], :line 1931, :examples nil, :notes nil, :arglists [""], :doc "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get-thread-bindings"}, :clojure.core.logic.fd/eq-form {:ns "clojure.core.logic.fd", :name "eq-form", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1151, :examples nil, :notes nil, :arglists ["form"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/eq-form"}, :clojure.core/chunk-append {:ns "clojure.core", :name "chunk-append", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-buffer :clojure.core/chunk], :line 687, :examples ["(let [buf (chunk-buffer 16)]\n  ;; Mutably append elements to the ChunkedBuffer\n  (dotimes [n 10]\n    (chunk-append buf n))\n\n  ;; Demonstrate pulling elements out.\n  ;; Note that the `capacity` we set above (16) for `buf`.\n  (let [ch (chunk buf)]\n    (for [n (range 0 17)]\n      (try (.nth ch n)\n           (catch ArrayIndexOutOfBoundsException e\n             \"too far!\")))))\n\n;; => (0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil \"too far!\")"], :notes nil, :arglists ["b x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-append"}, :clojure.core/rsubseq {:added "1.0", :ns "clojure.core", :name "rsubseq", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/subseq], :line 5066, :examples ["user> (rsubseq (sorted-set 1 2 3 4 5) < 3)\n(2 1)" ";; If you use the longer form, with the end condition, there are some rules.\n;; start-key should be <= end-key.  start-test should be \">\" or \">=\".\n;; end-test should be \"<\" or \"<=\".  If follow these rules you'll get all the\n;; values between start-key and end-key.  If you don't you won't get an error,\n;; but you probably won't get the result you expect.  These rules are exactly\n;; the same for subseq.\n\n;; As expected, returns everything between 2 and 4, in reverse order.\nuser=> (rsubseq (sorted-set 1 2 3 4 5) >= 2 <= 4)\n;; => (4 3 2)\n\n;; Probably not what you expected!\nuser=> (rsubseq (sorted-set 1 2 3 4 5) <= 4 >= 2)\n;; => (2 1)\n\n;; As expected, returns everything between 2 and 4, in order.\nuser=> (subseq (sorted-set 1 2 3 4 5) >= 2 <= 4)\n;; => (2 3 4)\n\n;; Probably not what you expected!\nuser=> (subseq  (sorted-set 1 2 3 4 5) <= 4 >= 2)\n;; => (4 5)\n"], :notes nil, :arglists ["sc test key" "sc start-test start-key end-test end-key"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rsubseq"}, :clojure.pprint/write-out {:added "1.2", :ns "clojure.pprint", :name "write-out", :file "clojure/pprint/pprint_base.clj", :type "function", :column 1, :see-alsos nil, :line 171, :examples nil, :notes nil, :arglists ["object"], :doc "Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/write-out"}, :clojure.core/inc {:added "1.2", :ns "clojure.core", :name "inc", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/dec :clojure.core/inc' :clojure.core/unchecked-inc], :line 914, :examples ["user=> (inc 1)\n2\n\nuser=> (inc 1.0)\n2.0\n\nuser=> (inc 1/2)\n3/2\n\nuser=> (inc -1)\n0" ";;increment all the element in a collection\n\n(map inc [1 2 3 4 5])\n;;(2 3 4 5 6)  return type list\n\n(into [] (map inc [1 2 3 4 5]))\n;;[2 3 4 5 6]  return type vector" ";; Careful when using ClojureScript\n;; Make sure you're passing a number\n;; because JavaScript + also does string concatenation\ncljs.user=> (inc \"1\")\n\"11\"\ncljs.user=> (inc 1)\n2\n\n;; Although it's not the case with dec\n;; In JavaScript \"1\" - 1 = 0\ncljs.user=> (dec \"1\")\n0\ncljs.user=> (dec 1)\n0\n\n"], :notes ["Is the documentation suppose to be: \"Returns a number one greater than x.\" ?  If not what is num?" "is code \"(def i (inc i))\" is conflict with the notion of immutable of data in Clojure. " "Nope, quite the opposite. \"def\" defines a var: \n<pre>\nuser=> (type (def i 1))\nclojure.lang.Var\n</pre>\nA var is one of the 4 types dealing with mutable state (it is not an immutable data structure, like maps, vectors, sets and so on) and it does so following a specific semantic (see http://clojure.org/reference/vars)."], :arglists ["x"], :doc "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/inc"}, :clojure.core.logic.pldb/db-facts {:ns "clojure.core.logic.pldb", :name "db-facts", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 122, :examples nil, :notes nil, :arglists ["base-db & facts"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db-facts"}, :clojure.inspector/tree-model {:ns "clojure.inspector", :name "tree-model", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos nil, :line 56, :examples nil, :notes nil, :arglists ["data"], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/tree-model"}, :clojure.core/shutdown-agents {:added "1.0", :ns "clojure.core", :name "shutdown-agents", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/send :clojure.core/send-off :clojure.core/agent :clojure.core/agent-error], :line 2246, :examples [";; Creating an agent\nuser> (def a (agent 1))\n#'user/a\n\n;; Create a function that can handle an agent\n\nuser> (defn agent-action [a]\n\t33)\n#'user/agent-action\n\n;; The agent will become 33\nuser> (send-off a agent-action)\n#<Agent@dde4f2: 33>\n\nuser> @a\n33\n;; Create another agent before shutdown\nuser> (def c (agent 3))\n#'user/c\n\n;; Shutdown agents is called\nuser> (shutdown-agents)\nnil\n\n;; Attempt to turn c into 33\nuser> (send c agent-action)\n#<Agent@b162fa: 3>\n\n;; The result is that it is still the same value it was initialized with\nuser> @c\n3\n\n;; Agent created after shutdown\nuser> (def d (agent 4))\n#'user/d\n\n;; Try sending it\nuser> (send d agent-action)\n#<Agent@356519: 4>\n\n;; Same thing, there are no threads to process the agents\nuser> @d\n4" ";; Create the agent that we will be using\nuser=> (def a (agent 0))\n#'user/a\n\n;; Dereference the agent to show the value is 0\nuser=> @a\n0\n\n;; Create a function that can increment the agent\n;; This will continually update the value of the agent\nuser=> (defn agent-inc [a]\n        (send-off *agent* agent-inc)\n        (inc a))\n#'user/agent-inc\n\n;; Send the agent to the agent-inc function\n;; The value is 188 because by the time the repl has sent off the\n;; agent to the function, the function has already been called recursively\nuser=> (send a agent-inc)\n#<Agent@6b850d: 188>\n\n;; Dereference of the value a second or so later\nuser=> @a\n716889\n\n;; Another dereference in another couple of seconds\nuser=> @a\n1455264\n\n;; Shutdown the threads for the agents\nuser=> (shutdown-agents)\nnil\n\n;; Dereference the agent to see what value it is\nuser=> @a\n3522353\n\n;; Dereference the agent again in a few seconds\n;; It's the same value, because the agent pool of threads are no longer\n;; active\nuser=> @a\n3522353\n"], :notes nil, :arglists [""], :doc "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/shutdown-agents"}, :clojure.core.logic/rembero {:ns "clojure.core.logic", :name "rembero", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2483, :examples [";;https://github.com/clojure/core.logic/blob/master/src/main/clojure/clojure/core/logic.clj#L2483\n;; (rembero x l o)\n;; my simple reminder is: x+o=l (L, not 1)\n\n(run* [q]\n  (fresh [a b x y]\n    (== q [a b])\n    (rembero a [:apple :banana :carrot] x)\n    (rembero b x y)))\n;; ([:apple :banana] [:apple :carrot] [:banana :apple] [:banana :carrot] [:carrot :apple] [:carrot :banana])"], :notes nil, :arglists ["x l o"], :doc "A relation between l and o where x is removed from\n   l exactly one time.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/rembero"}, :clojure.core.logic/uai {:ns "clojure.core.logic", :name "uai", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 747, :examples nil, :macro true, :notes nil, :arglists ["& args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/uai"}, :clojure.core/remove {:added "1.0", :ns "clojure.core", :name "remove", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/filter :clojure.core/group-by :clojure.core/keep], :line 2818, :examples ["(remove pos? [1 -2 2 -1 3 7 0])\n;;=> (-2 -1 0)\n\n(remove nil? [1 nil 2 nil 3 nil])\n;;=> (1 2 3)\n\n;; remove items that are evenly divisible by 3\n(remove #(zero? (mod % 3)) (range 1 21))\n;;=> (1 2 4 5 7 8 10 11 13 14 16 17 19 20)" ";; compare to filter\n\n(remove even? (range 10))\n;;=> (1 3 5 7 9)\n\n(remove (fn [x]\n  (= (count x) 1))\n  [\"a\" \"aa\" \"b\" \"n\" \"f\" \"lisp\" \"clojure\" \"q\" \"\"])\n;;=> (\"aa\" \"lisp\" \"clojure\" \"\")\n\n; When coll is a map, pred is called with key/value pairs.\n(remove #(> (second %) 100)\n       {:a 1\n        :b 2\n        :c 101\n        :d 102\n        :e -1})\n;;=> ([:a 1] [:b 2] [:e -1])\n" ";; remove items from a set/list\n\n(remove #{:a} #{:b :c :d :a :e})\n;;=> (:e :c :b :d)\n\n(remove #{:a} [:b :c :d :a :e :a :f])\n;;=> (:b :c :d :e :f)\n" ";; use map as a pred\n\n(remove {:a 42 :b 69} #{:a :b :c})\n;;=> (:c)"], :notes nil, :arglists ["pred" "pred coll"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/remove"}, :clojure.core.logic/get-attr {:ns "clojure.core.logic", :name "get-attr", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 450, :examples nil, :notes nil, :arglists ["s x attr"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/get-attr"}, :clojure.core.logic/run-nc {:ns "clojure.core.logic", :name "run-nc", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1257, :examples nil, :macro true, :notes nil, :arglists ["n bindings & goals"], :doc "Executes goals until a maximum of n results are found. Does not\n   occurs-check.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-nc"}, :clojure.core.async/>! {:ns "clojure.core.async", :name ">!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/>!! :clojure.core.async/put! :clojure.core.async/<!], :line 147, :examples ["user=> (let [c (chan 1)]\n  #_=>   (go (>! c 1)\n  #_=>       (println \"Got => \" (<! c))))\n\nGot =>  1\n\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@4a061708>\n"], :notes nil, :arglists ["port val"], :doc "puts a val into port. nil values are not allowed. Must be called\n  inside a (go ...) block. Will park if no buffer space is available.\n  Returns true unless port is already closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/>!"}, :clojure.core/alias {:added "1.0", :ns "clojure.core", :name "alias", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-aliases :clojure.core/ns-unalias :clojure.core/require :clojure.core/ns], :line 4230, :examples ["(require 'clojure.string)\n;;=> nil\n\n(alias 'string 'clojure.string)\n;;=> nil\n\n(string/capitalize \"hONdURas\")\n;;=> \"Honduras\"" ";; The alias can also be created when the \n;; namespace is required using the :as keyword.\n\n(require '[clojure.string :as string])\n(string/capitalize \"hONdURas\")\n;;=> \"Honduras\""], :notes nil, :arglists ["alias namespace-sym"], :doc "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/alias"}, :clojure.test/*testing-vars* {:ns "clojure.test", :name "*testing-vars*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 267, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*testing-vars*"}, :clojure.core/false? {:added "1.0", :ns "clojure.core", :name "false?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/not], :line 505, :examples ["(false? false) ;=> true\n(false? true) ;=> false\n(false? nil) ;=> false\n(false? \"foo\") ;=> false"], :notes nil, :tag "java.lang.Boolean", :arglists ["x"], :doc "Returns true if x is the value false, false otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/false_q"}, :clojure.core/every-pred {:added "1.3", :ns "clojure.core", :name "every-pred", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/some-fn :clojure.core/every?], :line 7316, :examples ["user=> ((every-pred number? odd?) 3 9 11)\ntrue"], :notes ["Careful—every predicate with no arguments is considered true:\n<pre>\nuser> ((every-pred (constantly false)))\ntrue\nuser> ((every-pred (constantly false)) 1)\nfalse\n</pre>"], :arglists ["p" "p1 p2" "p1 p2 p3" "p1 p2 p3 & ps"], :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/every-pred"}, :clojure.spec.alpha/check-asserts? {:ns "clojure.spec.alpha", :name "check-asserts?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1898, :examples nil, :notes nil, :arglists [""], :doc "Returns the value set by check-asserts.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/check-asserts_q"}, :clojure.core/intern {:added "1.0", :ns "clojure.core", :name "intern", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/alter-var-root :clojure.core/ns-unmap], :line 6237, :examples ["user=> (intern 'user 'x \"Foobar\")\n#'user/x\n\nuser=> x\n\"Foobar\"\n"], :notes ["\"The Namespace system maintains global maps of symbols to Var objects (see Namespaces). If a def expression does not find an interned entry in the current namespace for the symbol being def-ed, it creates one, otherwise it uses the existing Var. This find-or-create process is called interning. This means that, unless they have been unmap-ed, Var objects are stable references and need not be looked up every time. It also means that namespaces constitute a global environment in which, as described in Evaluation, the compiler attempts to resolve all free symbols as Vars.\n\n\"The var special form or the #' reader macro (see Reader) can be used to get an interned Var object instead of its current value.\"\n\n-- [https://clojure.org/reference/vars]"], :arglists ["ns name" "ns name val"], :doc "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/intern"}, :clojure.core/-' {:added "1.0", :ns "clojure.core", :name "-'", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/- :clojure.core/unchecked-subtract :clojure.core/unchecked-negate], :line 1023, :examples [";; unlike the * and + functions there is no 0 arity form\n(-')\n;; ArityException: wrong number of args (0)\n\n(-' 1)\n;;=> -1 \n\n(-' 6 3)  \n;;=> 3\n\n(-' 10 3 2)  \n;;=> 5\n\n(- 0 9000000000000000000 1000000000000000000)\n;; ArithmeticException: integer overflow\n\n(-' 0 9000000000000000000 1000000000000000000)\n;;=> 10000000000000000000N "], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/-'"}, :clojure.core/ratio? {:added "1.0", :ns "clojure.core", :name "ratio?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3568, :examples ["(ratio? 22/7)\n;; => true\n\n(ratio? 22)\n;; => false\n\n(ratio? 2.2)\n;; => false\n" ";; Both True\nuser=> (ratio? 22/7) \n;; => true\nuser=> (rational? 22/7)\n;; => true\n\n;; Different\nuser=> (ratio? 22)\n;; => false\nuser=> (rational? 22)\n;; => true\n\n;; Both False\nuser=> (ratio? 0.5)\n;; => false\nuser=> (rational? 0.5)\n;; => false"], :notes nil, :arglists ["n"], :doc "Returns true if n is a Ratio", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ratio_q"}, :clojure.core.logic/unbound-rands {:ns "clojure.core.logic", :name "unbound-rands", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 97, :examples nil, :notes nil, :arglists ["a c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unbound-rands"}, :clojure.core/max {:added "1.0", :ns "clojure.core", :name "max", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/max-key :clojure.core/min], :line 1107, :examples [";; `max` returns the largest of its arguments\nuser=> (max 1 2 3 4 5)  \n5\n\n;; regardless of order of those arguments\nuser=> (max 5 4 3 2 1)\n5\n\nuser=> (max 100)\n100" ";; If elements are already in a sequence, use apply\nuser=> (apply max [1 2 3 4 3])\n4\nuser=> (apply max '(4 3 5 6 2))\n6" "user> (reduce max [1 2 3 4 5 6 7 6 5 4 3])\n7"], :notes ["As of 1.6, `max`'s behavior differs when it's passed single / multiple non-numeric arguments:\n\n```\n(max \"foo\") ;;=> \"foo\"\n\n(max \"foo\" \"bar\") ;;=> ClassCastException thrown\n```"], :arglists ["x" "x y" "x y & more"], :doc "Returns the greatest of the nums.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/max"}, :clojure.core.reducers/monoid {:added "1.5", :ns "clojure.core.reducers", :name "monoid", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 320, :examples ["(require '[clojure.core.reducers :as reducers])\n\n(reducers/fold\n  (reducers/monoid + (constantly 0))\n  (range 10000))\n;; => 49995000\n\n(reducers/fold\n  (reducers/monoid max (constantly Long/MIN_VALUE))\n  [1 2 7 10 3 -5])\n;; => 10"], :notes nil, :arglists ["op ctor"], :doc "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/monoid"}, :clojure.core/list? {:added "1.0", :ns "clojure.core", :name "list?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq? :clojure.core/sequential? :clojure.core/coll? :clojure.core/map? :clojure.core/set? :clojure.core/vector?], :line 6139, :examples [";; an idiomatic persistent-list is a list\n(list? '(1 2 3))\n;;=> true\n\n;; a persistent-list is a list\n;; (list? (list 1 2))\n;;=> true\n\n;; a numeric value (long) is not a list\n(list? 0)\n;;=> false\n\n;; a persistent-array-map is not a list\n(list? {})\n;;=> false\n\n;; a persistent-vector is not a list\n(list? [])\n;;=> false\n\n;; a lazy-sequence is not always a list\n(list? (range 10))\n;;=> false\n" ";; not all lists are lists\n(cons 1 '(2 3))\n;; => (1 2 3)\n(= '(1 2 3) (cons 1 '(2 3)))\n;; => true\n(list? (cons 1 '(2 3)))\n;; => false\n\n;; good news is:\n(seq? (cons 1 '(2 3)))\n;; => true\n(seq? [1 2 3])\n;; => false\n\n;; So seq? might be what you are looking \n;; for when you want to test listness.\n\n\n\n\n\n"], :notes ["You may want to use `seq?` instead of `list?`, especially if you might be dealing with a lazy sequence as returned by `filter`, `range`, etc."], :arglists ["x"], :doc "Returns true if x implements IPersistentList", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/list_q"}, :clojure.spec.alpha/conform* {:ns "clojure.spec.alpha", :name "conform*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["spec x"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/conform*"}, :clojure.zip/children {:added "1.0", :ns "clojure.zip", :name "children", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/zipper], :line 75, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns a seq of the children of node at loc, which must be a branch", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/children"}, :clojure.main/repl-prompt {:ns "clojure.main", :name "repl-prompt", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 92, :examples nil, :notes nil, :arglists [""], :doc "Default :prompt hook for repl", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl-prompt"}, :clojure.core/*print-readably* {:added "1.0", :ns "clojure.core", :name "*print-readably*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-readably*"}, :clojure.string/replace-first {:added "1.2", :ns "clojure.string", :name "replace-first", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/replace :clojure.core/re-pattern :clojure.core/subs :clojure.string/re-quote-replacement], :line 138, :examples ["user=> (use '[clojure.string :only (replace-first)])\n\n;; Only replace the first match.\nuser=> (replace-first \"A good day to you, sir.  Good day.\" #\"day\" \"night\")\n\"A good night to you, sir.  Good day.\"\n\n;; If there are no matches, return the original string.\nuser=> (replace-first \"A good day to you, sir.\" #\"madam\" \"master\")\n\"A good day to you, sir.\"\n\n;; (?i) at the beginning of a pattern makes the entire thing match\n;; case-insensitively, at least for US ASCII characters.  (?u) does\n;; the corresponding thing for Unicode.\nuser=> (replace-first \"Day need not be SHOUTED.\" #\"(?i)day\" \"night\")\n\"night need not be SHOUTED.\"\n\n;; See here for many details on regex patterns:\n;; http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html\n;; Also the book \"Mastering Regular Expressions\" by Jeffrey Friedl.\n" "user=> (use '[clojure.string :only (replace-first)])\n\n;; Pattern matches from beginning of string (signified by ^) up to the\n;; last occurrence of /, because by default * is greedy, i.e. it\n;; matches as much as possible.\nuser=> (replace-first \"/path/to/file/name\" #\"^.*/\" \"\")\n\"name\"\n\n;; Use *? to match as little as possible.\nuser=> (replace-first \"/path/to/file/name\" #\"^.*?/\" \"\")\n\"path/to/file/name\"\n" ";; Note: When replace-first or replace have a regex pattern as their\n;; match argument, dollar sign ($) and backslash (\\) characters in\n;; the replacement string are treated specially.\n\n;; Example: pattern matches string \"fodder\", with (o+) matching \"o\"\n;; and (\\S+) matching \"dder\".  Replacement string says to replace the\n;; entire match \"fodder\" with $2, the string matched by the second\n;; parenthesized group, \"dder\", followed by $1, \"o\".\nuser=> (str/replace-first \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" \"$2$1\")\n\"fabulous ddero foo food\"\n\n;; To avoid this special treatment of $ and \\, you must escape them with\n;; \\.  Because it is in a Clojure string, to get one \\ we must escape\n;; *that* with its own \\.\nuser=> (str/replace-first \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" \"\\\\$2\\\\$1\")\n\"fabulous $2$1 foo food\"\n\n;; To ensure the replacement is treated literally, call\n;; java.util.regex.Matcher/quoteReplacement on it.  A shorter name\n;; like re-qr can be handy.\nuser=> (import '(java.util.regex Matcher))\njava.util.regex.Matcher\n\nuser=> (defn re-qr [replacement]\n         (Matcher/quoteReplacement replacement))\n#'user/re-qr\n\nuser=> (str/replace-first \"fabulous fodder foo food\" #\"f(o+)(\\S+)\" (re-qr \"$2$1\"))\n\"fabulous $2$1 foo food\"\n" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases."], :notes nil, :tag "java.lang.String", :arglists ["s match replacement"], :doc "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/replace-first"}, :clojure.core/io! {:added "1.0", :ns "clojure.core", :name "io!", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos nil, :line 2504, :examples ["user=> (def a (ref 0))\n#'user/a\n\nuser=> (dosync\n         (io! (println \"hello\"))\n         (alter a inc))\nIllegalStateException I/O in transaction\n\nuser=> (dosync\n         (println \"hello\")\n         (alter a inc))\n\"hello\"\n1\n\nuser=> (defn fn-with-io []\n         (io! (println \"hello\")))\n#'user/fn-with-io\n\nuser=> (dosync\n         (fn-with-io)\n         (alter a inc))\nIllegalStateException I/O in transaction"], :macro true, :notes nil, :arglists ["& body"], :doc "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/io!"}, :clojure.core/integer? {:added "1.0", :ns "clojure.core", :name "integer?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/number? :clojure.core/int?], :line 1366, :examples ["user=> (integer? 1)\ntrue\nuser=> (integer? 1.0)\nfalse" ";; Note: tests if it's a math integer, not a Java Integer\nuser=> (integer? (inc Integer/MAX_VALUE))\ntrue" ";; integer? returns true for BigInts. If you don't want this behavior, you can \n;; use the int? predicate instead in Clojure 1.9 or later:\n\n(integer? 13N)\n;; => true\n\n(int? 13N)\n;; => false"], :notes nil, :arglists ["n"], :doc "Returns true if n is an integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/integer_q"}, :clojure.core/simple-ident? {:added "1.9", :ns "clojure.core", :name "simple-ident?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ident? :clojure.core/qualified-ident?], :line 1609, :examples nil, :notes nil, :arglists ["x"], :doc "Return true if x is a symbol or keyword without a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/simple-ident_q"}, :clojure.core.logic.fd/IInterval {:ns "clojure.core.logic.fd", :name "IInterval", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 16, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/IInterval"}, :clojure.test/*stack-trace-depth* {:added "1.1", :ns "clojure.test", :name "*stack-trace-depth*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 252, :examples nil, :notes nil, :arglists [], :doc "The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*stack-trace-depth*"}, :clojure.string/join {:added "1.2", :ns "clojure.string", :name "join", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.core/split-at :clojure.core/split-with :clojure.core/interpose], :line 180, :examples ["user=> (clojure.string/join \", \" [1 2 3])\n\"1, 2, 3\"" ";; Splits a string on space character and joins \n;; the resulting collection with a line feed character\n\n(use '[clojure.string :only (join split)])\n\nuser=> (println\n         (join \"\\n\"\n           (split \"The Quick Brown Fox\" #\"\\s\")))\nThe\nQuick\nBrown\nFox\nnil" ";; Note that empty strings and nils will appear as blank items\n;; in the result:\n\n(require '[clojure.string :as string])\n\n(string/join \", \" [\"spam\" nil \"eggs\" \"\" \"spam\"])\n;;=> \"spam, , eggs, , spam\"\n\n;; If you'd like to avoid this, you might do something like this:\n\n(string/join \", \" (remove string/blank? [\"spam\" nil \"eggs\" \"\" \"spam\"]))\n;;=> \"spam, eggs, spam\""], :notes nil, :tag "java.lang.String", :arglists ["coll" "separator coll"], :doc "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/join"}, :clojure.core/alter-var-root {:added "1.0", :ns "clojure.core", :name "alter-var-root", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-redefs :clojure.core/with-redefs-fn :clojure.core/intern :clojure.core/var :clojure.core/set!], :line 5445, :examples ["(defn sqr [n] \n  \"Squares a number\"\n  (* n n))\n\nuser=> (sqr 5)\n25\n\nuser=> (alter-var-root \n         (var sqr)                     ; var to alter\n         (fn [f]                       ; fn to apply to the var's value\n           #(do (println \"Squaring\" %) ; returns a new fn wrapping old fn\n                (f %))))\n\nuser=> (sqr 5)\nSquaring 5\n25\n" ";;change the value of a var, instead of (def varName value)\nuser=> (def string \"abcd\")\n#'user/string\n\nuser=> string\n\"abcd\"\n\nuser=> (alter-var-root #'string (constantly \"wxyz\"))\n\"wxyz\"\n\nuser=> string\n\"wxyz\""], :notes nil, :arglists ["v f & args"], :doc "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/alter-var-root"}, :clojure.core.logic/everyg {:ns "clojure.core.logic", :name "everyg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1677, :examples nil, :notes nil, :arglists ["g coll"], :doc "A pseudo-relation that takes a coll and ensures that the goal g\n   succeeds on every element of the collection.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/everyg"}, :clojure.core.async/split {:ns "clojure.core.async", :name "split", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 575, :examples ["(require '[clojure.core.async :refer :all])\n\n(def c (chan))\n\n(let [[c1 c2] (split odd? c)]\n  (go-loop []\n    (println \"c1: \" (<! c1))\n    (<! (timeout 10))\n    (recur))\n  (go-loop []\n    (println \"c2: \" (<! c2))\n    (<! (timeout 100))\n    (recur)))\n\n(dotimes [n 10]\n  (>!! c n))\n\n;; will prints\nc2: c1:   01\nc2:  2\nc1:  3\nc2:  4\nc1:  5\nc2:  6\nc1:  7\nc2:  8\nc1:  9"], :notes nil, :arglists ["p ch" "p ch t-buf-or-n f-buf-or-n"], :doc "Takes a predicate and a source channel and returns a vector of two\n  channels, the first of which will contain the values for which the\n  predicate returned true, the second those for which it returned\n  false.\n\n  The out channels will be unbuffered by default, or two buf-or-ns can\n  be supplied. The channels will close after the source channel has\n  closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/split"}, :clojure.core/read-string {:added "1.0", :ns "clojure.core", :name "read-string", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pr-str :clojure.core/str :clojure.core/read :clojure.core/load-string :clojure.core/*read-eval* :clojure.main/load-script :clojure.edn/read-string], :line 3771, :examples ["user=> (read-string \"1.1\")          \n1.1\n\nuser=> (read-string \"1.1.1 (+ 1 1)\")\njava.lang.RuntimeException: java.lang.NumberFormatException: Invalid number: 1.1.1 (NO_SOURCE_FILE:0)\n\nuser=> (read-string \"(+ 1 1)\")\n(+ 1 1)\n" "user=> (eval (read-string \"(+ 1 1)\"))\n2\n\nuser=> (read-string (prn-str (+ 1 1)))\n2\n" "user=> (+ 11 (read-string \"23\"))\n34\n" "user=> (read-string \"; foo\\n5\")\n5\n\nuser=> (read-string \"#^String x\")\nx\n\nuser=> (read-string \"(1)\")\n(1)\n\nuser=> (read-string \"(+ 1 2) (- 3 2)\")\n(+ 1 2)\n\nuser=> (read-string \"@a\")\n(clojure.core/deref a)\n\nuser=> (read-string \"(+ 1 2))))))\")\n(+ 1 2)\n\nuser=> (read-string \"::whatever-namespace-you-are-in\")\n:user/whatever-namespace-you-are-in" ";convert a string representing a sequence,\n;to the sequence that the string represents\nuser=> (read-string \"(\\\\( \\\\x \\\\y \\\\) \\\\z)\")\n(\\( \\x \\y \\) \\z)\n\n;then you can convert to the string that the string-sequence represents\nuser=> (apply str (read-string \"(\\\\( \\\\x \\\\y \\\\) \\\\z)\"))\n\"(xy)z\"\n\n;which is the inverse of\nuser=> (str (first (list (seq \"(xy)z\"))))\n\"(\\\\( \\\\x \\\\y \\\\) \\\\z)\"" ";; you can think of read-string as the inverse of pr-str\n;; turn string into symbols\nuser=> (read-string \"(a b foo :bar)\")\n(a b foo :bar)\n\n;;turn symbols into a string\nuser=> (pr-str '(a b foo :bar))\n\"(a b foo :bar)\"" ";; WARNING: You SHOULD NOT use clojure.core/read-string to read data from\n;; untrusted sources.  See the examples for clojure.core/read, because the same\n;; issues exist for both read and read-string." ";; convert binary number provided in the form of a string to its numerical value.\nuser=> (read-string (str \"2r\" \"1011\"))\n11\n"], :notes ["read-string is useful for running clojure code from a script or translator."], :arglists ["s" "opts s"], :doc "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/read-string"}, :clojure.core.async/untap {:ns "clojure.core.async", :name "untap", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/tap :clojure.core.async/mult :clojure.core.async/untap-all], :line 720, :examples ["(def c (chan))\n(def m (mult c))\n\n(def d (chan))\n(tap m d)\n\n\n(put! c 5)\n(go (println (<! d))); PRINTS 5\n\n\n(untap m d)\n(go (println (<! d))) ; PRINTS NOTHING\n\n(put! c 55)\n\n(tap m d)\n(go (println (<! d))) ; STILL PRINTS NOTHING. THE MESSAGE WAS DROPPED \n\n\n"], :notes nil, :arglists ["mult ch"], :doc "Disconnects a target channel from a mult", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/untap"}, :clojure.core/destructure {:ns "clojure.core", :name "destructure", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 4355, :examples ["; look ma, no let!\n(map #(intern *ns* (first %) (eval (last %))) (partition 2 (destructure '[[a b] [\"a\" \"b\"]])))\nuser=> a\n\"a\"\nuser=> b\n\"b\"" ";; Based on the previous example...\n\n;; Suppose you want to do some work at the repl.\n;; It would be nice if the def and let had similar syntax but they do not.\n\n(defn def+ [bindings] \n  (let [bings (partition 2 (destructure bindings))\n        obj (first bings)\n        redef (rest bings)]\n    \n    (intern *ns* (first obj) (eval (second obj)))  \n    (map #(intern *ns* (first %) (eval (last %))) redef)))\n\n(def+ '[[u s v] [1 5 9]])      \n    \n;; def+ is better implemented as a macro.\n;; It does have the drawback of introducing some intermediate gen variables.\n;; But, it prints the names of all variables.\n\n(defmacro def+\n  \"binding => binding-form\n  internalizes binding-forms as if by def.\"\n  {:added \"1.9\", :special-form true, :forms '[(def+ [bindings*])]}\n  [& bindings]\n  (let [bings (partition 2 (destructure bindings))]\n    (sequence cat \n      ['(do) \n       (map (fn [[var value]] `(def ~var ~value)) bings)\n       [(mapv (fn [[var _]] (str var)) bings)]])))\n\n(def+ [u s v] [1 5 9] \n      foo \"bar\" \n      [a b] [\"abc\" \"bcd\"])\n;=> #'user/b\n\na\n;=> \"abc\"\n\n;; The justification for such a macro is manifest when\n;; debugging at the repl.\n;; Suppose the following is in a function and \n(let [[a b] [\"a\" \"b\"]] \n  (str a b)   ; is this correct?\n  (conj a b)  ; how about this?\n  (cat a b))  ; or this?\n\n;; Now in this case the problem is clear but in general it may not be.\n;; So you get set up to track down this problem. \n(def+ [a b] [\"a\" \"b\"])\n\n;; Without def+ you would have to do something like the following...\n(def ab [\"a\" \"b\"])\n(def a (nth ab 0))\n(def b (nth ab 1))\n;; ...to get set up in the repl."], :notes ["I found https://clojure.org/guides/destructuring extremely useful" "\"[The `destructure` function] implements the destructuring logic and [...] is designed to be invoked in a macro\". For more info about `desctructure` see https://clojure.org/guides/destructuring#_macros."], :arglists ["bindings"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/destructure"}, :clojure.spec.alpha/invalid? {:ns "clojure.spec.alpha", :name "invalid?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 141, :examples nil, :notes nil, :arglists ["ret"], :doc "tests the validity of a conform return value", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/invalid_q"}, :clojure.core.async/untap-all {:ns "clojure.core.async", :name "untap-all", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 725, :examples nil, :notes nil, :arglists ["mult"], :doc "Disconnects all target channels from a mult", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/untap-all"}, :clojure.core/when-let {:added "1.0", :ns "clojure.core", :name "when-let", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/if-let :clojure.core/when :clojure.core/when-not :clojure.core/if :clojure.core/when-first :clojure.core/when-some], :line 1853, :examples [";; Very useful when working with sequences. Capturing the return value \n;; of `seq` brings a performance gain in subsequent `first`/`rest`/`next`\n;; calls. Also the block is guarded by `nil` punning.\n\n(defn drop-one\n  [coll]\n  (when-let [s (seq coll)]\n    (rest s)))\n\nuser=> (drop-one [1 2 3])\n(2 3)\nuser=> (drop-one [])\nnil\n" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";; Works well with collections\n\n(def x {:whatever 1})\n\n(when-let [value (:whatever x)]\n  (println \"x+1 = \" (inc value)))\n\n;; Prints: \"x+1 = 2\"" ";; when-let multiple bindings version\n\n(defmacro when-let*\n  ([bindings & body]\n   (if (seq bindings)\n     `(when-let [~(first bindings) ~(second bindings)]\n        (when-let* ~(drop 2 bindings) ~@body))\n     `(do ~@body))))\n\n(when-let* [a 1 \n            b 2 \n            c (+ a b)]\n           (println \"yeah!\")\n           c)\n;;=>yeah!\n;;=>3\n\n(when-let* [a 1 \n            b nil \n            c 3]\n            (println \"damn! b is nil\")\n            a)\n;;=>nil\n" ";; test is evaluated before values are bound to binding, so destructuring works\n(when-let [[a] nil] [a])\n=> nil\n(when-let [[a] [:a]] [a])\n=> [:a]\n(when-let [[a] []] [a])\n=> [nil]" ";; when-let multiple bindings version\n\n(defmacro when-let*\n          [bindings & body]\n          `(let ~bindings\n                (if (and ~@(take-nth 2 bindings))\n                  (do ~@body)\n                  )))\n\n(when-let* [a 1 \n            b 2 \n            c (+ a b)]\n           (println \"yeah!\")\n           c)\n;;yeah!\n;;=> 3\n\n(when-let* [a 1 \n            b nil \n            c 3]\n            (println \"damn! b is nil\")\n            a)\n;;=> nil" "(require '[reagent.core :as r])\n\n(def float-parsable? (comp not js/isNaN js/parseFloat))\n(def find-parsable-or-nil \n  (comp first \n        (partial re-find \n                 #\"(\\-?\\d+\\.)?\\d+([eE][-+]?\\d+)?\")))\n\n(defn number-input\n \"HTML input element for number only input\"\n [value]\n [:input\n  {:value @value\n   :type \"text\"\n   :on-change (comp\n               #(when-let [new-value %]\n                 (reset! value new-value))\n               (fn [value]\n                (cond\n                 (empty? value) \"\"\n                 (float-parsable? value) value\n                 :otherwise (find-parsable-or-nil value)))\n               (fn [target]\n                (.-value target))\n               (fn [event]\n                (.-target event)))}])\n\n(def value (r/atom \"\"))\n\n(defn demo []\n [:div\n  ; Displays NaN when value is \"\", displays a number otherwise.\n  (-> @value js/parseFloat str) [:br]\n  [number-input value]])"], :macro true, :notes ["The difference between when-let and if-let is that when-let doesn't have an else clause and and also accepts multiple forms so you don't need to use a (do...)." "The word \"bindings\" seems not to be correct here. In fact `when-let` only accepts **one** binding and not multiple ones.\r\nSo \"bindings\" might be confusing, at least it was for me." "Agreed. It ought to be \"binding\" for clarity." "```clojure\n(when-let [name test]\n  (do-something-with-name))\n```\n\nIn the example above, `test` does not have to be a predicate.\n`test` can be any value which is like `(seq coll)` or `3`, `[1 2]`, or so.\n\nIf `test` is neither `false` nor `nil`, `test` is bound to `name`.\n"], :arglists ["bindings & body"], :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/when-let"}, :clojure.core.logic.pldb/db {:ns "clojure.core.logic.pldb", :name "db", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 125, :examples nil, :notes nil, :arglists ["& facts"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/db"}, :clojure.core.logic/runcg {:ns "clojure.core.logic", :name "runcg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2053, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/runcg"}, :clojure.core.async/into {:ns "clojure.core.async", :name "into", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 972, :examples ["user=> (def c\n         (clojure.core.async/into [:a :b :c]\n                                  (to-chan\n                                   (range 10))))\n#'user/c\n\nuser=> (<!! c)\n[:a :b :c 0 1 2 3 4 5 6 7 8 9]\n"], :notes nil, :arglists ["coll ch"], :doc "Returns a channel containing the single (collection) result of the\n  items taken from the channel conjoined to the supplied\n  collection. ch must close before into produces a result.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/into"}, :clojure.xml/parse {:added "1.0", :ns "clojure.xml", :name "parse", :file "clojure/xml.clj", :type "function", :column 1, :see-alsos [:clojure.xml/emit-element :clojure.core/with-out-str :clojure.xml/element], :line 78, :examples ["(require '[clojure.xml :as xml]\n         '[clojure.zip :as zip])\n\n;;convenience function, first seen at nakkaya.com later in clj.zip src\n(defn zip-str [s]\n  (zip/xml-zip \n      (xml/parse (java.io.ByteArrayInputStream. (.getBytes s)))))\n\n;;parse from xml-strings to internal xml representation\nuser=> (zip-str \"<a href='nakkaya.com'/>\")\n[{:tag :a, :attrs {:href \"nakkaya.com\"}, :content nil} nil]\n\n;;root can be rendered with xml/emit-element\nuser=> (xml/emit-element (zip/root [{:tag :a, :attrs {:href \"nakkaya.com\"}, :content nil} nil]))\n<a href='nakkaya.com'/>\n\n;;printed (to assure it's not lazy and for performance), can be caught to string variable with with-out-str"], :notes nil, :arglists ["s" "s startparse"], :doc "Parses and loads the source s, which can be a File, InputStream or\n  String naming a URI. Returns a tree of the xml/element struct-map,\n  which has the keys :tag, :attrs, and :content. and accessor fns tag,\n  attrs, and content. Other parsers can be supplied by passing\n  startparse, a fn taking a source and a ContentHandler and returning\n  a parser", :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/parse"}, :clojure.xml/element {:ns "clojure.xml", :name "element", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos [:clojure.xml/emit-element :clojure.core/struct :clojure.core/struct-map :clojure.xml/parse :clojure.core/with-out-str], :line 20, :examples ["(use 'clojure.zip)\n\n;;using our old friend struct for performance in maps \n(struct element :httplink {:href \"http://clojure.org\"} nil)\n=>\n{:tag   :httplink, \n :attrs {:href \"http://clojure.org\"}, \n :content nil}\n\n;;these elements can be output to ordinary xml strings with emit-element\n(emit-element (struct element :httplink {:href \"http://clojure.org\"} nil))\n=>\n<httplink href='http://clojure.org'/>\n;;this is printed - can be catched with macro with-out-str\n\n;;make hierarchies:\n(struct element :parent {:name \"Barbara\"} \n  [(struct element :children {:name \"Gina\"} nil) \n   (struct element :children {:name \"John\"} nil)])\n=>\n{:tag :parent, :attrs {:name \"Barbara\"}, :content \n   [{:tag :children, :attrs {:name \"Gina\"}, :content nil} \n    {:tag :children, :attrs {:name \"John\"}, :content nil}]}\n\n;;which can be emit-elemented as well\n\n(emit-element {:tag :parent, :attrs {:name \"Barbara\"}, :content [{:tag :children, :attrs {:name \"Gina\"}, :content nil} {:tag :children, :attrs {:name \"John\"}, :content nil}]})\n=>\n<parent name='Barbara'>\n <children name='Gina'/>\n <children name='John'/>\n</parent>"], :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/element"}, :clojure.core.logic.fd/distinct {:ns "clojure.core.logic.fd", :name "distinct", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 1077, :examples nil, :notes nil, :arglists ["v*"], :doc "A finite domain constraint that will guarantee that \n   all vars that occur in v* will be unified with unique \n   values. v* need not be ground. Any vars in v* should\n   eventually be given a domain.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/distinct"}, :clojure.core.async/Mult {:ns "clojure.core.async", :name "Mult", :file "clojure/core/async.clj", :type "var", :column 1, :see-alsos nil, :line 664, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/Mult"}, :clojure.core.logic/reify-lvar-name {:ns "clojure.core.logic", :name "reify-lvar-name", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 253, :examples nil, :notes nil, :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/reify-lvar-name"}, :clojure.core.logic.fd/eq {:ns "clojure.core.logic.fd", :name "eq", :file "clojure/core/logic/fd.clj", :type "macro", :column 1, :see-alsos nil, :line 1156, :examples nil, :macro true, :notes nil, :arglists ["& forms"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/eq"}, :clojure.core/defmacro {:added "1.0", :ns "clojure.core", :name "defmacro", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/macroexpand :clojure.core/macroexpand-1 :clojure.walk/macroexpand-all], :line 444, :examples ["(defmacro with-tree\n  \"works on a JTree and restores its expanded paths after executing body\"\n  [tree & body]\n  `(let [tree# ~tree\n         root# (.getRoot (.getModel tree#))\n         expanded# (if-let [x# (.getExpandedDescendants\n                                tree# (TreePath. root#))]\n                     (enumeration-seq x#)\n                     ())\n         selectionpaths# (. selectionmodel# getSelectionPaths)]\n     ~@body\n     (doseq [path# expanded#]\n       (.expandPath tree# path#))))\n\n;; usage:\n\n(with-tree *one-jtree-instance*\n   ;; some code here...\n  )" "(defmacro unless [pred a b]\n  `(if (not ~pred) ~a ~b))\n\n;; usage:\n\n(unless false (println \"Will print\") (println \"Will not print\"))" "(def dbg 1)\n\n(defmacro chk-flagM\n  \"Throws an exception if flag does not resolve; else returns flag's value.\"\n  [flag]\n  (if (not (resolve flag))\n    (throw (Exception. (str 'flag \" is not a valid var.\")))\n    flag))\n\n(defn write-csv-file\n  \"Writes a csv file using a key and an s-o-s\"\n  [out-sos out-file]\n\n  (if (>= (chk-flagM dbg) 2)\n    (println (first out-sos), \"\\n\", out-file))\n\n  (spit out-file \"\" :append false)\n  (with-open [out-data (io/writer out-file)]\n      (csv/write-csv out-data (map #(concat % [\"\"]) out-sos))))\n\n"], :macro true, :notes ["The body of a macro has two implicitly bound symbols: <code>&amp;form</code> and <code>&amp;env</code>.  They work like two extra unnamed args.  The names begin with '&amp;' to avoid name clashes with normal user-defined symbols.  The value of <code>&amp;form</code> is the form of the original macro call before macro expansion.  There's useful meta-data on <code>&amp;form</code>. The value of <code>&amp;env</code> is the \"environment\", which is basically a map of lexical bindings.  The keys of <code>&amp;env</code> are the lexically bound symbols.  The values are internal compiler details, and probably aren't useful for user code.\r\n\r\n\r\nSee also:\r\n[http://blog.jayfields.com/2011/02/clojure-and.html](http://blog.jayfields.com/2011/02/clojure-and.html)" "Due to syntax-quote resolving symbols (see the [Clojure reader docs](http://clojure.org/reader)), you won't be able to include a regular `let` statement inside a macro, i.e.:\r\n\r\n<pre>(defmacro m [] `(let [x 1] x))\r\n(m) ; => CompilerException java.lang.RuntimeException: Can't let qualified name: user/x, compiling:(NO_SOURCE_PATH:1)</pre>\r\n\r\nWe can see why:\r\n\r\n<pre>(macroexpand-1 '(m)) ; => (clojure.core/let [user/x 1] user/x)</pre>\r\nThe syntax-quote has resolved `x` to `user/x`â€”which can't be `let`. This is a good thing, as it's signalling to us that we should use gensyms by appending `#`:\r\n\r\n<pre>(defmacro m [] `(let [x# 1] x#))\r\n(m) ; => 1\r\n(macroexpand-1 '(m)) ; => (clojure.core/let [x__383__auto__ 1] x__383__auto__)</pre>" "@Arlen:\r\nIf you want to capture the local variables, or create a non-locally scoped variable, you can prepend them with ~', allow a namespace capture:\r\n\r\n<pre>(defmacro m [] `(let [~'x 1] ~'x))\r\n(m) ; =&gt; 1\r\n(macroexpand-1 '(m)) ; =&gt; (clojure.core/let [x 1] x)\r\n</pre>\r\nuseful, if you desire it."], :arglists ["name doc-string? attr-map? [params*] body" "name doc-string? attr-map? ([params*] body) + attr-map?"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defmacro"}, :clojure.core/cat {:added "1.7", :ns "clojure.core", :name "cat", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core.reducers/cat :clojure.core.reducers/foldcat], :line 7539, :examples [";; cat is handy for untangling nested collections when using transducers\n\n(into [] (comp cat cat (map inc)) [[[1] [2]] [[3] [4]]])\n;; => [2 3 4 5]" ";; Remove the need of (mapcat identity coll) idiom:\n(def rota (sequence cat (repeat [\"tom\" \"nick\" \"jane\"])))\n(nth rota 7) ; who's up next week?\n;; nick"], :notes nil, :arglists ["rf"], :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/cat"}, :clojure.core.async/merge {:ns "clojure.core.async", :name "merge", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/mix], :line 954, :examples ["user=> (def cx (chan))\n#'user/cx\n\nuser=> (def cy (chan))\n#'user/cy\n\nuser=> (def mc (clojure.core.async/merge [cx cy]))\n#'user/mc\n\nuser=> (put! cx \"Going to x\")\ntrue\n\nuser=> (put! cy \"Goint to y\")\ntrue\n\nuser=> (<!! mc)\n\"Going to x\"\n\nuser=> (<!! mc)\n\"Goint to y\"\n"], :notes nil, :arglists ["chs" "chs buf-or-n"], :doc "Takes a collection of source channels and returns a channel which\n  contains all values taken from them. The returned channel will be\n  unbuffered by default, or a buf-or-n can be supplied. The channel\n  will close after all the source channels have closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/merge"}, :clojure.reflect/do-reflect {:ns "clojure.reflect", :name "do-reflect", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["reflector typeref"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/do-reflect"}, :clojure.core/min-key {:added "1.0", :ns "clojure.core", :name "min-key", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/min :clojure.core/max-key], :line 4949, :examples [";; we have a list of key colours\n;; We want to find the one closest to a supplied colour\n;; We're storing rgb values as [r g b]\n;; use min-key to find colour that minimizes \n;; the euclidean distance between the supplied colour \n;; and each key colour\n;; thanks to rhudson, raek and mfex on #clojure\n\n(defn distance-squared [c1 c2]\n  \"Euclidean distance between two collections considered as coordinates\"\n  (->> (map - c1 c2) (map #(* % %)) (reduce +)))\n\n(def key-colours\n     {[224 41 224] :purple\n      [24 180 46] :green\n      [12 129 245] :blue\n      [254 232 23] :yellow\n      [233 233 233] :white\n      [245 27 55] :red\n      [231 119 41] :orange\n      })\n\n(defn rgb-to-key-colour\n  \"Find colour in colour map closest to the supplied [r g b] triple\"\n  [rgb-triple colour-map]\n  (colour-map\n   (apply min-key (partial distance-squared rgb-triple) (keys colour-map))))\n\nuser=> (rgb-to-key-colour [255 0 0] key-colours)\n:red\n" "; \"min-key\"/\"max-key\" to \"min\"/\"max\" like \"sort-by\" to \"sort\"\n(min-key #(Math/abs %) -3 1 4)\n; 1\n\n(apply min-key #(Math/abs %) [-3 1 4])\n; 1\n"], :notes nil, :arglists ["k x" "k x y" "k x y & more"], :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/min-key"}, :clojure.core.logic/and* {:ns "clojure.core.logic", :name "and*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1273, :examples nil, :notes nil, :arglists ["goals"], :doc "A function version of all, which takes a list of goals and succeeds only fi they all succeed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/and*"}, :clojure.core/unchecked-byte {:added "1.3", :ns "clojure.core", :name "unchecked-byte", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/byte], :line 3508, :examples ["user=> (unchecked-byte 127)\n127\nuser=> (unchecked-byte 128)\n-128\nuser=> (unchecked-byte 255)\n-1\nuser=> (unchecked-byte 256)\n0\nuser=> (unchecked-byte 257)\n1" "(unchecked-byte 1)\n;;=> 1\n(unchecked-byte 1N)\n;;=> 1\n(unchecked-byte 1.1)\n;;=> 1\n(unchecked-byte 1.9)\n;;=> 1\n(unchecked-byte 5/3)\n;;=> 1\n\n(unchecked-byte -1)\n;;=> -1\n(unchecked-byte -1N)\n;;=> -1\n(unchecked-byte -1.1)\n;;=> -1\n(unchecked-byte -1.9)\n;;=> -1\n(unchecked-byte -5/3)\n;;=> -1\n\n;;;; Note that (unchecked-byte) does not range check its argument\n;;;; so integer overflow or rounding may occur. \n;;;; Use (byte) if you want to throw an exception in such cases.\n\n(unchecked-byte 128)\n;;=> -128\n(unchecked-byte -129)\n;;=> 129\n\n(byte 128)\n;;=> IllegalArgumentException Value out of range for byte: 128\n(byte -129)\n;;=> IllegalArgumentException Value out of range for byte: -129\n\n(unchecked-byte 1.0E2)\n;;=> 100\n(unchecked-byte 1.0E3)\n;;=> -24\n\n(byte 1.0E2)\n;;=> 100\n(byte 1.0E3)\n;;=> IllegalArgumentException Value out of range for byte: 1000.0"], :notes nil, :arglists ["x"], :doc "Coerce to byte. Subject to rounding or truncation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-byte"}, :clojure.test/*initial-report-counters* {:ns "clojure.test", :name "*initial-report-counters*", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 264, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/*initial-report-counters*"}, :clojure.core.logic/to-stream {:ns "clojure.core.logic", :name "to-stream", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1794, :examples nil, :notes nil, :arglists ["aseq"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/to-stream"}, :clojure.set/intersection {:added "1.0", :ns "clojure.set", :name "intersection", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.set/union :clojure.set/difference :clojure.set/superset? :clojure.set/project], :line 33, :examples ["user=> (clojure.set/intersection #{1})\n#{1}\nuser=> (clojure.set/intersection #{1 2} #{2 3})\n#{2}\nuser=> (clojure.set/intersection #{1 2} #{2 3} #{3 4})\n#{}\nuser=> (clojure.set/intersection #{1 :a} #{:a 3} #{:a})\n#{:a}\n" "; gcd => Greatest common divisor\n(defn find-divisors [x]\n  (let [divisors (atom [x])]\n    (doseq [_x (range 1 x)] (if (== 0 (mod x _x))\n                              (swap! divisors conj _x)\n                              ))\n    @divisors\n    )\n  )\n(defn gcd [x y] (let\n                  [x-div (set (find-divisors x))\n                   y-div (set (find-divisors y))]\n                  (last (into [] (clojure.set/intersection y-div x-div)))\n                  ))\n;; lcm least common multiply\n(defn lcm [x y] (/ (Math/abs (* x y)) (gcd x y)))\n\n\n=> #'user/find-divisors\n=> #'user/gcd\n=> #'user/lcm\n(lcm 4 6)\n=> 12" "(clojure.set/intersection #{:a :b :c} #{:d :c :b})\n;=> #{:b :c}\n\n(clojure.set/intersection #{:a :e :i :o :u}\n\t\t\t  #{:a :u :r}\n\t\t\t  #{:r :u :s})\n;=> #{:u}" ";; Advice: Do not call intersection with non-set arguments.  If you\n;; are concerned that you may be unintentionally doing so, and want an\n;; exception to be thrown if you do, consider using the library\n;; funjible (https://github.com/jafingerhut/funjible) which provides\n;; its own definition of intersection that is identical to Clojure's,\n;; except it checks the types of its arguments.\n\n;; intersection might or might not return what you expect if you give it\n;; values that are not sets.  The implementation of intersection _does not\n;; check_ whether you are actually giving it values that are sets.  It\n;; _assumes_ so.\n\n;; It is possible that intersection _might_ throw an exception if you\n;; give it a non-set as an argument:\nuser=> (intersection #{1 3 5} [2 4])\nClassCastException clojure.lang.PersistentVector cannot be cast to clojure.lang.IPersistentSet  clojure.core/disj (core.clj:1517)\n\n;; But it can also simply return an answer that is not the\n;; intersection of the two collections:\nuser=> (intersection #{1 3 5} [2 4 6 8])\n#{1 3}\n\n;; In the previous case, it includes elements in the returned set that\n;; you would not expect.  It can also leave out elements in the\n;; returned set that you would expect to find there.\nuser=> (intersection #{\"1\" \"3\" \"5\"} [\"1\" \"3\" \"5\" \"7\"])\n#{}\n\n;; Why not change the definition of intersection so it always throws\n;; an exception if you give it a non-set argument?  I would guess that\n;; the primary reason is that the extra run-time type checks would\n;; slow intersection down by an amount that the Clojure core team does\n;; not want everyone to have to pay on every such call.\n\n;; Related Clojure tickets: \n;; https://dev.clojure.org/jira/browse/CLJ-1953\n;; https://dev.clojure.org/jira/browse/CLJ-2287\n"], :notes nil, :arglists ["s1" "s1 s2" "s1 s2 & sets"], :doc "Return a set that is the intersection of the input sets", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/intersection"}, :clojure.core/all-ns {:added "1.0", :ns "clojure.core", :name "all-ns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-name], :line 4113, :examples ["user=> (all-ns)\n(#<Namespace clojure.set> #<Namespace clojure.pprint> #<Namespace cake.contrib.server-socket> #<Namespace user> #<Namespace clojure.main> #<Namespace useful.io> #<Namespace clojure.core> #<Namespace clojure.java.shell> #<Namespace cake.tasks.help> #<Namespace clojure.zip> #<Namespace clojure.java.browse> #<Namespace clojure.repl> #<Namespace cake.tasks.new> #<Namespace cake.server> #<Namespace cake.ant> #<Namespace cake.contrib.find-namespaces> #<Namespace clojure.java.io> #<Namespace clojure.stacktrace> #<Namespace clojure.core.protocols> #<Namespace cake.project> #<Namespace clojure.xml> #<Namespace clojure.java.javadoc> #<Namespace useful> #<Namespace complete> #<Namespace cake>)" ";; The names of all your current namespaces that end in \"-test\":\n\n(->> (all-ns)\n     (map ns-name)\n     (map name)\n     (filter #(clojure.string/ends-with? % \"-test\")))\n;;=> (\"core-test\" \"farg.pmatch-test\")"], :notes nil, :arglists [""], :doc "Returns a sequence of all namespaces.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/all-ns"}, :clojure.core/num {:added "1.0", :ns "clojure.core", :name "num", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/number?], :line 3465, :examples ["user=> (num 2048)\n2048\n\n\n;; Calling a Number http://download.oracle.com/javase/6/docs/api/ method:\n\nuser=> (def x (num 2048))\n#'user/x\n\nuser=> (.floatValue x)\n2048.0\n"], :notes nil, :tag "java.lang.Number", :arglists ["x"], :doc "Coerce to Number", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/num"}, :clojure.core.logic/unify {:ns "clojure.core.logic", :name "unify", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 236, :examples nil, :notes nil, :arglists ["s u v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unify"}, :clojure.core/StackTraceElement->vec {:added "1.9", :ns "clojure.core", :name "StackTraceElement->vec", :file "clojure/core_print.clj", :type "function", :column 1, :see-alsos nil, :line 465, :examples [";;;; StackTraceElements look like vectors when printed, but they\n;;;; are actually a completely different type. \n;;;; (StackTraceElement->vec) turns them into normal Clojure vectors.\n\n(try \n  (/ 1 0)\n  (catch Exception e \n    (let [cause (->> e .getStackTrace seq first)]\n      (pprint cause)\n      (class cause))))\n;;=> [clojure.lang.Numbers divide \"Numbers.java\" 158]\n;;=> java.lang.StackTraceElement\n\n(try \n  (/ 1 0)\n  (catch Exception e \n    (let [cause (->> e .getStackTrace seq first StackTraceElement->vec)]\n      (pprint cause)\n      (class cause))))\n;;=> [clojure.lang.Numbers divide \"Numbers.java\" 158]\n;;=> clojure.lang.PersistentVector\n"], :notes nil, :arglists ["o"], :doc "Constructs a data representation for a StackTraceElement", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/StackTraceElement->vec"}, :clojure.core/proxy-super {:added "1.0", :ns "clojure.core", :name "proxy-super", :file "clojure/core_proxy.clj", :type "macro", :column 1, :see-alsos [:clojure.core/proxy], :line 391, :examples [";; Create a proxy for java.util.ArrayList that overrides the add() \n;; method and calls the super class implementation using proxy-super.\n(def lst (proxy [java.util.ArrayList] []\n           (add [x]\n             (println \"Adding some stuff:\" x)\n             (proxy-super add x))))\n\nuser=> (.add lst 1)\nAdding some stuff: 1\ntrue\n\nuser=> (.add lst 2)\nAdding some stuff: 2\ntrue\n\nuser=> (.add lst [:this :is :some :other :stuff])\nAdding some stuff: [:this :is :some :other :stuff]\ntrue\n\nuser=> (.size lst)\n3\n\n\n "], :macro true, :notes ["Note that proxy-super calls are not reentrant. If calling the base method results in another call to the virtual method you are overriding (before the proxy-super call has returned), your proxy's code will not be invoked. Instead, the call will go directly to the base class's method.\r\n"], :arglists ["meth & args"], :doc "Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/proxy-super"}, :clojure.core.async/solo-mode {:ns "clojure.core.async", :name "solo-mode", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 833, :examples nil, :notes nil, :arglists ["mix mode"], :doc "Sets the solo mode of the mix. mode must be one of :mute or :pause", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/solo-mode"}, :clojure.walk/walk {:added "1.1", :ns "clojure.walk", :name "walk", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/postwalk :clojure.walk/prewalk], :line 35, :examples ["(use 'clojure.walk)\n\n(walk #(* 2 %) #(apply + %) [1 2 3 4 5])\n;=> 30\n\n(walk second #(apply max %) [ [1 2] [3 4] [5 6] ])\n;=> 6\n\n(walk first #(apply max %) [ [1 2] [3 4] [5 6] ])\n;=> 5\n\n(walk first reverse [ [1 2] [3 4] [5 6] ])\n;=> (5 3 1)" "(require '[clojure.walk :as w])\n\n(w/walk (fn [[k v]] [k (* 10 v)]) identity {:a 1 :b 2 :c 3})\n;=> {:a 10, :c 30, :b 20}\n\n(w/postwalk #(if (number? %) (* 2 %) %) [[1 2 3] [4 7 2] [2 5 2]])\n;=> [[2 4 6] [8 14 4] [4 10 4]]\n\n(let [s [1 '(2 3 [1])]] \n  (w/postwalk #(if (seq? %) (vec %) %) s))\n;=> [1 [2 3 [1]]]\n\n(w/walk (comp vec reverse) identity {0 :start 1 :inprogress 2 :end})\n;=> {:start 0, :inprogress 1, :end 2}"], :notes nil, :arglists ["inner outer form"], :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/walk"}, :clojure.core.logic.fd/quot {:ns "clojure.core.logic.fd", :name "quot", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 983, :examples nil, :notes nil, :arglists ["u v w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/quot"}, :clojure.core.reducers/CollFold {:ns "clojure.core.reducers", :name "CollFold", :file "clojure/core/reducers.clj", :type "var", :column 1, :see-alsos nil, :line 81, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/CollFold"}, :clojure.core/split-with {:added "1.0", :ns "clojure.core", :name "split-with", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/split-at :clojure.string/split :clojure.core/take-while :clojure.core/drop-while], :line 2984, :examples ["user=> (split-with (partial >= 3) [1 2 3 4 5])\n[(1 2 3) (4 5)]\n\nuser=> (split-with (partial > 3) [1 2 3 2 1])\n[(1 2) (3 2 1)]\n\nuser=> (split-with (partial > 10) [1 2 3 2 1])\n[(1 2 3 2 1) ()]" ";; If your plan is to split based on a certain value, using sets as\n;; predicates here isn't entirely straightforward.\n\nuser=> (split-with #{:c} [:a :b :c :d])\n[() (:a :b :c :d)]\n\n;; This is because the split happens at the first false/nil predicate result.\n;; Your predicate should thus return false upon hitting the desired split value!\n\nuser=> (split-with (complement #{:c}) [:a :b :c :d])\n[(:a :b) (:c :d)]\n\n;; In short, the predicate defines an attribute valid for the whole left\n;; side of the split. There's no such guarantee for the right side!\n\nuser=> (split-with odd? [1 3 5 6 7 9])\n[(1 3 5) (6 7 9)]\n\n;; Except if your predicate never returns false.\nuser=> (split-with (complement #{:e}) [:a :b :c :d])\n[(:a :b :c :d) ()]\n"], :notes nil, :arglists ["pred coll"], :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/split-with"}, :clojure.core/aset-float {:added "1.0", :ns "clojure.core", :name "aset-float", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3927, :examples [";; create an array of 10 floats and set one of the values to 3.1415\n\nuser=> (def fs (float-array 10))\n#'user/fs\nuser=> (vec fs)\n[0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0]\nuser=> (aset-float fs 3 3.1415)\n3.1415\nuser=> (vec fs)\n[0.0 0.0 0.0 3.1415 0.0 0.0 0.0 0.0 0.0 0.0]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of float. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-float"}, :clojure.core.async/solo-mode* {:ns "clojure.core.async", :name "solo-mode*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m mode"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/solo-mode*"}, :clojure.core/remove-watch {:added "1.0", :ns "clojure.core", :name "remove-watch", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/add-watch :clojure.core/atom :clojure.core/var :clojure.core/ref], :line 2154, :examples ["(def a (atom nil))\n\n;; The key of the watch is `:logger`\n(add-watch a :logger #(println %4))\n\n(reset! a [1 2 3])\n\n;; Deactivate the watch by its assigned key\n(remove-watch a :logger)"], :notes nil, :arglists ["reference key"], :doc "Removes a watch (set by add-watch) from a reference", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/remove-watch"}, :clojure.core/disj! {:added "1.1", :ns "clojure.core", :name "disj!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc! :clojure.core/dissoc! :clojure.core/disj], :line 3392, :examples [";; Note how we always use the return value of disj! and conj! in these examples\n;; for all future modifications, rather than (incorrectly) ignoring the return\n;; value and continuing to modify the original transient set.  See examples for\n;; assoc! and dissoc! for more discussion and examples of this.\n\nuser=> (def foo (transient #{'pore-pore 'slow 'yukkuri}))\n#'user/foo\nuser=> (count foo)\n3\nuser=> (def foo (disj! foo 'yukkuri))\n#'user/foo\nuser=> foo\n#<TransientHashSet clojure.lang.PersistentHashSet$TransientHashSet@3bd840d9>\nuser=> (count foo)\n2\nuser=> (def foo (conj! foo 'yukkuri))\n#'user/foo\nuser=> foo\n#<TransientHashSet clojure.lang.PersistentHashSet$TransientHashSet@3bd840d9>\nuser=> (count foo)\n3\nuser=> (def foo (persistent! foo))\n#'user/foo\nuser=> foo\n#{yukkuri slow pore-pore}\n" ";; A faster implementation of disj for a large number of keys to disjoin:\n\n(defn disj* [s & ks]\n  (persistent!\n    (reduce disj! (transient s) ks)))\n\n(let [s (set (range 1000))\n      xs (range 400 600)]\n  (count (apply disj* s xs)))\n;; 800"], :notes nil, :arglists ["set" "set key" "set key & ks"], :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/disj!"}, :clojure.core/not-empty {:added "1.0", :ns "clojure.core", :name "not-empty", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/empty :clojure.core/empty? :clojure.core/seq], :line 5477, :examples ["user=> (not-empty [1])\n[1]\nuser=> (not-empty [1 3 5])\n[1 3 5]\nuser=> (not-empty [])\nnil\nuser=> (not-empty '())\nnil\nuser=> (not-empty {})\nnil\nuser=> (not-empty nil)\nnil" ";; Same behaviour for strings\n\nuser> (not-empty \"hello\")\n\"hello\"\n\nuser> (not-empty \"\")\nnil"], :notes nil, :arglists ["coll"], :doc "If coll is empty, returns nil, else coll", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/not-empty"}, :clojure.core/ns-interns {:added "1.0", :ns "clojure.core", :name "ns-interns", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-map :clojure.core/ns-publics :clojure.core/ns-aliases :clojure.core/ns-refers], :line 4173, :examples ["user=> (take 2 (ns-interns `clojure.core))\n([sorted-map #'clojure.core/sorted-map] [read-line #'clojure.core/read-line])\n\nuser=> (take 5 (sort (keys (ns-interns `clojure.java.io))))\n(Coercions IOFactory append? as-file as-relative-path)\n\nuser=> (count (ns-interns `clojure.core)) ; only 621 functions to learn :-)\n621\nuser=>" ";; See also http://clojure.org/namespaces for information on namespaces in Clojure and how to inspect and manipulate them"], :notes nil, :arglists ["ns"], :doc "Returns a map of the intern mappings for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-interns"}, :clojure.test/assert-any {:added "1.1", :ns "clojure.test", :name "assert-any", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 454, :examples nil, :notes nil, :arglists ["msg form"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/assert-any"}, :clojure.core/bean {:added "1.0", :ns "clojure.core", :name "bean", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos nil, :line 398, :examples ["user=> (import java.util.Date)\njava.util.Date\n\nuser=> (def ^:dynamic *now* (Date.))\n#'user/*now*\n\nuser=> (bean *now*)\n{:seconds 57, :date 13, :class java.util.Date, :minutes 55, :hours 17, :year 110, :timezoneOffset -330, :month 6, :day 2, :time 1279023957492}\n" ";; although not reference-able in Clojuredocs, \n;; org.clojure/java.data provides a useful, alternative 'from-java' function \n;; that works similarly to bean, but more customizable.\n;; See https://github.com/clojure/java.data for more info."], :notes nil, :arglists ["x"], :doc "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bean"}, :clojure.core.logic/treec {:ns "clojure.core.logic", :name "treec", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2876, :examples nil, :notes nil, :arglists ["x fc reifier"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/treec"}, :clojure.core/chunked-seq? {:ns "clojure.core", :name "chunked-seq?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk :clojure.core/chunk-first :clojure.core/chunk-rest :clojure.core/chunk-buffer :clojure.core/chunk-next], :line 707, :examples ["user=> (chunked-seq? (range 1000))\nfalse\n\nuser=> (chunked-seq? (seq (range 1000)))\ntrue\n\nuser=> (chunked-seq? (iterate inc 10))\nfalse\n\nuser=> (chunked-seq? (seq (iterate inc 10)))\nfalse"], :notes nil, :arglists ["s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunked-seq_q"}, :clojure.java.javadoc/add-remote-javadoc {:added "1.2", :ns "clojure.java.javadoc", :name "add-remote-javadoc", :file "clojure/java/javadoc.clj", :type "function", :column 1, :see-alsos nil, :line 48, :examples ["user=> (use 'clojure.java.javadoc)\nnil\n\nuser=> (add-remote-javadoc \"org.apache.commons.csv.\"\n           \"http://commons.apache.org/proper/commons-csv/apidocs/index.html\")\n{\"java.\" \"http://java.sun.com/javase/6/docs/api/\",\n \"javax.\" \"http://java.sun.com/javase/6/docs/api/\",\n \"org.apache.commons.codec.\" \"http://commons.apache.org/codec/api-release/\",\n \"org.apache.commons.csv.\" \"http://commons.apache.org/proper/commons-csv/apidocs/index.html\",\n \"org.apache.commons.io.\" \"http://commons.apache.org/io/api-release/\",\n \"org.apache.commons.lang.\" \"http://commons.apache.org/lang/api-release/\",\n \"org.ietf.jgss.\" \"http://java.sun.com/javase/6/docs/api/\",\n \"org.omg.\" \"http://java.sun.com/javase/6/docs/api/\",\n \"org.w3c.dom.\" \"http://java.sun.com/javase/6/docs/api/\",\n \"org.xml.sax.\" \"http://java.sun.com/javase/6/docs/api/\"}"], :notes nil, :arglists ["package-prefix url"], :doc "Adds to the list of remote Javadoc URLs.  package-prefix is the\n  beginning of the package name that has docs at this URL.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/add-remote-javadoc"}, :clojure.spec.alpha/cat-impl {:ns "clojure.spec.alpha", :name "cat-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1344, :examples nil, :notes nil, :arglists ["ks ps forms"], :doc "Do not call this directly, use 'cat'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/cat-impl"}, :clojure.core/find-keyword {:added "1.3", :ns "clojure.core", :name "find-keyword", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/keyword :clojure.core/name :clojure.core/keyword? :clojure.core/symbol :clojure.core/intern], :line 617, :examples ["user=> (find-keyword \"a\")\nnil\nuser=> :a\n:a\nuser=> (find-keyword \"a\")\n:a"], :notes nil, :tag "clojure.lang.Keyword", :arglists ["name" "ns name"], :doc "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find-keyword"}, :clojure.java.shell/with-sh-dir {:added "1.2", :ns "clojure.java.shell", :name "with-sh-dir", :file "clojure/java/shell.clj", :type "macro", :column 1, :see-alsos [:clojure.java.shell/sh], :line 21, :examples nil, :macro true, :notes nil, :arglists ["dir & forms"], :doc "Sets the directory for use with sh, see sh for details.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.shell/with-sh-dir"}, :clojure.core/next {:added "1.0", :ns "clojure.core", :name "next", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rest :clojure.core/first :clojure.core/fnext :clojure.core/nthrest :clojure.core/nthnext], :line 57, :examples ["user=> (next '(:alpha :bravo :charlie))\n(:bravo :charlie)\n\nuser=> (next (next '(:one :two :three)))\n(:three)\n\nuser=> (next (next (next '(:one :two :three))))\nnil" ";; next is used in the recursive call.  (This is a naive implementation for illustration only.  Using `rest` is usually preferred over `next`.)\n\n(defn my-map [func a-list]\n  (when a-list\n    (cons (func (first a-list))\n          (my-map func (next a-list)))))" ";; Difference between next and rest:\n\n(next [:a])\n;; => nil\n(rest [:a])\n;; => ()\n\n(next [])\n;; => nil\n(rest [])\n;; => ()\n\n(next nil)\n;; => nil\n(rest nil)\n;; => ()"], :notes ["<pre>(next aseq) === (seq (rest aseq))</pre>\r\n\r\nWhen writing lazy sequence functions, you should use [rest](../clojure.core/rest), not <b>next</b>."], :tag "clojure.lang.ISeq", :arglists ["coll"], :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/next"}, :clojure.core/seque {:added "1.0", :ns "clojure.core", :name "seque", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 5337, :examples ["user=> (let [start (System/nanoTime)\n             q (seque\n                 (iterate\n                   #(do (Thread/sleep 400) (inc %))\n                   0))]\n         (println \"sleep five seconds...\")\n         (Thread/sleep 5000)\n         (doseq [i (take 20 q)]\n           (println (int (/ (- (System/nanoTime) start) 1e7))\n                    \":\" i)))\n\n\n;; The iterate form returns a lazy seq that delays nearly a half-second \n;; before returning each subsequent item.  Here seque starts a thread \n;; generating the lazy seq.\n\n;; The body of the let allows the seque thread to get ahead by five seconds\n;; before it begins consuming the seq using doseq.  The doseq prints a \n;; timestamp and the value from the seq when it becomes available.  The\n;; first 11 or so are available almost instantly, until the consuming \n;; doseq catches up with the producing iterate, at which point the consumer\n;; blocks for 400ms before each item can be printed.\n\n;;sleep five seconds...\n500 : 0\n500 : 1\n500 : 2\n500 : 3\n500 : 4\n500 : 5\n500 : 6\n500 : 7\n500 : 8\n500 : 9\n500 : 10\n500 : 11\n520 : 12\n560 : 13\n600 : 14\n640 : 15\n680 : 16\n720 : 17\n760 : 18\n800 : 19\n\n" ";; A relatively fast producer (a file filter) and a variable speed consumer\n;; (because of pagination) are piped together. Use seque to enable search ahead \n;; of \"n\" items assuming consumer will soon paginate.\n\n(defn search-files [q root n]\n  (->> (java.io.File. root)\n       file-seq\n       (map (memfn getPath))\n       (filter #(re-find q %))\n       (seque n)))\n\n(defn paginate [n]\n  (let [root (System/getProperty \"user.home\")\n        search (search-files #\"\\.clj$\" root 1000)]\n    (loop [results (partition n search)]\n      (println (with-out-str (clojure.pprint/write (first results))))\n      (println \"more?\")\n      (when (= \"y\" (read-line))\n        (recur (rest results))))))\n\n(paginate 3)\n;; (\"/Users/reborg/.atom/fixtures/bad.clj\"\n;;  \"/Users/reborg/.atom/fixtures/empty.clj\"\n;;  \"/Users/reborg/.atom/fixtures/good.clj\")\n;; more?\n\n;; Note: seque is now producing 997 items ahead."], :notes nil, :arglists ["s" "n-or-q s"], :doc "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/seque"}, :clojure.zip/node {:added "1.0", :ns "clojure.zip", :name "node", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 64, :examples ["user=>(require '[clojure.zip :as zip])\nnil\nuser=> (def original [1 '(a b c) 2])\n#'user/original\nuser=> (def root-loc (zip/seq-zip (seq original)))\n#'user/root-loc\n\nuser=> (zip/node (zip/down root-loc))\n1\n"], :notes ["See tutorial of clojure.zip at \r\nhttp://www.exampler.com/blog/2010/09/01/editing-trees-in-clojure-with-clojurezip/"], :arglists ["loc"], :doc "Returns the node at loc", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/node"}, :clojure.core.logic/make-cs {:ns "clojure.core.logic", :name "make-cs", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 188, :examples nil, :notes nil, :arglists [""], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/make-cs"}, :clojure.core.logic/enforce-constraints {:ns "clojure.core.logic", :name "enforce-constraints", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2156, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/enforce-constraints"}, :clojure.core/volatile! {:added "1.7", :ns "clojure.core", :name "volatile!", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/vswap! :clojure.core/vreset! :clojure.core/volatile? :clojure.core/atom], :line 2517, :examples ["(def val (volatile! 0))\n\n@val\n;;=> 0\n\n(vswap! val inc)\n;;=> 1\n\n(vreset! val \"nothing\")\n;;=> \"nothing\"\n\n@val\n;;=> \"nothing\""], :notes ["An exhaustive StackOverflow question about volatile!\n\nhttp://stackoverflow.com/questions/31288608/what-is-clojure-volatile#comment50623688_31288608" "Volatiles are meant to hold state in stateful transducers, since they are more performant (and less capable) than atoms.\n\nVolatiles are just a wrapped  Java `volatile Object` reference. The Java `volatile`\nkeyword implies that reading and writing from this variable will not be reordered by JIT or the CPU. It does *not* imply atomicity.\n\nChanges to references made `volatile` are always \"written through\" CPU caches all the way to main memory (which is somewhat expensive), this means changes are guaranteed to propagate to other threads (nescessary in stateful transducers)."], :tag "clojure.lang.Volatile", :arglists ["val"], :doc "Creates and returns a Volatile with an initial value of val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/volatile!"}, :clojure.core// {:added "1.0", :ns "clojure.core", :name "/", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/quot :clojure.core/unchecked-divide-int], :line 1012, :examples ["user=> (/ 6 3)\n2\n\nuser=> (/ 6 3 2)\n1\n\nuser=> (/ 10)\n1/10\n\nuser=> (/ 1 3)\n1/3\n\nuser=> (/)\nArityException Wrong number of args (0) passed to: core$-SLASH-\n\nuser=> (/ 1 0)\njava.lang.ArithmeticException\n\nuser=> (/ 0)\njava.lang.ArithmeticException\n" ";;; Automatically handles floating point:\n\nuser=> (/ 43.0 2)\n21.5"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/_fs"}, :clojure.java.io/copy {:added "1.2", :ns "clojure.java.io", :name "copy", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/file], :line 391, :examples ["(ns your-project\n  (:require [clojure.java.io :as io]))\n\n(defn copy-file [source-path dest-path]\n  (io/copy (io/file source-path) (io/file dest-path)))\n\n(copy-file \"/home/username/squirrel.txt\" \"/home/username/burt-reynolds.txt\")"], :notes nil, :arglists ["input output & opts"], :doc "Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], char[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/copy"}, :clojure.repl/thread-stopper {:ns "clojure.repl", :name "thread-stopper", :file "clojure/repl.clj", :type "function", :column 1, :see-alsos nil, :line 271, :examples nil, :notes nil, :arglists ["" "thread"], :doc "Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/thread-stopper"}, :clojure.spec.alpha/gen {:ns "clojure.spec.alpha", :name "gen", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 272, :examples nil, :notes nil, :arglists ["spec" "spec overrides"], :doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/gen"}, :clojure.core/definterface {:added "1.2", :ns "clojure.core", :name "definterface", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/defprotocol :clojure.core/gen-interface :clojure.core/defrecord :clojure.core/deftype], :line 20, :examples [";; Part of a definterface from a Clojure program for the n-body problem\n;; at the Computer Language Benchmarks Game web site.\n;; For the rest of the program using it, see:\n;; http://github.com/jafingerhut/clojure-benchmarks/blob/master/nbody/nbody.clj-14.clj\n\n;; Currently Clojure does not permit type hints of arrays, e.g. ^ints as\n;; argument types or return types in a definterface.  This may be enhanced\n;; later.\n\n(definterface IBody\n  (^String name [])  ;; return type String, no arguments\n  (^double mass [])  ;; return type double\n  (^double x [])\n  (clone [] \"returns copy of self\")   ; return type defaults to ^Object\n  ;; 3 arguments of type double.  A deftype that implements this interface\n  ;; must implement the method p!  The definterface must use:\n  ;; _BANG_ for ! in Clojure method name\n  ;; _PLUS_ for +\n  ;; _ for -\n  (p_BANG_ [^double x ^double y ^double z] \"set pos.\")\n  ;; After name demangling, this must be implemented by Clojure method named v+!\n  (v_PLUS__BANG_ [^double vx ^double vy ^double vz] \"add to velocity\"))\n" ";; Note these differences between defprotocol and definterface:\n\n;; defprotocol requires that methods specify a first parameter, which \n;; will be the record object, while definterface requires that this\n;; parameter be left out:\n(definterface I (fooey []))\n;=> user.I\n(defprotocol P (fooey []))\n;=> IllegalArgumentException Definition of function fooey in protocol P must take at least one arg.  clojure.core/emit-protocol/fn--5964 (core_deftype.clj:612)\n(defprotocol P (fooey [this]))\n;=> P\n\n;; However, defrecord requires that a parameter for the record object\n;; be used, even with interfaces.  (A similar point applies to deftype.)\n(defrecord Irec [stuff] I (fooey [] \"foo\"))\n;=> CompilerException java.lang.IllegalArgumentException: Must supply at least one argument for 'this' in: fooey, compiling:(NO_SOURCE_PATH:1:1) \n(defrecord Irec [stuff] I (fooey [this] \"foo\"))\n;=> user.Irec\n(defrecord Prec [stuff] P (fooey [this] \"foo\"))\n;=> user.Prec\n\n;; Using an interface, only the dot form of the method is available with \n;; defrecord, while the protocol also allows use of normal Clojure function\n;; syntax.  (Similar points apply to deftype.)\n(.fooey (Irec. 42))\n;=> \"foo\"\n(fooey (Irec. 42))\n;=> IllegalArgumentException No implementation of method: :fooey of protocol: #'user/P found for class: user.Irec  clojure.core/-cache-protocol-fn (core_deftype.clj:544)\n(.fooey (Prec. 42))\n;=> \"foo\"\n(fooey (Prec. 42))\n;=> \"foo\"\n"], :macro true, :notes nil, :arglists ["name & sigs"], :doc "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/definterface"}, :clojure.core.logic/tramp {:ns "clojure.core.logic", :name "tramp", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2695, :examples nil, :notes nil, :arglists ["f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/tramp"}, :clojure.string/upper-case {:added "1.2", :ns "clojure.string", :name "upper-case", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/lower-case :clojure.string/capitalize], :line 207, :examples ["user=> (clojure.string/upper-case \"MiXeD cAsE\")\n\"MIXED CASE\"" ";; Non-character symbols will be returned back\nuser=> (clojure.string/upper-case \",.!@#$%^&*()\")\n\",.!@#$%^&*()\"" ";; upper-case can't handle nil \nuser=> (clojure.string/upper-case nil) ;;=> NullPointerException "], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Converts string to all upper-case.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/upper-case"}, :clojure.java.javadoc/*core-java-api* {:ns "clojure.java.javadoc", :name "*core-java-api*", :file "clojure/java/javadoc.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 21, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.java.javadoc/*core-java-api*"}, :clojure.core.logic.fd/process-dom {:ns "clojure.core.logic.fd", :name "process-dom", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 616, :examples nil, :notes nil, :arglists ["x dom domp"], :doc "If x is a var we update its domain. If it's an integer\n   we check that it's a member of the given domain. dom is\n   then new domain, it should have already been calculated from\n   domp which was the previous domain.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/process-dom"}, :clojure.core.logic.fd/interval-<= {:ns "clojure.core.logic.fd", :name "interval-<=", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 45, :examples nil, :notes nil, :arglists ["i j"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/interval-<="}, :clojure.core.async/poll! {:ns "clojure.core.async", :name "poll!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/offer!], :line 396, :examples ["(let [c (chan)]\n  (println (poll! c)))\n\n;; nil\n;;=> nil (it does not block even though there is no buffer!)\n\n(let [c (chan 1)]\n  (println (offer! c 10))\n  (println (poll! c)))\n;; true\n;; 10\n;;=> nil"], :notes nil, :arglists ["port"], :doc "Takes a val from port if it's possible to do so immediately.\n   Never blocks. Returns value if successful, nil otherwise.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/poll!"}, :clojure.core/empty {:added "1.0", :ns "clojure.core", :name "empty", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/not-empty :clojure.core/empty?], :line 5181, :examples ["(empty '(1 2)) ;; => ()\n(empty  [1 2]) ;; => []\n(empty  {1 2}) ;; => {}\n(empty #{1 2}) ;; => #{}\n\n;; Works for PersistentQueue as well, which is slightly harder to see\n(def q (conj clojure.lang.PersistentQueue/EMPTY 1))\n;; => #'user/q\nq\n;; => #<PersistentQueue clojure.lang.PersistentQueue@20>\n(seq q)\n;; => (1)\n\n(def empty-q (empty q))\n;; => #'user/empty-q\nempty-q\n;; => #<PersistentQueue clojure.lang.PersistentQueue@1>\n(seq empty-q)\n;; => nil\n\n;; returns nil when input is not supported or not a collection\n(empty (int-array [1 2])) ;; => nil\n(empty 1) ;; => nil\n\n(map empty [[\\a \\b] {1 2} (range 4)])\n;; => ([] {} ())\n\n(swap! (atom (range 10)) empty)      \n;; => ()\n" ";; The output will not necessarily be of the same JVM class as the input\nuser=> (class (seq [1]))\nclojure.lang.PersistentVector$ChunkedSeq\n\nuser=> (class (empty (seq [1])))\nclojure.lang.PersistentList$EmptyList\n" ";; Create the same data structure with the same metadata, but empty\n(def foo (with-meta #{1 2 3} {:some-meta 1}))\nfoo ;; => #{1 2 3}\n(meta foo) ;; => {:some-meta 1}\n\n(def empty-foo (empty foo))\nempty-foo ;; => #{}\n(meta empty-foo) ;; => {:some-meta 1}"], :notes nil, :arglists ["coll"], :doc "Returns an empty collection of the same category as coll, or nil", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/empty"}, :clojure.core.logic/llist {:ns "clojure.core.logic", :name "llist", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/lcons], :line 878, :examples ["(run* [q]\n  (fresh [a d]\n    (== [1 2 3 4] (llist a d))\n    (== q d))) ;; ((2 3 4))\n\n(run* [q]\n  (fresh [a d r]\n    (== [1 2 3 4] (llist a d r))\n    (== q r))) ;; a=1, d=2, r=(3 4)"], :macro true, :notes nil, :arglists ["f s" "f s & rest"], :doc "Constructs a sequence from 2 or more arguments, with the last argument as the\n   tail. The tail is improper if the last argument is a logic variable.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/llist"}, :clojure.core/sorted-set-by {:added "1.1", :ns "clojure.core", :name "sorted-set-by", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-set :clojure.core/sorted-map-by :clojure.core/compare], :line 425, :examples ["user> (sorted-set-by > 3 5 8 2 1)\n#{8 5 3 2 1}" ";; Be cautious about comparison functions that only compare part of\n;; the objects:\nuser=> (defn second-< [x y]\n         (< (second x) (second y)))\nuser=> (sorted-set-by second-< [:a 1] [:b 1] [:c 1])\n#{[:a 1]}\n\n;; Where did the other elements go?\n\n;; Replacing < with <= might look like a fix, but doesn't work,\n;; either:\nuser=> (defn second-<= [x y]\n         (<= (second x) (second y)))\nuser=> (def s2 (sorted-set-by second-<= [:a 1] [:b 1] [:c 1]))\n#'user/s2\nuser=> s2\n#{[:c 1] [:b 1] [:a 1]}\n;; So far, so good, but set membership tests can't find the elements.\nuser=> (contains? s2 [:b 1])\nfalse\nuser=> (s2 [:c 1])\nnil\n\n;; Here is one way to write a good comparison function.  When the two\n;; objects are equal in the parts we care about, use the tie-breaker\n;; 'compare' on the whole values to give them a consistent order that\n;; is only equal if the entire values are equal.\nuser=> (defn second-<-with-tie-break [x y]\n         (let [c (compare (second x) (second y))]\n           (if (not= c 0)\n             c\n             ;; Otherwise we don't care as long as ties are broken\n             ;; consistently.\n             (compare x y))))\nuser=> (def s3 (sorted-set-by second-<-with-tie-break [:a 1] [:b 1] [:c 1]))\n#'user/s3\nuser=> s3\n#{[:a 1] [:b 1] [:c 1]}\nuser=> (contains? s3 [:b 1])\ntrue\nuser=> (s3 [:c 1])\n[:c 1]\n;; All good now!" ";; Another custom comparator example.\n;; sorted-set of colls by size descending, then normal coll equality:\n\n(sorted-set-by \n  (fn [x y] (compare [(count y) x] [(count x) y]))\n  [3 :a] [:b] [1 :c] [:v] [:a])\n\n;; #{[1 :c] [3 :a] [:a] [:b] [:v]}"], :notes nil, :arglists ["comparator & keys"], :doc "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sorted-set-by"}, :clojure.core/filterv {:added "1.4", :ns "clojure.core", :name "filterv", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/filter :clojure.core/mapv], :line 6841, :examples [";; very similar to filter but returns a vector\n(filterv even? (range 10))\n;;=> [0 2 4 6 8]\n\n(filter (fn [x]\n    (= (count x) 1))\n    [\"a\" \"aa\" \"b\" \"n\" \"f\" \"lisp\" \"clojure\" \"q\" \"\"])\n;;=> [\"a\" \"b\" \"n\" \"f\" \"q\"]\n\n(filter #(= (count %) 1)\n    [\"a\" \"aa\" \"b\" \"n\" \"f\" \"lisp\" \"clojure\" \"q\" \"\"])\n;;=> [\"a\" \"b\" \"n\" \"f\" \"q\"]\n"], :notes nil, :arglists ["pred coll"], :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/filterv"}, :clojure.core/sync {:added "1.0", :ns "clojure.core", :name "sync", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/dosync], :line 2490, :examples nil, :macro true, :notes ["Same as dosync but allows for extra options (which are not currently supported).  Probably best to use dosync instead at the moment."], :arglists ["flags-ignored-for-now & body"], :doc "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sync"}, :clojure.core/uuid? {:added "1.9", :ns "clojure.core", :name "uuid?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 6725, :examples ["(uuid? (java.util.UUID/randomUUID))\n;;=> true\n(uuid? (read-string \"#uuid \\\"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\\\"\"))\n;;=> true\n\n(uuid? \"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\")\n;;=> false" ";; There is no (uuid) function to coerce a string to a UUID, but you can \n;; produce one via Java interop:\n\n(def u (java.util.UUID/fromString \"4fe5d828-6444-11e8-8222-720007e40350\"))\n;;=> #'user/u\nu\n;;=> #uuid \"4fe5d828-6444-11e8-8222-720007e40350\"\n(uuid? u)\n;;=> true" ";; Change a UUID to a string:\n\n\n(.toString (java.util.UUID/randomUUID))\n;;=>\"91bb281c-4cdd-4bea-bd9c-27b5f9c75812\""], :notes nil, :arglists ["x"], :doc "Return true if x is a java.util.UUID", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/uuid_q"}, :clojure.core.logic.fd/ISet {:ns "clojure.core.logic.fd", :name "ISet", :file "clojure/core/logic/fd.clj", :type "var", :column 1, :see-alsos nil, :line 28, :examples nil, :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/ISet"}, :clojure.core.logic/tabled-s {:ns "clojure.core.logic", :name "tabled-s", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 529, :examples nil, :notes nil, :arglists ["" "oc" "oc meta"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/tabled-s"}, :clojure.core/rationalize {:added "1.0", :ns "clojure.core", :name "rationalize", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 1269, :examples ["<pre>\r\nuser=> (rationalize 1.5)\r\n3/2\r\n</pre>" "user=> (rationalize Math/PI)\n3141592653589793/1000000000000000\n\nuser=> (rationalize (Math/sqrt 2))\n14142135623730951/10000000000000000" "(rationalize 2/4)\n;; => 1/2\n\n(rationalize 4/2)\n;; => 2\n\n(rationalize 2)\n;; => 2\n\n(rationalize 2.0)\n;; => 2N" ";; To quickly convert a mixed number to an improper fraction, \n;; multiply the denominator\n;; by the whole number and add to the numerator\n\n(= (+ 20 3/4) (rationalize (/ (+ (* 20 4) 3) 4)))\n;; => true"], :notes ["Remember that for irrational numbers, like sqrt 2, this is only an estimate (pretty good one). "], :arglists ["num"], :doc "returns the rational value of num", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/rationalize"}, :clojure.core.async/untap-all* {:ns "clojure.core.async", :name "untap-all*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/untap-all*"}, :clojure.core/find-protocol-impl {:ns "clojure.core", :name "find-protocol-impl", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 535, :examples nil, :notes nil, :arglists ["protocol x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find-protocol-impl"}, :clojure.core/some-fn {:added "1.3", :ns "clojure.core", :name "some-fn", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/every-pred :clojure.core/some :clojure.core/some-> :clojure.core/some->>], :line 7356, :examples ["\nuser=> ((some-fn even?) 1)\nfalse\nuser=> ((some-fn even?) 2)\ntrue\nuser=> ((some-fn even?) 1 2)\ntrue\n" ";; `some-fn` is useful for when you'd use `some` (to find out if any\n;; values in a given coll satisfy some predicate), but have more than\n;; one predicate. For example, to check if any values in a coll are\n;; either even or less than 10:\n\n(or (some even? [1 2 3])\n    (some #(< % 10) [1 2 3]))\n\n;; but `some-fn` can save you some duplication here:\n\n((some-fn even? #(< % 10)) 1 2 3)\n\n;; Minor note: the former returns nil if it doesn't find\n;; what it's looking for. The latter returns false." ";;; http://en.wikipedia.org/wiki/Fizz_buzz\n(def fizzbuzz\n  (some-fn #(and (= (mod % 3) 0) (= (mod % 5) 0) \"FizzBuzz\")\n           #(and (= (mod % 3) 0) \"Fizz\")\n           #(and (= (mod % 5) 0) \"Buzz\")\n           str))\n\n(run! println (map fizzbuzz (range 1 18)))\n\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n17" ";; Here's an easy way to apply several functions in succession to the same\n;; value and get the first true result. Note the double parentheses at the\n;; beginning: because some-fn returns a function, you have to apply it.\n\n((some-fn :a :b :c :d) {:c 3 :d 4})\n;=> 3\n\n;; Here's how to do the same thing but with a vector of functions.  Note\n;; the 'apply' as well as the double parentheses, since you have to make\n;; some-fn take its arguments from the vector.\n\n(def parsers\n  [parse-custom-command\n   parse-basic-command\n   parse-weird-command\n   reject-command])\n\n((apply some-fn parsers) text-from-user)\n\n;; Each element of parsers is a function that returns a data structure if\n;; it successfully parses its argument or nil if it fails. reject-command\n;; always succeeds, returning a representation of an error.\n\n;; Note the technique of putting a catch-all function for errors last.\n"], :notes nil, :arglists ["p" "p1 p2" "p1 p2 p3" "p1 p2 p3 & ps"], :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/some-fn"}, :clojure.core/class {:added "1.0", :ns "clojure.core", :name "class", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/type :clojure.core/class? :clojure.core/instance?], :line 3452, :examples ["user=> (class 1)\njava.lang.Long\n\nuser=> (class [1 2 3])\nclojure.lang.PersistentVector\n\nuser=> (class (String. \"foo\"))\njava.lang.String" "user=> (class class)\nclojure.core$class" "user=> (class nil)\nnil"], :notes nil, :arglists ["x"], :doc "Returns the Class of x", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/class"}, :clojure.core/case {:added "1.2", :ns "clojure.core", :name "case", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/cond :clojure.core/condp], :line 6617, :examples ["(let [mystr \"hello\"]\n  (case mystr\n    \"\" 0\n    \"hello\" (count mystr)))\n;;=> 5\n\n(let [mystr \"no match\"]\n  (case mystr\n        \"\" 0\n        \"hello\" (count mystr)))\n;; No matching clause: no match\n;;  [Thrown class java.lang.IllegalArgumentException]\n\n(let [mystr \"no match\"]\n  (case mystr\n        \"\" 0\n        \"hello\" (count mystr)\n        \"default\"))\n;;=> \"default\"\n\n;; You can give multiple values for the same condition by putting\n;; those values in a list.\n(case 'y\n      (x y z) \"x, y, or z\"\n      \"default\")\n;;=> \"x, y, or z\"\n\n(let [myseq '(1 2)]\n  (case myseq\n        (()) \"empty seq\"\n        ((1 2)) \"my seq\"\n        \"default\"))\n;;=> \"my seq\"\n\n;; \"The test-constants are not evaluated.They must be compile-time\n;; literals, and need not be quoted.\" \n(let [myvec [1 2]]\n  (case myvec\n        [] \"empty vec\"\n        (vec '(1 2)) \"my vec\"\n        \"default\"))\n;;=> \"default\"\n" ";; From: The Clojure Style Guide \n;;  https://github.com/bbatsov/clojure-style-guide#case\n;;  License: Creative Commons Attribution 3.0 Unported License\n;;\n;; Prefer case instead of cond or condp when test expressions are compile-time constants.\n\n;; good\n(cond\n  (= x 10) :ten\n  (= x 20) :twenty\n  (= x 30) :forty\n  :else :dunno)\n\n;; better\n(condp = x\n  10 :ten\n  20 :twenty\n  30 :forty\n  :dunno)\n\n;; best\n(case x\n  10 :ten\n  20 :twenty\n  30 :forty\n  :dunno)"], :macro true, :notes ["the third example describing myseq may be incorrect. I think we have to use vectors for comparing list of compile time constants.\r\n<pre>\r\n(let [myseq [1 2]]\r\n (case myseq\r\n  [] \"empty seq\"\r\n  [1 2] \"my seq\"\r\n  \"default\"))\r\n</pre>\r\n\r\nThe parenthesized test conditions are used when multiple test conditions give the same output (output expression). In my case , since both [true, true] and [false, false] return true, i have put them within parenthesis.\r\n\r\n<pre>\r\n(defn equ\r\n [a b]\r\n (case [a b]\r\n   ([true true] [false false]) true\r\n   true))\r\n\r\n(equ true true) ;; returns true\r\n(equ false false) ;; returns true\r\n(equ false true) ;; return false\r\n(equ true false) ;; returns false\r\n</pre>" "I updated that example with myseq to reflect behavior of Clojure 1.2.0 on my machine.  I also added an additional example to explicitly demonstrate multiple values for the same condition."], :arglists ["e & clauses"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/case"}, :clojure.test/testing {:added "1.1", :ns "clojure.test", :name "testing", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos [:clojure.test/is :clojure.test/deftest], :line 596, :examples ["(:use 'clojure.test)\n\n(testing \"Arithmetic\"\n  (testing \"with positive integers\"\n    (is (= 4 (+ 2 2)))\n    (is (= 7 (+ 3 4))))\n  (testing \"with negative integers\"\n    (is (= -4 (+ -2 -2)))\n    (is (= -1 (+ 3 -4)))))\n=> true\n\n\n---------------------------------------------------------------------------\n\n(testing \"Arithmetic\"\n  (testing \"with positive integers\"\n    (is (= 4 (+ 2 2)))\n    (is (= 7 (+ 3 4))))\n  (testing \"with negative integers\"\n    (is (= -5 (+ -2 -2)))                ;error here\n    (is (= -1 (+ 3 -4)))))\n\n=> FAIL in clojure.lang.PersistentList$EmptyList@1 (NO_SOURCE_FILE:641)\nArithmetic with negative integers        ;bread crumb trail\nexpected: (= -5 (+ -2 -2))\n  actual: (not (= -5 -4))\ntrue" ";; this is also valid:\n\n(deftest alternate-use\n  (testing \"test a vector of `is`\"\n      [(is true)\n       (is true)\n       (is true)]))\n\n;; which is useful in the following example:\n(defn with-resource [f]\n  (setup)\n  (f \"expected\")\n  (breakdown))\n\n(deftest alternate-use\n  (testing \"test a vector of `is`\"\n    (with-resource\n      (fn [resource]\n        [(is (= \"expected\" resource))]))))"], :macro true, :notes nil, :arglists ["string & body"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/testing"}, :clojure.core.logic/mplus* {:ns "clojure.core.logic", :name "mplus*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1072, :examples nil, :macro true, :notes nil, :arglists ["e" "e & e-rest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/mplus*"}, :clojure.core.logic/fnc {:ns "clojure.core.logic", :name "fnc", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 2611, :examples nil, :macro true, :notes nil, :arglists ["args & body"], :doc "Define an anonymous constraint that can be used with the unifier:\n\n     (let [oddc (fnc [x] (odd? x))]\n\n       (unifier {:a '?a} {:a 1} :when {'?a oddc})\n         ;;=> {:a 1}\n\n       (unifier {:a '?a} {:a 2} :when {'?a oddc})\n         ;;=> nil\n     )\n\n  Note, the constraint will not run until all arguments are fully ground.\n\n  Use defnc to define a constraint and assign a toplevel var.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fnc"}, :clojure.core/bit-or {:added "1.0", :ns "clojure.core", :name "bit-or", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/bit-and :clojure.core/bit-xor], :line 1294, :examples ["user=> (bit-or 2r1100 2r1001)\n13\n;; 13 = 2r1101\n\n;; the same in decimal\nuser=> (bit-or 12 9)\n13\n" ";; here is the truth table for OR\n(Integer/toBinaryString (bit-or 2r1100 2r1010) )\n;;=> \"1110\"\n;; or 2r1110"], :notes nil, :arglists ["x y" "x y & more"], :doc "Bitwise or", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-or"}, :clojure.test/join-fixtures {:added "1.1", :ns "clojure.test", :name "join-fixtures", :file "clojure/test.clj", :type "function", :column 1, :see-alsos [:clojure.test/use-fixtures :clojure.test/compose-fixtures], :line 695, :examples nil, :notes nil, :arglists ["fixtures"], :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/join-fixtures"}, :clojure.core.logic.fd/+c {:ns "clojure.core.logic.fd", :name "+c", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 849, :examples nil, :notes nil, :arglists ["u v w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/+c"}, :clojure.core/nfirst {:added "1.0", :ns "clojure.core", :name "nfirst", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/next :clojure.core/first :clojure.core/ffirst :clojure.core/fnext :clojure.core/nnext], :line 105, :examples ["user=> (nfirst [])\nnil \n\nuser=> (nfirst ['(a b c) '(b a c) '(c b a) '(a c b)])\n(b c)\n\nuser=> (nfirst {:a 1, :b 2, :c 3, :d 4})\n(1)\n\nuser=> (nfirst #{1 2 3})\njava.lang.IllegalArgumentException: Don't know how to create ISeq from: java.lang.Integer (NO_SOURCE_FILE:0)"], :notes nil, :arglists ["x"], :doc "Same as (next (first x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nfirst"}, :clojure.core.logic/merge-with-root {:ns "clojure.core.logic", :name "merge-with-root", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 579, :examples nil, :notes nil, :arglists ["s x root"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/merge-with-root"}, :clojure.core/ints {:added "1.0", :ns "clojure.core", :name "ints", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/int-array], :line 5313, :examples nil, :notes nil, :arglists ["xs"], :doc "Casts to int[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ints"}, :clojure.core.async/muxch* {:ns "clojure.core.async", :name "muxch*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["_"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/muxch*"}, :clojure.reflect/resolve-class {:ns "clojure.reflect", :name "resolve-class", :type "function", :see-alsos nil, :examples [";;Check if class c exists on the classpath\n(require '[clojure.reflect :refer [resolve-class]])\n\n(defn class-exists? [c] \n  (resolve-class (.getContextClassLoader (Thread/currentThread)) c))\n\n(class-exists? 'org.joda.time.DateTime) \n;;=> nil" ";; Obtaining a suitable class loader is an important consideration.\n;; to a large degree the class loader used by default is the\n;; context class loader which is controlled by \n*use-context-classloader*\n;=> true\n\n;; the following helper function shows the \n(require '[clojure.java.classpath :as cp])\n;=> nil\n\n;; the context class loader\n(def ccl (.getContextClassLoader (Thread/currentThread)))\n;=> #'boot.user/ccl\n(cp/classpath ccl)\n;=> (#object[java.io.File 0x709e8101 ...\n\n;; the system class loader\n(def scl (java.lang.ClassLoader/getSystemClassLoader)) \n;=> #'boot.user/scl\n(cp/classpath scl)\n;=> (#object[java.io.File 0x709e8101 ...\n\n;; the class loader used to load a particular class instance.\n(deftype Foo [bar])\n;=> boot.user.Foo\n(def icl (.getClassLoader (class (Foo. 4))))\n;=> #'boot.user/icl\n(cp/classpath icl)\n;=> (#object[java.io.File 0x709e8101 ...\n\n;; I recommend you use the DynamicClassLoader \n;; for cases when 'import' does not do it.\n;; https://github.com/clojure/clojure\n(def dcl (clojure.lang.DynamicClassLoader.))\n;=> #'boot.user/dcl\n(cp/classpath dcl)\n;=> (#object[java.io.File 0x709e8101 ...\n"], :notes nil, :tag "InputStream", :arglists ["this name"], :doc "Given a class name, return that typeref's class bytes as an InputStream.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/resolve-class"}, :clojure.core/distinct? {:added "1.0", :ns "clojure.core", :name "distinct?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/distinct], :line 5625, :examples ["user=> (distinct? 1 2 3)\ntrue\nuser=> (distinct? 1 2 3 3)\nfalse\nuser=> (distinct? 1 2 3 1)\nfalse"], :notes nil, :tag "java.lang.Boolean", :arglists ["x" "x y" "x y & more"], :doc "Returns true if no two of the arguments are =", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/distinct_q"}, :clojure.core.logic/== {:ns "clojure.core.logic", :name "==", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1156, :examples nil, :notes nil, :arglists ["u v"], :doc "A goal that attempts to unify terms u and v.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/=="}, :clojure.string/starts-with? {:added "1.8", :ns "clojure.string", :name "starts-with?", :file "clojure/string.clj", :type "function", :column 1, :see-alsos nil, :line 360, :examples ["(ns tst.xyz.core\n  (:use clojure.test )\n  (:require [clojure.string :as str] ))\n\n(deftest t-starts-with?\n  (is (str/starts-with? \"abcde\" \"a\"))\n  (is (str/starts-with? \"abcde\" \"ab\"))\n  (is (str/starts-with? \"abcde\" \"abc\"))\n\n  (is (not (str/starts-with? \"abcde\" \"b\")))\n  (is (not (str/starts-with? \"abcde\" \"bc\")))\n\n  (is (not (str/starts-with? \"a\" \"ab\")))\n  (is (not (str/starts-with? \"ab\" \"abc\"))))"], :notes nil, :arglists ["s substr"], :doc "True if s starts with substr.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/starts-with_q"}, :clojure.core/unchecked-add-int {:added "1.0", :ns "clojure.core", :name "unchecked-add-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/+ :clojure.core/+' :clojure.core/unchecked-subtract-int], :line 1183, :examples [";; Adding two int-range Longs works\n(unchecked-add-int 1 1)\n;;=> 2\n\n;; Adding two int-range BigInts works\n(unchecked-add-int 1N 1N)\n;;=> 2\n\n;; Doubles are truncated\n(unchecked-add-int 1 1.9)\n;;=> 2\n\n;; BigDecimals are truncated\n(unchecked-add-int 1 1.9M)\n;;=> 2\n\n;; Uncaught integer overflow\n(unchecked-add-int Integer/MAX_VALUE 1)\n;;=> -2147483648\n\n;; Uncaught integer underflow\n(unchecked-add-int Integer/MIN_VALUE -1)\n;;=> 2147483647\n\n;; Fails for Longs outside of int range\n(unchecked-add-int 2147483648 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for BigInts outside of int range\n(unchecked-add-int 2147483648N 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for Doubles outside of int range\n(unchecked-add-int 2147483648.0 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)\n\n;; Fails for BigDecimals outside of int range\n(unchecked-add-int 2147483648.0M 0)\n;;=> IllegalArgumentException Value out of range for int: 2147483648  clojure.lang.RT.intCast (RT.java:1205)"], :notes nil, :arglists ["x y"], :doc "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-add-int"}, :clojure.spec.alpha/nonconforming {:ns "clojure.spec.alpha", :name "nonconforming", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1761, :examples nil, :notes nil, :arglists ["spec"], :doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/nonconforming"}, :clojure.core.async/>!! {:ns "clojure.core.async", :name ">!!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/>! :clojure.core.async/put! :clojure.core.async/<!!], :line 137, :examples ["user=> (>!! c \"Blocking - not in go-block\")\ntrue\nuser=> (<!! c)\n\"Blocking - not in go-block\"\n"], :notes nil, :arglists ["port val"], :doc "puts a val into port. nil values are not allowed. Will block if no\n  buffer space is available. Returns true unless port is already closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/>!!"}, :clojure.core/*warn-on-reflection* {:added "1.0", :ns "clojure.core", :name "*warn-on-reflection*", :type "var", :see-alsos [:clojure.core/*unchecked-math*], :examples [";; define two variables then set *warn-on-reflection* to true and try to call\n;; one of their Java methods. Warnings are generated in both cases\n;; set *warn-on-reflection* to false and note that you can call both functions\n;; without a warning\n\nuser=> (def i 23)\n#'user/i\nuser=> (def s \"123\")\n#'user/s\nuser=> (set! *warn-on-reflection* true)\ntrue\nuser=> (.toString i)\nReflection warning, NO_SOURCE_PATH:4 - reference to field toString can't be resolved.\n\"23\"\nuser=> (.toString s)\nReflection warning, NO_SOURCE_PATH:5 - reference to field toString can't be resolved.\n\"123\"\n\n;; Reflection (and hence reflection warnings) could be removed by giving type hints:\nuser=> (.toString ^String s)\n\"123\"\n\nuser=> (set! *warn-on-reflection* false)\nfalse\nuser=> (.toString i)\n\"23\"\nuser=> (.toString s)\n\"123\"\nuser=>"], :notes nil, :arglists [], :doc "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*warn-on-reflection*"}, :clojure.spec.alpha/keys {:ns "clojure.spec.alpha", :name "keys", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 393, :examples nil, :macro true, :notes nil, :arglists ["& {:keys [req req-un opt opt-un gen]}"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y \n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/keys"}, :clojure.core/reset-meta! {:added "1.0", :ns "clojure.core", :name "reset-meta!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/meta :clojure.core/vary-meta :clojure.core/alter-meta! :clojure.core/with-meta], :line 2408, :examples ["(def ^{:key \"val\"} my-var \"\")\n;;=> #'user/my-var\n\n(meta #'my-var)\n;;=> {:key \"val\", :ns #<Namespace user>, :name my-var, :file \"NO_SOURCE_PATH\", :column 1, :line 1}\n\n(reset-meta! #'my-var {:new-key \"new-val\"}) ; replace all metadata\n;;=> {:new-key \"new-val\"}\n\n(meta #'my-var)\n;;=> {:new-key \"new-val\"}\n\n"], :notes nil, :arglists ["iref metadata-map"], :doc "Atomically resets the metadata for a namespace/var/ref/agent/atom", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reset-meta!"}, :clojure.core/extenders {:added "1.2", :ns "clojure.core", :name "extenders", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos [:clojure.core/defprotocol :clojure.core/extends?], :line 563, :examples ["user=> (defprotocol P (id [this]))\nP\nuser=> (extend-protocol P \n         String \n         (id [this] this)\n         clojure.lang.Symbol \n         (id [this] (name this))\n         clojure.lang.Keyword\n         (id [this] (name this)))\nnil\nuser=> (extenders P)\n(java.lang.String clojure.lang.Symbol clojure.lang.Keyword)\n"], :notes nil, :arglists ["protocol"], :doc "Returns a collection of the types explicitly extending protocol", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/extenders"}, :clojure.core/assert {:added "1.0", :ns "clojure.core", :name "assert", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.spec.alpha/assert], :line 4756, :examples ["user=> (assert true)\nnil\n\nuser=> (assert false)\njava.lang.AssertionError: Assert failed: false (NO_SOURCE_FILE:0)\n\nuser=> (assert nil)\njava.lang.AssertionError: Assert failed: nil (NO_SOURCE_FILE:0)\n\nuser=> (assert 0)\nnil\n\nuser=> (assert [1 2 3])\nnil\n\nuser=> (assert \"foo\")\nnil" ";; Messages can help you track down what went wrong.\nuser=> (assert (= 5 (+ 2 2)) \"There are four lights!\")\n\nAssertionError Assert failed: There are four lights!"], :macro true, :notes ["The documentation (\"... and throws an exception if ...\") is incorrect. It throws AssertionError which an Error and not an Exception. They both extend Throwable but Error is not an Exception."], :arglists ["x" "x message"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/assert"}, :clojure.core/*flush-on-newline* {:added "1.0", :ns "clojure.core", :name "*flush-on-newline*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*flush-on-newline*"}, :clojure.zip/down {:added "1.0", :ns "clojure.zip", :name "down", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/zipper], :line 109, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/down"}, :clojure.core/frequencies {:added "1.2", :ns "clojure.core", :name "frequencies", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/group-by :clojure.core/distinct], :line 7123, :examples ["user=> (frequencies ['a 'b 'a 'a])\n{a 3, b 1}" ";; Turn a frequency map back into a coll.\n\n(mapcat (fn [[x n]] (repeat n x)) {:a 2 :b 1 :c 3})\n;;=> (:a :a :b :c :c :c)\n"], :notes ["<pre>(fn [coll]\r\n   (let [gp (group-by identity coll)] \r\n      (zipmap (keys gp) (map #(count (second %)) gp))))</pre>" "    (into {} (for [[k v] (group-by identity \"abbbc\")] [k (count v)]))\r\n" "<pre>\nuser=> (frequencies [3 6 2 6 8 7 'b 'c 3 5 3 4 7 6 'a])\n{2 1, 3 3, 4 1, 5 1, 6 3, 7 2, 8 1, a 1, c 1, b 1}\nuser=> (frequencies [3 6 2 6 8 7 'b 'c])\n{3 1, 6 2, 2 1, 8 1, 7 1, b 1, c 1}\n;Note that the order of keys need not be in order of vector\n</pre>"], :arglists ["coll"], :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/frequencies"}, :clojure.core/bit-not {:added "1.0", :ns "clojure.core", :name "bit-not", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1278, :examples ["user=> (bit-not 2r0111)\n-8 \n\nuser=> (bit-not -2r1000)\n7"], :notes nil, :arglists ["x"], :doc "Bitwise complement", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bit-not"}, :clojure.core/print-ctor {:ns "clojure.core", :name "print-ctor", :file "clojure/core_print.clj", :type "function", :column 1, :see-alsos [:clojure.core/print-dup :clojure.core/read-string], :line 97, :examples [";; print-ctor assembles print-dup suitable constructors.\n;; The construction syntax is later used to initialize the same object type with \n;; read-string. Warning: there are security implications when evaluating untrusted\n;; sources with read-string. Be sure serialized data can't be tampered with.\n\n(defrecord Point [x y])\n;; user.Point\n\n(defmethod print-dup user.Point [o w]\n  (print-ctor o (fn [o w] (print-dup (vals o) w)) w))\n;; #object[clojure.lang.MultiFn 0x2409c5d]\n\n(binding [*print-dup* true] (pr-str (Point. 1 2)))\n;; \"#=(user.Point. (1 2))\"\n\n(read-string \"#=(user.Point. (1 2))\")\n;; #user.Point{:x 1, :y 2}"], :notes nil, :arglists ["o print-args w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print-ctor"}, :clojure.core/letfn {:added "1.0", :ns "clojure.core", :name "letfn", :special-form true, :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/let], :line 6463, :examples ["(letfn [(twice [x]\n           (* x 2))\n        (six-times [y]\n           (* (twice y) 3))]\n  (println \"Twice 15 =\" (twice 15))\n  (println \"Six times 15 =\" (six-times 15)))\n;; Twice 15 = 30\n;; Six times 15 = 90\n;;=> nil\n\n;; Unable to resolve symbol: twice in this context\n(twice 4)\n;; Evaluation aborted.\n\n;; Unable to resolve symbol: six-times in this context\n(six-times 100)\n;; Evaluation aborted.\n" ";; A contrived example of mutual recursion\n(defn even2? [n]\n  (letfn [(neven? [n] (if (zero? n) true (nodd? (dec n))))\n          (nodd? [n] (if (zero? n) false (neven? (dec n))))]\n    (neven? n)))\n" ";;using to create comparator\n\n(defn compartr [s1 s2]\n  (letfn [ (inner-author [author] ((juxt :lname :fname) author))] \n    (compare (inner-author s1) (inner-author s2))))\n=> #'user/compartr\n\n(sorted-set-by compartr\n               {:fname \"Steve\" :lname \"Smith\"}\n               {:fname \"David\" :lname \"Smith\"})\n\n=> #{{:fname \"David\", :lname \"Smith\"} {:fname \"Steve\", :lname \"Smith\"}}"], :macro true, :notes ["Using `letfn` allows you to create local functions that reference each other whereas `(let myfunc #(...)]...)` wouldn't because it executes its bindings serially." "To be more precise (about the note above), letfn allows ahead-of-definition use of functions. The following is ok:\n<pre>\n(defn testme [] \n  (let [twice (fn [x] (* x 2))\n        six-times (fn [y] (* (twice y) 3))] \n  (println \"15x6=\" (six-times 15))))\n</pre>\n\nBut this one for instance doesn't compile (and would be ok with letfn):\n\n<pre>\n(defn testme [] \n  (let [twelve-times (fn [x] (* (six-times x) 2)) \n        six-times (fn [y] (* y 6))] \n  (println \"2x12=\" (twelve-times 2))))\n</pre>\n" "<pre>\n(letfn [(six-times [y]\n           (* (twice y) 3))\n        (twice [x]\n           (* x 2))]\n  (println \"Twice 15 =\" (twice 15))\n  (println \"Six times 15 =\" (six-times 15)))\n;; Twice 15 = 30\n;; Six times 15 = 90\n;;=> nil\n</pre>"], :url nil, :arglists ["fnspecs & body"], :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/letfn", :forms ["(letfn [fnspecs*] exprs*)"]}, :clojure.core/remove-method {:added "1.0", :ns "clojure.core", :name "remove-method", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/get-method :clojure.core/methods :clojure.core/remove-all-methods :clojure.core/prefers :clojure.core/defmulti :clojure.core/defmethod], :line 1788, :examples [";; long example showing setting up a multi-method, then removing one of the \n;; methods, showing the multi-method has been removed\n\nuser=> (defmulti tos :Ob)\nnil\nuser=> (defn line [p1 p2] {:Ob :line :p1 p1 :p2 p2})\n#'user/line\nuser=> (defn circle [cent rad] {:Ob :circle :cent cent :rad rad})\n#'user/circle\nuser=> (defmethod tos :line [l] (str \"Line:\" (l :p1) (l :p2)))\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (defmethod tos :circle [c] (str \"Circle:\" (c :cent) (c :rad)))\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (def cc (circle [2 3] 3.3))\n#'user/cc\nuser=> (def ll (line [1 1][0 0]))\n#'user/ll\nuser=> (tos cc)\n\"Circle:[2 3]3.3\"\nuser=> (tos ll)\n\"Line:[1 1][0 0]\"\nuser=> (remove-method tos :line)\n#<MultiFn clojure.lang.MultiFn@73aecc3a>\nuser=> (tos ll)\njava.lang.IllegalArgumentException: No method in multimethod 'tos' for dispatch\nvalue: :line (NO_SOURCE_FILE:0)\nuser=>\n"], :notes nil, :arglists ["multifn dispatch-val"], :doc "Removes the method of multimethod associated with dispatch-value.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/remove-method"}, :clojure.set/project {:added "1.0", :ns "clojure.set", :name "project", :file "clojure/set.clj", :type "function", :column 1, :see-alsos nil, :line 72, :examples [";; `project` strips out unwanted key/value pairs from a set of maps. \n;; Suppose you have these descriptions of cows:\n\nuser=> (def cows #{  {:name \"betsy\" :id 33} {:name \"panda\" :id 34} })\n#'user/cows\n\n;; You care only about the names. So you can get them like this:\n\nuser=> (project cows [:name])\n#{{:name \"panda\"} {:name \"betsy\"}}\n" ";; also worked from vector of maps.\n\nuser=> (def sample [{:name \"Minsun\" :device \"iphone6\"}\n                    {:name \"hogle\" :device \"iphone7 matte black\"}])\n;;=> #'user/sample\n\nuser=> (clojure.set/project sample [:name])\n;;=> #{{:name \"hogle\"} {:name \"Minsun\"}}\n"], :notes ["is there a function that is like project, but returns a set of hash-maps with with all the keys but the ones project was given?" "This doesn't exist in clojure.set, but I think it would be what you wanted.\r\n\r\n<pre>\r\n(defn project-not [xrel ks]\r\n  ;; convert the given key sequence into a hash-set\r\n  ;; This represents keys that you don't want included\r\n  (let [ks-set (into #{} ks)]\r\n    ;; Do a projection on the keys that are not in ks\r\n    (clojure.set/project xrel\r\n                         ;; Assumes xrel is a set of maps\r\n                         ;; Grab the first map and extract the keys\r\n                         ;; Then remove any keys that are in ks-set\r\n                         ;; This will leave the remaining keys for\r\n                         ;; projection\r\n                         (remove #(ks-set %) (keys (first xrel))))))\r\n\r\nuser> (project-not cows [:id])\r\n#{{:name \"panda\" {:name \"betsy\"}}\r\n</pre>" "it strikes me as being very odd that the key set is a vector as opposed to vargs\r\n" "An alternate version of `project-not` that doesn't assume the first map in xrel has all the possible keys:\n\n<pre>\n(defn project-not\n  \"Returns a rel of the elements of xrel with keys in ks dissoced\"\n  [xrel ks]\n  (with-meta (set (map #(apply dissoc % ks) xrel)) (meta xrel)))\n</pre>"], :arglists ["xrel ks"], :doc "Returns a rel of the elements of xrel with only the keys in ks", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/project"}, :clojure.core/for {:added "1.0", :ns "clojure.core", :name "for", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/doseq :clojure.core/doall :clojure.core/recur :clojure.core/range], :line 4590, :examples [";; prepare a seq of the even values \n;; from the first six multiples of three\n(for [x [0 1 2 3 4 5]\n      :let [y (* x 3)]\n      :when (even? y)]\n  y)\n;;=> (0 6 12)\n" "(def digits (seq [1 2 3]))\n(for [x1 digits x2 digits] (* x1 x2))\n;;=> (1 2 3 2 4 6 3 6 9)" ";; produce a seq of all pairs drawn from two vectors\n(for [x ['a 'b 'c] \n      y [1 2 3]]\n  [x y])\n;;=> ([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])\n\n(for [suburb ['(\"name\" location)\n              '(\"name2\" location2)\n              '(\"name3\" location3)]\n      pollutant [\"CO2\" \"SO2\"]]\n  (conj (into [] (flatten [suburb pollutant])) (rand-int 10)))\n;;=> ([\"name\" location \"CO2\" 9]   [\"name\" location \"SO2\" 2] \n;;    [\"name2\" location2 \"CO2\" 2] [\"name2\" location2 \"SO2\" 0] \n;;    [\"name3\" location3 \"CO2\" 7] [\"name3\" location3 \"SO2\" 0])" ";; produce a seq of the first three powers for a range of integers\n(for [x (range 1 6) \n      :let [y (* x x) \n            z (* x x x)]] \n  [x y z])\n;;=> ([1 1 1] [2 4 8] [3 9 27] [4 16 64] [5 25 125])\n" ";; produce a seq of squares\n(for [x (range 3 7)] \n  (* x x))\n;;=> (9 16 25 36)" ";; prepare a seq of all keys from entries whose values are 0\n(for [[x y] '([:a 1] [:b 2] [:c 0]) :when (= y 0)] x)\n;;=> (:c)\n" ";; Demonstrating performance difference between :when and :while\n\n(time (dorun (for [x (range 1000) y (range 10000) :when (> x y)] [x y])))\n;; \"Elapsed time: 2898.908 msecs\"\n;;=> nil\n\n(time (dorun (for [x (range 1000) y (range 10000) :while (> x y)] [x y])))\n;; \"Elapsed time: 293.677 msecs\"\n;;=> nil\n" ";; Demonstrating functional difference between :when and :while\n\n(for [x (range 3) y (range 3)] [x y])\n;;=> ([0 0] [0 1] [0 2] \n;;    [1 0] [1 1] [1 2]\n;;    [2 0] [2 1] [2 2])\n\n(for [x (range 3) y (range 3) :when (not= x y)] [x y])\n;;=> (      [0 1] [0 2] \n;;    [1 0]       [1 2] \n;;    [2 0] [2 1]      )\n\n; Here we see the :while applied to the immediately preceding seq\n(for [x (range 3) y (range 3) :while (not= x y)] [x y])\n;;=> (             \n;;    [1 0]              \n;;    [2 0] [2 1]      )\n\n;; The placement of the :while is important\n;; :while can cause a halt for a particular sequence\n\n(for [x (range 3) y (range 3) :while (not= x 1)] [x y])\n;;=> ([0 0] [0 1] [0 2] [2 0] [2 1] [2 2])\n\n(for [x (range 3) :while (not= x 1) y (range 3)] [x y])\n;;=> ([0 0] [0 1] [0 2])\n" ";; More examples illustrating the difference between :when and :while\n\n;; Simple but inefficient method of checking whether a number is\n;; prime.\nuser=> (defn prime? [n]\n         (not-any? zero? (map #(rem n %) (range 2 n))))\n#'user/prime?\n\nuser=> (range 3 33 2)\n(3 5 7 9 11 13 15 17 19 21 23 25 27 29 31)\n\n;; :when continues through the collection even if some have the\n;; condition evaluate to false, like filter\nuser=> (for [x (range 3 33 2) :when (prime? x)]\n         x)\n(3 5 7 11 13 17 19 23 29 31)\n\n;; :while stops at the first collection element that evaluates to\n;; false, like take-while\nuser=> (for [x (range 3 33 2) :while (prime? x)]\n         x)\n(3 5 7)\n\n;; The examples above can easily be rewritten with filter or\n;; take-while.  When you have a for with multiple binding forms, so\n;; that the iteration occurs in a nested fashion, it becomes possible\n;; to write something briefly with 'for' that would be more verbose or\n;; unwieldy with nested filter or take-while expressions.\n\nuser=> (for [x (range 3 17 2) :when (prime? x)\n             y (range 3 17 2) :when (prime? y)]\n         [x y])\n([ 3 3] [ 3 5] [ 3 7] [ 3 11] [ 3 13]\n [ 5 3] [ 5 5] [ 5 7] [ 5 11] [ 5 13]\n [ 7 3] [ 7 5] [ 7 7] [ 7 11] [ 7 13]\n [11 3] [11 5] [11 7] [11 11] [11 13]\n [13 3] [13 5] [13 7] [13 11] [13 13])\n\nuser=> (for [x (range 3 17 2) :while (prime? x)\n             y (range 3 17 2) :while (prime? y)]\n         [x y])\n([3 3] [3 5] [3 7]\n [5 3] [5 5] [5 7]\n [7 3] [7 5] [7 7])\n\n;; This example only gives a finite result because of the :while\n;; expressions.\nuser=> (for [x (range) :while (< x 10) \n             y (range) :while (<= y x)]\n         [x y])\n\n([0 0]\n [1 0] [1 1]\n [2 0] [2 1] [2 2]\n [3 0] [3 1] [3 2] [3 3]\n [4 0] [4 1] [4 2] [4 3] [4 4]\n [5 0] [5 1] [5 2] [5 3] [5 4] [5 5]\n [6 0] [6 1] [6 2] [6 3] [6 4] [6 5] [6 6]\n [7 0] [7 1] [7 2] [7 3] [7 4] [7 5] [7 6] [7 7]\n [8 0] [8 1] [8 2] [8 3] [8 4] [8 5] [8 6] [8 7] [8 8]\n [9 0] [9 1] [9 2] [9 3] [9 4] [9 5] [9 6] [9 7] [9 8] [9 9])\n" ";; Here are a couple of examples where the only difference is where\n;; the :while is placed, but it makes a significant difference in the\n;; behavior.\n\n;; When x=2 y=1 is reached, :while (<= x y) evaluates false, so all\n;; further items in the y collection are skipped.  When x=3 y=1 is\n;; reached, the same thing happens.\n\nuser=> (for [x [1 2 3]\n             y [1 2 3]\n             :while (<= x y)\n             z [1 2 3]]\n         [x y z])\n([1 1 1] [1 1 2] [1 1 3]\n [1 2 1] [1 2 2] [1 2 3]\n [1 3 1] [1 3 2] [1 3 3])\n\n;; This is different.  When x=2 y=1 z=1 is reached, :while (<= x y)\n;; evaluates false, but since the :while is after the binding for z,\n;; all further items in the z collection are skipped.  Then x=2 y=2\n;; z=1 is tried, where the while expresssion evaluates true.\n\nuser=> (for [x [1 2 3]\n             y [1 2 3]\n             z [1 2 3]\n             :while (<= x y)]\n         [x y z])\n([1 1 1] [1 1 2] [1 1 3]\n [1 2 1] [1 2 2] [1 2 3]\n [1 3 1] [1 3 2] [1 3 3]\n [2 2 1] [2 2 2] [2 2 3]\n [2 3 1] [2 3 2] [2 3 3]\n [3 3 1] [3 3 2] [3 3 3])\n" "(defn all-files-present?\n\"Takes a list of real file names, and returns a map of files present 1\nand not present 0.\"\n[file-seq]\n(for [fnam file-seq\n :let [stat-map {(keyword fnam) (look-for fnam \"f\")}]]\n  stat-map))\n\n(into {}  (all-files-present? '(\"Makefile\" \"build.sh\" \"real-estate.csv\")))\n\n{:Makefile 1, :build.sh 1, :real-estate.csv 0}" ";; Flattening a seq of pairs using for comprehensions\n\n(def pairs (for [i (range 10)] [i (inc i)]))\n;; ([0 1] [1 2] [2 3] [3 4] [4 5] [5 6] [6 7] [7 8] [8 9] [9 10])\n\n(def flattened (for [pair pairs element pair] element))\n;; (0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10)" ";; Given an array of integers, return indices of the two numbers such that they \n;; add up to a specific target.\n\n;; You may assume that each input would have exactly one solution.\n;; Given nums = [2, 7, 11, 15], target = 9,\n\n;; Because nums[0] + nums[1] = 2 + 7 = 9,\n;; return [0, 1].\n\n(defn two-sum [nums target]\n  (let [nums-index (zipmap nums (range))\n        indexs (for [[x i] nums-index\n                     [y j] nums-index\n                     :when (< i j)\n                     :when (= (+ x y) target)]\n                 [i j])]\n    (first indexs)))\n\n(two-sum [2 7 11 15] 9)\n;; [0 1]\n" ";;; Cartesian products of two sets\n\n(#(set\n   (for[x %1, y %2]\n     [x y])) #{1 2 3} #{4 5})\n\n;=> #{[2 5] [3 4] [1 4] [1 5] [2 4] [3 5]}" ";; Nested 'for' example to produce indexes of Two-dimensional array\n(for [i (range 3)]\n   (for [j (range 3)]\n      [i j]))\n\n;=> (([0 0] [0 1] [0 2]) \n;    ([1 0] [1 1] [1 2]) \n;    ([2 0] [2 1] [2 2]))"], :macro true, :notes ["My English parser was choking on the description of this function.\r\n\r\n[This SO question](http://stackoverflow.com/questions/3322552/how-do-i-multiply-all-elements-in-one-collection-with-all-the-elements-in-another) has helped clarify how this function works." "Example 1 can be rewritten without using the for macro. Pure functional should be preferred if possible:\r\n<pre>\r\n(filter even? (map (partial * 3)  [0 1 2 3 4 5]))\r\n</pre>" "On juergenhoetzel's comment:\r\n\r\nAll the examples could be re-written in some combination of map and filter, but they are still valid examples of using the for comprehension, AFAIK:\r\n\r\nExamples:\r\n<pre>user=&gt; (mapcat (fn [e] (map (fn [x] (* x e)) [1 2 3])) [1 2 3])\r\n(1 2 3 2 4 6 3 6 9)\r\nuser=&gt; (mapcat (fn [e] (map (fn [x] [e x]) [1 2 3])) ['a 'b 'c])\r\n([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])\r\nuser=&gt; (map (fn [e] [e (* e e)(* e e e)]) (range 1 6))\r\n([1 1 1] [2 4 8] [3 9 27] [4 16 64] [5 25 125])\r\nuser=&gt; (map (fn [e] (* e e)) (range 3 7))\r\n(9 16 25 36)\r\nuser=&gt; (map first (filter (fn [[x y]] (= y 0)) '([:a 1] [:b 2] [:c 0])))\r\n(:c)\r\nuser=&gt;\r\n</pre>\r\n\r\n" "Take careful note of the description's wording:\r\n\r\n    binding-form/collection-expr pairs, \r\n    each followed by zero or more modifiers\r\n\r\nA consequence is that the binding list may *not* begin with a modifier, i.e a `:let`, `:when` or `:while`!\r\n\r\nThe following example is **illegal** syntax:\r\n\r\n    (for [:let [a 1] b (range 5)] \r\n      {a b})\r\n\r\nWhile it might sometimes be convenient to start a `for` with a `:let` to reduce code clutter, the \"correct\" procedure is to nest the `for` in a \"proper\" `let`, like this:\r\n\r\n    (let [a 1]\r\n      (for [b (range 5)] \r\n        {a b}))\r\n\r\nSimilarly, a `:when` is better represented by nesting in an `if`.\r\n\r\n" "The fifth example should probably be shown in first position, it's the most straightforward and readable for a beginner : \r\n\r\n(for [x (range 3 7)] (* x x))" "\"**Sequence** comprehension\", not \"list comprehension\".  "], :arglists ["seq-exprs body-expr"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/for"}, :clojure.core.async/chan {:ns "clojure.core.async", :name "chan", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/buffer :clojure.core.async/dropping-buffer :clojure.core.async/sliding-buffer], :line 73, :examples ["user=> (def c (chan))\n#'user/c\nuser=> (def c (chan 1))\n#'user/c\nuser=> (def c (chan (buffer 2)))\n#'user/c\n;; Clojure 1.7\nuser=> (def c (chan 1 (filter string?)))\n#'user/c\n\n" "(let [c (chan 3 (map inc))] ;; providing transducer which increments values by one\n  (>!! c 1)\n  (>!! c 2)\n  (>!! c 3)\n  (println (<!! c))\n  (println (<!! c))\n  (println (<!! c)))\n\n;; 2\n;; 3\n;; 4\n;;=> nil"], :notes nil, :arglists ["" "buf-or-n" "buf-or-n xform" "buf-or-n xform ex-handler"], :doc "Creates a channel with an optional buffer, an optional transducer\n  (like (map f), (filter p) etc or a composition thereof), and an\n  optional exception-handler.  If buf-or-n is a number, will create\n  and use a fixed buffer of that size. If a transducer is supplied a\n  buffer must be specified. ex-handler must be a fn of one argument -\n  if an exception occurs during transformation it will be called with\n  the Throwable as an argument, and any non-nil return value will be\n  placed in the channel.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/chan"}, :clojure.core.logic/trace-s {:ns "clojure.core.logic", :name "trace-s", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1295, :examples nil, :macro true, :notes nil, :arglists [""], :doc "Goal that prints the current substitution", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/trace-s"}, :clojure.core/doto {:added "1.0", :ns "clojure.core", :name "doto", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/-> :clojure.core/->>], :line 3818, :examples [";; Note that even though println returns nil, doto still returns the HashMap object\nuser> (doto (java.util.HashMap.)\n            (.put \"a\" 1)\n            (.put \"b\" 2)\n            (println))\n#<HashMap {b=2, a=1}>\n{\"b\" 2, \"a\" 1}\n\n;; Equivalent to\nuser> (def m (java.util.HashMap.))\nuser> (.put m \"a\" 1)\nuser> (.put m \"b\" 2)\nuser> m\n{\"a\" 1, \"b\" 2}\nuser> (println m)\n#object[java.util.HashMap 0x727fcc37 {a=1, b=2}]" ";; quick demonstration of using a Collections function on the resulting ArrayList\n\nuser=> (def al (doto (java.util.ArrayList.) (.add 11) (.add 3) (.add 7)))\n#'user/al\nuser=> al\n#<ArrayList [11, 3, 7]>\nuser=> (java.util.Collections/sort al)\nnil\nuser=> al\n#<ArrayList [3, 7, 11]>\nuser=>" ";; careful when calling 'dotimes' from within a 'doto' statement\nuser=> (doto (java.util.ArrayList.)\n             (.add -2)\n             (.add -1)\n             (dotimes [i 3] (.add i)))\njava.lang.IllegalArgumentException: dotimes requires a vector for its binding (NO_SOURCE_FILE:1)\n\n; what has happened is that (java.util.ArrayList.) has secretly\n; become the first argument to 'dotimes' and thus the exception\n; informs us that it can't find the binding vector required for\n; 'dotimes' to expand. You can cure this behaviour by simply using\n; 'do' instead of 'doto' or by wrapping the call to 'dotimes' in\n; a function. e.g:\n\n;using 'let' with implicit 'do' instead of 'doto'\nuser=> (let [al (java.util.ArrayList.)]\n         (.add al -2)\n         (.add al -1)\n         (dotimes [i 3] (.add al i))\n         al);return the ArrayList\n#<ArrayList [-2, -1, 0, 1, 2]>  ;exactly what we intended\n\n;wrapping 'dotimes' in a function literal\nuser=>(doto (java.util.ArrayList.)\n            (.add -2)\n            (.add -1)\n            (#(dotimes [i 3] (.add % i))))\n#<ArrayList [-2, -1, 0, 1, 2]>  ;exactly what we intended again\n"], :macro true, :notes nil, :arglists ["x & forms"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/doto"}, :clojure.core/with-local-vars {:added "1.0", :ns "clojure.core", :name "with-local-vars", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/with-bindings :clojure.core/var-set :clojure.core/volatile! :clojure.core/var-get], :line 4306, :examples [";; with-local-vars allows you to write more imperative-style code, for cases\n;; where you really want to.  factorial isn't a case where it helps, but\n;; it is short and familiar.  Note that (var-get acc) can be abbreviated\n;; as @acc\nuser=> (defn factorial [x]\n         (with-local-vars [acc 1, cnt x]\n           (while (> @cnt 0)\n             (var-set acc (* @acc @cnt))\n             (var-set cnt (dec @cnt)))\n           @acc))\n#'user/factorial\nuser=> (factorial 7)\n5040\n" "(with-local-vars [a-local-var-variable \"value\"]\n                 ;; If you use the symbol by itself, you get the Var back\n                 (println a-local-var-variable)\n                 ;; So when using local var variables, you must explicitly\n                 ;; get the value inside the Var\n                 (println (var-get a-local-var-variable))\n                 ;; You can also get the value of a Var by using deref\n                 (println (deref a-local-var-variable))\n                 ;; Or the @ reader macro\n                 (println @a-local-var-variable))" ";; with-local-vars allows you to write more imperative-style code, for cases\n;; where you really want to. This example demonstrate how to change variable value\n;; like in for-loop. There used doseq instead of for, because for is a macros\n;; that generates lazy sequence that will be realized out of ranges\n;; with-local-vars block \n(with-local-vars [n 0]  \n                 (doseq [x (range 3)]\n                        (do (var-set n (inc (var-get n)))\n                            (println (var-get n)))))\n;   1\n;   2\n;   3\n;=> nil\n"], :macro true, :notes nil, :arglists ["name-vals-vec & body"], :doc "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/with-local-vars"}, :clojure.core/get {:added "1.0", :ns "clojure.core", :name "get", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/map-indexed :clojure.core/get-in :clojure.core/find :clojure.core/select-keys :clojure.core/nth], :line 1486, :examples ["(get [1 2 3] 1)\n;;=> 2\n\n(get [1 2 3] 5)\n;;=> nil\n\n(get {:a 1 :b 2} :b)\n;;=> 2\n\n(get {:a 1 :b 2} :z \"missing\")\n;;=> \"missing\"\n\n" ";; to get an index of the element of a vector, use .indexOf\n(def v [\"one\" \"two\" \"three\" \"two\"])\n;; #'user/v\n\n(.indexOf v \"two\")\n;;=> 1\n\n(.indexOf v \"foo\")\n;;=> -1\n" ";; the system environment has a hash-map semantic\n(get (System/getenv) \"SHELL\")\n;;=> \"/bin/bash\"\n\n(get (System/getenv) \"PATH\")\n;;=> \"/usr/local/bin:/sbin:/usr/sbin:/usr/bin:/bin\"" ";; 'get' is not the only option\n(def my-map {:a 1 :b 2 :c 3})\n\n;; maps act like functions taking keys \n(my-map :a)\n;;=> 1\n\n;; even keys (if they are keywords) act like functions\n(:b my-map)\n;;=> 2" ";; it is tempting to try an index on a list\n(get '(a b c) 1)\n;;=> nil\n\n;; but you should use nth\n(nth '(a b c) 1)\n;;=> b" ";; Get also works with strings:\n(get \"abc\" 1)\n;;=> \\b" ";; For sorted stuff, \"key\" must be of the same type of the existing keys. \n;; This allows descending the sorted tree in log(N) average.\n\n(get (hash-map :a 1 :b 2) \"a\" \"not found\")\n;; \"not found\"\n\n(get (sorted-map :a 1 :b 2) \"a\" \"not found\")\n;; ClassCastException\n\n;; get works on transient maps, but silently fails on transient sets.\n;; A similar issue affects contains?.\n\n(get (transient #{0 1 2}) 1)\n;; nil\n\n;; get uses int cast with precision loss, with (.intValue x).\n;; The example below is explained because 4294967296 equal 2^32, thus\n;; (.intValue 4294967296) returns 0.\n;; Be careful with sufficiently large keys:\n\n(get [\"a\" \"b\" \"c\"] 4294967296)\n;; \"a\""], :notes ["Why is this character/string?" "(:mykey my-hash-map :none) means the same as (get my-hash-map :mykey :none) and <br/>\n('mysym my-hash-map :none) means the same as (get my-hash-map 'mysym :none).<br/>\nSo, you can use (:a {:a 1 :b 2} :not-inserted) as (get {:a 1 :b 2} :a :not-inserted).<br/>\nSee \n<a href='http://clojure.org/data_structures#Data%20Structures-Keywords'>http://clojure.org/data_structures#Data Structures-Keywords</a> and\n<a href='http://clojure.org/data_structures#Data%20Structures-Symbols'>http://clojure.org/data_structures#Data Structures-Symbols</a>"], :arglists ["map key" "map key not-found"], :doc "Returns the value mapped to key, not-found or nil if key not present.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get"}, :clojure.pprint/*print-right-margin* {:added "1.2", :ns "clojure.pprint", :name "*print-right-margin*", :file "clojure/pprint/pprint_base.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 40, :examples [";; Compare the two outputs below. Note how pprint puts the map on two lines\n;; in the second snippet to avoid having a line longer than 5 characters.\n\n(binding [clojure.pprint/*print-right-margin* 15]\n  (clojure.pprint/pprint {:foo \"bar\"}))\n; Prints:\n; {:foo \"bar\"}\n\n(binding [clojure.pprint/*print-right-margin* 5]\n  (clojure.pprint/pprint {:foo \"bar\"}))\n; Prints:\n; {:foo\n;  \"bar\"}"], :notes nil, :arglists [], :doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/*print-right-margin*"}, :clojure.core/long {:added "1.0", :ns "clojure.core", :name "long", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/int :clojure.core/longs :clojure.core/long-array :clojure.core/unchecked-long], :line 3472, :examples ["v.1.3.0\nuser=> (let [num (* 1234567890 21)] [num (int num) (long num)])\n[25925925690 156121914 25925925690]\n\nv.1.6.0\nuser=> (let [num (* 1234567890 21)] [num (int num) (long num)])\nIllegalArgumentException Value out of range for int: 25925925690" "v.1.3.0\nuser=> (= 21 (long 21))\ntrue \n\n;; but\nuser=> (.equals 21 (long 21))\nfalse \n\n;; and thus\nuser=> (get {21 :twenty-one} (long 21))\nnil \n\nv.1.6.0\nuser=> (= 21 (long 21))\ntrue \n\nuser=> (.equals 21 (long 21))\ntrue\n\nuser=> (.equals 21.0 (long 21))\nfalse\n\nuser=> (.equals (long 21.0) (long 21)) \ntrue"], :notes ["the second example is no longer true."], :arglists ["x"], :doc "Coerce to long", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/long"}, :clojure.core/chars {:added "1.1", :ns "clojure.core", :name "chars", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/char-array], :line 5298, :examples ["user=> (seq (chars (char-array \"this is a good one\")))\n(\\t \\h \\i \\s \\space \\i \\s \\space \\a \\space \\g \\o \\o \\d \\space \\o \\n \\e)"], :notes nil, :arglists ["xs"], :doc "Casts to chars[]", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chars"}, :clojure.core/volatile? {:added "1.7", :ns "clojure.core", :name "volatile?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/volatile! :clojure.core/vswap! :clojure.core/vreset!], :line 2540, :examples ["(def a (volatile! 0))\n\nuser=> (volatile? a)\n;;=> true\n\n(def b 0)\n\nuser=> (volatile? b)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Returns true if x is a volatile.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/volatile_q"}, :clojure.core/*unchecked-math* {:added "1.3", :ns "clojure.core", :name "*unchecked-math*", :type "var", :see-alsos [:clojure.core/*warn-on-reflection*], :examples ["user=> (unchecked-add Long/MAX_VALUE 1)\n-9223372036854775808\n\nuser=> (+ Long/MAX_VALUE 1)\nArithmeticException integer overflow  clojure.lang.Numbers.throwIntOverflow\n\nuser=> (set! *unchecked-math* true)\ntrue\n\nuser=> (+ Long/MAX_VALUE 1)\n-9223372036854775808"], :notes ["Note that, even if `*unchecked-math*` is true when compiling, the unchecked operations are used only when both operands are primitive; if either operand is boxed, normal Clojure arithmetic is used (see [this message](http://groups.google.com/group/clojure/msg/532b32950db75f56) from Stuart Sierra on the Clojure Google group). This can be worked around by adding type hints (e.g. `^long`) where necessary."], :arglists [], :doc "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. While bound\n  to :warn-on-boxed, same behavior as true, and a warning is emitted\n  when compilation uses boxed math. Default: false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*unchecked-math*"}, :clojure.zip/rights {:added "1.0", :ns "clojure.zip", :name "rights", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 102, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns a seq of the right siblings of this loc", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/rights"}, :clojure.core/ref-max-history {:added "1.1", :ns "clojure.core", :name "ref-max-history", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref :clojure.core/ref-min-history :clojure.core/ref-history-count], :line 2471, :examples nil, :notes nil, :arglists ["ref" "ref n"], :doc "Gets the max-history of a ref, or sets it and returns the ref", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ref-max-history"}, :clojure.core/if-let {:added "1.0", :ns "clojure.core", :name "if-let", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/when-let :clojure.core/if :clojure.core/if-some], :line 1833, :examples ["user=> (defn sum-even-numbers [nums]\n         (if-let [nums (seq (filter even? nums))]\n           (reduce + nums)\n           \"No even numbers found.\"))\n#'user/sum-even-numbers\n\nuser=> (sum-even-numbers [1 3 5 7 9])\n\"No even numbers found.\"\n\nuser=> (sum-even-numbers [1 3 5 7 9 10 12])\n22\n" " (if-let [x false y true]\n     \"then\"\n     \"else\")\n;; java.lang.IllegalArgumentException: if-let requires exactly 2 forms in binding vector (NO_SOURCE_FILE:1)\n;; see if-let* below\n\n(defn if-let-demo [arg]\n  (if-let [x arg]\n    \"then\"\n    \"else\"))\n\n(if-let-demo 1) ; anything except nil/false\n;;=> \"then\"\n(if-let-demo nil)\n;;=> \"else\"\n(if-let-demo false)\n;;=> \"else\"\n" ";; This macro is nice when you need to calculate something big. And you need \n;; to use the result but only when it's true:\n\n(if-let [life (meaning-of-life 12)]\n   life\n   (if-let [origin (origin-of-life 1)]\n      origin\n      (if-let [shooter (who-shot-jr 5)]\n         shooter\n\t 42)))\n\n;; As you can see in the above example it will return the answer \n;; to the question only if the answer is not nil. If the answer\n;; is nil it will move to the next question. Until finally it\n;; gives up and returns 42." ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." ";;; with destructuring binding\n\n;; successful case\n(if-let [[w n] (re-find #\"a(\\d+)x\" \"aaa123xxx\")]\n  [w n]\n  :not-found)  ;=> [\"a123x\" \"123\"]\n\n;; unsuccessful case\n(if-let [[w n] (re-find #\"a(\\d+)x\" \"bbb123yyy\")]\n  [w n]\n  :not-found) ;=> :not-found\n\n;; same as above\n(if-let [[w n] nil]\n  [w n]\n  :not-found) ;=> :not-found\n\n;; on Map\n(if-let [{:keys [a b]} nil]\n  [a b]\n  :not-found) ;=> :not-found\n" ";; Note that the binding only extends to the then form, not to the else:\nuser=> (if-let [x nil] \"then\" x)\nCompilerException java.lang.RuntimeException: Unable to resolve symbol:\nx in this context, compiling: ..." ";; Works well with collections\n\n=> (def x {:whatever 1})\n\n=> (if-let [value (:whatever x)] value \"Not found\")\n1\n\n=> (if-let [value (:no-match x)] value \"Not found\")\n\"Not found\"" ";; if-let multiple bindings version\n;; Edited: Else branch did not work with expressions.\n\n(defmacro if-let*\n  ([bindings then]\n   `(if-let* ~bindings ~then nil))\n  ([bindings then else]\n   (if (seq bindings)\n     `(if-let [~(first bindings) ~(second bindings)]\n        (if-let* ~(drop 2 bindings) ~then ~else)\n        ~else)\n     then)))\n\n(if-let* [a 1\n          b (+ a 1) ]\n          b)\n;;=> 2\n\n(if-let* [a 1\n           b (+ a 1)\n           c false] ;;false or nil - does not matter\n           b\n           a)\n\n;;=> 1" ";; (if-let [definition condition] then else):\n;; if the value of condition is truthy, then that value is assigned to the definition, \n;; and \"then\" is evaluated.\n;; Otherwise the value is NOT assigned to the definition, and \"else\" is evaluated.\n\n;; Although you can use this structure with booleans, \n;; there's not much point unless you only want to\n;; use the resulting boolean if it's true - as evidenced in the first example below.\n;; if-let is mostly useful when checking for nil.\n\n;; In this first example if Clare is old, it outputs \"Clare is old\".\n;; (the let part of the statement is rather pointless, \n;; as the definition old-clare-age is never used).\n\n(def clare-age 47)\n(if-let [old-clare-age (> clare-age 100)] \n  \"Clare is old\" \n  \"Clare is not old\")\n;;=> Clare is not old\n\n;; In the next two examples, it only outputs Clare's age if it is valid (ie not nil)\n\n(def clare-age nil)\n(if-let [valid-clare-age clare-age] \n  (str \"Clare has a valid age: \" valid-clare-age) \n  \"Clare's age is invalid\")\n;;=> Clare's age is invalid\n\n(def clare-age 47)\n(if-let [valid-clare-age clare-age] \n  (str \"Clare has a valid age: \" valid-clare-age) \n  \"Clare's age is invalid\")\n;;=> Clare has a valid age: 47" "(if-let [value true]\n  \"The expression is true!\"\n  \"Sorry, it's not true.\")" ";; Destructuring maps\n(def x {:it 1 :that 2})\n(def y {:that 2}\n(if-let [{value :it} x] value \"Not found\") ;;=> 1\n(if-let [{value :it} nil] value \"Not found\") ;;=> \"Not found\"\n(if-let [{value :it} false] value \"Not found\") ;;=> \"Not found\"\n(if-let [{value :it} y] value \"Not found\") ;;=> nil\n(if-let [{value :it} {}] value \"Not found\") ;;=> nil\n(if-let [{value :it} 1] value \"Not found\") ;;=> nil" ";; if-let multiple bindings version\n(defmacro if-let*\n          ([bindings then nil])\n          ([bindings then else]\n            `(let ~bindings\n                  (if (and ~@(take-nth 2 bindings))\n                    ~then\n                    ~else\n                    ))))\n\n\n(if-let* [a 1\n          b (+ a 1) ]\n          b)\n;;=> 2\n\n(if-let* [a 1\n           b (+ a 1)\n           c false] ;;false or nil - does not matter\n           b\n           a)\n\n;;=> 1"], :macro true, :notes ["The difference between when-let and if-let is that when-let doesn't have an else clause and and also accepts multiple forms so you don't need to use a (do...)." "I wonder what motivates the restriction of only one binding, e.g. many Schemes implement an `and-let*` form which allows multiple bindings, evaluating them in order and breaking out on the first binding that evaluates to false. Can somebody shed some light on this?"], :arglists ["bindings then" "bindings then else & oldform"], :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/if-let"}, :clojure.core.logic.pldb/indexed? {:ns "clojure.core.logic.pldb", :name "indexed?", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 31, :examples nil, :notes nil, :arglists ["v"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/indexed_q"}, :clojure.core.logic/updatecg {:ns "clojure.core.logic", :name "updatecg", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2045, :examples nil, :notes nil, :arglists ["c"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/updatecg"}, :clojure.java.io/writer {:added "1.2", :ns "clojure.java.io", :name "writer", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/reader :clojure.java.io/IOFactory :clojure.java.io/output-stream :clojure.core/spit], :line 104, :examples [";; This example shows the use of the ':append' option\n(defn write-file []\n  (with-open [w (clojure.java.io/writer  \"f:/w.txt\" :append true)]\n    (.write w (str \"hello\" \"world\"))))" ";; This example shows the use of the ':encoding' option.\n(require '(clojure.data.xml :as xml))\n\n(let [tags (xml/element :foo {:foo-attr \"foo value\"}\n                    (xml/element :bar {:bar-attr \"bar value\"}\n                             (xml/element :baz {} \"The baz value\")))]\n  (with-open [out-file (clojure.java.io/writer \"/temp/bar.xml\" :encoding \"UTF-8\")]\n    (xml/emit tags out-file))\n  (with-open [input (clojure.java.io/reader \"/temp/bar.xml\")]\n    (xml/parse input)))\n;;=> #clojure.data.xml.Element{:tag :foo, :attrs {:foo-attr \"foo value\"}, \n;;    :content \n;;       (#clojure.data.xml.Element{:tag :bar, :attrs {:bar-attr \"bar value\"},\n;;         :content \n;;             (#clojure.data.xml.Element{:tag :baz, :attrs {}, :content (\"The baz value\")})})}" ";; When a Writer is created from a Socket using `with-open`, the \n;; underlying Socket is closed along with the Writer.\n\n;; Create the Socket.\n(require '[clojure.java.io :as io])\n(def socket (java.net.Socket.))\n(.connect socket (java.net.InetSocketAddress. \"www.google.com\" 80))\n(.isClosed socket)\n;;=> false\n\n;; Write to the Socket.\n(with-open [w (io/writer socket)]\n  (.write w \"GET / HTTP/1.0\\n\\n\")\n  (.flush w))\n(.isClosed socket)\n;;=> true\n\n;; Attempt to read from the Socket.\n(with-open [r (io/reader socket)\n            s (java.io.StringWriter.)]\n  (io/copy r s))\n;;=> java.net.SocketException: Socket is closed\n"], :notes nil, :tag "java.io.Writer", :arglists ["x & opts"], :doc "Attempts to coerce its argument into an open java.io.Writer.\n   Default implementations always return a java.io.BufferedWriter.\n\n   Default implementations are provided for Writer, BufferedWriter,\n   OutputStream, File, URI, URL, Socket, and String.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Writer is properly\n   closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/writer"}, :clojure.core/ex-info {:added "1.4", :ns "clojure.core", :name "ex-info", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/ex-data :clojure.core/throw :clojure.core/try :clojure.core/catch :clojure.core/finally :clojure.stacktrace/print-stack-trace], :line 4739, :examples ["(try\n  (throw \n    (ex-info \"The ice cream has melted!\" \n       {:causes             #{:fridge-door-open :dangerously-high-temperature} \n        :current-temperature {:value 25 :unit :celsius}}))\n  (catch Exception e (ex-data e)))\n\n;;=> {:causes #{:fridge-door-open :dangerously-high-temperature} \n;;    :current-temperature {:value 25 :unit :celsius}}))\n\n"], :notes nil, :arglists ["msg map" "msg map cause"], :doc "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ex-info"}, :clojure.core/double {:added "1.0", :ns "clojure.core", :name "double", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 3484, :examples ["user=> (double 1)\n1.0" ";; Ratios can be explicitly coerced to a floating-point representation:\nuser=> (double 1/3)\n;= 0.3333333333333333"], :notes nil, :arglists ["x"], :doc "Coerce to double", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/double"}, :clojure.java.io/resource {:added "1.2", :ns "clojure.java.io", :name "resource", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.core/slurp :clojure.java.io/reader :clojure.core/line-seq], :line 446, :examples ["; Use clojure.java.io/resource to read resources from the classpath:\n\n(ns rescue.core\n  (:require [clojure.java.io :as io] ))\n\n; Populate the file on the command line:  \n;   echo \"Hello Resources!\" > resources/hello.txt\n(def data-file (io/resource \n                   \"hello.txt\" ))\n(defn -main []\n  (println (slurp data-file)) )\n; When do \"lein run\"\n; => Hello Resources!" "(require '(clojure.java.io :as io))\n\n;; If the resource does not exist on the classpath a nil is returned.\n(io/resource \"I_do_not_exist.txt\")\n;;=> nil"], :notes ["If you need to `slurp` a file from a JAR file, don't call `io/file` on the result of calling `io/resource`, or you will get an exception that says the resource is \"not a file\". Instead, call `slurp` directly on the result of `io/resource`." "If you need to copy a **binary** file from a running JAR (or WAR), don't call `slurp` as it will try and decode the file. Instead, extract similarily to:\n\n<pre>\n(with-open [in (io/input-stream (io/resource \"file.dat\"))] ;; resources/file.dat\n    (io/copy in (io/file \"/path/to/extract/file.dat\"))))\n</pre>"], :tag "java.net.URL", :arglists ["n" "n loader"], :doc "Returns the URL for a named resource. Use the context class loader\n   if no loader is specified.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/resource"}, :clojure.core/ns-imports {:added "1.0", :ns "clojure.core", :name "ns-imports", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ns-map], :line 4166, :examples ["user> (ns-imports 'clojure.core)\n{ClassVisitor clojure.asm.ClassVisitor, ProcessBuilder java.lang.ProcessBuilder, Enum java.lang.Enum, SuppressWarnings java.lang.SuppressWarnings, Throwable java.lang.Throwable, InterruptedException ...chop...}"], :notes nil, :arglists ["ns"], :doc "Returns a map of the import mappings for the namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ns-imports"}, :clojure.core/list {:added "1.0", :ns "clojure.core", :name "list", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 16, :examples ["user=> (list 'a 'b 'c 'd 'e 'f 'g)\n(a b c d e f g)\nuser=> (list 1 2 3)\n(1 2 3)" "user=> (let [m {:1 1 :2 2 :3 3 :4 4}] (map list (keys m) (vals m)))\n((:1 1) (:2 2) (:3 3) (:4 4))" ";; Lists can also be constructed literally using quote, but note the difference\n\n;; When using list the arguments are evaluated\n(let [x 1 y 2]\n  (list x y))\n;; => (1 2)\n\n;; ... and when using quote ' they are not:\n(let [x 1 y 2]\n  '(x y))\n;; => (x y)\n\n;; there is syntax quote ` (back tick) that allows selective evaluation inside it with ~:\n(let [x 1 y 2]\n  `(~x ~y))\n;; => (1 2)\n\n;; But syntax quote ` is mostly used in macro definitions where most elements\n;; should not be evaluated and unquoted with ~ and list form above feels\n;; more idiomatic for simple list construction."], :notes nil, :arglists ["& items"], :doc "Creates a new list containing the items.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/list"}, :clojure.spec.alpha/get-spec {:ns "clojure.spec.alpha", :name "get-spec", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 340, :examples nil, :notes nil, :arglists ["k"], :doc "Returns spec registered for keyword/symbol/var k, or nil.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/get-spec"}, :clojure.core.logic/ifa* {:ns "clojure.core.logic", :name "ifa*", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1361, :examples nil, :macro true, :notes nil, :arglists ["" "[e & gs] & grest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/ifa*"}, :clojure.core/lazy-seq {:added "1.0", :ns "clojure.core", :name "lazy-seq", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/lazy-cat :clojure.core/realized? :clojure.core/doall :clojure.core/iterate], :line 675, :examples [";; The following defines a lazy-seq of all positive numbers.  Note that \n;; the lazy-seq allows us to make a recursive call in a safe way because\n;; the call does not happen immediately but instead creates a closure.\n\nuser=> (defn positive-numbers \n\t([] (positive-numbers 1))\n\t([n] (lazy-seq (cons n (positive-numbers (inc n))))))\n#'user/positive-numbers\n\nuser=> (take 5 (positive-numbers))\n(1 2 3 4 5)\n\n" ";; A lazy-seq of Fibonacci numbers (fn = fn-1 + fn-2)\n;; The producer function takes exactly two parameters\n;; (because we need the last 2 elements to produce a new one)\nuser=> (defn fib \n         ([]\n           (fib 1 1))\n         ([a b]\n           (lazy-seq (cons a (fib b (+ a b))))))\n\nuser=> (take 5 (fib))\n(1 1 2 3 5)" ";; It might be easier to think about the producer function as a function\n;; that, given element n, produces element n+1 via a recursive call to \n;; itself, wrapped with lazy-seq to delay its execution\n;; We might also provide no-argument version of the function that calls \n;; itself for the first element(s) of the sequence being generated.\n;; => variant of fibonaci with a no-arg version and using cons first:\n(defn sum-last-2 \n   ([] (sum-last-2 1 2)) \n   ([n m] (cons n (lazy-seq (sum-last-2 m (+ n m))))))\n\nuser=> (take 6 (sum-last-2))\n(1 2 3 5 8 13)" ";; An example combining lazy sequences with higher order functions\n;; Generate prime numbers using trial division.\n;; Note that the starting set of sieved numbers should be\n;; the set of integers starting with 2 i.e., (iterate inc 2) \n(defn sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))\n\nuser=> (take 20 (sieve (iterate inc 2)))\n(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71)\n\n\nSadly (nth (sieve (iterate inc 2)) 10000) results in StackOverflowError ;(" ";; Other examples on this page are little too eager to produce the head of collection\n;; right away. lazy-seq was introduced to make it possible to postpone any computation\n;; until data is needed.\n;; While it is not relevant for these simple examples, it could be important\n;; for real apps where producing each element is expensive.\n\n;; Here is a demonstration.\n;; Let's define a function that prints mysqr when it's called\n(defn mysqr [n]\n  (println \"mysqr\")\n  (* n n))\n;; => #'user/mysqr\n\n;; Now function squares that is adopted from positive-numbers example above\n;; Note that lazy-seq is inside of cons\n(defn squares\n  ([n] (cons (mysqr n) (lazy-seq (squares (inc n))))))\n;; => #'user/squares\n\n(def sqrs (squares 1))\n;; => mysqr  <-- NOTE THAT mysqr WAS CALLED WHEN WE SIMPLY REQUESTED COLLECTION\n;; => #'user/sqrs\n\n(take 1 sqrs)\n;; => (1) <-- HERE WE ARE GETTING FIRST ELEMENT THAT WAS CALCULATED BEFORE\n\n;; Now let's redefine 'squares' by wrapping its entire body in lazy-seq:\n(defn squares\n  ([n] (lazy-seq (cons (mysqr n) (squares (inc n))))))\n;; => #'user/squares\n\n;; And when we request the collection:\n(def sqrs (squares 1))\n;; => #'user/sqrs\n;; NOTE THAT mysqr WAS NOT CALLED HERE\n\n(take 1 sqrs)\n;; => mysqr <- AND HERE mysqr IS CALLED WHEN FIRST ELEMENT IS ACTUALLY REQUESTED\n;; => (1)" ";; Compare recursive functions and lazy sequences\n;; generate (some) valid parenthesis combinations.\n;; (Side note: Everything this generates are valid combinations, but this\n;;   doesn't generate all possible valid combinations.) \n;; valid paren combinations for 1 paren - ()\n;; valid paren combinations for 2 paren - ()(),(())\n;; valid paren combinations for 3 paren - ()()(),()(()),(())(),(()()),((()))\n\n;; given ith item, generate (i+1)th item\n(defn next-parens\n    [xs]\n    (set (mapcat (juxt\n                  #(str \"()\" %)\n                  #(str % \"()\")\n                  #(str \"(\" % \")\"))\n                 xs)))\n\n;; recursive function to get n paren combinations\n;; combinations are recursively calculated on the stack\n(defn parens-nth-item\n    [n]\n    (if (= 0 n)\n      #{\"\"}\n      (next-parens (parens-nth-item (dec n)))))\nuser=> (parens-nth-item 3)\n#{\"(()())\" \"((()))\" \"()()()\" \"()(())\" \"(())()\"}\n\n;; lazy function to get sequence of paren combinations\n;; combinations are lazily calculated on the heap\n(defn parens-sequence\n    [xs]\n    (lazy-seq (cons xs (parens-sequence (next-parens xs)))))\n\nuser=> (take 3 (parens-sequence #{\"\"}))\n(#{\"()\"} #{\"(())\" \"()()\"} #{\"(()())\" \"((()))\" \"()()()\" \"()(())\" \"(())()\"})" "; Create a finite-length lazy seq\n(defn finite-lazy-builder [values]\n  (lazy-seq\n    ; We need the when-let so the lazy-seq will terminate\n    (when-let [ss (seq values)]\n      (cons (first values)\n            (finite-lazy-builder (next values))))))\n\n(println (finite-lazy-builder [1 2 3 4 5] ))\n;=> (1 2 3 4 5)\n\n" ";;generate a seq by multiplying the first n numbers starting from 1\n;;1*1\n;;1*2\n;;2*3\n;;6*4 .....\n\n\n(defn multiplen\n  ([]\n   (multiplen 1 1))\n  ([total x]\n   (let [new-total (* total x)]\n     (lazy-seq\n      (cons new-total (multiplen new-total (inc x)))))))\n\n;;take the first 5 elements \n(take 5 (multiplen))\n\n;;(1 2 6 24 120)"], :macro true, :notes ["I think every form of (cons a (lazy-seq (f b))) in examples should be changed to (lazy-seq (cons a (f b))) to be fully lazy.<br/>\n\nThink about<br/>\n(def one-over ((fn helper [n] (cons (/ 1 n) (lazy-seq (helper (inc n))))) 0))<br/>\nand<br/>\n(def one-over ((fn helper [n] (lazy-seq (cons (/ 1 n) (helper (inc n))))) 0))<br/>\n\nFirst one throws an exception right after hitting enter key, while second code postpones the calculation(and that's the point of lazyness!).<br/>\nTherefore, cons should be inside of lazy-seq.\n"], :arglists ["& body"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/lazy-seq"}, :clojure.core/nat-int? {:added "1.9", :ns "clojure.core", :name "nat-int?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/pos-int? :clojure.core/neg-int? :clojure.core/int?], :line 1412, :examples ["user> (nat-int? 0)\ntrue\nuser> (nat-int? 1)\ntrue\nuser> (nat-int? -1)\nfalse\n;; especially useful for specs\nuser> (require '[clojure.spec :as spec])\nnil\nuser> (spec/def quantity nat-int?)\nuser/quantity\nuser> (spec/def ::quantity nat-int?)\n:user/quantity\nuser> (spec/valid? ::quantity -1)\nfalse" "(nat-int? 0)\n;;=> true\n(nat-int? 1)\n;;=> true\n(nat-int? 9223372036854775807)\n;;=> true\n\n;;;; false for negative values\n\n(nat-int? -1)\n;;=> false\n\n;;;; false for decimal values\n\n(nat-int? 0.0)\n;;=> false\n(nat-int? 1.0)\n;;=> false\n(nat-int? 1/2)\n;;=> false\n\n;;;; false for BigInt values\n\n(nat-int? 0N)\n;;=> false\n(nat-int? 1N)\n;;=> false\n(nat-int? 9223372036854775808)\n;;=> false"], :notes nil, :arglists ["x"], :doc "Return true if x is a non-negative fixed precision integer", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/nat-int_q"}, :clojure.core.async/offer! {:ns "clojure.core.async", :name "offer!", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/poll!], :line 389, :examples ["(let [c (chan)]\n  (println (offer! c 42)))\n\n;; nil\n;;=> nil (it does not block even though there is no buffer!)\n\n(let [c (chan 1)]\n  (println (offer! c 42)))\n;; true \n;;=> nil"], :notes nil, :arglists ["port val"], :doc "Puts a val into port if it's possible to do so immediately.\n   nil values are not allowed. Never blocks. Returns true if offer succeeds.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/offer!"}, :clojure.core/bound? {:added "1.2", :ns "clojure.core", :name "bound?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/thread-bound?], :line 5452, :examples ["user=> (def foobar)\n#'user/foobar\nuser=> (bound? #'foobar)\nfalse\nuser=> (def boing 10)\n#'user/boing\nuser=> (bound? #'boing)\ntrue\nuser=> (defn plus3 [n] (+ 3 n))\n#'user/plus3\nuser=> (bound? #'plus3)\ntrue\n"], :notes nil, :arglists ["& vars"], :doc "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/bound_q"}, :clojure.core.logic/get-dom {:ns "clojure.core.logic", :name "get-dom", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 515, :examples nil, :notes nil, :arglists ["s x dom"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/get-dom"}, :clojure.core/+ {:added "1.2", :ns "clojure.core", :name "+", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/+' :clojure.core/* :clojure.core/- :clojure.core/unchecked-add :clojure.core/inc], :line 976, :examples ["(+)\n;;=> 0\n\n(+ 1)\n;;=> 1\n\n(+ -10)\n;;=> -10\n\n(+ 1 2)\n;;=> 3\n\n(+ 1 2 3)\n;;=> 6\n\n(apply + (range 10000000000000 10000000001000))\n;; ArithmeticException: integer overflow"], :notes nil, :arglists ["" "x" "x y" "x y & more"], :doc "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/+"}, :clojure.core/var {:ns "clojure.core", :name "var", :type "var", :see-alsos [:clojure.core/meta :clojure.core/symbol :clojure.core/symbol? :clojure.core/var? :clojure.core/binding :clojure.core/with-redefs :clojure.core/with-redefs-fn :clojure.core/set! :clojure.core/var-set :clojure.core/var-get :clojure.core/with-local-vars], :examples [";;getting meta-data for a defined symbol (as opposed to what it's pointing to.\n\nuser=> meta\n#<core$meta clojure.core$meta@2e257f1b>\n\nuser=> (var meta)\n#'clojure.core/meta\n\n;; Reader shortcut for var is #'\nuser=> #'meta\n#'clojure.core/meta\n\nuser=> (meta (var meta))\n{:ns #<Namespace clojure.core>, :name meta, :file \"clojure/core.clj\", :line 178, :arglists ([obj]), :doc \"Returns the metadata of obj, returns nil if there is no metadata.\", :added \"1.0\"}\n" "=> *clojure-version*\n{:major 1, :minor 5, :incremental 0, :qualifier \"RC17\"}\n=> var\n;CompilerException java.lang.RuntimeException: Unable to resolve symbol: var in this context, compiling:(NO_SOURCE_PATH:1:42) \n=> (var)\n;CompilerException java.lang.NullPointerException, compiling:(NO_SOURCE_PATH:1:1) \n=> (var 1)\n;CompilerException java.lang.ClassCastException: java.lang.Long cannot be cast to clojure.lang.Symbol, compiling:(NO_SOURCE_PATH:1:1) \n=> (var defn)\n#'clojure.core/defn\n=> (var defn 1 2 3 4)\n#'clojure.core/defn\n" "user> (def a 1)\n#'user/a\n\nuser> (def b (var a))\n#'user/b\n\nuser> (alter-var-root (var a) inc)\n2\n\nuser> (alter-var-root b inc)\n3\n\nuser> (deref b)\n3\n"], :notes nil, :arglists [], :doc "The symbol must resolve to a var, and the Var object itself (not its value)\nis returned. The reader macro #'x expands to (var x). See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/var"}, :clojure.core.async/dropping-buffer {:ns "clojure.core.async", :name "dropping-buffer", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/buffer :clojure.core.async/sliding-buffer :clojure.core.async/chan], :line 54, :examples ["(let [c (chan (dropping-buffer 2))]\n  (future (dotimes [x 3]\n            (>!! c x)\n            (println \"Sent: \" x)))\n  (println \"Done\")\n  (future (dotimes [x 3]\n            (println \"Got: \" (<!! c)))\n          (println \"done getting\")))\n\n;Done\n;Sent:  0\n;Sent:  1\n;Sent:  2 (this one is discarded) this is the reason we did not get `Got: 2`\n;Got:  0\n;Got:  1"], :notes nil, :arglists ["n"], :doc "Returns a buffer of size n. When full, puts will complete but\n  val will be dropped (no transfer).", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/dropping-buffer"}, :clojure.reflect/->AsmReflector {:ns "clojure.reflect", :name "->AsmReflector", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos nil, :line 196, :examples ["(require '[clojure.reflect :as cr])\n(import  '(clojure.reflect.AsmReflector))\n\n;; Let us see what is available in the AsmReflector\n(->> clojure.reflect.AsmReflector \n     cr/reflect\n     :members\n     (sort-by :name)\n     (pp/print-table [:name :flags :parameter-types]))\n\n; |                        :name |                    :flags |   :parameter-types |\n; |------------------------------+---------------------------+--------------------|\n; |            __cached_class__0 |       #{:private :static} |                    |\n; |               class_resolver |         #{:public :final} |                    |\n; | clojure.reflect.AsmReflector |                #{:public} | [java.lang.Object] |\n; |                     const__0 | #{:public :static :final} |                    |\n; |                     const__3 | #{:public :static :final} |                    |\n; |                     const__4 | #{:public :static :final} |                    |\n; |                     const__5 | #{:public :static :final} |                    |\n; |                   do_reflect |                #{:public} | [java.lang.Object] |\n; |                     getBasis |        #{:public :static} |                 [] |\n;;=> nil\n"], :notes nil, :arglists ["class-resolver"], :doc "Positional factory function for class clojure.reflect.AsmReflector.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/->AsmReflector"}, :clojure.core/quote {:ns "clojure.core", :name "quote", :type "var", :see-alsos [:clojure.core/unquote], :examples [";; ' is the shortcut for quote\nuser> (= 'a (quote a))\ntrue\n\n;; quoting keeps something from being evaluated\nuser> (quote (println \"foo\"))\n(println \"foo\")\n\n=> *clojure-version*\n{:major 1, :minor 5, :incremental 0, :qualifier \"RC17\"}\n=> (quote)\nnil\n=> (quote 1)\n1\n=> (quote 1 2 3 4 5)\n1\n=> quote\nCompilerException java.lang.RuntimeException: Unable to resolve symbol: quote in this context, compiling:(NO_SOURCE_PATH:1:42)\n" ";; Proof that ' is just a syntactic sugar for quote:\nuser=> (macroexpand ''(1 2 3))\n(quote (1 2 3))\n\n;; Two ' must be used because reader processes and removes the first one"], :notes ["Quote gives you the unevaluated form.  That is:\r\n\r\n<pre>user=&gt; '(foo bar baz)</pre>\r\n\r\nWill not attempt to evaluate foo as a function but rather just return the data structure as is (with the three symbols unevaluated).</pre></pre>" "I found this blog post interesting: http://blog.8thlight.com/colin-jones/2012/05/22/quoting-without-confusion.html\r\n\r\nCheers"], :arglists [], :doc "Yields the unevaluated form. See http://clojure.org/special_forms for more\ninformation.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/quote"}, :clojure.core/*print-length* {:added "1.0", :ns "clojure.core", :name "*print-length*", :file "clojure/core_print.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 16, :examples [";; Oops! Don't this!!!\nuser=> (iterate inc 0)\n;; Frantically doing C-c C-c :-P\n; Evaluation aborted.\n\nuser=> (set! *print-length* 10)\n10\n\n;; Now it's perfectly fine. Yay!\nuser=> (iterate inc 0)\n(0 1 2 3 4 5 6 7 8 9 ...)\n\n"], :notes nil, :arglists [], :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-length*"}, :clojure.core.logic/unify-with-pmap* {:ns "clojure.core.logic", :name "unify-with-pmap*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2497, :examples nil, :notes nil, :arglists ["u v s"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unify-with-pmap*"}, :clojure.spec.alpha/spec {:ns "clojure.spec.alpha", :name "spec", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 345, :examples nil, :macro true, :notes nil, :arglists ["form & {:keys [gen]}"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/spec"}, :clojure.spec.alpha/valid? {:ns "clojure.spec.alpha", :name "valid?", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 751, :examples nil, :notes nil, :arglists ["spec x" "spec x form"], :doc "Helper function that returns true when x is valid for spec.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/valid_q"}, :clojure.test/set-test {:added "1.1", :ns "clojure.test", :name "set-test", :file "clojure/test.clj", :type "macro", :column 1, :see-alsos nil, :line 647, :examples nil, :macro true, :notes nil, :arglists ["name & body"], :doc "Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/set-test"}, :clojure.core/subvec {:added "1.0", :ns "clojure.core", :name "subvec", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vector :clojure.core/vector?], :line 3784, :examples [";; not supplying 'end' returns vector from 'start' to (count vector)\nuser=> (subvec [1 2 3 4 5 6 7] 2)\n[3 4 5 6 7]\n\n;; supplying 'end' returns vector from 'start' to element (- end 1)\nuser=> (subvec [1 2 3 4 5 6 7] 2 4)\n[3 4]" ";; Remove one item by index\n\n(let [coll [0 1 2 3 4 5]\n      i 3]\n  (concat (subvec coll 0 i)\n          (subvec coll (inc i))))\n;; => (0 1 2 4 5)" ";; To query the indices of a subvec:\n(def foo (vec (range 10)))\n(def bar (subvec foo 3 7)) \n=> (.start bar)\n3\n=> (.end bar)\n7\n\n;; Increments with repeated slicing:\n(def baz (subvec bar 2))\n=> (.start baz)\n5\n\n;; Return the original vector:\n=> (.v bar)\n[0 1 2 3 4 5 6 7 8 9]\n=> (.v baz)\n[0 1 2 3 4 5 6 7 8 9]"], :notes ["<pre>\n;; Note that subvec holds a reference to the original vector. If you plan \n;; to split a large vector and never using it again, consider freeing up\n;; the reference.\n\n(let [v1 (subvec (vec (range 1e7)) 0 5)\n      v2 (subvec (vec (range 1e7)) 5 10)]\n      (into v1 v2))\n;; OutOfMem\n\n(let [v1 (into [] (subvec (vec (range 1e7)) 0 5))\n      v2 (into [] (subvec (vec (range 1e7)) 5 10))]\n      (into v1 v2))\n;; [0 1 2 3 4 5 6 7 8 9]\n</pre>"], :arglists ["v start" "v start end"], :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/subvec"}, :clojure.core.reducers/folder {:added "1.5", :ns "clojure.core.reducers", :name "folder", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 114, :examples ["(require '[clojure.core.reducers :as r])\n(r/fold\n  (r/monoid merge (constantly {}))\n  (fn [m k v] (assoc m k (+ 3 v)))\n  (r/folder\n    (zipmap (range 100) (range 100))\n    (fn [rf] (fn [m k v] (if (zero? (mod k 10)) (rf m k v) m)))))\n;; {0 3, 70 73, 20 23, 60 63, 50 53, 40 43, 90 93, 30 33, 10 13, 80 83}"], :notes nil, :arglists ["coll xf"], :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/folder"}, :clojure.core/ref-set {:added "1.0", :ns "clojure.core", :name "ref-set", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref :clojure.core/alter :clojure.core/commute :clojure.core/dosync], :line 2447, :examples ["user=> (def foo (ref {}))\n#'user/foo\n\nuser=> (dosync\n         (ref-set foo {:foo \"bar\"}))\n{:foo \"bar\"}\n\nuser=> @foo\n{:foo \"bar\"}\n"], :notes nil, :arglists ["ref val"], :doc "Must be called in a transaction. Sets the value of ref.\n  Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/ref-set"}, :clojure.spec.alpha/merge {:ns "clojure.spec.alpha", :name "merge", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 482, :examples ["\n(s/def ::fname string?)\n(s/def ::lname string?)\n(s/def ::street string?)\n(s/def ::city string?)\n\n(s/def ::person (s/keys :req [::fname ::lname]))\n(s/def ::address (s/keys :req [::street ::city]))\n\n;; Merging...\n(s/def ::contact (s/merge ::person ::address))\n\n(s/valid? ::contact {::fname \"Rich\" ::lname \"Hickey\"\n                     ::street \"Some Street\" ::city \"New York\"})\n;;=> true"], :macro true, :notes nil, :arglists ["& pred-forms"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/merge"}, :clojure.core/await1 {:ns "clojure.core", :name "await1", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3283, :examples nil, :notes nil, :arglists ["a"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/await1"}, :clojure.core.async/transduce {:ns "clojure.core.async", :name "transduce", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 612, :examples nil, :notes nil, :arglists ["xform f init ch"], :doc "async/reduces a channel with a transformation (xform f).\n  Returns a channel containing the result.  ch must close before\n  transduce produces a result.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/transduce"}, :clojure.core.reducers/flatten {:added "1.5", :ns "clojure.core.reducers", :name "flatten", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 207, :examples ["user=> (require '[clojure.core.reducers :as r])\n\nuser=> (into [] (r/flatten [1 [2 3 4 5 6 7] 8]))\n[1 2 3 4 5 6 7 8]\n\nuser=> (into [] (r/flatten [0 2 [[2 3] 8 [[100]] nil [[nil]]] -2]))\n[0 2 2 3 8 100 nil nil -2]\n\nuser=> (into [] (r/flatten nil))\n[]\n"], :notes nil, :arglists ["" "coll"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/flatten"}, :clojure.core/*ns* {:added "1.0", :ns "clojure.core", :name "*ns*", :type "var", :see-alsos nil, :examples ["user=> *ns*\n#<Namespace user>" "user=> (ns foo.bar)\nnil\n\nfoo.bar=> *ns*\n#<Namespace foo.bar>" ";; A (rare) trap which can happen is attempting to dynamically call `in-ns`, due to how\n;; `*ns*` is really an instance of `clojure.lang.Var` with a root binding.\nuser=> (ns my.namespace)\nnil\n\nmy.namespace=> *ns*\n#<Namespace my.namespace>\n\n;; This will *only* work in the REPL (or REPL-like environments)!!\n;; Tools like Boot and Lein may or may not provide this (read the manual/code)\nmy.namespace=> (defn swap-ns! [ns-name] (in-ns ns-name))\n#'my.namespace/swap-ns!\n\nmy.namespace=> (swap-ns! 'other.ns)\n#namespace[other.ns]\n\n;; Later, at runtime...\n;; Throws IllegalStateException(\"Can't change/establish root binding of: *ns* with set\")\n;; Remember, *ns* is a root var and in-ns calls set!, which only works after\n;; someone somewhere calls the binding macro (or Java equivalent)\n(defn -main\n  [& args]\n  (println *ns*)\n  (swap-ns! 'arbitrary-namespace))\n;; prints #namespace[clojure.core] and then will crash"], :notes ["A trap I fell into was that *ns* seems to get assigned to clojure.core when run as a \"gen-class\" compiled class." "To clarify the above point, see my example above. Although within Lein/Boot/REPL/Compiler contexts, `*ns*` is thread-local due to the use of the `binding` machinery, and so `in-ns` works in those situtations, `*ns*` has a root of `clojure.core`. That means that, at runtime, you cannot call `in-ns` within functions until you've first called `binding`. (This could be relevant for e.g. `eval` calls.)"], :tag "clojure.lang.Namespace", :arglists [], :doc "A clojure.lang.Namespace object representing the current namespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*ns*"}, :clojure.core/let {:added "1.0", :ns "clojure.core", :name "let", :special-form true, :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/letfn :clojure.core/if-let :clojure.core/fn], :line 4447, :examples [";; let is a Clojure special form, a fundamental building block of the language.\n;;\n;; In addition to parameters passed to functions, let provides a way to create\n;; lexical bindings of data structures to symbols. The binding, and therefore \n;; the ability to resolve the binding, is available only within the lexical \n;; context of the let. \n;; \n;; let uses pairs in a vector for each binding you'd like to make and the value \n;; of the let is the value of the last expression to be evaluated. let also \n;; allows for destructuring which is a way to bind symbols to only part of a \n;; collection.\n\n;; A basic use for a let:\nuser=> (let [x 1] \n         x)\n1\n\n;; Note that the binding for the symbol y won't exist outside of the let:\nuser=> (let [y 1] \n         y)\n1\nuser=> (prn y)\njava.lang.Exception: Unable to resolve symbol: y in this context (NO_SOURCE_FILE:7)\n\n;; Note that if you use def inside a let block, your interned variable is within the current namespace and will appear OUTSIDE of the let block. \nuser=> (let [y 1] \n         (def z y) \n         y)\n1\nuser=> z\n1\n\n;; Another valid use of let:\nuser=> (let [a 1 b 2] \n         (+ a b))\n3\n\n;; The forms in the vector can be more complex (this example also uses\n;; the thread macro):\nuser=> (let [c (+ 1 2)\n             [d e] [5 6]] \n         (-> (+ d e) (- c)))\n8\n\n;; The bindings for let need not match up (note the result is a numeric\n;; type called a ratio):\nuser=> (let [[g h] [1 2 3]] \n         (/ g h))\n1/2\n\n;; From http://clojure-examples.appspot.com/clojure.core/let with permission." "user=> (let [a (take 5 (range))\n             {:keys [b c d] :or {d 10 b 20 c 30}} {:c 50 :d 100}\n             [e f g & h] [\"a\" \"b\" \"c\" \"d\" \"e\"]\n             _ (println \"I was here!\")\n             foo 12\n             bar (+ foo 100)]\n         [a b c d e f g h foo bar])\nI was here!\n[(0 1 2 3 4) 20 50 100 \"a\" \"b\" \"c\" (\"d\" \"e\") 12 112]\n" "; :as example \n\nuser=> (let [[x y :as my-point] [5 3]]\n         (println x y)\n         (println my-point))\n\n5 3\n[5 3]\n\n; :as names the group you just destructured.\n\n; equivalent to (and better than)\n\nuser=> (let [[x y] [5 3]\n             my-point [x y]]\n         ;..." ";;; map destructuring, all features\nuser=>\n(let [\n      ;;Binding Map\n      {:keys [k1 k2]        ;; bind vals with keyword keys\n       :strs [s1 s2]        ;; bind vals with string keys\n       :syms [sym1 sym2]    ;; bind vals with symbol keys\n       :or {k2 :default-kw, ;; default values\n            s2 :default-s, \n            sym2 :default-sym} \n       :as m}  ;; bind the entire map to `m`\n      ;;Data\n      {:k1 :keyword1, :k2 :keyword2,  ;; keyword keys\n       \"s1\" :string1, \"s2\" :string2,  ;; string keys\n       'sym1 :symbol1,                ;; symbol keys\n       ;; 'sym2 :symbol2              ;; `sym2` will get default value\n       }] \n  [k1 k2 s1 s2 sym1 sym2 m])  ;; return value\n\n[:keyword1, :keyword2, \n :string1, :string2,\n :symbol1, :default-sym, ;; key didn't exist, so got the default\n {'sym1 :symbol1, :k1 :keyword1, :k2 :keyword2, \n  \"s1\" :string1, \"s2\" :string2}]\n\n;; remember that vector and map destructuring can also be used with \n;; other macros that bind variables, e.g. `for` and `doseq`" ";;; no value of a key\nuser> (let [{:keys [a b] :as m} (:x {})]\n        [a b m])\n[nil nil nil]\n\n;;; same as above\nuser> (let [{:keys [a b] :as m} nil]\n        [a b m])\n[nil nil nil]\n\n;;; similar case on Vector\nuser> (let [[a b :as v] nil]\n        [a b v])\n[nil nil nil]\n" ";; lexical clojure (or let-over-fn) is an idiom for doing, in functional languages,\n;; something very similar to object based programming.\n;; Using combinations of 'let' and 'fn' can produce many interesting results.\n\n;; note the use of the ! on the functions to indicate the side effect\n(defn counter []\n  (let [cnt (atom 0)]\n    {:inc! (fn [] (swap! cnt inc))\n     :dec! (fn [] (swap! cnt dec)) \n     :get (fn [] @cnt)} ))\n\n;; we can now make and use the object\n(let [cnt (counter)]\n  ((:inc! cnt))\n  ((:inc! cnt)) \n  ((:get cnt)))\n;;=> 2" "(let [[a b & c :as d] [1 2 3 4 5]]\n   (println a) ; 1\n   (println b) ; 2\n   (println c)  ; (3 4 5)\n   d) ;[1 2 3 4 5]" ";;defina F1Car record\n(defrecord F1Car [team engine tyre oil])\n\n;;build the constructor distructing a single map with options\n(defn make-f1team [f1-team f1-engine {:keys [f1-tyre f1-oil] :as opts}]\n  (let [{:keys [tyre oil]} opts]\n    (map->F1Car {:team f1-team\n                       :engine f1-engine\n                       :tyre f1-tyre\n                       :oil f1-oil})))\n\n;;create a record\n(def mclaren (make-f1team \"RedBull\" \"Renault\" {:f1-tyre\"Pirelli\" :f1-oil \"Castrol\"}))\n\n;;retrieve values\n(keys mclaren)\n(vals mclaren)\n(:team mclaren)\n(:oil mclaren)"], :macro true, :notes ["Nota Bene: `let` in Clojure is like `let*` in Scheme -- each init-expr has access to the preceding binding forms. (There is also a `let*`, but it is more or less `let` without destructuring, and in fact is the underlying implementation.)"], :arglists ["bindings & body"], :doc "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/let", :forms ["(let [bindings*] exprs*)"]}, :clojure.core/replicate {:added "1.0", :ns "clojure.core", :name "replicate", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/repeat], :line 2998, :examples ["user=> (apply str (replicate 7 \\space))\n       ; 7 spaces\n\nuser=> (replicate 7 (rand-int 10))\n(3 3 3 3 3 3 3) ; the same number"], :deprecated "1.3", :notes ["Note that `replicate` is obsolete. It's functionality is now available via the two-arg arity form of [`repeat`](http://clojuredocs.org/v/1578)."], :arglists ["n x"], :doc "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/replicate"}, :clojure.core/find-protocol-method {:ns "clojure.core", :name "find-protocol-method", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 546, :examples nil, :notes nil, :arglists ["protocol methodk x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/find-protocol-method"}, :clojure.zip/branch? {:added "1.0", :ns "clojure.zip", :name "branch?", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos nil, :line 69, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns true if the node at loc is a branch", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/branch_q"}, :clojure.core/reduced {:added "1.5", :ns "clojure.core", :name "reduced", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/reduce :clojure.core/reduced? :clojure.core/unreduced :clojure.core/ensure-reduced], :line 2828, :examples [";; Suppose you want to short-circuit a sum like:\n(reduce (fn [a v] (+ a v)) (range 10))\n;;=> 45\n\n;; So that it returns the sum of the integers if less than 100:\n(reduce (fn [a v] (if (< a 100) (+ a v) (reduced :big))) (range 10))\n;;=> 45\n\n;; But the keyword :big otherwise:\n(reduce (fn [a v] (if (< a 100) (+ a v) (reduced :big))) (range 20))\n;;=> :big\n\n;; The value returned by (reduced :big) short-circuits the reduction so that \n;; it returns the wrapped value without ranging over the entire sequence.\n;; This is useful for infinite lazy sequences:\n(reduce (fn [a v] (if (< a 100) (+ a v) (reduced :big))) (range))\n;;=>:big\n\n;; Which would otherwise not terminate." ";;re-implementing (some) using (reduce) and (reduced):\n\n(defn resome [pred koll]\n  (reduce (fn [_ c] (when-let [x (pred c)] (reduced x)))\n          nil koll))\n\n;;user> (resome #{4} [3 4 2 3 2])\n;;>>> 4\n;;user> (resome even? [3 41 25 3 2])\n;;>>> true\n;;user> (resome even? [3 41 25 3 27])\n;;>>> nil"], :notes nil, :arglists ["x"], :doc "Wraps x in a way such that a reduce will terminate with the value x", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/reduced"}, :clojure.xml/*current* {:ns "clojure.xml", :name "*current*", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :dynamic true, :line 16, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/*current*"}, :clojure.core/*err* {:added "1.0", :ns "clojure.core", :name "*err*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :doc "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*err*"}, :clojure.core.logic.fd/-domc {:ns "clojure.core.logic.fd", :name "-domc", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 692, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-domc"}, :clojure.core/when-some {:added "1.6", :ns "clojure.core", :name "when-some", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/if-some :clojure.core/when-let], :line 1888, :examples ["user=> (when-some [x 1] [x :ok])\n[1 :ok]\n\nuser=> (when-some [x nil] [x :ok])\nnil" "user=> (when-some [x \"Hello\"] (println x))\n\"Hello\"\nnil\n\nuser=> (when-some [x nil] (println x))\nnil" ";; In contrast with when-let, when-some evaluates the body for false values:\n(when-some [x false] {:x x})  ; => {:x false}\n\n;; While when-let suppresses evaluation for false values:\n(when-let [x false] {:x x})   ; => nil"], :macro true, :notes nil, :arglists ["bindings & body"], :doc "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/when-some"}, :clojure.core/fn {:added "1.0", :ns "clojure.core", :name "fn", :special-form true, :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/defn], :line 4479, :examples [";; simple anonymous function passed to (map )\nuser=> (map (fn [x] (* x x)) (range 1 10))\n(1 4 9 16 25 36 49 64 81) \n\n;; anonymous function with a name.  not so anonymous now is it?\n;; this is useful in stack traces\n(fn add [a b] (+ a b))\n\n;; anonymous function with two params, the second is destructured\nuser=> (reduce (fn [m [k v]] (assoc m v k)) {} {:b 2 :a 1 :c 3})\n{2 :b, 1 :a, 3 :c} \n\n;; define and instantly call an anonymous function\nuser=> ((fn [a b c] (+ a b c)) 2 4 6)\n12\n\n;; define and instantly call an anonymous variadic function \n;; \"nums\" is a list here\nuser=> ((fn [& nums] (/ (apply + nums) (count nums))) 1 2 3 4)\n5/2 \n\n;; define and instantly call an anonymous mixed function\n;; \"nums\" is a list, while \"int\" is a number\nuser=> ((fn [int & nums] (+ int (/ (apply + nums) (count nums)))) 10 1 2 3 4)\n25/2 \n\n;; define and instantly call an anonymous overloaded function \n;; even though it is quite pointless\nuser=>  ((fn ([a] (inc a)) ([a b] (+ a b))) 3)\n4\n\n" ";; the shortcut form for (fn ) is #( )\n;; where parameters are referred by their index with the prefix %\n\n;; the equivalent of \nuser=> ((fn [a b c] (+ a b c)) 2 4 6)\n12\n\n;; is\nuser=> (#(+ %1 %2 %3) 2 4 6)\n12\n" ";; shortcut form #() cannot be used for maps etc.\n\nuser=> ((fn [] {:a 1}))\n{:a 1}\n\nuser=> (#({:a 1}))\nArityException Wrong number of args (0) passed to: PersistentArrayMap\n\nuser=> (#([1]))\nArityException Wrong number of args (0) passed to: PersistentVector\n\n;; explanation for the\tfirst error:\n;; #(f) is a shortcut for (fn [] (f))\n;; that means (#({:a 1})) is shortcut for ((fn [] ({:a 1})))\n;; which leads to the error above because you cannot apply a map to an empty\n;; argument list.\n\n;; i.e. you can only use #() shortcut if the fn body is a list.\n;; As ((fn [] {:a 1})) has the same result \n;; as ((fn [] (identity {:a 1}))), you can write:\n\nuser=> (#(identity {:a 1}))\n{:a 1}" ";;map and anonymous function\n;;apply a function to a collection using an anonymous function\n\n(defn byten\n  [nums]\n  (map #(* 10 %) nums))\n\n(byten [1 2 3 4 5])\n;;(10 20 30 40 50)"], :macro true, :notes ["The signature is wrong. It should be (quoting from [clojure.org][1])\r\n\r\n`(fn name? [params* ] exprs*)`\r\n\r\n`(fn name? ([params* ] exprs*)+)`\r\n\r\n\r\n  [1]: http://clojure.org/special_forms#fn" "What is the purpose of `name?` ?" "@terjedahl `name?` allows for self-recursion, as well as generating more human-friendly class names; it can also make the code clearer." "This leaves more questions. What is the performance cost? Why (fn name...) is repeated twice? What is a \"binding-form\"?\n\nThe syntax looks good compared to [lambda function](http://dobegin.com/lambda-functions-everywhere/) syntax in other programming languages." "`fn` also supports the prepost map, the same as `defn`\n```\nboot.user=> (def adder (fn [x] {:post [(pos? %)]} (inc x)))\n#'boot.user/adder\nboot.user=> (adder -2)\n\njava.lang.AssertionError: Assert failed: (pos? %)\n```"], :arglists ["& sigs"], :doc "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/fn", :forms ["(fn name? [params*] exprs*)" "(fn name? ([params*] exprs*) +)"]}, :clojure.core/future-cancel {:added "1.1", :ns "clojure.core", :name "future-cancel", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/future :clojure.core/future? :clojure.core/future-cancelled? :clojure.core/future-done?], :line 6920, :examples ["\nuser=> (def f (future (Thread/sleep 5000) (inc 0)))\n#'user/f\n\nuser=> (future-cancel f)                           \ntrue\n\nuser=> (future-cancelled? f)                       \ntrue" "\nuser=> (def f (future (inc 0)))\n#'user/f\n\nuser=> (future-cancel f)                           \nfalse\n\nuser=> (future-cancelled? f)                       \nfalse"], :notes nil, :arglists ["f"], :doc "Cancels the future, if possible.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/future-cancel"}, :clojure.java.io/as-url {:added "1.2", :ns "clojure.java.io", :name "as-url", :type "function", :see-alsos nil, :examples ["(use '[clojure.java.io :only (as-url)])\n(import 'java.io.File)\n\nuser=> (as-url nil)\nnil\n\nuser=> (as-url (File. \"/tmp\"))\n#<URL file:/tmp/>\n\nuser=> (as-url \"http://clojuredocs.org\")\n#<URL http://clojuredocs.org>\n\nuser=> (as-url \"http://clojuredocs.org:8080\")\n#<URL http://clojuredocs.org:8080>\n\nuser=> (as-url \"clojuredocs.org\")\n#<CompilerException java.net.MalformedURLException: no protocol: clojuredocs.org>\n\n\n\n\n\n"], :notes nil, :tag "java.net.URL", :arglists ["x"], :doc "Coerce argument to a URL.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/as-url"}, :clojure.core.async/thread {:ns "clojure.core.async", :name "thread", :file "clojure/core/async.clj", :type "macro", :column 1, :see-alsos [:clojure.core.async/thread-call :clojure.core.async/go], :line 448, :examples ["(defn fake-fetch []\n  (thread \n    (Thread/sleep 5000) \n    \"Ready!\")\n\n;; returns immediately, prints \"Ready!\" after 5 secs\n(let [c (fake-fetch)]\n  (go (println (<! c))))\n"], :macro true, :notes nil, :arglists ["& body"], :doc "Executes the body in another thread, returning immediately to the\n  calling thread. Returns a channel which will receive the result of\n  the body when completed, then close.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/thread"}, :clojure.spec.alpha/specize* {:ns "clojure.spec.alpha", :name "specize*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["_" "_ form"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/specize*"}, :clojure.java.io/output-stream {:added "1.2", :ns "clojure.java.io", :name "output-stream", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/writer :clojure.java.io/input-stream :clojure.java.io/IOFactory :clojure.java.io/make-output-stream], :line 138, :examples ["(:use [clojure.java.io :only [output-stream]])\n\n(defn use-output-stream []\n  (with-open [o (output-stream \"test.txt\")]\n    (.write o 65))) ; Writes 'A'"], :notes nil, :tag "java.io.OutputStream", :arglists ["x & opts"], :doc "Attempts to coerce its argument into an open java.io.OutputStream.\n   Default implementations always return a java.io.BufferedOutputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the OutputStream is\n   properly closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/output-stream"}, :clojure.core.async/unsub {:ns "clojure.core.async", :name "unsub", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos nil, :line 906, :examples nil, :notes nil, :arglists ["p topic ch"], :doc "Unsubscribes a channel from a topic of a pub", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/unsub"}, :clojure.spec.alpha/multi-spec {:ns "clojure.spec.alpha", :name "multi-spec", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 364, :examples ["Use retag function to allow generative testing of multi-spec whose\nmultimethod has a :default dispatch method.\n\n(require '[clojure.spec.alpha :as s]\n         '[clojure.spec.gen.alpha :as gen])\n\n(s/def ::tag #{:a :b :c :d})\n(s/def ::example-key keyword?)\n(s/def ::different-key keyword?)\n\n(defmulti tagmm :tag)\n(defmethod tagmm :a [_] (s/keys :req-un [::tag ::example-key]))\n(defmethod tagmm :default [_] (s/keys :req-un [::tag ::different-key]))\n\n(s/def ::example (s/multi-spec tagmm :tag))\n(gen/sample (s/gen ::example))\n;=> only get examples with :tag :a\n\n(s/def ::example (s/multi-spec tagmm (fn retag [gen-v dispatch-tag] gen-v)))\n(gen/sample (s/gen ::example))\n;=> get examples with all :tag options"], :macro true, :notes nil, :arglists ["mm retag"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/multi-spec"}, :clojure.inspector/get-child-count {:ns "clojure.inspector", :name "get-child-count", :file "clojure/inspector.clj", :type "var", :column 1, :see-alsos nil, :line 33, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/get-child-count"}, :clojure.core.logic.pldb/facts-for {:ns "clojure.core.logic.pldb", :name "facts-for", :file "clojure/core/logic/pldb.clj", :type "function", :column 1, :see-alsos nil, :line 16, :examples nil, :notes nil, :arglists ["dbs kname"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.pldb/facts-for"}, :clojure.core.logic/run-constraints* {:ns "clojure.core.logic", :name "run-constraints*", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2115, :examples nil, :notes nil, :arglists ["xs cs ws"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/run-constraints*"}, :clojure.core.logic/unbound-names {:ns "clojure.core.logic", :name "unbound-names", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 249, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/unbound-names"}, :clojure.core/init-proxy {:added "1.0", :ns "clojure.core", :name "init-proxy", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos [:clojure.core/construct-proxy :clojure.core/update-proxy], :line 297, :examples [";; Used as a one-off initialization for the proxy overrides when the\n;; instance was built with \"construct-proxy\".\n\n(import 'clojure.lang.IDeref)\n\n(def MyException (get-proxy-class Exception IDeref))\n\n(defn bail\n  ([ex s]\n    (-> ex\n        (construct-proxy s)\n        (init-proxy\n          {\"deref\" (fn [this] (str \"Cause: \" s))})))\n  ([ex s e]\n    (-> ex\n        (construct-proxy s e)\n        (init-proxy\n          {\"deref\" (fn [this] (str \"Root: \" (.getMessage e)))}))))\n\n@(bail MyException \"error\")\n;; \"Cause: error\"\n\n@(bail MyException \"s\" (RuntimeException. \"caused by root\"))\n;; \"Root: caused by root\""], :notes nil, :arglists ["proxy mappings"], :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/init-proxy"}, :clojure.core/meta {:added "1.0", :ns "clojure.core", :name "meta", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/with-meta :clojure.core/*print-meta* :clojure.core/vary-meta], :line 202, :examples ["(use 'clojure.pprint)\n(pprint (meta #'first))\n;;=> prints the following...\n{:ns #<Namespace clojure.core>,\n :name first,\n :added \"1.0\",\n :file \"clojure/core.clj\",\n :static true,\n :column 1,\n :line 49,\n :arglists ([coll]),\n :doc\n \"Returns the first item in the collection. Calls seq on its\\n    \n argument. If coll is nil, returns nil.\"}" ";; attach metadata to s.\n;; ^:private is a shorthand notation for ^{:private true} and\n;; ^String is a shorthand notation for ^{:tag java.lang.String}.\n(def ^:private ^String s \"Hello, world!\")\n\n;; inspect the metadata attached to s.\n;; note, you need to use the var #'s, instead of the symbol s, as the argument.\n(clojure.pprint/pprint (meta #'s))\n;; =>\n{:private true,\n :tag java.lang.String,\n :line 3,\n :column 1,\n :file \"/tmp/form-init5430922801479403331.clj\",\n :name s,\n :ns #object[clojure.lang.Namespace 0x13fca031 \"user\"]}\n"], :notes nil, :arglists ["obj"], :doc "Returns the metadata of obj, returns nil if there is no metadata.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/meta"}, :clojure.core/comparator {:added "1.0", :ns "clojure.core", :name "comparator", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos nil, :line 3086, :examples [";; simple example to create an ArrayList, initially [1,2,0]\n;; and sort it in descending order\n\nuser=> (def a (new java.util.ArrayList [1 2 0]))\n#'user/a\nuser=> (def compx (comparator (fn [x y] (> x y))))\n#'user/compx\nuser=> (java.util.Collections/sort a compx)\nnil\nuser=> a\n#<ArrayList [2, 1, 0]>\n\n;; Note however that 'comparator' is rarely (never?) needed because if\n;; the fn returns a boolean, the .compare implementation Clojure provides\n;; causes it to behave the same as if 'comparator' were wrapped around it:\n\n(sort (comparator (fn [x y] (> x y))) [1 2 0]) ;=> (2 1 0)\n(sort (fn [x y] (> x y)) [1 2 0])              ;=> (2 1 0)\n(sort > [1 2 0])                               ;=> (2 1 0)\n(sort < [1 2 0])                               ;=> (0 1 2)"], :notes nil, :arglists ["pred"], :doc "Returns an implementation of java.util.Comparator based upon pred.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/comparator"}, :clojure.core/get-proxy-class {:added "1.0", :ns "clojure.core", :name "get-proxy-class", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos [:clojure.core/construct-proxy], :line 276, :examples [";; generates a new Java class extending/implementing the given classes/interfaces:\n;; See \"construct-proxy\" on how to get an instance.\n\n(import '[clojure.lang IDeref IObj])\n(def DocumentException (get-proxy-class Exception IDeref))\n\n(type DocumentException)\n;; java.lang.Class\n\n(ancestors DocumentException)\n;; #{java.io.Serializable \n;;   clojure.lang.IProxy \n;;   java.lang.Exception \n;;   clojure.lang.IDeref \n;;   java.lang.Object \n;;   java.lang.Throwable}\n"], :notes nil, :arglists ["& bases"], :doc "Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get-proxy-class"}, :clojure.core.async/toggle* {:ns "clojure.core.async", :name "toggle*", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["m state-map"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/toggle*"}, :clojure.core/constantly {:added "1.0", :ns "clojure.core", :name "constantly", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/repeatedly], :line 1437, :examples ["user=> (def boring (constantly 10))\n#'user/boring\n\nuser=> (boring 1 2 3)\n10\n\nuser=> (boring)\n10\n\nuser=> (boring \"Is anybody home?\")\n10\n" ";; A really goofy way to find the size of a collection\nuser=> (reduce + (map (constantly 1) [:a :b :c]))\n3" ";; constantly returns a function which always returns the same value\n(map (constantly 9) [1 2 3])\nuser=> (9 9 9)\n\n(map (constantly (rand-int 100)) [:a :b :c])\nuser=> (43 43 43)" ";; 'Removed' example that was more about transducers than `constantly`.\n\n:O"], :notes ["any examples of when this would be useful? I think it is weird to want a function that always returns \"x\" regardless of the number of arguments passed to it - however since this exists in core I'm sure it is sensible, more a case of I've not enough experience to appreciate its value." "I asked about use cases for this function in #clojure and got a good response from amalloy:\r\n\r\nSay you want to call a library function that asks you to pass it a function; it's going to call that function ten times with different arguments to decide how to populate a list it gives you.  But your program is really simple and you want the list to just be full of zeroes.  So you call:\r\n\r\n    (libfn (constantly 0))\r\n\r\nHope that's useful!" "(constantly 1) is often useful when it comes to testing. You can think of it like you would a \"stub\"." "constantly is typically used as an argument to a higher order function when a constant value is needed. " "It is also quite useful in unit tests:\n\n<pre>\n(deftest foo\n  (testing \"Clojure tweets only\"\n    (with-redefs [twitter/get-tweets\n                  (constantly [\"#clojure is awesome!\" \"Yay! #winning\"])]\n      (is (= [\"#clojure is awesome!\"]\n             (only-clojure \"@happyguy\"))))))\n</pre>\n" "Basically, when you already know the result of a function that you would need\nto pass to a higher order function, you can simply wrap it in a constantly to\navoid creating a variadic anonymous function.\n\n    (defn hof [f]\n      (do-something-with (f ...))\n\n    (def x \"result\")\n\n    (hof (constantly x)) " "I've used this to create a `no-op`  function.\n\n```clojure\n(let [handler (if (some? value)\n                 #(do-something-with value)\n                 ; else no-op\n                 (constantly nil))]\n  ; call handler\n  (handler \"foo\" \"bar\"))\n```" "Just a shortcut to <pre>(fn [& args] x)</pre>\n"], :arglists ["x"], :doc "Returns a function that takes any number of arguments and returns x.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/constantly"}, :clojure.string/split {:added "1.2", :ns "clojure.string", :name "split", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.core/subs :clojure.string/replace :clojure.core/re-seq :clojure.string/split-lines :clojure.string/trim], :line 219, :examples ["user=> (require '[clojure.string :as str])\n\nuser=> (str/split \"Clojure is awesome!\" #\" \")\n[\"Clojure\" \"is\" \"awesome!\"]\n\nuser=> (str/split \"q1w2e3r4t5y6u7i8o9p0\" #\"\\d+\")\n[\"q\" \"w\" \"e\" \"r\" \"t\" \"y\" \"u\" \"i\" \"o\" \"p\"]\n\n;; Note that the 'limit' arg is the maximum number of strings to\n;; return (not the number of splits)\nuser=> (str/split \"q1w2e3r4t5y6u7i8o9p0\" #\"\\d+\" 5)\n[\"q\" \"w\" \"e\" \"r\" \"t5y6u7i8o9p0\"]\n\n;; to get back all the characters of a string, as a vector of strings:\nuser=> (str/split \" q1w2 \" #\"\")\n[\" \" \"q\" \"1\" \"w\" \"2\" \" \"]\n;; Note: sequence, in contrast, would return characters.\n\n;; Using lookarounds (lookahead, lookbehind) one can keep the matching characters:\nuser=> (str/split \" something and ACamelName \" #\"(?=[A-Z])\")\n[\" something and \" \"A\" \"Camel\" \"Name \"]\n\n;; If the pattern is not found, we get back the original string untouched:\nuser=> (str/split \"a\" #\"b\")\n[\"a\"]\n\nuser=> (str/split \" \" #\"b\")\n[\" \"]\n\nuser=> (str/split \"\" #\"b\")\n[\"\"]\n\n;; If everything matches, an empty vector is returned!\nuser=> (str/split \"a\" #\"a\")\n[]\n\nuser=> (str/split \"aaa\" #\"a\")\n[]\n\n;; but:\nuser=> (str/split \"\" #\"\")\n[\"\"]" ";; Splits a string on space character and joins \n;; the resulting collection with a line feed character\n\n(use '[clojure.string :only (join split)])\n\nuser=> (println\n         (join \"\\n\"\n           (split \"The Quick Brown Fox\" #\"\\s\")))\nThe\nQuick\nBrown\nFox\nnil" "(use '[clojure.string :only (split triml)])\n\n;; Splitting on whitespace is a common desire.\nuser=> (split \"Some words to split\" #\"\\s+\")\n[\"Some\" \"words\" \"to\" \"split\"]\n\n;; By using the pattern #\"\\s+\", we split on all occurrences of one or\n;; more consecutive whitespace characters.\nuser=> (split \"Some    words   with\\tother whitespace      \\n\" #\"\\s+\")\n[\"Some\" \"words\" \"with\" \"other\" \"whitespace\"]\n\n;; If you are used to Perl's special behavior of split(' ', $str),\n;; where it ignores leading whitespace in the string to be split, this\n;; does not quite do it.\nuser=> (split \"   Leading whitespace causes empty first string\" #\"\\s+\")\n[\"\" \"Leading\" \"whitespace\" \"causes\" \"empty\" \"first\" \"string\"]\n\n;; This will do it.\nuser=> (defn perl-split-on-space [s]\n         (split (triml s) #\"\\s+\"))\n#'user/perl-split-on-space\nuser=> (perl-split-on-space \"   This is often what you want   \")\n[\"This\" \"is\" \"often\" \"what\" \"you\" \"want\"]\n\n;; There might be cases where you want this instead.\nuser=> (split \"Some    words   with\\tother whitespace      \\n\" #\"\\s\")\n[\"Some\" \"\" \"\" \"\" \"words\" \"\" \"\" \"with\" \"other\" \"whitespace\"]\n" "(use '[clojure.string :only (split)])\n\n;; Split on every occurrence of : character\nuser=> (split \"root:*:0:0:admin:/var/root:/bin/sh\" #\":\")\n[\"root\" \"*\" \"0\" \"0\" \"admin\" \"/var/root\" \"/bin/sh\"]\n\n;; Empty strings are returned when two colons appear consecutively in\n;; the string to be split.\nuser=> (split \"root::0:0::/var/root:/bin/sh\" #\":\")\n[\"root\" \"\" \"0\" \"0\" \"\" \"/var/root\" \"/bin/sh\"]\n\n;; Without specifying a limit, any empty strings at the end are\n;; omitted.\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\")\n[\"root\" \"\" \"0\" \"0\" \"admin\" \"/var/root\"]\nuser=> (split \"root::0:0:admin::\" #\":\")\n[\"root\" \"\" \"0\" \"0\" \"admin\"]\n\n;; If you want all of the fields, even trailing empty ones, use a\n;; negative limit.\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\" -1)\n[\"root\" \"\" \"0\" \"0\" \"admin\" \"/var/root\" \"\"]\nuser=> (split \"root::0:0:admin::\" #\":\" -1)\n[\"root\" \"\" \"0\" \"0\" \"admin\" \"\" \"\"]\n\n;; Use a positive limit of n to limit the maximum number of strings in\n;; the return value to n.  If it returns exactly n strings, the last\n;; contains everything left over after splitting off the n-1 earlier\n;; strings.\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\" 2)\n[\"root\" \":0:0:admin:/var/root:\"]\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\" 3)\n[\"root\" \"\" \"0:0:admin:/var/root:\"]\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\" 4)\n[\"root\" \"\" \"0\" \"0:admin:/var/root:\"]\nuser=> (split \"root::0:0:admin:/var/root:\" #\":\" 15)\n[\"root\" \"\" \"0\" \"0\" \"admin\" \"/var/root\" \"\"]\n" "(:require [clojure.string :as cstr])\n\n(def legal-ref \"1321-61\")\n\n(cstr/split legal-ref #\"-\")\n[\"1321\" \"61\"]" ";; Note: See clojure.core/subs for discussion of behavior of substrings\n;; holding onto references of the original strings, which can\n;; significantly affect your memory usage in some cases." ";; Note: see clojure.string/trim for an example where\n;; (split ... #\"\\s\") might not do what you expect!"], :notes ["user=> (clojure.string/split \"foo bar\")\r\njava.lang.ClassNotFoundException: clojure.string\r\n\r\nDo I need to require / use anything?" "You need to add a namespace:\r\nuser => (use 'clojure.string)" "I 've a doubt...in ruby if I've this:\r\n\r\nbignumber=\"2938434\"\r\n\r\nI can do this\r\n\r\nbignumber.split(\"\") \r\n\r\nand get\r\n(\"2\", \"9\", \"3\", \"8\" .....)\r\n\r\nHow can I do this with clojure?...thanks" "Hi, cocoOS. You may want to do it like this:\r\n\r\n<pre>user=&gt; (use '[clojure.string :only (split)])\r\nnil\r\nuser=&gt; (def bignumber \"2938434\")\r\n#'user/bignumber\r\nuser=&gt; (split bignumber #\"\")\r\n[\"\" \"2\" \"9\" \"3\" \"8\" \"4\" \"3\" \"4\"]\r\n</pre>\r\n\r\nYou will have to filter out the empty string.\r\n\r\n<br>\r\n\r\nBut there are other ways, like:\r\n<pre>user=&gt; (map str (vec bignumber))\r\n(\"2\" \"9\" \"3\" \"8\" \"4\" \"3\" \"4\")\r\n</pre>" "<pre>\r\nuser=> (seq \"2938434\")\r\n(\\2 \\9 \\3 \\8 \\4 \\3 \\4)\r\n</pre>\r\n\r\nmight also be what you want." "Thanks for the help Domon and Iceland_jack, one more question:\r\n\r\nSay I have used sequence in the way:\r\n\r\nuser=&gt; (seq \"2938434\")\r\n(\\2 \\9 \\3 \\8 \\4 \\3 \\4)\r\n\r\nIf I only wanted to access the 4th item in the sequence (which is 8), how would I do so? Aside from using (next (next (next ...))) ? Just trying to index it giving that I want position 4" "When limit=1 the original string is returned\n\n<pre>\n(clojure.string/split \"abcd\" #\"a\" 1)\n=> [\"abcd\"]\n\n(clojure.string/split \"abcd\" #\"a\" 2)\n=> [\"\" \"bcd\"]\n</pre>" "@Instinct212\n<pre>\n(nth (seq \"2938434\") 3)\n=> \\8\n</pre>" "There is a change in behaviour between Java 7 and Java 8 that can affect the returned values.  \"When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.\" was added to the docs for split().\n\nBoth run with Clojure 1.8, the code below splits a string based on capital letters, but...\n\nin Java 7\n\n<pre>(clojure.string/split \"PrimaryEmailAddr\" #\"(?=[A-Z])\")\n=> [\"\" \"Primary\" \"Email\" \"Addr\"]</pre>\n\n⁠⁠⁠in Java 8\n\n<pre>(clojure.string/split \"PrimaryEmailAddr\" #\"(?=[A-Z])\")\n=> [\"Primary\" \"Email\" \"Addr\"]</pre>"], :arglists ["s re" "s re limit"], :doc "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/split"}, :clojure.core/defrecord {:added "1.2", :ns "clojure.core", :name "defrecord", :file "clojure/core_deftype.clj", :type "macro", :column 1, :see-alsos [:clojure.core/deftype :clojure.core/defstruct :clojure.core/defprotocol :clojure.core/instance? :clojure.core/record?], :line 312, :examples [";; from Stu's examples:\n\n(defrecord Person [fname lname address])\n-> user.Person\n\n(defrecord Address [street city state zip])\n-> user.Address\n\n(def stu (Person. \"Stu\" \"Halloway\"\n           (Address. \"200 N Mangum\"\n                      \"Durham\"\n                      \"NC\"\n                      27701)))\n-> #'user/stu\n\n(:lname stu)\n-> \"Halloway\"\n\n(-> stu :address :city)\n-> \"Durham\"\n\n(assoc stu :fname \"Stuart\")\n-> #:user.Person{:fname \"Stuart\", :lname \"Halloway\", :address #:user.Address{:street \"200 N Mangum\", :city \"Durham\", :state \"NC\", :zip 27701}}\n\n(update-in stu [:address :zip] inc)\n-> #:user.Person{:fname \"Stu\", :lname \"Halloway\", :address #:user.Address{:street \"200 N Mangum\", :city \"Durham\", :state \"NC\", :zip 27702}}" ";; This example shows how to implement a Java interface in defrecord.\n;; We'll implement FileNameMap (because it has a simple interface, \n;; not for its real purpose).  \n\n(import java.net.FileNameMap)\n-> java.net.FileNameMap\n\n;; Define a record named Thing with a single field a.  Implement\n;; FileNameMap interface and provide an implementation for the single\n;; method:  String getContentTypeFor(String fileName)\n(defrecord Thing [a]\n  FileNameMap\n    (getContentTypeFor [this fileName] (str a \"-\" fileName)))\n-> user.Thing\n\n;; construct an instance of the record\n(def thing (Thing. \"foo\"))\n-> #'user/thing\n\n;; check that the instance implements the interface\n(instance? FileNameMap thing)\n-> true\n\n;; get all the interfaces for the record type\n(map #(println %) (.getInterfaces Thing))\n-> java.net.FileNameMap\n-> clojure.lang.IObj\n-> clojure.lang.ILookup\n-> clojure.lang.IKeywordLookup\n-> clojure.lang.IPersistentMap\n-> java.util.Map\n-> java.io.Serializable\n\n;; actually call the method on the thing instance and pass \"bar\"\n(.getContentTypeFor thing \"bar\")\n-> \"foo-bar\"" ";; prepare a protocol\nuser=> (defprotocol Fun-Time (drinky-drinky [_]))\nFun-Time\n\n;; define a record and extend the previous protocol, implementing its function\nuser=> (defrecord Someone [nick-name preferred-drink] Fun-Time (drinky-drinky [_] (str nick-name \"(having \" preferred-drink \"): uuumm\")))\nuser.Someone\n;; NOTE how 'nick-name' and 'preferred-drink' are symbols that are not declared anywhere, they are 'provided' inside the function\n\n;; instantiate the protocol once and store it\nuser=> (def dude (->Someone \"belun\" \"daiquiri\"))\n#'user/dude\n\n;; use the function defined inside the protocol on the protocol instance\nuser=> (drinky-drinky dude)\n\"belun(having daiquiri): uuumm\"\n\n\n;; courtesy of Howard Lewis Ship - http://java.dzone.com/articles/changes-cascade-and-cautionary" "; If you define a defrecord in one namespace and want to use it\n; from another, there are 2 options:\n; 1. use the constructor (->Record) \n; (only available in clojure >= 1.4)\n;\n; 2. first require the namespace and then import\n; the record as a regular class.\n; The require+import order makes sense if you consider that first\n; the namespace has to be compiled--which generates a class for\n; the record--and then the generated class must be imported.\n; (Thanks to raek in #clojure for the explanations!)\n\n; Namespace \"my/data.clj\", where a defrecord is declared\n(ns my.data)\n\n(defrecord Employee [name surname])\n\n; Option 1: \n; Namescape \"my/queries-option-one.clj\", where a defrecord is used\n(ns my-queries-one\n  (:use [my.data]))\n\n(println\n  \"Employees named Albert:\"\n  (filter #(= \"Albert\" (.name %))\n    [(->Employee \"Albert\" \"Smith\")\n     (->Employee \"John\" \"Maynard\")\n     (->Employee \"Albert\" \"Cheng\")]))\n\n; Option 2:\n; Namescape \"my/queries-option-two.clj\", where a defrecord is used\n(ns my.queries-option-two\n  (:require my.data)\n  (:import [my.data Employee]))\n\n(println\n  \"Employees named Albert:\"\n  (filter #(= \"Albert\" (.name %))\n    [(Employee. \"Albert\" \"Smith\")\n     (Employee. \"John\" \"Maynard\")\n     (Employee. \"Albert\" \"Cheng\")]))" ";; The map->Recordclass form works only in Clojure 1.3 or higher\n\n(defrecord Foo [a b])\n\n(defrecord Bar [a b c])\n\n(defrecord Baz [a c])\n\n(def f (Foo. 10 20))\n(println f)\n-> #user.Foo{:a 10, :b 20}\n\n(def r (map->Bar (merge f {:c 30})))\n(println r)\n-> #user.Bar{:a 10, :b 20, :c 30}\n\n(def z (map->Baz (merge f {:c 30})))\n(println z)\n-> #user.Baz{:a 10, :c 30, :b 20}" ";; Construct a record from a vector.\n(def info [\"Carl\" 20])\n\n(defrecord Person [name age])\n\n(apply ->Person info)\n-> #user.Person{:name \"Carl\", :age 20}\n\n;; This is particularly useful for mapping parsed CSV files to records\n(map #(apply ->Person %) parsed-csv-file)" ";; Destructuring a record\n\n(defrecord Cat [age weight])\n\n(def Jasper (Cat. 2 10))\n\n(defn about-cat [{:keys [age weight]}] \n  (str age \" yrs old and \" weight \" lbs\"))\n\n(about-cat Jasper)\n->\"2 yrs old and 10 lbs\"" "(defrecord Person [name age])\n;;=> user.Person\n\n(def ertu (->Person \"Ertu\" 24))\n;;=> #'user/ertu\n\n(record? ertu)\n;;=> true\n\n(record? (assoc ertu :address \"Somewhere\"))\n;;=> true\n\n;;removing base fields converts record to regular map\n(record? (dissoc ertu :name))\n;;=> false" ";;iterate over the keys\n\n;;define the record\n(defrecord record-class [alplha beta])\n\n;;create a defrecord variable\n(def record (record-class. 1 2))\n\n;;iterate over the keys\n(for [key (keys record)]\n   (println (key record)))" ";;define Address record\n(defrecord Address [city state])\n\n;;define Person record\n(defrecord Person [firstname lastname ^Address address])\n\n;;buid the constructor\n(defn make-person ([fname lname city state]\n                   (->Person fname lname (->Address city state))))\n\n;;create a person\n(def person1 (make-person \"John\" \"Doe\" \"LA\" \"CA\"))\n\n;;retrieve values\n(:firstname person1)\n(:city (:address person1))" ";; Binary Search Tree (variation on implementation by Edd Mann)\n\n(defrecord Node [value left right])\n\n(defn insert [{:keys [value left right] :as node} item]\n  (cond\n    (nil? node) (Node. item nil nil)\n    (< item value) (Node. value (insert left item) right)\n    (> item value) (Node. value left (insert right item))\n    :else (update node :count (fnil inc 1)))) ; Use of :count, not in defrecord\n\n(defn coll->bst [coll] (reduce insert nil coll))\n\n(coll->bst [10 5 20 10 10])\n=> #example.bst.Node{:value 10,\n                     :left #example.bst.Node{:value 5, :left nil, :right nil},\n                     :right #example.bst.Node{:value 20, :left nil, :right nil},\n                     :count 3}\n"], :macro true, :notes ["http://tech.puredanger.com/2010/11/23/implementing-java-interfaces-with-clojure-records/"], :arglists ["name [& fields] & opts+specs"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the record class will cause the\n             namespace in which the record was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta,\n  __extmap, __hash and __hasheq are currently reserved and should not\n  be used when defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/defrecord"}, :clojure.set/index {:added "1.0", :ns "clojure.set", :name "index", :file "clojure/set.clj", :type "function", :column 1, :see-alsos [:clojure.core/hash-map :clojure.core/get], :line 95, :examples ["(use '[clojure.set :only (index)])\n\n;; Suppose you have a set of descriptions of the weights of animals:\n\nuser=> (def weights #{ {:name 'betsy :weight 1000}\n                       {:name 'jake :weight 756}\n                       {:name 'shyq :weight 1000} })\n\n\n;; You want the names of all the animals that weight 1000. One way to do \n;; that uses `index`. First, you can group the set elements (the maps) so\n;; that those with the same weights are in the same group.\n\nuser=> (def by-weight (index weights [:weight]))\n#'user/by-weight\n\n;; index returns a map.  The keys are maps themselves, where {:weight 756} and {:weight 1000} are taken from the maps in the weights set.  The values in the map returned by index are sets that contain map entries from the above weights set.\n\nuser=> by-weight\n{{:weight 756} #{{:name jake, :weight 756}}, \n {:weight 1000} #{{:name shyq, :weight 1000} \n                  {:name betsy, :weight 1000}}}\n\n\n;; To better visualize the by-weight map that is returned by index, you can query it using get, using {:weight 756} as the key.  This will return all the maps (animals) that contain a weight of 756.  In this case, there is only one result, which is a set containing a single map. \n\nuser=> (get by-weight {:weight 756})\n#{{:name jake, :weight 756}}\n\n\n;; To see that there are two animals with a weight of 1000, you can query by-weight with the key {:weight 1000}.  This returns a set containing two maps.\n\nuser=> (get by-weight {:weight 1000})\n#{{:name shyq, :weight 1000} {:name betsy :weight 1000}}\n \n\n;; You can verify by using count\n\nuser=> (count (get by-weight {:weight 1000}))\n2\n\n\n;; To get the names of those two animals we can map a name-extracting function\n;; over the set of two maps. Since a keyword in a map is also a function that\n;; returns its corresponding value, we can just use `:name` as our function:\n\nuser=> (map :name (get by-weight {:weight 1000}))\n(shyq betsy)\n" ";; AN EXAMPLE SHOWING HOW TO DO A JOIN WITH INDEX\n(require '[clojure.set :as s]\n         '[clojure.core.reducers :as r])\n                 \n(def ds1 [{:id 1 :name \"name1\"}\n          {:id 2 :name \"name2\"}\n          {:id 3 :name \"name3\"}])\n          \n(def ds2 [{:id 2 :address \"addr2\"}\n          {:id 3 :address \"addr3\"}\n          {:id 4 :address \"addr4\"}])\n\n(into () (r/map #(r/reduce merge %) (vals (s/index (s/union ds2 ds1) [:id]))))"], :notes nil, :arglists ["xrel ks"], :doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :library-url "https://github.com/clojure/clojure", :href "/clojure.set/index"}, :clojure.test/assert-expr {:ns "clojure.test", :name "assert-expr", :file "clojure/test.clj", :type "var", :column 1, :see-alsos nil, :line 475, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.test/assert-expr"}, :clojure.edn/read-string {:added "1.5", :ns "clojure.edn", :name "read-string", :file "clojure/edn.clj", :type "function", :column 1, :see-alsos [:clojure.edn/read :clojure.core/prn-str :clojure.core/read-string :clojure.main/load-script], :line 37, :examples [";; The following code is a subset of that found at\n;; http://www.compoundtheory.com/clojure-edn-walkthrough\n;; It illustrates the fact that the readers \n;; 'read' and 'read-string' have symmetric writers\n;; 'prn' and 'prn-str'.\n\n(ns edn-example.core\n    (require [clojure.edn :as edn]))\n \n(def sample-map {:foo \"bar\" :bar \"foo\"})\n \n;; Here you can see that the 'prn-str' is the writer...\n(defn convert-sample-map-to-edn\n    \"Converting a Map to EDN\"\n    []\n    ;; yep, converting a map to EDN is that simple\"\n    (prn-str sample-map))\n \n(println \"Let's convert a map to EDN: \" (convert-sample-map-to-edn))\n;=> Let's convert a map to EDN:  {:foo \"bar\", :bar \"foo\"}\n \n;; ...and the reader is 'read-string'\n(println \"Now let's covert the map back: \" (edn/read-string (convert-sample-map-to-edn)))\n;=> Now let's covert the map back:  {:foo bar, :bar foo}" ";; The following demonstrates the use case of edn built-in tagged elements\nuser=> (class (clojure.edn/read-string \"#inst \\\"1985-04-12T23:20:50.52Z\\\"\"))\njava.util.Date\n\n" ";; if you want to specify custom processing of some field add tag and function which process it\n;; let's assume we have edn with some relative paths and want to make tham absolute\n\n(def config \"{:k8s-path #path \\\"./infra/k8s\\\"}\")\n\n(defn absolute [path])\n\n(edn/read-string {:readers {'path absolute}} config)\n\n{:k8s-path \"/users/some_user/project/k8s-path\"}"], :notes nil, :arglists ["s" "opts s"], :doc "Reads one object from the string s. Returns nil when s is nil or empty.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map as per clojure.edn/read", :library-url "https://github.com/clojure/clojure", :href "/clojure.edn/read-string"}, :clojure.core.logic/subst? {:ns "clojure.core.logic", :name "subst?", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 540, :examples nil, :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/subst_q"}, :clojure.core/*default-data-reader-fn* {:added "1.5", :ns "clojure.core", :name "*default-data-reader-fn*", :file "clojure/core.clj", :type "var", :column 1, :see-alsos [:clojure.core/*data-readers* :clojure.core/tagged-literal], :dynamic true, :line 7707, :examples [";; Clojure includes a generic tagged-literal type, able to read any\n;; tagged literal. This makes a great default-data-reader-fn.\n\n;; Clojure can't read tagged literals without a registered reader:\nuser=> #object[clojure.lang.Namespace 0x23bff419 \"user\"]\nRuntimeException No reader function for tag object  clojure.lang.LispReader$CtorReader.readTagged (LispReader.java:1430)\n\n;; Set tagged-literal to be the default tagged value reader:\nuser=> (set! *default-data-reader-fn* tagged-literal)\n\n;; Try again\nuser=> #object[clojure.lang.Namespace 0x23bff419 \"user\"]\n#object [clojure.lang.Namespace 599782425 \"user\"]\n\n;; Now it works, and reads to a TaggedLiteral object, which\n;; supports ILookup on :tag and :form keys\nuser=> [(:tag *1) (:form *1)]\n[object [clojure.lang.Namespace 599782425 \"user\"]]\n"], :notes nil, :arglists [], :doc "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*default-data-reader-fn*"}, :clojure.core/hash-combine {:ns "clojure.core", :name "hash-combine", :file "clojure/core_deftype.clj", :type "function", :column 1, :see-alsos nil, :line 126, :examples [";; Calculates the hashes for x and y and produces a new hash that represents\n;; the combination of the two.\n\nuser=> (hash-combine 100 \"a\")\n-1640524969\n"], :notes nil, :arglists ["x y"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/hash-combine"}, :clojure.core.logic/pair {:ns "clojure.core.logic", :name "pair", :file "clojure/core/logic.clj", :type "var", :column 1, :see-alsos nil, :line 214, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/pair"}, :clojure.core/->> {:added "1.1", :ns "clojure.core", :name "->>", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/-> :clojure.core/some->> :clojure.core/comp :clojure.core/cond->> :clojure.core/cond-> :clojure.core/as->], :line 1685, :examples [";; An example of using the \"thread-last\" macro to get\n;; the sum of the first 10 even squares.\nuser=> (->> (range)\n            (map #(* % %))\n            (filter even?)\n            (take 10)\n            (reduce +))\n1140\n\n;; This expands to:\nuser=> (reduce +\n               (take 10\n                     (filter even?\n                             (map #(* % %)\n                                  (range)))))\n1140\n" "user=> (def c 5)\nuser=> (->> c (+ 3) (/ 2) (- 1))                          \n3/4\n\n;; and if you are curious why\nuser=> (use 'clojure.walk)\nuser=> (macroexpand-all '(->> c (+ 3) (/ 2) (- 1)))\n(- 1 (/ 2 (+ 3 c)))\n\n" ";; let's compare thread first (->) and thread last ( ->> )\nuser=> (macroexpand '(-> 0 (+ 1) (+ 2) (+ 3)))\n(+ (+ (+ 0 1) 2) 3)\nuser=> (macroexpand '(->> 0 (+ 1) (+ 2) (+ 3)))\n(+ 3 (+ 2 (+ 1 0)))" ";; ->> and -> by simple string concatenation\n\n;; Effectively (str \" jmd\" \"hello\")\nuser=> (->> \"hello\" (str \" jmd\"))\n\" jmdhello\"\n\n;; Effectively (str \"hello\" \" jmd\")\nuser=> (-> \"hello\" (str \" jmd\"))\n=> \"hello jmd\"" ";; It is OK to omit the parentheses if a function takes only one argument\n(->> [1 2 [3 4] 5]\n     flatten  ; no parenthesis\n     (map inc))\n=> (2 3 4 5 6)\n     " ";; It's OK to include anonymous function in the thread, but don't forget\n;; to put in an extra pair of parentheses to call the function\n(->> [1 2 3 4 5]\n     ((fn [coll] (map inc coll))) ; double parentheses\n     (apply +))                          \n=> 20\n\n;; the short hand form of the anonymous function works the same\n(->> [1 2 3 4 5]\n     (#(map inc %)) ; double parentheses\n     (apply +))  " ";; For large threads you can use commas (interpreted as whitespaces) \n;; to visualize where the items are going to be inserted.\n\n;; Takes the first 5 even numbers\nuser=> (->> (range)\n            (filter even?)\n            (take 5))\n=> (0 2 4 6 8)\n\n;; with two commas (you can use one if you prefer)\nuser=> (->> (range)\n            (filter even? ,,)\n            (take 5 ,,))\n=> (0 2 4 6 8)\n\n;; For instance:\n;; (filter even? ,,)\n;; means\n;; (filter even? (range))" ";;practical example\n\n(def entries [{:month 1 :val 12}\n              {:month 2 :val 3}\n              {:month 3 :val 32}\n              {:month 4 :val 18}\n              {:month 5 :val 32}\n              {:month 6 :val 62}\n              {:month 7 :val 12}\n              {:month 8 :val 142}\n              {:month 9 :val 52}\n              {:month 10 :val 18}\n              {:month 11 :val 23}\n              {:month 12 :val 56}])\n(defn get-result\n  [coll m]\n  (->> coll\n       (take-while\n        #(<= (:month %) m))))\n\n(defn get-total\n  [coll m]\n  (->>\n   (get-result coll m)\n   (map #(:val %))\n   (reduce +)))\n\n(get-total entries 3)\n" "(defn new-map\n  [coll]\n  (->>\n   coll\n   (map\n    (fn [[k v]]\n      [k (inc v)]))\n   (into {})))\n\n(new-map {:a 1 :b 2 :c 3})\n"], :macro true, :notes ["I'm getting: `Exception in thread \"main\" java.lang.Exception: Unable to resolve symbol: -&gt;&gt; in this context (11.clj:25)`\r\n\r\nIt's also extremely hard to Google this method. It'd be nice if there was a non-symbol name for this that one could search for.\r\n\r\n**Update**\r\n\r\nThe name of this operator is called a thrush." "See also <a href=\"http://clojuredocs.org/v/1872\">-&gt;</a> which is similar but threads the first expr as the <b>second</b> argument of the forms." "My error was due to using an old version of Clojure. I was using 1.0.0." "There is something I don't get : in the case \"form\" is a seq, why should we write\r\n... (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\r\n\r\nand not \r\n... (with-meta `(~@form  ~x) (meta form))\r\n\r\nas items order in \"form\" is not changed ?\r\n\r\n" "\"See also -> which is similar but threads the first expr as the second argument of the forms.\"\n\nThis is incorrect, it is not the second ARGUMENT, but the second ITEM."], :arglists ["x & forms"], :doc "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/->>"}, :clojure.core/send {:added "1.0", :ns "clojure.core", :name "send", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/shutdown-agents :clojure.core/send-off :clojure.core/agent], :line 2103, :examples ["user=> (def my-agent (agent 100))\n#'user/my-agent\nuser=> @my-agent\n100\n\n;; Note the following happens asynchronously in a thread\n;; pool\nuser=> (send my-agent + 100)\n#<Agent@5afc0f5: 200>\n\n;; Assuming the addition has completed the value will\n;; now be updated when we look at it.\nuser=> @my-agent\n200" ";; update agent value\nuser => (def foo (agent 100)) \n#'user/my-agent\nuser => @foo\n100\n\n;; function get \"old value\"\nuser => (send foo (fn [old-foo] \n                      (println  old-foo \"foo will change\")\n                      (+ old-foo 100)))\n100 foo will change\n#agent[{:status :ready, :val 200} 0x000000]\n\nuser => @foo\n200"], :notes ["See \"send-off\" for the differences between \"send\" and \"send-off\"."], :arglists ["a f & args"], :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/send"}, :clojure.core/chunk-buffer {:ns "clojure.core", :name "chunk-buffer", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-append :clojure.core/chunk], :line 684, :examples ["(chunk-buffer 32)\n;; => #<ChunkBuffer clojure.lang.ChunkBuffer@749392c7>\n\n;; Coerce to an ArrayChunk via clojure.core/chunk, cons\n;; a chunked sequence onto it resulting in a\n;; clojure.lang.PersistentVector$ChunkedSeq, grab the first\n;; chunk to get an ArrayChunk, and pull the first element out\n;; using .nth/nth.\n(-> (chunk-buffer 32)\n    (chunk)\n    (chunk-cons (seq [1 2 3]))\n    (chunk-first)\n    (.nth 0))\n;; => 1"], :notes nil, :tag "clojure.lang.ChunkBuffer", :arglists ["capacity"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-buffer"}, :clojure.core/seqable? {:added "1.9", :ns "clojure.core", :name "seqable?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/seq :clojure.core/seq?], :line 6145, :examples [";;;; nil is seqable\n\n(seqable? nil)\n;;=> true\n\n;;;; Anything that implements CharSequence is seqable\n\n(seqable? \"\")\n;;=> true\n(seqable? (java.lang.StringBuilder.))\n;;=> true\n(seqable? (java.lang.StringBuffer.))\n;;=> true\n\n;;;; Anything that implements Seqable is seqable\n\n(seqable? [])\n;;=> true\n(seqable? {})\n;;=> true\n(seqable? #{})\n;;=> true\n(seqable? '())\n;;=> true\n(seqable? (lazy-seq))\n;;=> true\n\n;;;; Anything that implements Iterable is seqable\n\n(seqable? (java.util.ArrayList.))\n;;=> true\n(seqable? (java.util.HashMap.))\n;;=> true\n(seqable? (java.util.HashSet.))\n;;=> true\n\n;;;; Arrays are seqable\n\n(seqable? (int-array 5 1))\n;;=> true\n(seqable? (double-array 5 1.0))\n;;=> true\n(seqable? (char-array 5 \\c))\n;;=> true\n\n;;;; Some stuff that isn't seqable\n\n(seqable? true)\n;;=> false\n(seqable? \\c)\n;;=> false\n(seqable? 1)\n;;=> false\n(seqable? 1.0)\n;;=> false\n(seqable? (fn f []))\n;;=> false\n"], :notes nil, :arglists ["x"], :doc "Return true if the seq function is supported for x", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/seqable_q"}, :clojure.core/replace {:added "1.0", :ns "clojure.core", :name "replace", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.walk/prewalk-replace :clojure.walk/postwalk-replace :clojure.core/map :clojure.string/replace], :line 4998, :examples ["user=> (replace [:zeroth :first :second :third :fourth] [0 2 4 0])\n[:zeroth :second :fourth :zeroth]\n\nuser=> (replace [10 9 8 7 6] [0 2 4])\n[10 8 6]" "user=> (replace {2 :two, 4 :four} [4 2 3 4 5 6 2])\n[:four :two 3 :four 5 6 :two]\n\nuser=> (replace '{0 ZERO, 1 ONE, 2 TWO} '(This is the code 0 1 2 0))\n(This is the code ZERO ONE TWO ZERO)" "; Behaves somewhat similar to map, but notice the differences\nuser=> (map [:zeroth :first :second :third :fourth] [0 2 4 0])\n(:zeroth :second :fourth :zeroth)\n\n; 1. replace returns a vector, while map returns a seq\n; 2. replace keeps unmatched values, while map replace with nil\nuser=> (map {} [0])\n(nil)\nuser=> (map [] [0])\nIndexOutOfBoundsException   clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107)\n" "user=> (replace {2 :a, 4 :b} [1 2 3 4])\n;;=> [1 :a 3 :b]" ";; On hash-maps:\n\n(def user {:name \"jack\" :city \"London\" :id 123})\n(defn entry [k v] (clojure.lang.MapEntry/create k v))\n(def sub {(entry :city \"London\") [:postcode \"WD12\"]})\n\n(into {} (replace sub user))\n;; {:name \"jack\", :postcode \"WD12\", :id 123}"], :notes ["The behaviour for vectors was a little strange for me. I'd say replace \"selects\" from \"smap\" the indexes which are in \"coll\""], :arglists ["smap" "smap coll"], :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/replace"}, :clojure.core/int {:added "1.0", :ns "clojure.core", :name "int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/char :clojure.core/long :clojure.core/integer? :clojure.core/ints :clojure.core/int-array :clojure.core/short], :line 874, :examples ["user=> (int 1)\r\n1\r\n\r\nuser=> (int 1M)\r\n1\r\n\r\nuser=> (int 1.2)\r\n1\r\n\r\nuser=> (int \\1)\r\n49\r\n\r\nuser=> (int \\a)\r\n97\r\n\r\nuser=> (int \"1\")\r\njava.lang.ClassCastException: ...\r\n"], :notes ["To convert a string containing a number to an integer, use Java's Integer/parseInt, e.g. `(Integer/parseInt \"-10\")`."], :arglists ["x"], :doc "Coerce to int", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/int"}, :clojure.main/demunge {:added "1.3", :ns "clojure.main", :name "demunge", :file "clojure/main.clj", :type "function", :column 1, :see-alsos nil, :line 31, :examples ["(use 'clojure.main)\n\n(demunge \"clojure.core$println\")\n=>\"clojure.core/println\""], :notes nil, :arglists ["fn-name"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/demunge"}, :clojure.core/proxy-call-with-super {:ns "clojure.core", :name "proxy-call-with-super", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos nil, :line 384, :examples nil, :notes nil, :arglists ["call this meth"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/proxy-call-with-super"}, :clojure.core/second {:added "1.0", :ns "clojure.core", :name "second", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/first :clojure.core/nth :clojure.core/fnext :clojure.core/next], :line 91, :examples ["user=> (second '(:alpha :bravo :charlie))\n:bravo\n\nuser=> (second [1 2 3])\n2\n\nuser=> (second {:a 1 :b 2 :c 3})\n[:b 2]\n\nuser=> (second #{1 2 3})\n2\n\nuser=> (second [1 2])\n2\n\nuser=> (second [1])\nnil\n\nuser=> (second [])\nnil\n\nuser=> (second nil)\nnil"], :notes ["Synonym of `fnext`."], :arglists ["x"], :doc "Same as (first (next x))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/second"}, :clojure.core/coll? {:added "1.0", :ns "clojure.core", :name "coll?", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/seq? :clojure.core/list? :clojure.core/sequential? :clojure.core/map? :clojure.core/vector? :clojure.core/set?], :line 6133, :examples [";; a map is a collection\n(coll? {})\n;;=> true\n\n;; a set is a collection\n(coll? #{})\n;;=> true\n\n;; a vector is a collection\n(coll? [])\n;;=> true\n\n;; a list is a collection \n(coll? '())\n;;=> true\n\n;; a number (long) is not a collection\n(coll? 4)\n;;=> false\n\n;; a string is not a collection\n(coll? \"fred\")\n;;=> false\n\n;; ...but a string sequence is a collection\n(coll? (seq \"fred\"))\n;;=> true\n\n;; a boolean is not a collection\n(coll? true)\n;;=> false\n\n;; nil is not a collection\n(coll? nil)\n;;=> false\n" "user=> (coll? {:a 10 :b 20}) ; map is a collection of map-entries\ntrue" ";; contrast to example code for sequential?\n;;\nuser> (coll? '(1 2 3))\ntrue\nuser> (coll? [1 2 3])\ntrue\nuser> (coll? (range 1 5))\ntrue\nuser> (coll? 1)\nfalse\nuser> (coll? {:a 2 :b 1})   \ntrue\nuser> (coll? {:a 2 :b 1})  ; in contrast to sequential?, coll? returns true for\n                           ; a hash map\ntrue\nuser> (sequential? {:a 2 :b 1})\nfalse"], :notes nil, :arglists ["x"], :doc "Returns true if x implements IPersistentCollection", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/coll_q"}, :clojure.core/set-error-handler! {:added "1.2", :ns "clojure.core", :name "set-error-handler!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/agent :clojure.core/agent-error :clojure.core/restart-agent], :line 2186, :examples ["(def bond (agent 7))\n\n(defn err-handler-fn [ag ex]\n  (println \"evil error occured: \" ex \" and we still have value \" @ag))\n\n(set-error-handler! bond err-handler-fn)\n\n;;division by zero:\n\n(send bond (fn [x] (/ x 0)))\n=>evil error occured:  #<ArithmeticException java.lang.ArithmeticException: \n=>Divide by zero>  and we still have value  7\n\n(send bond inc)\n=>FAILURE ;;Agent is failed, needs restart, but keeps the last OK value\n\n@bond\n=>7\n\n(restart-agent bond 7) ;; or replace 7 with @ag\n\n(send bond inc)\n=>#<Agent@88d00c6: 7> ;;because of async update\n\n@bond\n=>8\n" "(deftest t-rstart\n  (future (println \"running in a thread...\"))\n  (let [agt (agent 0)\n\n        ; This doesn't work\n        h01 (fn [a e]\n              (println :10 \"agent error found:\" )\n              (println :11 \"restarting agent...\")\n              (restart-agent a 100)\n              (Thread/sleep 100)\n              (println :12 \"agent restarted, state=\" @a))\n\n        ; This works. Need to call restart-agent in a separate thread\n        h02 (fn [a e]\n              (println :20 \"agent error found:\" )\n              (future\n                (println :21 \"restarting agent...\")\n                (restart-agent a 200)\n                (println :22 \"agent restarted, state=\" @a))) ;=> 200\n  ]\n    (set-error-handler! agt h02)\n    (send agt inc)\n    (Thread/sleep 100) (println :01 @agt)  ;=> 1\n    (Thread/sleep 100) (send agt #(/ % 0))\n    (Thread/sleep 100) (println :02 @agt)  ;=> 200\n    (Thread/sleep 100) (send agt inc)\n    (Thread/sleep 100) (println :03 @agt)  ;=> 201\n))\n\n; Output\n;   running in a thread...\n;   :01 1\n;   :20 agent error found:\n;   :21 restarting agent...\n;   :22 agent restarted, state= 200\n;   :02 200\n;   :03 201"], :notes nil, :arglists ["a handler-fn"], :doc "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/set-error-handler!"}, :clojure.string/blank? {:added "1.2", :ns "clojure.string", :name "blank?", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/trim :clojure.string/triml :clojure.string/trimr], :line 287, :examples ["user> (clojure.string/blank? nil)\ntrue\n\nuser> (clojure.string/blank? \"\")\ntrue\n\nuser> (clojure.string/blank? \"   \")\ntrue\n\nuser> (clojure.string/blank? \" a \")\nfalse\n\nuser> (clojure.string/blank? false)\ntrue\n\nuser> (clojure.string/blank? \"\\n\")\ntrue" ";; A way to remove blanks from a string.\n(def astr \"This contains  blanks \\n \\t \\r and other whitespace\")\n(->> astr \n     (#(clojure.string/split % #\"\\s\")) \n     (remove clojure.string/blank?) \n     (clojure.string/join \" \"))\n\n;;=> \"This contains blanks and other whitespace\"\n\n;; Of course the task can be better performed other ways.\n;; The goal here is just to show how blank? works.\n(clojure.string/replace (clojure.string/trim astr) #\"\\s{2,}\" \" \")" ";; The list of the 25 whitespace chars in UTF-16. Using the \\uNNNN hex code\n;; when another representation is not available or not printable.\n;; \\u0020 is the common white space, AKA \" \" or '\\space' as a single char.\n\n(require '[clojure.string :as s])\n\n(s/blank? \"\\t \\n \\u000b \\f \\r \\u001c \\u001d \\u001e \\u001f\") ;; true\n(s/blank? \"\\u0020 \\u1680 \\u2000 \\u2001 \\u2002 \\u2003\") ;; true\n(s/blank? \"\\u2004 \\u2005 \\u2006 \\u2008 \\u2009\") ;; true\n(s/blank? \"\\u200a \\u2028 \\u2029 \\u205f \\u3000\") ;; true"], :notes nil, :arglists ["s"], :doc "True if s is nil, empty, or contains only whitespace.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/blank_q"}, :clojure.core.async/mult {:ns "clojure.core.async", :name "mult", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/tap :clojure.core.async/untap], :line 669, :examples ["user=> (def sz 20)\n#'user/sz\n\nuser=> (def c (chan sz))\n#'user/c\n\nuser=> (def mult-c (mult c))\n#'user/mult-c\n\nuser=> (def cx (chan sz))\n#'user/cx\n\nuser=> (def cy (chan sz))\n#'user/cy\n\nuser=> (def cz (chan sz))\n#'user/cz\n\nuser=> (tap mult-c cx)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@63942268>\n\nuser=> (tap mult-c cy)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@1f025346>\n\nuser=> (tap mult-c cz)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@29d4cd91>\n\nuser=> (put! c \"sent to all\")\ntrue\n\nuser=> (<!! cx)\n\"sent to all\"\n\nuser=> (<!! cy)\n\"sent to all\"\n\nuser=> (<!! cz)\n\"sent to all\"\n\n" ";; Dont read from the source of mult, or you'll get read race contention\n\nuser> (def a (chan))\nuser> (def m (mult a))\nuser> (def b (chan))\nuser> (tap m b)\nuser> (go-loop [] (when-let [v (<! b)] (do (println \"b got\" v) (recur))))\n;; next line is pain self inflicted \nuser> (go-loop [] (when-let [v (<! a)] (do (println \"a(source) got\" v) (recur))))\nuser> (put! a \"Hello \")\nb got Hello \nuser> (put! a \" World\")\na(source) got  World\n"], :notes nil, :arglists ["ch"], :doc "Creates and returns a mult(iple) of the supplied channel. Channels\n  containing copies of the channel can be created with 'tap', and\n  detached with 'untap'.\n\n  Each item is distributed to all taps in parallel and synchronously,\n  i.e. each tap must accept before the next item is distributed. Use\n  buffering/windowing to prevent slow taps from holding up the mult.\n\n  Items received when there are no taps get dropped.\n\n  If a tap puts to a closed channel, it will be removed from the mult.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/mult"}, :clojure.core/force {:added "1.0", :ns "clojure.core", :name "force", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/delay], :line 753, :examples [";; an example for delay using an event-queue\nuser> (import  [java.util.concurrent PriorityBlockingQueue])\njava.util.concurrent.PriorityBlockingQueue\nuser> (defn create-event-element [delayed-event tme]\n  (struct event delayed-event tme))\n#'user/create-event-element\nuser> (defn comp-queue [e1 e2]\n  (if (< (:time e1) (:time e2))\n    true false))\n#'user/comp-queue\nuser> (defn update [n]\n\t(reset! c n))\n#'user/update\nuser> (defn create-event-queue [comp-queue size]\n  (new PriorityBlockingQueue size (comp comp-queue)))\n#'user/create-event-queue\nuser> (def queue (create-event-queue comp-queue 10))\n#'user/queue\nuser> (def elements (take 10 (repeatedly \n\t\t\t      (fn[](create-event-element \n\t\t\t\t    (delay (update (rand-int 20)))\n\t\t\t\t    (rand))))))\n#'user/elements\nuser> (def c (atom 0))\n#'user/c\nuser> @c\n0\nuser> (doseq [e elements]\n\t     (.add queue e))\nnil\nuser> (dotimes [_ 10]\n\t       (let [e (.poll queue)]\n\t\t    (println \"c=\" @c)\n\t\t    (print \"time=\" (:time e) \":\")\n\t\t    (println (force (:object e)))))\nc= 0\ntime= 0.07805244345581108 :19\nc= 19\ntime= 0.24297414417455565 :6\nc= 6\ntime= 0.24427040715816817 :0\nc= 0\ntime= 0.24938478920862384 :17\nc= 17\ntime= 0.33612588239752494 :6\nc= 6\ntime= 0.5148481493716295 :5\nc= 5\ntime= 0.5823642080700586 :7\nc= 7\ntime= 0.7674970100941858 :4\nc= 4\ntime= 0.9206272921555505 :14\nc= 14\ntime= 0.9958255204018474 :4\nnil\nuser> @c\n4\nuser> (def elements (take 10 (repeatedly \n\t\t\t      (fn[](create-event-element \n\t\t\t\t    (delay (update (rand-int 20)))\n\t\t\t\t    (rand))))))\n#'user/elements\n;; if we check 'element', delay objects will be evaluated. The below is\n;; this example. Please compare the above with the below.\nuser> elements  \n({:object #<Delay@37a63e06: 16>, :time 0.48566816399656854} {:object #<Delay@3321875: 19>, :time 0.9374202154797486} {:object #<Delay@4de3aaf6: 17>, :time 0.3271116626875401} {:object #<Delay@1ded246d: 15>, :time 0.8843712542267577} {:object #<Delay@3bf27f74: 10>, :time 0.86383171974926} {:object #<Delay@2d8db76b: 14>, :time 0.2120086056700251} {:object #<Delay@3304e92a: 5>, :time 0.9406336968276247} {:object #<Delay@767de91: 0>, :time 0.2150071400135528} {:object #<Delay@34450563: 7>, :time 0.7520042839572664} {:object #<Delay@1f64c164: 1>, :time 0.6264819751284463})\n;; The object of the last elements is #<Delay@1f64c164: 1>. Therefore,\n;; This indicates the atom 'c' has already updated.\nuser> @c  \n1 \nuser> (doseq [e elements]\n\t     (.add queue e))\nnil\n;; 'atom c' has never been updated because it has already\n;; been evaluated.\nuser> (dotimes [_ 10]\n\t       (let [e (.poll queue)]\n\t\t    (println \"c=\" @c)\n\t\t    (print \"time=\" (:time e) \":\")\n\t\t    (println (force (:object e)))))\nc= 1\ntime= 0.2120086056700251 :14\nc= 1\ntime= 0.2150071400135528 :0\nc= 1\ntime= 0.3271116626875401 :17\nc= 1\ntime= 0.48566816399656854 :16\nc= 1\ntime= 0.6264819751284463 :1\nc= 1\ntime= 0.7520042839572664 :7\nc= 1\ntime= 0.86383171974926 :10\nc= 1\ntime= 0.8843712542267577 :15\nc= 1\ntime= 0.9374202154797486 :19\nc= 1\ntime= 0.9406336968276247 :5\nnil\nuser> " ";; the tarai benchmark comparing non-lazy version with lazy-version\n(defn tarai [x y z]\n  (if (<= (x) (y))\n      (y)\n      (recur (fn [] (tarai (fn [] (- (x) 1)) y z))\n             (fn [] (tarai (fn [] (- (y) 1)) z x))\n             (fn [] (tarai (fn [] (- (z) 1)) x y)))))\n\n(defn tarai-d [x y z]\n  (if (<= (force x) (force y))\n      (force y)\n      (recur (delay (tarai-d (- (force x) 1) y z))\n               (delay (tarai-d (- (force y) 1) z x))\n               (delay (tarai-d (- (force z) 1) x y)))))\n\nuser> (dotimes [_ 10] (time (tarai (fn [] 192) (fn [] 96) (fn [] 0))))\n\"Elapsed time: 139.660729 msecs\"\n\"Elapsed time: 132.493587 msecs\"\n\"Elapsed time: 135.867772 msecs\"\n\"Elapsed time: 132.924774 msecs\"\n\"Elapsed time: 137.491084 msecs\"\n\"Elapsed time: 134.72752 msecs\"\n\"Elapsed time: 132.969652 msecs\"\n\"Elapsed time: 135.795754 msecs\"\n\"Elapsed time: 134.261724 msecs\"\n\"Elapsed time: 138.059968 msecs\"\n\nnil\nuser> (dotimes [_ 10 ]  (time (tarai-d 192 96 0)))\n\"Elapsed time: 3.181795 msecs\"\n\"Elapsed time: 2.960096 msecs\"\n\"Elapsed time: 3.000855 msecs\"\n\"Elapsed time: 3.140536 msecs\"\n\"Elapsed time: 3.658821 msecs\"\n\"Elapsed time: 3.319659 msecs\"\n\"Elapsed time: 2.9182 msecs\"\n\"Elapsed time: 3.125442 msecs\"\n\"Elapsed time: 2.944342 msecs\"\n\"Elapsed time: 2.951613 msecs\"\nnil"], :notes nil, :arglists ["x"], :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/force"}, :clojure.java.io/reader {:added "1.2", :ns "clojure.java.io", :name "reader", :file "clojure/java/io.clj", :type "function", :column 1, :see-alsos [:clojure.java.io/writer :clojure.java.io/input-stream :clojure.java.io/IOFactory :clojure.core/slurp], :line 86, :examples ["(with-open [rdr (clojure.java.io/reader \"/tmp/foo.txt\")]\n    (reduce conj [] (line-seq rdr)))" "(with-open [rdr (clojure.java.io/reader \"http://www.google.com\")]\n   (printf \"%s\\n\" (clojure.string/join \"\\n\" (line-seq rdr))))\n;; <!doctype html><html itemscope=\"\" itemtype=\"http://schema.org/WebPage\" ...\n;;=> nil"], :notes ["Java documentation links for the listed argument types that have â€œdefault implementationsâ€�:\r\n\r\n* [`Reader`](http://docs.oracle.com/javase/7/docs/api/java/io/Reader.html)\r\n* [`BufferedReader`](http://docs.oracle.com/javase/7/docs/api/java/io/BufferedReader.html)\r\n* [`InputStream`](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html)\r\n* [`File`](http://docs.oracle.com/javase/7/docs/api/java/io/File.html)\r\n* [`URI`](http://docs.oracle.com/javase/7/docs/api/java/net/URI.html)\r\n* [`URL`](http://docs.oracle.com/javase/7/docs/api/java/net/URL.html)\r\n* [`Socket`](http://docs.oracle.com/javase/7/docs/api/java/net/Socket.html)\r\n* byte arrays (`byte[]`)\r\n* character arrays (`char[]`)\r\n* [`String`](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html) (resolved as a URI or a local file name)" "`opts` depend on the type of the reader but [common ones include](https://github.com/clojure/clojure/blob/cc69d19bd471c48d441071fff43e768ffa7eb8e5/src/clj/clojure/java/io.clj) `:encoding` and, where applicable, `:buffer-size`."], :tag "java.io.Reader", :arglists ["x & opts"], :doc "Attempts to coerce its argument into an open java.io.Reader.\n   Default implementations always return a java.io.BufferedReader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte arrays, character arrays,\n   and String.\n\n   If argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Reader is properly\n   closed.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/reader"}, :clojure.core.logic/->ConstraintStore {:ns "clojure.core.logic", :name "->ConstraintStore", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 109, :examples nil, :notes nil, :arglists ["km cm cid running"], :doc "Positional factory function for class clojure.core.logic.ConstraintStore.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/->ConstraintStore"}, :clojure.core.logic.fd/bounds {:ns "clojure.core.logic.fd", :name "bounds", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 39, :examples nil, :notes nil, :arglists ["i"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/bounds"}, :clojure.core/uri? {:added "1.9", :ns "clojure.core", :name "uri?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 7765, :examples ["(uri? (new java.net.URI \"http://clojuredocs.org/\"))\n;;=> true\n\n(uri? (new java.net.URL \"http://clojuredocs.org/\"))\n;;=> false\n(uri? \"http://clojuredocs.org/\")\n;;=> false\n"], :notes nil, :arglists ["x"], :doc "Return true if x is a java.net.URI", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/uri_q"}, :clojure.walk/prewalk {:added "1.1", :ns "clojure.walk", :name "prewalk", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/postwalk :clojure.walk/prewalk-demo :clojure.walk/prewalk-replace], :line 60, :examples [";; From http://stackoverflow.com/questions/8089074/idiomatically-iterating-over-a-2-or-higher-dimensional-sequence-in-clojure/8091544#8091544\n\n(def matrix [[1 2 3]\n             [4 5 6]\n             [7 8 9]])\n(use 'clojure.walk :only [prewalk])\n\n(prewalk #(if (number? %) (inc %) %) matrix)\n=> [[2 3 4] [5 6 7] [8 9 10]]" ";; an example to show the differences between postwalk and prewalk\n;; (see the counterpart at postwalk)\n\n(let [counter     (atom 0)\n      print-touch (fn [x]\n                    (print (swap! counter inc) \":\" (pr-str x) \"→ \"))\n      change-type (fn [x]\n                    (let [new-x (if (vector? x)\n                                  (apply list x)\n                                  (str x))]\n                      (prn new-x)\n                      new-x))]\n  (clojure.walk/prewalk (fn [x]\n                          (print-touch x)\n                          (change-type x))\n                         [:a [:ba :bb] :c]))\n\n;; printed output:\n\n1 : [:a [:ba :bb] :c] → (:a [:ba :bb] :c)\n2 : :a → \":a\"\n3 : [:ba :bb] → (:ba :bb)\n4 : :ba → \":ba\"\n5 : :bb → \":bb\"\n6 : :c → \":c\"\n\n;; returned value:\n\n=> (\":a\" (\":ba\" \":bb\") \":c\")"], :notes nil, :arglists ["f form"], :doc "Like postwalk, but does pre-order traversal.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/prewalk"}, :clojure.core.logic/project {:ns "clojure.core.logic", :name "project", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1327, :examples nil, :macro true, :notes nil, :arglists ["[& vars] & goals"], :doc "Extract the values bound to the specified logic vars. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/project"}, :clojure.core.logic.fd/>= {:ns "clojure.core.logic.fd", :name ">=", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 839, :examples nil, :notes nil, :arglists ["u v"], :doc "A finite domain constraint. u must be greater than or equal to v.\n   u and v must eventually be given domains if vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/>="}, :clojure.core.async/alt! {:ns "clojure.core.async", :name "alt!", :file "clojure/core/async.clj", :type "macro", :column 1, :see-alsos [:clojure.core.async/alts!], :line 347, :examples [";; attempts to put trade on channel trade-ch within 1 second.\n;; yields :timed-out or :sent.\n\n(let [timeout-ch (timeout 1000)]\n  (alt!\n    timeout-ch :timed-out\n    ;; note use of double-nested vector; [trade-ch trade]\n    ;; would be interpreted as two channels to take from, resulting\n    ;; in an odd error.\n    [[trade-ch trade]] :sent))" "(def trade-ch (chan))\n\n(go-loop []\n         (<! (timeout 1000))\n         (print (<! trade-ch))\n         (recur))\n\n(go \n (let [timeout-ch (timeout 1000)\n       trade 100]\n   (->\n    (alt!\n     [[trade-ch trade]] :sent\n     timeout-ch :timed-out)\n    print))) ;;eval this at will\n\n\n;;printout example\ncore.js[38]:\t\n:sent\ncore.js[38]:\t\n100\ncore.js[38]:\t\n100\ncore.js[38]:\t\n:sent\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:timed-out\ncore.js[38]:\t\n:sent\ncore.js[38]:\t\n100\n\n\n\n" ";; Reading from multiple channels, handling whichever gets data first\n(use 'clojure.core.async)\n\n(def result-chan (chan))\n\n(def error-chan (chan))\n\n(def dont-care-chan (chan))\n\n(go\n  (alt!\n    result-chan ([result] (println! (str \"Success: \" result)))\n    error-chan ([error] (println! (str \"Error: \" error)))\n    dont-care-chan (println \"Don't care about the value!\")))\n\n;; Given\n(put! result-chan \"Some result\")\n\n;; Output\n;; Success: Some result\n\n;; Given\n(put! error-chan \"Some error\")\n\n;; Output\n;; Error: Some error\n\n;; Given\n(put! dont-care-chan \"Some value\")\n\n;; Output\n;; Don't care about the value!"], :macro true, :notes nil, :arglists ["& clauses"], :doc "Makes a single choice between one of several channel operations,\n  as if by alts!, returning the value of the result expr corresponding\n  to the operation completed. Must be called inside a (go ...) block.\n\n  Each clause takes the form of:\n\n  channel-op[s] result-expr\n\n  where channel-ops is one of:\n\n  take-port - a single port to take\n  [take-port | [put-port put-val] ...] - a vector of ports as per alts!\n  :default | :priority - an option for alts!\n\n  and result-expr is either a list beginning with a vector, whereupon that\n  vector will be treated as a binding for the [val port] return of the\n  operation, else any other expression.\n\n  (alt!\n    [c t] ([val ch] (foo ch val))\n    x ([v] v)\n    [[out val]] :wrote\n    :default 42)\n\n  Each option may appear at most once. The choice and parking\n  characteristics are those of alts!.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/alt!"}, :clojure.core.logic/-nafc {:ns "clojure.core.logic", :name "-nafc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2701, :examples nil, :notes nil, :arglists ["c args"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-nafc"}, :clojure.repl/dir {:ns "clojure.repl", :name "dir", :file "clojure/repl.clj", :type "macro", :column 1, :see-alsos [:clojure.repl/doc :clojure.repl/source :clojure.repl/apropos], :line 202, :examples ["user=> (require 'clojure.string 'clojure.repl)\n\nuser=> (clojure.repl/dir clojure.string)\nblank?\ncapitalize\nescape\njoin\nlower-case\nreplace\nreplace-first\nreverse\nsplit\nsplit-lines\ntrim\ntrim-newline\ntriml\ntrimr\nupper-case"], :macro true, :notes nil, :arglists ["nsname"], :doc "Prints a sorted directory of public vars in a namespace", :library-url "https://github.com/clojure/clojure", :href "/clojure.repl/dir"}, :clojure.core/pcalls {:added "1.0", :ns "clojure.core", :name "pcalls", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/pvalues :clojure.core/future :clojure.core/pmap], :line 6957, :examples ["user=> (pcalls function-1 function-2 ...)\n\n(result1 result2 ...)" ";; pcalls is implemented using Clojure futures.  See examples for 'future'\n;; for discussion of an undesirable 1-minute wait that can occur before\n;; your standalone Clojure program exits if you do not use shutdown-agents."], :notes nil, :arglists ["& fns"], :doc "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/pcalls"}, :clojure.inspector/collection-tag {:ns "clojure.inspector", :name "collection-tag", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos nil, :line 22, :examples ["user=> (clojure.inspector/collection-tag (first {:a 1 :b 2}))\n;;=> :entry\nuser=> (clojure.inspector/collection-tag {:a 1})\n;;=> :seqable\nuser=> (clojure.inspector/collection-tag #{:a 1})\n;;=> :seqable\nuser=> (clojure.inspector/collection-tag [1 2])\n;;=> :seq\nuser=> (clojure.inspector/collection-tag :a)\n;;=> :atom\n"], :notes nil, :arglists ["x"], :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/collection-tag"}, :clojure.inspector/inspect {:added "1.0", :ns "clojure.inspector", :name "inspect", :file "clojure/inspector.clj", :type "function", :column 1, :see-alsos nil, :line 154, :examples nil, :notes nil, :arglists ["x"], :doc "creates a graphical (Swing) inspector on the supplied object", :library-url "https://github.com/clojure/clojure", :href "/clojure.inspector/inspect"}, :clojure.core/*print-meta* {:added "1.0", :ns "clojure.core", :name "*print-meta*", :type "var", :see-alsos [:clojure.core/pr], :examples ["user=> (binding [*print-meta* true] \n         (pr (var defmacro)) )\n;;^{:macro true, :ns #<Namespace clojure.core>, :name defmacro, :arglists ^{:line 424, :column 15} ([name doc-string? attr-map? [params*] body] [name doc-string? attr-map? ^{:line 425, :column 46} ([params*] body) + attr-map?]), :column 1, :added \"1.0\", :doc \"Like defn, but the resulting function name is declared as a\\n  macro and will be used as a macro by the compiler when it is\\n  called.\", :line 419, :file \"clojure/core.clj\"} #'clojure.core/defmacro\nnil\n"], :notes ["\"printing an object\" means via **pr** not print or println"], :arglists [], :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*print-meta*"}, :clojure.core/vec {:added "1.0", :ns "clojure.core", :name "vec", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/vector :clojure.core/vector? :clojure.core/vector-of], :line 367, :examples ["user=> (vec '(1 2 3))\n[1 2 3]\n\nuser=> (vec [1 2 3])\n[1 2 3]\n\nuser=> (vec #{1 2 3})\n[1 3 2]\n\nuser=> (vec {:a 1 :b 2 :c 3})\n[[:c 3] [:b 2] [:a 1]]\n\nuser=> (vec '())\n[]\n\nuser=> (vec nil)\n[]" ";; Warning.  If the arg is a Java array, then the returned vector will alias it,\n;; and modifying the array will thus modify the vector.  To avoid this, do\n;; not modify the array after the vec call.  One way to guarantee this is to\n;; make a copy of the array, call vec on the new array, and then lose all\n;; references to the copy so it cannot be accessed in any way.\n\nuser=> (def a (to-array (repeat 4 0)))\n#'user/a\nuser=> (seq a)\n(0 0 0 0)\nuser=> (def v (vec a))\n#'user/v\nuser=> v\n[0 0 0 0]\n\n;; Now change a, and v changes, too, since they share state.\nuser=> (aset a 2 -5)\n-5\nuser=> v\n[0 0 -5 0]\n\n;; One way to avoid this\nuser=> (def v (vec (aclone a)))\n#'user/v\nuser=> v\n[0 0 -5 0]\nuser=> (aset a 2 -20)\n-20\nuser=> v\n[0 0 -5 0]\n"], :notes nil, :arglists ["coll"], :doc "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/vec"}, :clojure.core/interleave {:added "1.0", :ns "clojure.core", :name "interleave", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/interpose :clojure.core/zipmap], :line 4275, :examples [";; This example takes a list of keys and a separate list of values and \n;; inserts them into a map.\n(apply assoc {} \n   (interleave [:fruit :color :temp] \n               [\"grape\" \"red\" \"hot\"]))\n\n;;=> {:temp \"hot\", :color \"red\", :fruit \"grape\"}\n" ";; Simple example:\n(interleave [:a :b :c] [1 2 3])\n;;=> (:a 1 :b 2 :c 3)" ";; The shortest input stops interleave:\n\n(interleave [:a :b :c] [1 2])\n;;=> (:a 1 :b 2)\n\n(interleave [:a :b] [1 2 3])\n;;=> (:a 1 :b 2)" "(def s1 [[:000-00-0000 \"TYPE 1\" \"JACKSON\" \"FRED\"]\n         [:000-00-0001 \"TYPE 2\" \"SIMPSON\" \"HOMER\"]\n         [:000-00-0002 \"TYPE 4\" \"SMITH\" \"SUSAN\"]])\n\n(interleave (map #(nth % 0 nil) s1) (map #(nth % 1 nil) s1))\n;;=> (:000-00-0000 \"TYPE 1\" \n;;    :000-00-0001 \"TYPE 2\"\n;;    :000-00-0002 \"TYPE 4\")" "(def s1 [[:000-00-0000 \"TYPE 1\" \"JACKSON\" \"FRED\"]\n         [:000-00-0001 \"TYPE 2\" \"SIMPSON\" \"HOMER\"]\n         [:000-00-0002 \"TYPE 4\" \"SMITH\" \"SUSAN\"]])\n\n(def cols [0 2 3])\n\n(defn f1 \n  [s1 col] \n  (map #(get-in s1 [% col] nil) (range (count s1))))\n\n(apply interleave (map (partial f1 s1) cols))\n;;=> (:000-00-0000 \"JACKSON\" \"FRED\" \n;;    :000-00-0001 \"SIMPSON\" \"HOMER\" \n;;    :000-00-0002 \"SMITH\" \"SUSAN\")" "(interleave (repeat \"a\") [1 2 3])\n;;=>(\"a\" 1 \"a\" 2 \"a\" 3)\n"], :notes nil, :arglists ["" "c1" "c1 c2" "c1 c2 & colls"], :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/interleave"}, :clojure.test/test-all-vars {:added "1.1", :ns "clojure.test", :name "test-all-vars", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :line 736, :examples nil, :notes nil, :arglists ["ns"], :doc "Calls test-vars on every var interned in the namespace, with fixtures.", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/test-all-vars"}, :clojure.core/key {:added "1.0", :ns "clojure.core", :name "key", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/keys :clojure.core/val :clojure.core/map :clojure.core/hash-map], :line 1559, :examples [";; the following emulates 'keys'\n(map key {:a 1 :b 2})\n;;=> (:a :b)\n" ";; extracts the key of a map entry\n(key (clojure.lang.MapEntry. :a :b))\n;;=> :a\n"], :notes nil, :arglists ["e"], :doc "Returns the key of the map entry.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/key"}, :clojure.data/Diff {:added "1.3", :ns "clojure.data", :name "Diff", :file "clojure/data.clj", :type "var", :column 1, :see-alsos nil, :line 71, :examples nil, :notes nil, :arglists [], :doc "Implementation detail. Subject to change.", :library-url "https://github.com/clojure/clojure", :href "/clojure.data/Diff"}, :clojure.core/trampoline {:added "1.0", :ns "clojure.core", :name "trampoline", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/loop :clojure.core/recur :clojure.core/letfn], :line 6219, :examples ["(defn foo [x]\n   (if (< x 0)\n     (println \"done\")\n     #(foo (do (println :x x) (dec x)))))\n;; #'user/foo\n\n;; `trampoline` will keep calling the function \n;; for as long as \"foo\" returns a function.\n\n(trampoline foo 10)\n;; :x 10\n;; :x 9\n;; :x 8\n;; :x 7\n;; :x 6\n;; :x 5\n;; :x 4\n;; :x 3\n;; :x 2\n;; :x 1\n;; :x 0\n;; done\n;;=> nil" ";; Short tutorial-style article with example of using trampoline at this link:\n;; http://jakemccrary.com/blog/2010/12/06/trampolining-through-mutual-recursion/" ";; Using mutually recursive functions to implement a finite state machine (FSM)\n;; This machine has three states {a b c} and \n;; seven transitions {:a-b :a-c :b-a :b-c :c-a :c-b :final}.\n\n(defn foo [cmds]\n(letfn\n   [(a-> [[_ & rs]]\n      #(case _ \n         :a-b (b-> rs)\n         :a-c (c-> rs)\n         false))\n    (b-> [[_ & rs]]\n      #(case _ \n         :b-a (a-> rs)\n         :b-c (c-> rs)\n         false))\n    (c-> [[_ & rs]]\n      #(case _ \n         :c-a (a-> rs)\n         :c-b (c-> rs)\n         :final true\n         false))]\n  (trampoline a-> cmds)))\n    \n(foo [:a-b :b-c :c-a :a-c :final])\n;;=> true" ";; from <the joy of clojure 2nd>\n;; Mutually recursive functions are nice for implementing \n;; finite state machines (FSAs)\n\n(defn elevator [commands]\n  (letfn\n      [(ff-open [[_ & r]]\n         \"When the elevator is open on the 1st floor\nit can either close or be done.\"\n         #(case _\n            :close (ff-closed r)\n            :done true\n            false))\n       (ff-closed [[_ & r]\n                   \"When the elevator is closed on the 1st floor\nit can either open or go up.\"\n                   #(case _\n                      :open (ff-open r)\n                      :up (sf-closed r)\n                      false))\n         (sf-closed [[_ & r]]\n                    \"When the elevator is closed on the 2nd floor\nit can either go down or open.\"\n                    #(case _\n                       :down (ff-closed r)\n                       :open (sf-open r)\n                       false))\n         (sf-open [[_ & r]]\n                  \"When the elevator is open on the 2nd floor\nit can either close or be done\"\n                  #(case _\n                     :close (sf-closed r)\n                     :done true\n                     false))]\n      \n(trampoline ff-open commands)))\n\n(elevator [:close :open :close :up :open :open :done])\n                                        ;=> false\n(elevator [:close :up :open :close :down :open :done])\n                                        ;=> true\n;; run at your own risk!\n(elevator (cycle [:close :open]))                                       \n ; ... runs forever" ";; without trampoline\n(declare hatt)\n(defn catt [n]\n  (when-not (zero? n)\n    (when (zero? (rem n 100))\n      (println \"catt:\" n))\n    (hatt (dec n))))\n(defn hatt [n]\n  (when-not (zero? n)\n    (if (zero? (rem n 100))\n      (println \"hatt:\" n))\n    (catt (dec n))))\n\n;; std=> catt: 100000000\n;; std=> catt: 99999900\n;; std=> catt: 99999800\n;; std=> catt: 99999700\n;; std=> catt: 99999600\n;; std=> catt: 99999500\n;; std=> catt: 99999400\n;; .\n;; .\n;; .\n;; std => CompilerException java.lang.StackOverflowError\n\n;; with trampoline\n\n(declare hattr)\n\n(defn cattr [n]\n  (when-not (zero? n)\n    (when (zero? (rem n 100))\n      (println \"cattr:\" n))\n    (fn [] (hattr (dec n)))))\n(defn hattr [n]\n  (when-not (zero? n)\n    (if (zero? (rem n 100))\n      (println \"hatttr:\" n))\n    (fn [] (cattr (dec n)))))\n\n(trampoline cattr 10000000)\n\n;; std=> catt: 100000000\n;; std=> catt: 99999900\n;; std=> catt: 99999800\n;; std=> catt: 99999700\n;; std=> catt: 99999600\n;; std=> catt: 99999500\n;; std=> catt: 99999400\n;; .\n;; .\n;; .\n;; std=> catt: 100\n"], :notes ["A tutorial on how to use trampoline is available here: \r\n\r\nhttp://pramode.net/clojure/2010/05/08/clojure-trampoline/\r\n\r\nand here:\r\n\r\nhttp://jakemccrary.com/blog/2010/12/06/trampolining-through-mutual-recursion.html"], :arglists ["f" "f & args"], :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/trampoline"}, :clojure.core/update-proxy {:added "1.0", :ns "clojure.core", :name "update-proxy", :file "clojure/core_proxy.clj", :type "function", :column 1, :see-alsos [:clojure.core/init-proxy], :line 308, :examples [";; from http://groups.google.com/group/clojure/msg/71702435ccd1d189\nuser> (import java.util.Date)\njava.util.Date\n\nuser> (def d (proxy [Date] [] (toString [] \"hello\")))\n#'user/d\n\nuser> d\n#<Date$0 hello>\n\nuser> (.toString d)\n\"hello\"\n\nuser> (.toGMTString d)\n\"17 Nov 2010 12:57:28 GMT\"\n\nuser> (update-proxy d {\"toGMTString\" (fn [this] \"goodbye\")})\nnil\n\nuser> (.toGMTString d)\n\"goodbye\" "], :notes nil, :arglists ["proxy mappings"], :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/update-proxy"}, :clojure.core/areduce {:added "1.0", :ns "clojure.core", :name "areduce", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/amap], :line 5205, :examples [";; This should be about as quick as summing up a array of floats in java.\n\nuser=> (defn asum [^floats xs]\n         (areduce xs i ret (float 0)\n                  (+ ret (aget xs i))))\n\nuser=> (asum (float-array [1 2 3]))\n6.0\n"], :macro true, :notes nil, :arglists ["a idx ret init expr"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/areduce"}, :clojure.core/print-str {:added "1.0", :ns "clojure.core", :name "print-str", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/println-str :clojure.core/print], :line 4720, :examples [";; Create a string from the given items and store it in x.\nuser=> (def x (print-str 1 \"foo\" \\b \\a \\r {:a 2}))\n#'user/x\n\n;; It's a string.\nuser=> (string? x)\ntrue\n\n;; Notice that each item is separated by a space.\nuser=> x\n\"1 foo b a r {:a 2}\"\n\n"], :notes nil, :tag "java.lang.String", :arglists ["& xs"], :doc "print to a string, returning it", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/print-str"}, :clojure.core/*file* {:added "1.0", :ns "clojure.core", :name "*file*", :type "var", :see-alsos nil, :examples nil, :notes ["Does this actually work? I couldn't get it to print anything but NO_SOURCE_PATH. (And no, this wasn't in the REPL.)" "If you're having trouble getting this feature to work as advertised, check out [this StackOverflow Question](http://stackoverflow.com/questions/12692698/file-variable-not-working/12693068)."], :arglists [], :doc "The path of the file being evaluated, as a String.\n\n  When there is no file, e.g. in the REPL, the value is not defined.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*file*"}, :clojure.core/parents {:added "1.0", :ns "clojure.core", :name "parents", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/descendants :clojure.core/ancestors :clojure.core/derive :clojure.core/underive :clojure.core/make-hierarchy :clojure.core/isa?], :line 5525, :examples [";; simple example showing single parented derivation\n;; then adding another parent\n\nuser=> (derive ::toy_poodle ::poodle)\nnil\nuser=> (parents ::toy_poodle)\n#{:user/poodle}\nuser=> (derive ::toy_poodle ::toy_dogs)\nnil\nuser=> (parents ::toy_poodle)\n#{:user/poodle :user/toy_dogs}\nuser=>"], :notes nil, :arglists ["tag" "h tag"], :doc "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/parents"}, :clojure.core.logic.fd/- {:ns "clojure.core.logic.fd", :name "-", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 906, :examples nil, :notes nil, :arglists ["u v w"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-"}, :clojure.core.logic/fnm {:ns "clojure.core.logic", :name "fnm", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1632, :examples nil, :macro true, :notes nil, :arglists ["t as tabled? & cs"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/fnm"}, :clojure.core/unchecked-multiply-int {:added "1.0", :ns "clojure.core", :name "unchecked-multiply-int", :file "clojure/core.clj", :type "function", :column 1, :see-alsos nil, :line 1211, :examples nil, :notes nil, :arglists ["x y"], :doc "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/unchecked-multiply-int"}, :clojure.xml/content-handler {:ns "clojure.xml", :name "content-handler", :file "clojure/xml.clj", :type "var", :column 1, :see-alsos nil, :line 26, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.xml/content-handler"}, :clojure.core.async/sub {:ns "clojure.core.async", :name "sub", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/pub], :line 898, :examples ["user=> (def c (chan 1))\n#'user/c\n\nuser=> (def sub-c (pub c :route))\n#'user/sub-c\n\nuser=> (def cx (chan 1))\n#'user/cx\n\nuser=> (sub sub-c :up-stream cx)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@526eb67f>\n\nuser=> (def cy (chan 1))\n#'user/cy\n\nuser=> (sub sub-c :down-stream cy)\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@777692ac>\n\nuser=> (go-loop [_ (<! cx)]\n         (println \"Got something coming up!\"))\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@49e2e0f9>\n\nuser=> (go-loop [_ (<! cy)]\n         (println \"Got something going down!\"))\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@33498147>\n\nuser=> (put! c {:route :up-stream :data 123})\ntrue\nGot something coming up!\n\nuser=> (put! c {:route :down-stream :data 123})\nGot something going down!\ntrue\n"], :notes nil, :arglists ["p topic ch" "p topic ch close?"], :doc "Subscribes a channel to a topic of a pub.\n\n  By default the channel will be closed when the source closes,\n  but can be determined by the close? parameter.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/sub"}, :clojure.core/and {:added "1.0", :ns "clojure.core", :name "and", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/or :clojure.core/if], :line 834, :examples ["user=> (and true true)\ntrue\n\nuser=> (and true false)\nfalse\n\nuser=> (and false false)\nfalse\n\nuser=> (and '() '())\n()\n\nuser=> (and '[] '[])\n[]\n\nuser=> (and 0 1)  ; Note that this is *not* bitwise 'and'\n1\n\nuser=> (and 1 0)\n0\n" ";; See examples for \"if\" explaining Clojure's idea of logical true\n;; and logical false." "; Note that, and does not evaluate if the first value is false\nuser=> (and false nil)\nfalse\n\nuser=> (and nil false)\nnil\n\nuser=> (and false (println \"foo\"))\nfalse\n\nuser=> (and (println \"foo\") false)\nfoo\nnil" "; From the Clojure 1.9 source code.\n(defn qualified-keyword?\n  \"Return true if x is a keyword with a namespace\"\n  [x] (and (keyword? x) (namespace x) true))\n\n; Note how the return value of and is value of the last expression.\nuser=> (qualified-keyword? :hi/there)\ntrue\n\n; If we instead define the function as:\n(defn qualified-keyword?\n  [x] (and (keyword? x) (namespace x)))\n; we get the namespace as return value:\nuser=> (qualified-keyword? :hi/there)\n\"hi\""], :macro true, :notes ["Note <b>add</b> is a macro, so you cannot <b>apply</b> it. For example, there is a vector of some Boolean values <b>[true true false true]</b>, which you want to test to see if they are all true. The code below will not work: <pre>(apply add [true true false true]) ;won't work</pre>\r\nInstead, use this: <pre>(every? identity [true  true false true])</pre> More discussion can be found at http://osdir.com/ml/clojure/2010-01/msg01242.html"], :arglists ["" "x" "x & next"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/and"}, :clojure.core/*use-context-classloader* {:ns "clojure.core", :name "*use-context-classloader*", :type "var", :see-alsos nil, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*use-context-classloader*"}, :clojure.core.logic/make-suspended-stream {:ns "clojure.core.logic", :name "make-suspended-stream", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1854, :examples nil, :notes nil, :arglists ["cache ansv* f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/make-suspended-stream"}, :clojure.string/triml {:added "1.2", :ns "clojure.string", :name "triml", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/trim :clojure.string/trim-newline :clojure.string/trimr], :line 251, :examples ["(use 'clojure.string)\n(triml \"        my string         \")\n=> \"my string         \"\n" ";; Note: see an example at trim for the differences between\n;; \"whitespace\" for trim/trimr/triml and \n;; \"whitespace\" for regex (\\s)"], :notes nil, :tag "java.lang.String", :arglists ["s"], :doc "Removes whitespace from the left side of string.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/triml"}, :clojure.core.async/go-loop {:ns "clojure.core.async", :name "go-loop", :file "clojure/core/async.clj", :type "macro", :column 1, :see-alsos [:clojure.core/loop :clojure.core.async/go], :line 457, :examples ["(go-loop [seconds 1]\n         (<! (timeout 1000))\n         (print \"waited\" seconds \"seconds\")\n         (recur (inc seconds)))\n\n;;waited 1 seconds\n;;waited 2 seconds\n;;waited 3 seconds\n;;..." "user=> (def c (chan 1))\n#'user/c\n\nuser=> (go-loop []\n         (let [x (<! c)]\n           (println \"Got a value in this loop:\" x))\n         (recur))\n\n#<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@30df0e27>\n\nuser=> (doseq [n (range 3)] (put! c n))\nnil\nGot a value in this loop: 0\nGot a value in this loop: 1\nGot a value in this loop: 2\n"], :macro true, :notes nil, :arglists ["bindings & body"], :doc "Like (go (loop ...))", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/go-loop"}, :clojure.zip/end? {:added "1.0", :ns "clojure.zip", :name "end?", :file "clojure/zip.clj", :type "function", :column 1, :see-alsos [:clojure.zip/zipper], :line 258, :examples nil, :notes nil, :arglists ["loc"], :doc "Returns true if loc represents the end of a depth-first walk", :library-url "https://github.com/clojure/clojure", :href "/clojure.zip/end_q"}, :clojure.core.async/pipeline-async {:ns "clojure.core.async", :name "pipeline-async", :file "clojure/core/async.clj", :type "function", :column 1, :see-alsos [:clojure.core.async/pipeline :clojure.core.async/pipeline-blocking], :line 559, :examples [";; NOTICE!\n;; `pipeline-async` has different syntax, in it's `af` function, \n;; than the other 2 `pipeline` fns\n\n(def ca> (chan 1))\n(def cb> (chan 1))\n(defn c-af [val result] ; notice the signature is different for `pipeline-async`, it includes a channel\n  (go (<! (timeout 1000))\n      (>! result (str val \"!!!\"))\n      (close! result)))\n(pipeline-async\n 1\n cb>\n c-af\n ca>)\n(go (println (<! cb>)))\n(go (>! ca> \"hello\"))"], :notes nil, :arglists ["n to af from" "n to af from close?"], :doc "Takes elements from the from channel and supplies them to the to\n  channel, subject to the async function af, with parallelism n. af\n  must be a function of two arguments, the first an input value and\n  the second a channel on which to place the result(s). af must close!\n  the channel before returning.  The presumption is that af will\n  return immediately, having launched some asynchronous operation\n  (i.e. in another thread) whose completion/callback will manipulate\n  the result channel. Outputs will be returned in order relative to\n  the inputs. By default, the to channel will be closed when the from\n  channel closes, but can be determined by the close?  parameter. Will\n  stop consuming the from channel if the to channel closes. See also\n  pipeline, pipeline-blocking.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.async/pipeline-async"}, :clojure.core.logic.fd/-distinctc {:ns "clojure.core.logic.fd", :name "-distinctc", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 986, :examples nil, :notes nil, :arglists ["x y* n*"], :doc "The real *individual* distinct constraint. x is a var that now is bound to\n   a single value. y* were the non-singleton bound vars that existed at the\n   construction of the constraint. n* is the set of singleton domain values \n   that existed at the construction of the constraint. We use categorize to \n   determine the current non-singleton bound vars and singleton vlaues. if x\n   is in n* or the new singletons we have failed. If not we simply remove \n   the value of x from the remaining non-singleton domains bound to vars.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-distinctc"}, :clojure.main/repl-requires {:ns "clojure.main", :name "repl-requires", :file "clojure/main.clj", :type "var", :column 1, :see-alsos nil, :line 164, :examples nil, :notes nil, :arglists [], :doc "A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.", :library-url "https://github.com/clojure/clojure", :href "/clojure.main/repl-requires"}, :clojure.core/aset-boolean {:added "1.0", :ns "clojure.core", :name "aset-boolean", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/boolean-array], :line 3922, :examples [";; create an array of 10 booleans and set one value to true\n;; using aset-boolean\n\nuser=> (def bs (boolean-array 10))\n#'user/bs\nuser=> (vec bs)\n[false false false false false false false false false false]\nuser=> (aset-boolean bs 2 true)\ntrue\nuser=> (vec bs)\n[false false true false false false false false false false]\nuser=>"], :notes ["See [aset](http://clojuredocs.org/clojure.core/aset) for illustrations of multi-dimensional syntax."], :arglists ["array idx val" "array idx idx2 & idxv"], :doc "Sets the value at the index/indices. Works on arrays of boolean. Returns val.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/aset-boolean"}, :clojure.java.io/make-reader {:added "1.2", :ns "clojure.java.io", :name "make-reader", :type "function", :see-alsos nil, :examples nil, :notes ["Don't use this.  You probably want [reader](reader) instead."], :arglists ["x opts"], :doc "Creates a BufferedReader. See also IOFactory docs.", :library-url "https://github.com/clojure/clojure", :href "/clojure.java.io/make-reader"}, :clojure.core/realized? {:added "1.3", :ns "clojure.core", :name "realized?", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/promise :clojure.core/delay :clojure.core/future], :line 7453, :examples [";; Create a promise\nuser> (def p (promise))\n#'user/p ; p is our promise\n\n;; Check if was delivered/realized\nuser> (realized? p)\nfalse ; No yet\n\n;; Delivering the promise\nuser> (deliver p 42)\n#<core$promise$reify__5727@47122d: 42>\n\n;; Check again if it was delivered\nuser> (realized? p)\ntrue ; Yes!\n\n;; Deref to see what has been delivered\nuser> @p\n42\n\n;; Note that @ is shorthand for deref\nuser> (deref p)\n42" ";; For lazy sequences\n\nuser=> (def r (range 5))\n#'user/r\nuser=> (realized? r)\nfalse\nuser=> (first r)\n0\nuser=> (realized? r)\ntrue\n\n; As of Clojure 1.7.0 range returns a LongRange, not a LazySeq\n; see https://groups.google.com/forum/#!topic/clojure/NFwHkZxUFuY\n\nuser=> (def r (lazy-seq (range 5)))\n#'user/r\nuser=> (realized? r)\nfalse\nuser=> (first r)\n0\nuser=> (realized? r)\ntrue"], :notes nil, :arglists ["x"], :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/realized_q"}, :clojure.core/min {:added "1.0", :ns "clojure.core", :name "min", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/max :clojure.core/min-key], :line 1117, :examples ["user=> (min 1 2 3 4 5)  \n1\nuser=> (min 5 4 3 2 1)\n1\nuser=> (min 100)\n100" ";; If elements are already in a sequence, use apply\nuser=> (apply min [1 2 3 4 3])\n1\nuser=> (apply min '(4 3 5 6 2))\n2"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "Returns the least of the nums.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/min"}, :clojure.spec.alpha/or-spec-impl {:ns "clojure.spec.alpha", :name "or-spec-impl", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos nil, :line 1008, :examples nil, :notes nil, :arglists ["keys forms preds gfn"], :doc "Do not call this directly, use 'or'", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/or-spec-impl"}, :clojure.core.logic/map->SubstValue {:ns "clojure.core.logic", :name "map->SubstValue", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 197, :examples nil, :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.core.logic.SubstValue, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/map->SubstValue"}, :clojure.core/*compiler-options* {:added "1.4", :ns "clojure.core", :name "*compiler-options*", :type "var", :see-alsos nil, :examples [";; Toggle locals clearing (set it to true to aid with debugging)\n(alter-var-root #'clojure.core/*compiler-options* \n                update :disable-locals-clearing not)"], :notes nil, :arglists [], :doc "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  Alpha, subject to change.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*compiler-options*"}, :clojure.core.logic/sync-eset {:ns "clojure.core.logic", :name "sync-eset", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 455, :examples nil, :notes nil, :arglists ["s v seenset f"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/sync-eset"}, :clojure.core/prn-str {:added "1.0", :ns "clojure.core", :name "prn-str", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/prn :clojure.edn/read-string], :line 4711, :examples ["user=> (def x \"Hello!\\nMy name is George.\\n\")\n#'user/x\n\nuser=> (prn-str x)\n=> \"\\\"Hello!\\\\nMy name is George.\\\\n\\\"\\n\"\n" ";; Be aware that prn-str and friends are influenced by a couple global variables\n;; such as *print-length*:\n\n(set! *print-length* 10)\n(prn-str (range 15))\n;=> \"(0 1 2 3 4 5 6 7 8 9 ...)\\n\"\n\n(set! *print-length* -1)\n(prn-str (range 15))\n;=> \"(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\\n\""], :notes nil, :tag "java.lang.String", :arglists ["& xs"], :doc "prn to a string, returning it", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/prn-str"}, :clojure.core/commute {:added "1.0", :ns "clojure.core", :name "commute", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/ref :clojure.core/alter :clojure.core/dosync], :line 2414, :examples ["user=> (def counter (ref 0))\n#'user/counter\n\n;; deciding whether to increment the counter takes the terribly long time\n;; of 100 ms -- it is decided by committee.\nuser=> (defn commute-inc! [counter]\n         (dosync (Thread/sleep 100) (commute counter inc)))\n#'user/commute-inc!\nuser=> (defn alter-inc! [counter]\n         (dosync (Thread/sleep 100) (alter counter inc)))\n#'user/alter-inc!\n\n;; what if n people try to hit the counter at once?\nuser=> (defn bombard-counter! [n f counter]\n         (apply pcalls (repeat n #(f counter))))\n#'user/bombard-counter!\n\n;; first, use alter.  Everyone is trying to update the counter, and\n;; stepping on each other's toes, so almost every transaction is getting \n;; retried lots of times:\nuser=> (dosync (ref-set counter 0))\n0\nuser=> (time (doall (bombard-counter! 20 alter-inc! counter)))\n\"Elapsed time: 2007.049224 msecs\"\n(3 1 2 4 7 10 5 8 6 9 13 14 15 12 11 16 17 20 18 19)\n;; note that it took about 2000 ms = (20 workers * 100 ms / update)\n\n;; now, since it doesn't matter what order people update a counter in, we\n;; use commute:\nuser=> (dosync (ref-set counter 0))\n0\nuser=> (time (doall (bombard-counter! 20 commute-inc! counter)))\n\"Elapsed time: 401.748181 msecs\"\n(1 2 3 4 5 9 10 6 7 8 11 15 13 12 14 16 19 17 18 20)\n;; notice that we got actual concurrency this time." "; Note that commute will ALWAYS run the update function TWICE. \n; Example courtesy of \"Clojure for the Brave and True\"\n; https://github.com/flyingmachine/brave-clojure-web\n\n(defn sleep-print-update\n  [sleep-time thread-name update-fn]\n  (fn [state]\n    (Thread/sleep sleep-time)\n    (println (str thread-name \": \" state))\n    (update-fn state)))\n\n(def counter (ref 0))\n(future (dosync (commute counter (sleep-print-update 100 \"Commute Thread A\" inc))))\n(future (dosync (commute counter (sleep-print-update 150 \"Commute Thread B\" inc))))\n\n; printed output is:\nCommute Thread A: 0   ; (after 100ms)\nCommute Thread B: 0   ; (after 150ms)\nCommute Thread A: 0   ; (after 200ms)\nCommute Thread B: 1   ; (after 300ms)\n"], :notes ["Note to understand the difference to 'alter':\r\n\r\nCommute should be used when it doesn't matter whether anyone else has changed (altered or commuted) the ref using a successful transaction. This often implies that this ref is not affected by any conditions, i.e. it should be changed the same way no matter what. (thanks to raek for clarifying that for me)" "In the concurrency video RH explains that commute is useful for actions where the order in which they alter the value doesn't matter, e.g. incrementing a counter."], :arglists ["ref fun & args"], :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/commute"}, :clojure.core/compare {:added "1.0", :ns "clojure.core", :name "compare", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/sort-by :clojure.core/sorted-set-by :clojure.core/sorted-map-by], :line 823, :examples [";; various examples\n;; comparing vectors of different sizes does not work as you may expect\n;; the longer vector is always \"greater\" regardless of contents \n\nuser=> (compare [0 1 2] [0 1 2])\n0\nuser=> (compare [1 2 3] [0 1 2 3])\n-1\nuser=> (compare [0 1 2] [3 4])\n1\nuser=> (compare nil [1 2 3])\n-1\nuser=> (compare [1 2 3] nil)\n1\nuser=>  (compare [2 11] [99 1])\n-1\nuser=> (compare \"abc\" \"def\")\n-3\nuser=> (compare \"abc\" \"abd\")\n-1" ";; number comparisons give results of either 1, 0 or -1\n(compare 1 0) ;; => 1\n(compare 1 1) ;; => 0\n(compare 1 2) ;; => -1\n(compare 1 3) ;; => -1\n\n;; string comparisons give results of the distance between the first characters\n(compare \"B\" \"A\") ;; => 1\n(compare \"B\" \"B\") ;; => 0\n(compare \"B\" \"C\") ;; => -1\n(compare \"AA\" \"ZZ\") ;; => -25\n" "(compare true false)\n;;=> 1\n(compare false true)\n;;=> -1\n(compare true true)\n;;=> 0\n(compare false false)\n;;=> 0"], :notes ["It is clear what `compare` does, but how do you turn its output into an answer to questions like ‘is x less than y’ or ‘is x greater than or equal to y’?\n\nWhile the numeric `<` `<=` `=` `>=` `>` provide that answer in Boolean form right away, with `compare` a second step is required.\n\n    ((juxt < <= = >= >) 2 3)\n    ;;=> [true true false false false]\n\nHere is a listing of the same relations using `compare`:\n\n    ((juxt (comp neg? compare)\n           (comp not pos? compare)\n           (comp zero? compare)\n           (comp not neg? compare)\n           (comp pos? compare))\n     \"2\" \"3\")\n    ;;=> [true true false false false]\n"], :arglists ["x y"], :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/compare"}, :clojure.core/format {:added "1.0", :ns "clojure.core", :name "format", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/printf :clojure.pprint/cl-format :clojure.pprint/print-table], :line 5678, :examples [";; See http://download.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html\n;; for formatting options.\nuser=> (format \"Hello there, %s\" \"bob\")\n\"Hello there, bob\"\n" "user=> (format \"%5d\" 3)\n\"    3\"\n\nuser=> (format \"Pad with leading zeros %07d\" 5432)\n\"Pad with leading zeros 0005432\"\n\nuser=> (format \"Left justified :%-7d:\" 5432)\n\"Left justified :5432   :\"\n\nuser=> (format \"Locale-specific group separators %,12d\" 1234567)\n\"Locale-specific group separators    1,234,567\"\n\nuser=> (format \"decimal %d  octal %o  hex %x  upper-case hex %X\" 63 63 63 63)\n\"decimal 63  octal 77  hex 3f  upper-case hex 3F\"\n\nuser=> (format \"%2$d %1$s\" \"Positional arguments\" 23)\n\"23 Positional arguments\"\n\n;;    ====== Clojure format/printf and large integers =====\n\n;; This big number doesn't fit in a Long.  It is a\n;; clojure.lang.BigInt, which format cannot handle directly.\nuser=> (format \"%5d\" 12345678901234567890)\nIllegalFormatConversionException d != clojure.lang.BigInt  java.util.Formatter$FormatSpecifier.failConversion (Formatter.java:3999)\n\n;; You can convert it to a java.math.BigInteger, which format does handle.\nuser=> (format \"%5d\" (biginteger 12345678901234567890))\n\"12345678901234567890\"\n\n;; If you do this very often, you might want to use something like\n;; format-plus to avoid sprinkling your code with calls to biginteger.\n(defn coerce-unformattable-types [args]\n  (map (fn [x]\n         (cond (instance? clojure.lang.BigInt x) (biginteger x)\n               (instance? clojure.lang.Ratio x) (double x)\n               :else x))\n       args))\n\n(defn format-plus [fmt & args]\n  (apply format fmt (coerce-unformattable-types args)))\n\n;; Now this works:\nuser=> (format-plus \"%5d\" 12345678901234567890)\n\"12345678901234567890\"" ";;  ==== Clojure format/printf and floating-point formats ====\nuser=> (format \"%.3f\" 2.0)\n\"2.000\"\n\n;; format doesn't handle integers or ratios with %e, %f, %g, or %a\nuser=> (format \"%.3f\" 2)\nIllegalFormatConversionException f != java.lang.Long  java.util.Formatter$FormatSpecifier.failConversion (Formatter.java:3999)\n\n;; In general, if you want to use floating-point formats %e, %f, %g,\n;; or %a with format or printf, and you don't know whether the values\n;; you want to format are floats or doubles, you should convert them:\nuser=> (format \"%.3f\" (double 2))\n\"2.000\"\n\nuser=> (format \"%.3f\" (double (/ 5 2)))\n\"2.500\"\n\n;; One could make a function that parses the format string to look for\n;; %f and other floating-point formats and automatically coerces the\n;; corresponding arguments to doubles, but such a function probably\n;; wouldn't fit into a short example.  You could also consider using\n;; cl-format which does handle these kinds of things for you.  The main\n;; disadvantage to doing so is that you have to learn a different syntax\n;; for format specifiers." ";; format doesn't know what nil should look like:\nuser=> (format \"%s\" nil)\n\"null\"\n;; You can use cl-format in this situation:\nuser=> (clojure.pprint/cl-format nil \"~s\" nil)\n\"nil\"\n"], :notes ["Note that `(format)` is [not currently supported](http://dev.clojure.org/jira/browse/CLJS-324) in ClojureScript, only in Clojure."], :arglists ["fmt & args"], :doc "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/format"}, :clojure.core.logic.fd/-disjoint? {:ns "clojure.core.logic.fd", :name "-disjoint?", :type "function", :see-alsos nil, :examples nil, :notes nil, :arglists ["this that"], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/-disjoint_q"}, :clojure.spec.alpha/double-in {:ns "clojure.spec.alpha", :name "double-in", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 1869, :examples nil, :macro true, :notes nil, :arglists ["& {:keys [infinite? NaN? min max], :or {infinite? true, NaN? true}, :as m}"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/double-in"}, :clojure.core/amap {:added "1.0", :ns "clojure.core", :name "amap", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/areduce :clojure.core/map], :line 5189, :examples ["(def an-array (int-array 25000 (int 0)))\n\nuser=> (time (amap ^ints an-array \n                   idx \n                   ret \n                   (+ (int 1) \n                      (aget ^ints an-array idx))))\n\n\"Elapsed time: 14.708653 msecs\"\n\n;; Note: without type hinting the performance of would not be good."], :macro true, :notes nil, :arglists ["a idx ret expr"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/amap"}, :clojure.core.logic.fd/intersection* {:ns "clojure.core.logic.fd", :name "intersection*", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 369, :examples nil, :notes nil, :arglists ["is js"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/intersection*"}, :clojure.core/chunk-cons {:ns "clojure.core", :name "chunk-cons", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/chunk-buffer :clojure.core/chunk :clojure.core/chunk-append :clojure.core/chunk-rest :clojure.core/chunk-next :clojure.core/chunk-first], :line 702, :examples ["(let [chunked-cons (-> (chunk-buffer 32)\n                   (chunk)\n                   (chunk-cons (seq (range 42))))]\n\n  chunked-cons\n  ;; => (0 1 2 3 4 5 6 7 8 9 10\n  ;;       11 12 13 14 15 16 17 18\n  ;;       19 20 21 22 23 24 25 26\n  ;;       27 28 29 30 31 32 33 34\n  ;;       35 36 37 38 39 40 41)\n\n  (class chunked-cons)\n  ;; => clojure.lang.ChunkedCons\n\n)" ";; byte-seq creates a lazy chunked sequence of bytes from an InputStream.\n;; It takes the optimal chunk \"size\" to model a physical resource \n;; (for a disk this would be the block size).\n\n(import '[java.io FileInputStream InputStream])\n\n(defn byte-seq [^InputStream is size]\n  (let [ib (byte-array size)]\n    ((fn step []\n       (lazy-seq\n         (let [n (.read is ib)]\n           (when (not= -1 n)\n             (let [cb (chunk-buffer size)]\n               (dotimes [i size] (chunk-append cb (aget ib i)))\n               (chunk-cons (chunk cb) (step))))))))))\n\n;; Example with a text file and block size 4096.\n(with-open [is (FileInputStream. \"/usr/share/dict/words\")]\n  (let [bs (byte-seq is 4096)]\n    (String. (byte-array (take 20 bs)))))\n;; \"A\\na\\naa\\naal\\naalii\\naam\""], :notes nil, :arglists ["chunk rest"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core/chunk-cons"}, :clojure.spec.alpha/with-gen {:ns "clojure.spec.alpha", :name "with-gen", :file "clojure/spec/alpha.clj", :type "function", :column 1, :see-alsos [:clojure.spec.alpha/gen], :line 189, :examples ["(require '[clojure.spec.alpha :as s]\n         '[clojure.spec.gen.alpha :as g])\n\n;; generator for int? includes positive and negative integers\n(-> int?\n    s/gen\n    g/generate)\n;; => -31\n;; => -177\n;; => 7\n\n;; there's a pos-int? generator that generates only positive integers, but\n;; for the sake of this example let's pretend it doesn't exist\n(-> pos-int?\n    s/gen\n    g/generate)\n;; => 848961\n;; => 11767\n;; => 3479479\n\n;; let's attach a new generator to int? so it generates only positive integers\n(require '[clojure.test.check.generators :as test.g])\n\n(defn abs [^long v] (Math/abs v))\n\n;; let's generate only positive int? values\n(-> int?\n    (s/with-gen #(test.g/fmap abs (s/gen int?)))\n    s/gen\n    g/generate)\n;; => 299578\n;; => 438034\n;; => 315023\n;; => 31\n\n"], :notes nil, :arglists ["spec gen-fn"], :doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/with-gen"}, :clojure.core.reducers/->Cat {:ns "clojure.core.reducers", :name "->Cat", :file "clojure/core/reducers.clj", :type "function", :column 1, :see-alsos nil, :line 263, :examples nil, :notes nil, :arglists ["cnt left right"], :doc "Positional factory function for class clojure.core.reducers.Cat.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/->Cat"}, :clojure.core.logic.fd/disjoint?* {:ns "clojure.core.logic.fd", :name "disjoint?*", :file "clojure/core/logic/fd.clj", :type "function", :column 1, :see-alsos nil, :line 449, :examples nil, :notes nil, :arglists ["is js"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic.fd/disjoint_q*"}, :clojure.core/clojure-version {:added "1.0", :ns "clojure.core", :name "clojure-version", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/*clojure-version*], :line 7001, :examples ["user=> (clojure-version)\n\"1.2.0-master-SNAPSHOT\""], :notes nil, :arglists [""], :doc "Returns clojure version as a printable string.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/clojure-version"}, :clojure.core.reducers/pool {:ns "clojure.core.reducers", :name "pool", :file "clojure/core/reducers.clj", :type "var", :column 4, :see-alsos nil, :line 41, :examples nil, :notes nil, :arglists [], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.reducers/pool"}, :clojure.core/def {:ns "clojure.core", :name "def", :type "var", :see-alsos [:clojure.core/defn :clojure.core/fn :clojure.core/defmacro :clojure.core/defmulti :clojure.core/defonce :clojure.core/ns-unmap], :examples ["user=> (def my-val 5)\n#'user/my-val\n\nuser=> my-val\n5" "user=> (def my-function (fn [x] (* x x x)))\n#'user/my-function\nuser=> (my-function 4)\n64" ";; This is an example of setting a docstring during a def.\n;; (Note that the clojure.repl namespace which contains the\n;;  doc function is not loaded by default in Emacs' SLIME mode.)\n\nuser> (def ted-nugent \"The nuge rocks\" 123)\n#'user/ted-nugent\nuser> (doc ted-nugent)\n-------------------------\nuser/ted-nugent\n  The nuge rocks\nuser> ted-nugent\n123\n" ";; give function another name\nuser=> (def sys-map map)\n\n;; give macro another name\nuser=> (def #^{:macro true} sys-loop #'loop)" ";;Assign a Function to a Variable\n\n(def say-hello\n (fn [name]\n   (str \"Hello \" name)))\n\n(say-hello \"World\")\n;;\"Hello World\"\n\n\n;;the same but using an anonymous function\n(def say-hello\n #(str \"Hello \" %))\n\n(say-hello \"World\")\n;;\"Hello World\"\n\n\n;;anonymous function using two arguments\n(def hello-doc #(str \"Hello \" %1 %2))\n\n(hello-doc \"Dr.\" \"House\")\n;;\"Hello Dr.House\"\n\n"], :notes nil, :arglists [], :doc "Creates and interns or locates a global var with the name of symbol and a\nnamespace of the value of the current namespace (*ns*). See\nhttp://clojure.org/special_forms for more information.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/def"}, :clojure.core.logic/member1o {:ns "clojure.core.logic", :name "member1o", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 1762, :examples nil, :notes nil, :arglists ["x l"], :doc "Like membero but uses to disequality further constraining\n   the results. For example, if x and l are ground and x occurs\n   multiple times in l, member1o will succeed only once.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/member1o"}, :clojure.core/<= {:added "1.0", :ns "clojure.core", :name "<=", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/>=], :line 1047, :examples ["user=> (<= 1 2)\ntrue\nuser=> (<= 2 2)\ntrue\nuser=> (<= 3 2)\nfalse\nuser=> (<= 2 3 4 5 6)\ntrue" "user=> (<= 1 2 3 2)\nfalse\n\nuser=> (<= 1 2 3 3)\ntrue"], :notes nil, :arglists ["x" "x y" "x y & more"], :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/<="}, :clojure.core/sorted-map {:added "1.0", :ns "clojure.core", :name "sorted-map", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/sorted-map-by :clojure.core/subseq :clojure.core/rsubseq :clojure.core/sorted-set :clojure.core/array-map :clojure.core/hash-map :clojure.core/sorted?], :line 398, :examples ["(sorted-map :z 3, :a 1, :b 2)   ;;=> {:a 1, :b 2, :z 3}\n(into (sorted-map) {:a 2 :b 1}) ;;=> {:a 2, :b 1}" "; 'seq' can be used to turn a map into a list of vectors\n; notice how the list is built in the sorted order as with vectors.\n(seq (into (sorted-map) {:key1 \"value1\" :key2 \"value2\"}))\n;;=> ([:key1 \"value1\"] [:key2 \"value2\"])" "; sorting on integer keys\n; also notice how each pair becomes a `MapEntry` ('key' 'val')\n(into (sorted-map) [[23 :x][17 :y]])\n;;=> {17 :y, 23 :x}" ";; clojure doesn't have a `sorted-map?` function to distinguish a sorted-map\n;; from a regular map. use `instance?`:\n(def unremarkable-map {:k1 \"v1\" :k2 \"v2\"})\n(def very-remarkable-map (into (sorted-map) unremarkable-map))\n(instance? clojure.lang.PersistentTreeMap unremarkable-map)\n;;=> false\n(instance? clojure.lang.PersistentTreeMap very-remarkable-map)\n;;=> true\n\n;; This works because:\n(type unremarkable-map)\n;;=> clojure.lang.PersistentArrayMap (PersistentHashMap if many key-val-pairs)\n(type very-remarkable-map)\n;;=> clojure.lang.PersistentTreeMap\n\n;; Clojure does have a `sorted?` predicate so you could define `sorted-map?`\n(def sorted-map? (every-pred map? sorted?))\n"], :notes nil, :arglists ["& keyvals"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/sorted-map"}, :clojure.pprint/fresh-line {:added "1.2", :ns "clojure.pprint", :name "fresh-line", :file "clojure/pprint/cl_format.clj", :type "function", :column 1, :see-alsos nil, :line 1245, :examples nil, :notes nil, :arglists [""], :doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :library-url "https://github.com/clojure/clojure", :href "/clojure.pprint/fresh-line"}, :clojure.core.logic/conda {:ns "clojure.core.logic", :name "conda", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos [:clojure.core.logic/condu :clojure.core.logic/conde :clojure.core.logic/defna :clojure.core.logic/fna], :line 1417, :examples [";; Mind the order:\n\n(defn logic-test-1 []\n  (run* [q r]\n    (membero q [\"linux\" \"windows\" \"mac\" \"android\" \"\"])\n    (conda\n     [(membero q [\"linux\" \"windows\"]) (== r 1)]\n     [(== q \"mac\") (== r 2)]\n     [succeed (== q \"\") (== r 3)])))\n;; => ([\"linux\" 1] [\"windows\" 1] [\"mac\" 2] [\"\" 3])\n;; conda takes ground values and matches them one by one against its clauses.   \n\n(defn logic-test-2 []\n  (run* [q r]\n    (conda\n     [(membero q [\"linux\" \"windows\"]) (== r 1)]\n     [(== q \"mac\") (== r 2)]\n     [succeed (== q \"\") (== r 3)])\n    (membero q [\"linux\" \"windows\" \"mac\" \"android\" \"\"])))\n;; ([\"linux\" 1] [\"windows\" 1])\n;; conda takes a fresh variable and associates it to the head of its first clause.\n;; only the rest of the first clause (== r 1) is considered"], :macro true, :notes nil, :arglists ["& clauses"], :doc "Soft cut. Once the head of a clause has succeeded\n  all other clauses will be ignored. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/conda"}, :clojure.core/denominator {:added "1.2", :ns "clojure.core", :name "denominator", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/numerator], :line 3582, :examples [";; denominator always returns the denominator of the reduced fraction\n;;\nuser=> (denominator (/ 2 3))\n3\nuser=> (denominator (/ 3 6))\n2\nuser=> (map denominator [(/ 3 2) (/ 2 3) (/ 4 5) (/ 4 6)])\n(2 3 5 3)\nuser=>"], :notes nil, :tag "java.math.BigInteger", :arglists ["r"], :doc "Returns the denominator part of a Ratio.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/denominator"}, :clojure.core/declare {:added "1.0", :ns "clojure.core", :name "declare", :file "clojure/core.clj", :type "macro", :column 1, :see-alsos [:clojure.core/def], :line 2768, :examples ["user=> (defn foo []\n         (undefined-func))\n; Evaluation aborted. Unable to resolve symbol: undefined-func in this context\nnil\n\nuser=> (declare undefined-func)\n#'user/undefined-func\n\nuser=> (defn foo []\n         (undefined-func))\n#'user/foo\n" "user=> (declare show)\n#'user/show\nuser=> (defn welcome [user-name] (prn (show) user-name))\n#'user/welcome\nuser=> (defn show [] (prn \"welcome \"))\n#'user/show\nuser=> (welcome \"lu4nx\")\n\"welcome \"\nnil \"lu4nx\"\nnil\nuser=> " "; def will do too.\nuser=> (def show)\n#'user/show\nuser=> (defn welcome [user-name] (prn (show) user-name))\n#'user/welcome\nuser=> (defn show [] (prn \"welcome\"))\n#'user/show\nuser=> (welcome \"lu4nx\")\n\"welcome\"\nnil \"lu4nx\"\nnil" ";;Declare (like \"def\") has a natural partner in \"var\".\n;;Consider trying to embed a to-be-defined function in a data structure:\n\n(declare foo)\n(def bar {:handy-fn foo})\n(defn foo [] 42)\n((:handy-fn bar))\n;;IllegalStateException Attempting to call unbound fn: #'user/foo  clojure.lang.Var$Unbound.throwArity (Var.java:43)\n\n;;:handy-fn in bar is now permanently linked to the unbound var\n;; present when the def was evaluated. This can be avoided\n;; by not evaluating foo when creating bar.\n\n(declare foo)\n;;(def bar {:handy-fn (var foo)})\n(def bar {:handy-fn #'foo})\n(defn foo [] 42)\n((:handy-fn bar))\n;; 42"], :macro true, :notes nil, :arglists ["& names"], :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/declare"}, :clojure.core/symbol {:added "1.0", :ns "clojure.core", :name "symbol", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/var :clojure.core/var? :clojure.core/symbol? :clojure.core/name :clojure.core/namespace :clojure.core/keyword :clojure.core/resolve], :line 574, :examples [";; Returns a symbol with the given namespace and name.\n;;\n;; (symbol name): name can be a string or a symbol.\n;;\n;; (symbol ns name): ns and name must both be strings.\n;;\n;; A symbol string begins with a non-numeric character and can contain\n;; alphanumeric characters and *, +, !, -, _, and ?.  (see\n;; http://clojure.org/reader for details).\n;;\n;; symbol does not validate input strings for ns and name, and may return\n;; improper symbols with undefined behavior for non-conformant ns and\n;; name.\n\nuser=> (symbol 'foo)\nfoo\n\nuser=> (symbol \"foo\")\nfoo\n\nuser=> (symbol \"clojure.core\" \"foo\")\nclojure.core/foo\n" ";; some gotchas to be aware of:\n\nuser=> (symbol \"user\" 'abc)\nClassCastException clojure.lang.Symbol cannot be cast to java.lang.String  clojure.core/symbol (core.clj:523)\n\nuser=> (symbol *ns* \"abc\")\nClassCastException clojure.lang.Namespace cannot be cast to java.lang.String  clojure.core/symbol (core.clj:523)\n\nuser=> (symbol 'user \"abc\")\nClassCastException clojure.lang.Symbol cannot be cast to java.lang.String  clojure.core/symbol (core.clj:523)\n\n\n;; Warning - the following generated symbols are non-conformant and may wreak\n;; serious havoc in the near/far future when least expected...\n\nuser=> (symbol \"abc def\")\nabc def\n\nuser=> (symbol \"123def\")\n123def\n\nuser=> (symbol \"/123/def/ghi\")\n/123/def/ghi\n\nuser=> (symbol \"/abc/def/ghi\")\n/abc/def/ghi" ";; but keywords and numbers are not names\n(symbol 3)\n;; Long cannot be cast to String\n\n;; ... and so they cannot be converted to symbols\n(symbol :dog) \n;; Keyword cannot be cast to String"], :notes nil, :tag "clojure.lang.Symbol", :arglists ["name" "ns name"], :doc "Returns a Symbol with the given namespace and name.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/symbol"}, :clojure.test/test-var {:added "1.1", :ns "clojure.test", :name "test-var", :file "clojure/test.clj", :type "function", :column 1, :see-alsos nil, :dynamic true, :line 707, :examples nil, :notes nil, :arglists ["v"], :doc "If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).", :library-url "https://github.com/clojure/clojure", :href "/clojure.test/test-var"}, :clojure.core/conj! {:added "1.1", :ns "clojure.core", :name "conj!", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/transient :clojure.core/assoc! :clojure.core/dissoc! :clojure.core/conj], :line 3350, :examples [";; As seen on http://clojure.org/transients\n;; array is initially made transient, modified then\n;; finally made persistent.\n\n;; Note: This example correctly always uses the return value of conj! for\n;; future modifications, not the original value of v.  See assoc! examples\n;; for some discussion of why this is important.\n\n(defn vrange2 [n]\n  (loop [i 0 v (transient [])]\n    (if (< i n)\n      (recur (inc i) (conj! v i))\n      (persistent! v))))\n\nuser=> (vrange2 10)\n[0 1 2 3 4 5 6 7 8 9]"], :notes nil, :arglists ["" "coll" "coll x"], :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/conj!"}, :clojure.core/to-array-2d {:added "1.0", :ns "clojure.core", :name "to-array-2d", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/to-array], :line 3969, :examples ["user> (def a (to-array-2d [[1 2 3][4 5 6]]))\n#'user/a\nuser> (alength a)\n2\nuser> (alength (aget a 0))\n3\nuser> (aget a 0 0)\n1\nuser> (aget a 0 1)\n2\nuser> (aget a 0 2)\n3\nuser> (aget a 1 0)\n4\nuser> (aget a 2 0)\nâ†’ ERROR\nnil\n\nuser> " ";; quick example of a ragged array where the length of each element of the \n;; 2d array is unique\n\nuser=> (def a (to-array-2d [[0][1 2][3 4 5][6 7 8 9]]))\n#'user/a\nuser=> (map alength [(aget a 0)(aget a 1)(aget a 2)])\n(1 2 3)\nuser=>\nuser=> (aget a 0 2)\nArrayIndexOutOfBoundsException   java.lang.reflect.Array.get (Array.java:-2)"], :notes nil, :tag "[[Ljava.lang.Object;", :arglists ["coll"], :doc "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/to-array-2d"}, :clojure.reflect/ClassResolver {:ns "clojure.reflect", :name "ClassResolver", :file "clojure/reflect/java.clj", :type "var", :column 1, :see-alsos [:clojure.reflect/resolve-class], :line 184, :examples ["(require '[clojure.reflect :as cr]) \n\n;; Let us see what is available in the JavaReflector\n(->> clojure.reflect.ClassResolver \n     cr/reflect\n     :members\n     (sort-by :name)\n     (pp/print-table [:name :flags :parameter-types])\n; |         :name |               :flags |   :parameter-types |\n; |---------------+----------------------+--------------------|\n; | resolve_class | #{:public :abstract} | [java.lang.Object] |\n;;=> nil\n"], :notes nil, :arglists [], :doc nil, :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/ClassResolver"}, :clojure.core.logic/-fixc {:ns "clojure.core.logic", :name "-fixc", :file "clojure/core/logic.clj", :type "function", :column 1, :see-alsos nil, :line 2843, :examples nil, :notes nil, :arglists ["x f reifier" "x f runnable reifier"], :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/-fixc"}, :clojure.string/index-of {:added "1.8", :ns "clojure.string", :name "index-of", :file "clojure/string.clj", :type "function", :column 1, :see-alsos [:clojure.string/last-index-of], :line 318, :examples ["(use '[clojure.string :only [index-of]])\n\n(index-of \"ababc\" \"\")\n;;=> 0\n\n(index-of \"ababc\" \"a\")\n;;=> 0\n\n(index-of \"ababc\" \"ab\")\n;;=> 0\n\n(index-of \"ababc\" \"ab\" 1)\n;;=> 2\n\n(index-of \"ababc\" \"abc\")\n;;=> 2\n\n(index-of \"ababc\" \"abcd\")\n;;=> nil\n\n(index-of \"ababc\" \\c)\n;;=> 4\n\n\n;; same as .indexOf method\n\n(.indexOf \"ababc\" \"ab\")\n;;=> 0\n\n(.indexOf \"ababc\" \"ab\" 1)\n;;=> 2\n\n\n;; different from .indexOf method\n\n(.indexOf \"ababc\" \"abcd\")\n;;=> -1\n\n(.indexOf \"ababc\" \\c)\n;;=> IllegalArgumentException No matching method found: indexOf for class java.lang.String  clojure.lang.Reflector.invokeMatchingMethod (Reflector.java:80)\n\n" ";; Also works with other java.lang.CharSequence impls:\n\n(import 'java.lang.StringBuffer)\n(require '[clojure.string :as s])\n\n(s/index-of (StringBuffer. \"Bonjure Clojure\") \\j)\n;; 3"], :notes nil, :arglists ["s value" "s value from-index"], :doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.", :library-url "https://github.com/clojure/clojure", :href "/clojure.string/index-of"}, :clojure.core/mod {:added "1.0", :ns "clojure.core", :name "mod", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/rem :clojure.core/quot :clojure.core//], :line 3558, :examples ["user=> (mod 10 5)\n0\n\nuser=> (mod 10 6)\n4\n\nuser=> (mod 10 10)\n0\n\nuser=> (mod 10 -1)\n0\n\n;; The mod function is defined as the amount by which a number exceeds the\n;; largest integer multiple of the divisor that is not greater than that number.\n;; The largest integer multiple of 5 not greater than -2 is 5 * -1 = -5.\n;; The amount by which -2 exceeds -5 is 3. \n;;\nuser=> (mod -2  5) \n3" ";; Per rem docs: https://clojuredocs.org/clojure.core/rem#example-542692c8c026201cdc3269e1\n\n;; rem and mod are commonly used to get the remainder.\n;; mod means Gaussian mod, so the result is always\n;; non-negative.  Don't confuse it with ANSI C's %\n;; operator, which despite being pronounced\n;; 'mod' actually implements rem, i.e. -10 % 3 = -1.\n\nuser=> (mod -10 3)\n2\n\nuser=> (rem -10 3)\n-1" ";; It works for float / double numbers, too, where it is defined as\n;; (- n (* (Math/floor (/ n d)) d))\n\nuser=> (mod 1.5 1)\n;;=> 0.5\n\nuser=> (mod 475.095 7)\n;;=> 6.095000000000027\n\nuser=> (mod 1024.8402 5.12)\n;;=> 0.8402000000000953\n\nuser=> (mod -1024.8402 5.12)\n;;=> 4.279799999999905\n\nuser=> (let [n 1024.8402\n             d 5.12\n             q (Math/floor (/ n d))\n             r (mod n d)]\n         (->> (* q d) (+ r) (- n)))\n;;=> 0.0\n"], :notes ["The difference between **rem** and **mod** can be remembered by noting that **mod** always returns a value between 0 and div." "I am confused by the comment about the definition on lines 13+ of the example - which is not accurate when invoking mod when 'num' is positive and 'div' negative. Applying the definition to <pre>(mod 10 -3)</pre> we have \r\n<li> the largest multiple of -3 not exceeding 10 is 9, from using -3 as a multiplier</li>\r\n<li> however (mod 10 -3) yields -2, meaning that 10 exceeds the largest multiple not greater than 10 by -2 i.e. 10 - -2 = 12 is the largest multiple &lt;= 10, a contradiction.</li>\r\n<li> therefore (mod 10 -3) should yield 1, not -2 </li>\r\n\r\n<i>So unless I misunderstood</i>, the definition should be changed to something like: <br>\r\n<p>\"The mod function is defined as the amount by which a number exceeds the largest integer multiple of the divisor that is not greater than that number, <i>except when the number is positive and the divisor negative, in which case the result is the amount by which the number exceeds the smallest multiple that is not smaller than the number.</i>\"</p>\r\n\r\n<b>Or, change the implementation to something similar to</b>:\r\n\r\n<pre>(defn mod-2\r\n\t  [num div]\r\n\t  (let [m (rem num div)]\r\n\t    (if (or (zero? m) (= (pos? num) (pos? div)))\r\n\t     \tm\r\n\t     \t(if (pos? div) (+ m div) m)))) \r\n</pre>\r\n\t     \t\r\nto fit the current definition."], :arglists ["num div"], :doc "Modulus of num and div. Truncates toward negative infinity.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/mod"}, :clojure.walk/prewalk-demo {:added "1.1", :ns "clojure.walk", :name "prewalk-demo", :file "clojure/walk.clj", :type "function", :column 1, :see-alsos [:clojure.walk/prewalk], :line 86, :examples ["(use 'clojure.walk)\n\nuser> (prewalk-demo [[1 2] [3 4 [5 6]] [7 8]])\nWalked: [[1 2] [3 4 [5 6]] [7 8]]\nWalked: [1 2]\nWalked: 1\nWalked: 2\nWalked: [3 4 [5 6]]\nWalked: 3\nWalked: 4\nWalked: [5 6]\nWalked: 5\nWalked: 6\nWalked: [7 8]\nWalked: 7\nWalked: 8\n[[1 2] [3 4 [5 6]] [7 8]]\n\nuser> (prewalk-demo {:a 1 :b 2})\nWalked: {:a 1, :b 2}\nWalked: [:a 1]\nWalked: :a\nWalked: 1\nWalked: [:b 2]\nWalked: :b\nWalked: 2\n{:a 1, :b 2}"], :notes nil, :arglists ["form"], :doc "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.", :library-url "https://github.com/clojure/clojure", :href "/clojure.walk/prewalk-demo"}, :clojure.reflect/map->Method {:ns "clojure.reflect", :name "map->Method", :file "clojure/reflect/java.clj", :type "function", :column 1, :see-alsos [:clojure.reflect/map->Constructor :clojure.reflect/map->Field], :line 128, :examples ["(require '[clojure.reflect :as cr])\n\n;; I have no idea what this is for but here is what it does.\n(cr/map->Method {}) \n;=> #clojure.reflect.Method{:name nil, :return-type nil, \n;;                          :declaring-class nil, :parameter-types nil,\n;;                          :exception-types nil, :flags nil}"], :notes nil, :arglists ["m__7585__auto__"], :doc "Factory function for class clojure.reflect.Method, taking a map of keywords to field values.", :library-url "https://github.com/clojure/clojure", :href "/clojure.reflect/map->Method"}, :clojure.spec.alpha/inst-in {:ns "clojure.spec.alpha", :name "inst-in", :file "clojure/spec/alpha.clj", :type "macro", :column 1, :see-alsos nil, :line 1844, :examples nil, :macro true, :notes nil, :arglists ["start end"], :doc "Returns a spec that validates insts in the range from start\n(inclusive) to end (exclusive).", :library-url "https://github.com/clojure/clojure", :href "/clojure.spec.alpha/inst-in"}, :clojure.core.logic/is {:ns "clojure.core.logic", :name "is", :file "clojure/core/logic.clj", :type "macro", :column 1, :see-alsos nil, :line 1344, :examples nil, :macro true, :notes nil, :arglists ["u v op"], :doc "Set the value of a var to value of another var with the operation\n   applied. Non-relational.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core.logic/is"}, :clojure.core/get-in {:added "1.2", :ns "clojure.core", :name "get-in", :file "clojure/core.clj", :static true, :type "function", :column 1, :see-alsos [:clojure.core/assoc-in :clojure.core/update-in :clojure.core/find :clojure.core/get :clojure.core/->], :line 6062, :examples [";; We can use get-in for reaching into nested maps:\nuser=> (def m {:username \"sally\"\n               :profile {:name \"Sally Clojurian\"\n                         :address {:city \"Austin\" :state \"TX\"}}})\n#'user/m\n\nuser=> (get-in m [:profile :name])\n\"Sally Clojurian\"\nuser=> (get-in m [:profile :address :city])\n\"Austin\"\nuser=> (get-in m [:profile :address :zip-code])\nnil\nuser=> (get-in m [:profile :address :zip-code] \"no zip code!\")\n\"no zip code!\"\n\n\n;; Vectors are also associative:\nuser=> (def v [[1 2 3]\n               [4 5 6]\n               [7 8 9]])\n#'user/v\nuser=> (get-in v [0 2])\n3\nuser=> (get-in v [2 1])\n8\n\n\n;; We can mix associative types:\nuser=> (def mv {:username \"jimmy\"\n                :pets [{:name \"Rex\"\n                        :type :dog}\n                       {:name \"Sniffles\"\n                        :type :hamster}]})\n#'user/mv\nuser=> (get-in mv [:pets 1 :type])\n:hamster\n" "(def s1 [[:000-00-0000 \"TYPE 1\" \"JACKSON\" \"FRED\"]\n         [:000-00-0001 \"TYPE 2\" \"SIMPSON\" \"HOMER\"]\n         [:000-00-0002 \"TYPE 4\" \"SMITH\" \"SUSAN\"]])\n\n(def cols [0 2 3])\n\n(defn f1 \n  [s1 col] \n  (map #(get-in s1 [% col] nil) (range (count s1))))\n\n(apply interleave (map (partial f1 s1) cols))\n\n(:000-00-0000 \"JACKSON\" \"FRED\" :000-00-0001 \"SIMPSON\" \"HOMER\" :000-00-0002 \"SMITH\" \"SUSAN\")" ";; spam link removed" ";; Introduction of references is jarring to get-in usage\n\n(def owners [{:owner \"Jimmy\"\n              :pets (ref [{:name \"Rex\"\n                           :type :dog}\n                          {:name \"Sniffles\"\n                           :type :hamster}])} \n              {:owner \"Jacky\" \n               :pets (ref [{:name \"Spot\" \n                            :type :mink}\n                           {:name \"Puff\" \n                            :type :magic-dragon}])}])\n;;=> 'user/owners\n\n(get-in owners [0 :pets])\n;;=> #<Ref@: [{:name \"Rex\", :type :dog} {:name \"Sniffles\", :type :hamster}>\n\n;; In order to go deeper the get needs to be split \n;; as the deref cannot be used as part of the get.\n(-> (get-in owners [0 :pets]) deref (get-in [1 :type]))\n;;=> :hamster\n\n;; At this point it clear that the thread operator \n;; can be used to produce similar results. \n(-> owners (nth 0) :pets deref (nth 1) :type)\n;;=> :hamster" ";; If the nested structure contains list, it does not work, because list is \n;; not an associative structure.\n(def a {:a '({:b1 2} {:b2 4}) :c 3})\n;;=> 'user/a\n(get-in a [:a 0 :b])\n;;=> nil" ";; If an empty sequence is used as keys, the whole structure is returned.\n(get-in {:a 1 :b 2} [])\n;;=> {:a 1, :b 2}\n(get-in {:a 1, :b 2} '())\n;;=> {:a 1, :b 2}\n\n;; nil also counts as an empty sequence!\n(get-in {:a 1 :b 2} nil)\n;;=> {:a 1, :b 2}\n\n;; Be careful if you use a nill-able key sequence with not-found value.\n;; This can be a source of bug.\n(get-in {:a 1 :b 2} nil :nothing)\n;;=> {:a 1, :b 2}" ";;practical example\n\n(def employee\n  {:name \"John\"\n   :details {:email \"info@domain.com\"\n             :phone \"555-144-300\"}})\n\n(get-in employee [:details :email])\n;;\"info@domain.com\""], :notes nil, :arglists ["m ks" "m ks not-found"], :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/get-in"}, :clojure.core/* {:added "1.2", :ns "clojure.core", :name "*", :file "clojure/core.clj", :type "function", :column 1, :see-alsos [:clojure.core/*' :clojure.core/unchecked-multiply], :line 1000, :examples [";; there is an implicit 1\n(*)\n;;=> 1 \n\n;; the implicit 1 comes into play\n(* 6)\n;;=> 6\n\n(* 2 3)\n;;=> 6\n\n(* 2 3 4)\n;;=> 24\n\n(* 0.5 200)\n;;=> 100.0\n\n(* 1234567890 9876543210)\n;; ArithmeticException integer overflow"], :notes nil, :arglists ["" "x" "x y" "x y & more"], :doc "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", :library-url "https://github.com/clojure/clojure", :href "/clojure.core/*"}}