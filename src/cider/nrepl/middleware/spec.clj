(ns cider.nrepl.middleware.spec
  (:require [cider.nrepl.middleware.util.error-handling :refer [with-safe-transport]]
            [cider.nrepl.middleware.util.spec :as spec-utils]
            [clojure.tools.nrepl
             [middleware :refer [set-descriptor!]]
             [misc :refer [response-for]]]
            [cider.nrepl.middleware.util.cljs :as cljs]
            [clojure.string :as str]
            [clojure.walk :as walk]
            [clojure.pprint :as pp]
            [clojure.string :as str]))

(defn str-non-colls
  "Given a form, convert all non collection childs to str."
  [form]
  (walk/postwalk #(if (coll? %)
                    %
                    (str %))
                 form))

(defn spec-list
  "Retrieves a list of all specs in the registry, sorted by ns/name.
  If filter-regex is not empty, keep only the specs with that prefix."
  [filter-regex]
  (let [sorted-specs (->> (spec-utils/registry)
                          keys
                          (map str) 
                          sort)]
    (if (not-empty filter-regex)
      (filter (fn [spec-symbol-str]
                (let [checkable-part (if (.startsWith ^String spec-symbol-str ":")
                                       (subs spec-symbol-str 1)
                                       spec-symbol-str)]
                  (re-find (re-pattern filter-regex) checkable-part)))
              sorted-specs)
      sorted-specs)))


(defn get-multi-spec-sub-specs
  "Given a multi-spec form, call its multi method methods to retrieve
  its subspecs."
  [multi-spec-form]
  (let [[_ multi-method-symbol & _] multi-spec-form]
   (->> @(resolve multi-method-symbol)
        methods 
        (map (fn [[spec-k method]]
               [spec-k (spec-utils/form (method nil))])))))

(defn add-multi-specs
  "Walk down a spec form and for every subform that is a multi-spec
  add its sub specs."
  [form]
  (walk/postwalk (fn [sub-form]
                   (if (and (coll? sub-form)
                            (symbol? (first sub-form))
                            (-> sub-form first name (= "multi-spec")))
                     (concat sub-form (get-multi-spec-sub-specs sub-form))
                     sub-form))
                 form))

(defn spec-from-string
  "Given a string like \"clojure.core/let\" or \":user/email\" returns
  the associated spec in the registry, if there is one."
  [s]
  (let [[spec-ns spec-kw] (str/split s #"/")]
    (if (.startsWith ^String spec-ns ":")
      (spec-utils/get-spec (keyword (subs spec-ns 1) spec-kw))
      (spec-utils/get-spec (symbol s)))))

(defn spec-form
  "Given a spec symbol as a string, get the spec form and prepare it for
  a response."
  [spec-name]
  (-> (spec-utils/form (spec-from-string spec-name))
      add-multi-specs
      str-non-colls))

(defn spec-example
  "Given a spec symbol as a string, returns a string with a pretty printed
  example generated by the spec."
  [spec-name]
  (with-out-str
   (-> (spec-from-string spec-name)
       spec-utils/generate
       pp/pprint)))

;; Replies

(defn spec-list-reply [msg]
  {:spec-list (spec-list (:filter-regex msg))})

(defn spec-form-reply [msg]
  {:spec-form (spec-form (:spec-name msg))})

(defn spec-example-reply [msg]
  {:spec-example (spec-example (:spec-name msg))})

(defn wrap-spec
  "Middleware that provides clojure.spec browsing functionality."
  [handler]
  (with-safe-transport handler
    "spec-list" spec-list-reply
    "spec-form" spec-form-reply
    "spec-example" spec-example-reply))

(set-descriptor!
 #'wrap-spec
 (cljs/requires-piggieback
  {:handles
   {"spec-list"
    {:doc "Return a sorted list of all specs in the registry"
     :returns {"status" "done"
               "spec-list" "The sorted list of all specs in the registry with their descriptions"}
     :optional {"filter-regex" "Only the specs that matches filter prefix regex will be returned "}}

    "spec-form"
    {:doc "Return the form of a given spec"
     :requires {"spec-name" "The spec namespaced keyword we are looking for"}
     :returns {"status" "done"
               "spec-form" "The spec form"}}

    "spec-example"
    {:doc "Return a string with a pretty printed example for a spec"
     :requires {"spec-name" "The spec namespaced keyword we want the example for"}
     :returns {"status" "done"
               "example" "The pretty printed spec example string"}}}}))
