{"clojure.core/conj!" ["clojure.core/transient" "clojure.core/assoc!" "clojure.core/dissoc!"],
 "clojure.core/*in*" ["clojure.core/*out*"],
 "clojure.core/quot" ["clojure.core/rem" "clojure.core/mod"],
 "clojure.set/select" ["clojure.core/filter"],
 "clojure.core/try" ["clojure.core/catch" "clojure.core/finally" "clojure.core/throw"],
 "clojure.core/dorun" ["clojure.core/doall"],
 "clojure.core/number?" ["clojure.core/num"],
 "clojure.core/bit-shift-left" ["clojure.core/bit-shift-left" "clojure.core/unsigned-bit-shift-right" "clojure.core/bit-shift-right"],
 "clojure.core/shorts" ["clojure.core/short-array"],
 "clojure.core/shutdown-agents" ["clojure.core/send" "clojure.core/send-off" "clojure.core/agent" "clojure.core/agent-error"],
 "clojure.core/restart-agent" ["clojure.core/agent-error" "clojure.core/agent"],
 "clojure.core.async/<!!" ["clojure.core.async/<!" "clojure.core.async/take!"],
 "clojure.java.io/input-stream" ["clojure.java.io/reader" "clojure.java.io/output-stream" "clojure.java.io/IOFactory" "clojure.core/with-open" "clojure.java.io/make-input-stream"],
 "clojure.core/assoc-in" ["clojure.core/assoc" "clojure.core/update-in" "clojure.core/get-in"],
 "clojure.core/when-first" ["clojure.core/when-let"],
 "clojure.core/interpose" ["clojure.core/interleave" "clojure.string/join"],
 "clojure.core/print" ["clojure.core/pr" "clojure.core/println" "clojure.core/print-str"],
 "clojure.core/namespace" ["clojure.core/ns" "clojure.core/name"],
 "clojure.test/use-fixtures" ["clojure.test/join-fixtures" "clojure.test/compose-fixtures"],
 "clojure.java.io/file" ["clojure.core/file-seq" "clojure.java.io/reader" "clojure.java.io/writer" "clojure.java.io/delete-file"],
 "clojure.core/when" ["clojure.core/when-not" "clojure.core/when-let" "clojure.core/if"],
 "clojure.xml/emit-element" ["clojure.core/with-out-str" "clojure.xml/element"],
 "clojure.core.async/chan" ["clojure.core.async/buffer" "clojure.core.async/dropping-buffer" "clojure.core.async/sliding-buffer"],
 "clojure.core/*assert*" ["clojure.core/assert"],
 "clojure.test/deftest-" ["clojure.test/deftest"],
 "clojure.core/odd?" ["clojure.core/even?"],
 "clojure.core/unchecked-add" ["clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/declare" ["clojure.core/def"],
 "clojure.core/assoc!" ["clojure.core/dissoc!" "clojure.core/transient" "clojure.core/conj!"],
 "clojure.core/hash" ["clojure.core/get"],
 "clojure.inspector/inspect-tree" ["clojure.inspector/inspect-table"],
 "clojure.core/remove-ns" ["clojure.core/create-ns" "clojure.core/find-ns"],
 "clojure.core/proxy-super" ["clojure.core/proxy"],
 "clojure.core/partition-by" ["clojure.core/partition" "clojure.core/partition-all" "clojure.core/group-by"],
 "clojure.core/print-method" ["clojure.core/print-dup"],
 "clojure.core/refer" ["clojure.core/refer-clojure" "clojure.core/ns"],
 "clojure.core/deref" ["clojure.core/atom" "clojure.core/agent" "clojure.core/ref"],
 "clojure.repl/apropos" ["clojure.repl/source" "clojure.repl/doc" "clojure.repl/dir"],
 "clojure.string/join" ["clojure.core/split-at" "clojure.core/split-with" "clojure.core/interpose"],
 "clojure.core/finally" ["clojure.core/try" "clojure.core/catch"],
 "clojure.core/future-call" ["clojure.core/future"],
 "clojure.core/persistent!" ["clojure.core/transient"],
 "clojure.core/every-pred" ["clojure.core/some-fn"],
 "clojure.pprint/print-table" ["clojure.pprint/pprint" "clojure.inspector/inspect-table"],
 "clojure.core/var?" ["clojure.core/def" "clojure.core/var" "clojure.core/var-get" "clojure.core/var-set" "clojure.core/with-local-vars"],
 "clojure.core/bit-shift-right" ["clojure.core/bit-shift-left" "clojure.core/bit-xor" "clojure.core/bit-or" "clojure.core/bit-and" "clojure.core/bit-set" "clojure.core/bit-test" "clojure.core/bit-flip" "clojure.core/bit-and-not" "clojure.core/bit-clear" "clojure.core/unsigned-bit-shift-right"],
 "clojure.core.async/<!" ["clojure.core.async/take!" "clojure.core.async/<!!"],
 "clojure.core/commute" ["clojure.core/ref"],
 "clojure.core/reduce" ["clojure.core/reductions" "clojure.core/apply" "clojure.core/frequencies"],
 "clojure.core/filter" ["clojure.core/remove" "clojure.core/keep"],
 "clojure.core/replace" ["clojure.walk/prewalk-replace" "clojure.walk/postwalk-replace" "clojure.core/map"],
 "clojure.core/printf" ["clojure.core/format" "clojure.pprint/cl-format"],
 "clojure.core/zero?" ["clojure.core/pos?" "clojure.core/neg?"],
 "clojure.core/compare-and-set!" ["clojure.core/atom" "clojure.core/reset!" "clojure.core/swap!"],
 "clojure.core/while" ["clojure.core/loop"],
 "clojure.core/merge-with" ["clojure.core/merge"],
 "clojure.core/into-array" ["clojure.core/to-array" "clojure.core/make-array"],
 "clojure.core/load-string" ["clojure.core/read-string"],
 "clojure.zip/vector-zip" ["clojure.zip/seq-zip" "clojure.zip/xml-zip" "clojure.zip/next" "clojure.zip/end?"],
 "clojure.core/pmap" ["clojure.core/map" "clojure.core/future"],
 "clojure.core/not-any?" ["clojure.core/some" "clojure.core/every?"],
 "clojure.core/double-array" ["clojure.core/doubles" "clojure.core/aget" "clojure.core/aset" "clojure.core/aset-double"],
 "clojure.core/-" ["clojure.core/-'"],
 "clojure.core/send" ["clojure.core/shutdown-agents" "clojure.core/send-off" "clojure.core/agent"],
 "clojure.test/testing" ["clojure.test/is" "clojure.test/deftest"],
 "clojure.core/ref-history-count" ["clojure.core/ref-min-history" "clojure.core/ref-max-history" "clojure.core/ref"],
 "clojure.core/iterator-seq" ["clojure.core/seq"],
 "clojure.core/take-last" ["clojure.core/last" "clojure.core/butlast" "clojure.core/drop-last"],
 "clojure.core/->" ["clojure.core/->>" "clojure.core/as->"],
 "clojure.core/keep-indexed" ["clojure.core/map-indexed" "clojure.core/keep"],
 "clojure.core/empty" ["clojure.core/not-empty"],
 "clojure.core/repeatedly" ["clojure.core/repeat" "clojure.core/iterate" "clojure.core/lazy-seq" "clojure.core/dotimes" "clojure.core/doall" "clojure.core/rand-int" "clojure.core/constantly"],
 "clojure.core/some-fn" ["clojure.core/every-pred" "clojure.core/some"],
 "clojure.string/upper-case" ["clojure.string/lower-case" "clojure.string/capitalize"],
 "clojure.core/not" ["clojure.core/complement" "clojure.core/false?"],
 "clojure.core/defstruct" ["clojure.core/struct" "clojure.core/create-struct" "clojure.core/defrecord"],
 "clojure.core/binding" ["clojure.core/with-redefs" "clojure.core/with-bindings" "clojure.core/with-local-vars"],
 "clojure.core/vals" ["clojure.core/val" "clojure.core/keys"],
 "clojure.core/map-indexed" ["clojure.core/map" "clojure.core/keep-indexed"],
 "clojure.core/agent-error" ["clojure.core/agent" "clojure.core/restart-agent" "clojure.core/set-error-handler!"],
 "clojure.core/reverse" ["clojure.core/rseq"],
 "clojure.core/iterate" ["clojure.core/cycle" "clojure.core/repeatedly" "clojure.core/repeat"],
 "clojure.core/fn" ["clojure.core/defn"],
 "clojure.core/ns-refers" ["clojure.core/ns-map"],
 "clojure.string/capitalize" ["clojure.string/upper-case" "clojure.string/lower-case"],
 "clojure.core/num" ["clojure.core/number?"],
 "clojure.core/set" ["clojure.core/hash-set" "clojure.core/sorted-set" "clojure.core/conj" "clojure.set/join" "clojure.set/select" "clojure.set/difference" "clojure.set/intersection" "clojure.set/union" "clojure.set/index" "clojure.set/project" "clojure.set/rename" "clojure.set/rename-keys" "clojure.set/map-invert" "clojure.core/disj" "clojure.core/distinct"],
 "clojure.core/*clojure-version*" ["clojure.core/clojure-version"],
 "clojure.core/future-cancelled?" ["clojure.core/future" "clojure.core/future?" "clojure.core/future-cancel" "clojure.core/future-done?"],
 "clojure.core/not-every?" ["clojure.core/every?" "clojure.core/not-any?" "clojure.core/some"],
 "clojure.core/identity" ["clojure.core/nil?"],
 "clojure.core/sorted-map" ["clojure.core/sorted-map-by" "clojure.core/subseq" "clojure.core/rsubseq" "clojure.core/sorted-set" "clojure.core/array-map" "clojure.core/hash-map"],
 "clojure.core/==" ["clojure.core/=" "clojure.core/identical?"],
 "clojure.core/juxt" ["clojure.core/partial" "clojure.core/comp"],
 "clojure.core/derive" ["clojure.core/parents" "clojure.core/ancestors" "clojure.core/descendants" "clojure.core/isa?" "clojure.core/make-hierarchy" "clojure.core/underive"],
 "clojure.core/alter-var-root" ["clojure.core/with-redefs" "clojure.core/with-redefs-fn" "clojure.core/intern" "clojure.core/var"],
 "clojure.core/partition" ["clojure.core/partition-all" "clojure.core/split-at" "clojure.core/partition-by"],
 "clojure.core/ints" ["clojure.core/int-array"],
 "clojure.repl/source-fn" ["clojure.repl/source"],
 "clojure.core/class" ["clojure.core/type" "clojure.core/class?" "clojure.core/instance?"],
 "clojure.core/remove" ["clojure.core/filter"],
 "clojure.core/subvec" ["clojure.core/vector" "clojure.core/vector?"],
 "clojure.core/distinct" ["clojure.core/distinct?"],
 "clojure.walk/postwalk" ["clojure.walk/prewalk" "clojure.walk/postwalk-demo" "clojure.walk/postwalk-replace"],
 "clojure.core/defmethod" ["clojure.core/defmulti" "clojure.core/remove-method" "clojure.core/remove-all-methods" "clojure.core/prefers" "clojure.core/methods" "clojure.core/get-method"],
 "clojure.test/join-fixtures" ["clojure.test/use-fixtures" "clojure.test/compose-fixtures"],
 "clojure.core/instance?" ["clojure.core/type" "clojure.core/supers" "clojure.core/doto" "clojure.core/class"],
 "clojure.java.shell/with-sh-dir" ["clojure.java.shell/sh"],
 "clojure.core/short" ["clojure.core/int" "clojure.core/byte" "clojure.core/shorts" "clojure.core/short-array"],
 "clojure.core/unchecked-subtract" ["clojure.core/unchecked-add" "clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/disj" ["clojure.core/dissoc" "clojure.core/disj!" "clojure.set/difference"],
 "clojure.core/sorted-map-by" ["clojure.core/sorted-map" "clojure.core/subseq" "clojure.core/rsubseq" "clojure.core/sorted-set-by"],
 "clojure.core/split-with" ["clojure.core/split-at" "clojure.string/split" "clojure.core/take-while" "clojure.core/drop-while"],
 "clojure.core/dotimes" ["clojure.core/repeat" "clojure.core/for" "clojure.core/doseq"],
 "clojure.core/await" ["clojure.core/await-for"],
 "clojure.core/supers" ["clojure.core/type" "clojure.core/instance?" "clojure.core/bases" "clojure.core/ancestors"],
 "clojure.test/is" ["clojure.test/are" "clojure.test/deftest"],
 "clojure.core/cond->" ["clojure.core/cond->>" "clojure.core/->" "clojure.core/->>" "clojure.core/as->" "clojure.core/some->" "clojure.core/some->>" "clojure.core/cond"],
 "clojure.core/interleave" ["clojure.core/interpose" "clojure.core/zipmap"],
 "clojure.core/sorted?" ["clojure.core/sorted-map" "clojure.core/sorted-set"],
 "clojure.string/trim-newline" ["clojure.string/trim" "clojure.string/triml" "clojure.string/trimr"],
 "clojure.core/vector-of" ["clojure.core/vec" "clojure.core/vector" "clojure.core/vector?"],
 "clojure.core/delay?" ["clojure.core/delay"],
 "clojure.core/defprotocol" ["clojure.core/reify" "clojure.core/extend-type" "clojure.core/extend-protocol" "clojure.core/extends?" "clojure.core/satisfies?"],
 "clojure.inspector/inspect-table" ["clojure.pprint/print-table" "clojure.inspector/inspect-tree"],
 "clojure.core/repeat" ["clojure.core/repeatedly" "clojure.core/cycle" "clojure.core/constantly" "clojure.core/dotimes"],
 "clojure.core/unchecked-remainder" ["clojure.core/unchecked-add" "clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/class?" ["clojure.core/class"],
 "clojure.core/ns-map" ["clojure.core/ns-interns" "clojure.core/ns-publics" "clojure.core/ns-refers" "clojure.core/ns-imports"],
 "clojure.core/unchecked-negate" ["clojure.core/unchecked-add" "clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/extend-type" ["clojure.core/extend" "clojure.core/extend-protocol" "clojure.core/defprotocol"],
 "clojure.core/rand-nth" ["clojure.core/rand"],
 "clojure.core/import" ["clojure.core/require" "clojure.core/use" "clojure.core/ns"],
 "clojure.string/trim" ["clojure.string/triml" "clojure.string/trimr" "clojure.string/trim-newline"],
 "clojure.core/neg?" ["clojure.core/pos?" "clojure.core/zero?"],
 "clojure.core/take" ["clojure.core/drop" "clojure.core/take-while" "clojure.core/take-last" "clojure.core/take-nth"],
 "clojure.walk/prewalk-demo" ["clojure.walk/prewalk"],
 "clojure.core/require" ["clojure.core/remove-ns" "clojure.core/import" "clojure.core/use" "clojure.core/ns"],
 "clojure.core/case" ["clojure.core/cond" "clojure.core/condp"],
 "clojure.core/to-array" ["clojure.core/alength" "clojure.core/char-array" "clojure.core/int-array" "clojure.core/long-array" "clojure.core/into-array" "clojure.core/make-array" "clojure.core/to-array-2d"],
 "clojure.reflect/reflect" ["clojure.pprint/print-table"],
 "clojure.core/with-bindings" ["clojure.core/with-bindings*" "clojure.core/with-local-vars" "clojure.core/binding" "clojure.core/with-redefs"],
 "clojure.core/sync" ["clojure.core/dosync"],
 "clojure.java.javadoc/javadoc" ["clojure.repl/doc"],
 "clojure.core/set-validator!" ["clojure.core/atom" "clojure.core/agent" "clojure.core/ref"],
 "clojure.core/meta" ["clojure.core/with-meta" "clojure.core/*print-meta*"],
 "clojure.core/ref-set" ["clojure.core/ref"],
 "clojure.core/booleans" ["clojure.core/boolean-array"],
 "clojure.core/keep" ["clojure.core/keep-indexed" "clojure.core/map" "clojure.core/filter"],
 "clojure.core/cycle" ["clojure.core/lazy-seq"],
 "clojure.zip/lefts" ["clojure.zip/rights"],
 "clojure.java.io/copy" ["clojure.java.io/file"],
 "clojure.core/false?" ["clojure.core/not"],
 "clojure.core/comp" ["clojure.core/partial" "clojure.core/juxt"],
 "clojure.core/print-dup" ["clojure.core/print-ctor" "clojure.core/print-method"],
 "clojure.core/transient" ["clojure.core/persistent!" "clojure.core/conj!" "clojure.core/assoc!" "clojure.core/pop!" "clojure.core/dissoc!" "clojure.core/disj!"],
 "clojure.core/first" ["clojure.core/rest" "clojure.core/next" "clojure.core/nth" "clojure.core/second" "clojure.core/take" "clojure.core/ffirst"],
 "clojure.core/with-redefs" ["clojure.core/with-redefs-fn" "clojure.core/alter-var-root" "clojure.core/with-bindings"],
 "clojure.core/use" ["clojure.core/refer" "clojure.core/require" "clojure.core/ns" "clojure.core/import"],
 "clojure.core/keys" ["clojure.core/vals" "clojure.core/hash-map" "clojure.core/key" "clojure.core/defn"],
 "clojure.core/deftype" ["clojure.core/definterface" "clojure.core/defprotocol"],
 "clojure.core/defmulti" ["clojure.core/defmethod" "clojure.core/remove-method" "clojure.core/remove-all-methods" "clojure.core/prefers" "clojure.core/methods" "clojure.core/get-method" "clojure.core/defprotocol"],
 "clojure.core/with-meta" ["clojure.core/vary-meta" "clojure.core/meta" "clojure.core/alter-meta!"],
 "clojure.core/future?" ["clojure.core/future"],
 "clojure.core/some->>" ["clojure.core/->>" "clojure.core/some->"],
 "clojure.string/replace-first" ["clojure.string/replace" "clojure.core/re-pattern" "clojure.core/subs"],
 "clojure.core/*read-eval*" ["clojure.core/read" "clojure.core/read-string" "clojure.core/load"],
 "clojure.core/spit" ["clojure.core/slurp" "clojure.java.io/writer" "clojure.core/load-file"],
 "clojure.core/nfirst" ["clojure.core/next"],
 "clojure.core/longs" ["clojure.core/long-array"],
 "clojure.core/alter" ["clojure.core/ref" "clojure.core/commute"],
 "clojure.core/bytes" ["clojure.core/byte-array"],
 "clojure.core/prefer-method" ["clojure.core/prefers" "clojure.core/get-method" "clojure.core/methods"],
 "clojure.zip/seq-zip" ["clojure.zip/xml-zip" "clojure.zip/vector-zip"],
 "clojure.core/cond" ["clojure.core/condp" "clojure.core/case" "clojure.core/if"],
 "clojure.core/unquote" ["clojure.core/unquote-splicing"],
 "clojure.core/trampoline" ["clojure.core/loop" "clojure.core/recur"],
 "clojure.core/char?" ["clojure.core/char"],
 "clojure.core/second" ["clojure.core/first" "clojure.core/nth" "clojure.core/fnext" "clojure.core/next"],
 "clojure.core/ref-min-history" ["clojure.core/ref" "clojure.core/ref-max-history" "clojure.core/ref-history-count"],
 "clojure.core/peek" ["clojure.core/first" "clojure.core/pop" "clojure.core/conj"],
 "clojure.core/type" ["clojure.core/class" "clojure.core/supers" "clojure.core/instance?"],
 "clojure.string/trimr" ["clojure.string/trim" "clojure.string/triml"],
 "clojure.core/aset-double" ["clojure.core/double-array"],
 "clojure.core/for" ["clojure.core/doseq" "clojure.core/doall" "clojure.core/recur"],
 "clojure.core/find" ["clojure.core/get" "clojure.core/get-in"],
 "clojure.core/fnext" ["clojure.core/ffirst" "clojure.core/second"],
 "clojure.core/ref" ["clojure.core/alter" "clojure.core/ref-set" "clojure.core/add-watch" "clojure.core/dosync" "clojure.core/commute" "clojure.core/ensure" "clojure.core/ref-history-count" "clojure.core/ref-min-history" "clojure.core/ref-max-history" "clojure.core/set-validator!"],
 "clojure.core/future-cancel" ["clojure.core/future" "clojure.core/future?" "clojure.core/future-cancelled?" "clojure.core/future-done?"],
 "clojure.core/nthrest" ["clojure.core/drop" "clojure.core/nthnext" "clojure.core/nth"],
 "clojure.core/with-local-vars" ["clojure.core/with-bindings"],
 "clojure.core/memoize" ["clojure.core/delay"],
 "clojure.core/agent" ["clojure.core/set-error-handler!" "clojure.core/send" "clojure.core/send-off" "clojure.core/release-pending-sends" "clojure.core/agent-error" "clojure.core/restart-agent" "clojure.core/add-watch" "clojure.core/set-error-mode!" "clojure.core/set-validator!"],
 "clojure.set/superset?" ["clojure.set/subset?" "clojure.core/set"],
 "clojure.core/some->" ["clojure.core/some->>" "clojure.core/->" "clojure.core/cond->" "clojure.core/cond->>" "clojure.core/as->" "clojure.core/->>"],
 "clojure.core/bit-test" ["clojure.core/bit-set" "clojure.core/bit-shift-left" "clojure.core/bit-xor"],
 "clojure.core/*out*" ["clojure.core/*in*"],
 "clojure.core/sorted-set-by" ["clojure.core/sorted-set" "clojure.core/sorted-map-by" "clojure.core/compare"],
 "clojure.core/with-in-str" ["clojure.core/with-out-str"],
 "clojure.core/test" ["clojure.core/var" "clojure.core/meta" "clojure.core/assert" "clojure.test/with-test"],
 "clojure.core/remove-method" ["clojure.core/get-method" "clojure.core/methods" "clojure.core/remove-all-methods" "clojure.core/prefers" "clojure.core/defmulti" "clojure.core/defmethod"],
 "clojure.core/list?" ["clojure.core/seq?" "clojure.core/sequential?" "clojure.core/coll?"],
 "clojure.repl/pst" ["clojure.core/*e"],
 "clojure.xml/parse" ["clojure.xml/emit-element" "clojure.core/with-out-str" "clojure.xml/element"],
 "clojure.core/with-bindings*" ["clojure.core/with-bindings"],
 "clojure.core/update-in" ["clojure.core/assoc-in" "clojure.core/get-in" "clojure.core/fnil"],
 "clojure.core/loop" ["clojure.core/recur" "clojure.core/trampoline" "clojure.core/when" "clojure.core/while"],
 "clojure.core/to-array-2d" ["clojure.core/to-array"],
 "clojure.core/reset!" ["clojure.core/swap!" "clojure.core/compare-and-set!" "clojure.core/atom"],
 "clojure.java.io/make-input-stream" ["clojure.java.io/IOFactory"],
 "clojure.core/promise" ["clojure.core/realized?" "clojure.core/future" "clojure.core/deliver"],
 "clojure.core/satisfies?" ["clojure.core/extend" "clojure.core/defprotocol"],
 "clojure.core/print-str" ["clojure.core/println-str" "clojure.core/print"],
 "clojure.core/nil?" ["clojure.core/identity"],
 "clojure.inspector/atom?" ["clojure.core/isa?"],
 "clojure.core/pop!" ["clojure.core/assoc!" "clojure.core/dissoc!"],
 "clojure.core/when-let" ["clojure.core/if-let" "clojure.core/when" "clojure.core/when-not" "clojure.core/if" "clojure.core/when-first"],
 "clojure.core/mod" ["clojure.core/rem"],
 "clojure.string/split-lines" ["clojure.string/split"],
 "clojure.core/eval" ["clojure.core/read-string"],
 "clojure.core/if" ["clojure.core/cond" "clojure.core/when" "clojure.core/if-let" "clojure.core/if-not"],
 "clojure.core/if-let" ["clojure.core/when-let" "clojure.core/if"],
 "clojure.core/gen-class" ["clojure.core/proxy" "clojure.core/gen-interface"],
 "clojure.string/lower-case" ["clojure.string/upper-case" "clojure.string/capitalize"],
 "clojure.core/macroexpand-1" ["clojure.core/macroexpand" "clojure.walk/macroexpand-all"],
 "clojure.core/amap" ["clojure.core/areduce" "clojure.core/map"],
 "clojure.core/vec" ["clojure.core/vector" "clojure.core/vector?" "clojure.core/vector-of"],
 "clojure.core/bound-fn*" ["clojure.core/bound-fn"],
 "clojure.core/reductions" ["clojure.core/reduce"],
 "clojure.core//" ["clojure.core/quot"],
 "clojure.core/find-ns" ["clojure.core/create-ns" "clojure.core/remove-ns"],
 "clojure.core/remove-all-methods" ["clojure.core/remove-method" "clojure.core/prefers" "clojure.core/methods" "clojure.core/get-method" "clojure.core/defmulti" "clojure.core/defmethod"],
 "clojure.core/conj" ["clojure.core/cons" "clojure.core/into" "clojure.core/peek" "clojure.core/pop"],
 "clojure.core/array-map" ["clojure.core/assoc" "clojure.core/hash-map" "clojure.core/sorted-map"],
 "clojure.core/fn?" ["clojure.core/ifn?"],
 "clojure.core/inc" ["clojure.core/dec"],
 "clojure.core/alter-meta!" ["clojure.core/vary-meta" "clojure.core/with-meta"],
 "clojure.set/intersection" ["clojure.set/union" "clojure.set/difference" "clojure.set/superset?" "clojure.set/project"],
 "clojure.java.io/as-file" ["clojure.java.io/file"],
 "clojure.walk/prewalk" ["clojure.walk/postwalk" "clojure.walk/prewalk-demo" "clojure.walk/prewalk-replace"],
 "clojure.core/re-matches" ["clojure.core/re-find" "clojure.core/subs"],
 "clojure.core/dissoc!" ["clojure.core/assoc!"],
 "clojure.core/ns-aliases" ["clojure.core/alias"],
 "clojure.core/group-by" ["clojure.core/partition-by" "clojure.core/frequencies"],
 "clojure.core/load-file" ["clojure.core/load" "clojure.core/spit"],
 "clojure.core/throw" ["clojure.core/try" "clojure.core/catch" "clojure.core/finally"],
 "clojure.core/extend" ["clojure.core/satisfies?" "clojure.core/extends?" "clojure.core/extenders" "clojure.core/extend-type" "clojure.core/extend-protocol"],
 "clojure.core/char-name-string" ["clojure.core/char-escape-string"],
 "clojure.xml/element" ["clojure.xml/emit-element" "clojure.core/struct" "clojure.core/struct-map" "clojure.xml/parse" "clojure.core/with-out-str"],
 "clojure.core/min" ["clojure.core/max" "clojure.core/min-key"],
 "clojure.core/dec" ["clojure.core/dec'"],
 "clojure.core/*e" ["clojure.repl/pst"],
 "clojure.core/letfn" ["clojure.core/let"],
 "clojure.zip/up" ["clojure.zip/down" "clojure.zip/left" "clojure.zip/right" "clojure.zip/next" "clojure.zip/seq-zip"],
 "clojure.string/triml" ["clojure.string/trim" "clojure.string/trim-newline" "clojure.string/trimr"],
 "clojure.core/unchecked-inc" ["clojure.core/unchecked-add" "clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/create-ns" ["clojure.core/remove-ns" "clojure.core/find-ns"],
 "clojure.core/min-key" ["clojure.core/min" "clojure.core/max-key"],
 "clojure.repl/doc" ["clojure.repl/source" "clojure.repl/dir" "clojure.repl/apropos"],
 "clojure.string/split" ["clojure.core/subs" "clojure.string/replace" "clojure.core/re-seq" "clojure.string/split-lines"],
 "clojure.core/into" ["clojure.core/conj"],
 "clojure.edn/read-string" ["clojure.edn/read" "clojure.core/prn-str"],
 "clojure.core/contains?" ["clojure.core/some" "clojure.core/get"],
 "clojure.core/keyword" ["clojure.core/name" "clojure.core/keyword?" "clojure.core/namespace" "clojure.core/find-keyword" "clojure.core/symbol"],
 "clojure.core/int-array" ["clojure.core/ints" "clojure.core/aget" "clojure.core/aset" "clojure.core/aset-int"],
 "clojure.core/when-not" ["clojure.core/when" "clojure.core/when-let" "clojure.core/if"],
 "clojure.test/with-test" ["clojure.core/test" "clojure.core/meta" "clojure.test/deftest"],
 "clojure.core/vary-meta" ["clojure.core/with-meta" "clojure.core/alter-meta!"],
 "clojure.core/*3" ["clojure.core/*1" "clojure.core/*2"],
 "clojure.core/struct-map" ["clojure.core/struct"],
 "clojure.core/val" ["clojure.core/vals"],
 "clojure.template/apply-template" ["clojure.template/do-template"],
 "clojure.core/load" ["clojure.core/load-file" "clojure.core/*read-eval*"],
 "clojure.java.shell/with-sh-env" ["clojure.java.shell/sh"],
 "clojure.core/remove-watch" ["clojure.core/add-watch"],
 "clojure.core/assoc" ["clojure.core/assoc-in" "clojure.core/dissoc" "clojure.core/merge"],
 "clojure.core/not=" ["clojure.core/=" "clojure.core/not"],
 "clojure.repl/dir" ["clojure.repl/doc" "clojure.repl/source" "clojure.repl/apropos"],
 "clojure.core/char" ["clojure.core/char?" "clojure.core/int" "clojure.core/chars" "clojure.core/char-array"],
 "clojure.core/map?" ["clojure.core/hash-map"],
 "clojure.core/sequential?" ["clojure.core/seq?" "clojure.core/coll?"],
 "clojure.core/re-find" ["clojure.core/re-groups" "clojure.core/re-matcher" "clojure.core/re-pattern" "clojure.core/re-seq" "clojure.core/re-matches" "clojure.core/subs"],
 "clojure.core/ensure" ["clojure.core/commute" "clojure.core/ref-set" "clojure.core/ref" "clojure.core/alter"],
 "clojure.core/let" ["clojure.core/letfn" "clojure.core/if-let"],
 "clojure.core/re-groups" ["clojure.core/re-find"],
 "clojure.core/parents" ["clojure.core/descendants" "clojure.core/ancestors" "clojure.core/derive" "clojure.core/underive" "clojure.core/make-hierarchy" "clojure.core/isa?"],
 "clojure.core/pvalues" ["clojure.core/pmap" "clojure.core/future"],
 "clojure.core/ifn?" ["clojure.core/fn?"],
 "clojure.core/name" ["clojure.core/namespace"],
 "clojure.core/catch" ["clojure.core/try" "clojure.core/finally"],
 "clojure.core/deliver" ["clojure.core/promise"],
 "clojure.zip/insert-child" ["clojure.zip/zipper" "clojure.zip/append-child"],
 "clojure.core/numerator" ["clojure.core/denominator"],
 "clojure.core/make-hierarchy" ["clojure.core/isa?" "clojure.core/derive" "clojure.core/underive" "clojure.core/parents" "clojure.core/descendants" "clojure.core/ancestors"],
 "clojure.core/*" ["clojure.core/*'"],
 "clojure.core/and" ["clojure.core/or" "clojure.core/if"],
 "clojure.core/seq" ["clojure.core/seq?" "clojure.core/empty?" "clojure.core/iterator-seq"],
 "clojure.core/frequencies" ["clojure.core/group-by" "clojure.core/distinct"],
 "clojure.core/var-get" ["clojure.core/with-local-vars"],
 "clojure.core/clear-agent-errors" ["clojure.core/restart-agent"],
 "clojure.core/+" ["clojure.core/+'" "clojure.core/*" "clojure.core/-"],
 "clojure.core/next" ["clojure.core/rest" "clojure.core/first" "clojure.core/fnext"],
 "clojure.set/difference" ["clojure.set/union" "clojure.set/intersection" "clojure.set/superset?" "clojure.set/project"],
 "clojure.core/var-set" ["clojure.core/with-local-vars"],
 "clojure.core/slurp" ["clojure.java.io/reader" "clojure.core/spit"],
 "clojure.core/make-array" ["clojure.core/int-array" "clojure.core/double-array" "clojure.core/float-array" "clojure.core/short-array" "clojure.core/long-array" "clojure.core/char-array" "clojure.core/byte-array" "clojure.core/boolean-array" "clojure.core/object-array" "clojure.core/to-array" "clojure.core/to-array-2d" "clojure.core/into-array" "clojure.core/aget" "clojure.core/aset" "clojure.core/alength" "clojure.core/amap" "clojure.core/areduce"],
 "clojure.core/bound-fn" ["clojure.core/bound-fn*"],
 "clojure.core/push-thread-bindings" ["clojure.core/pop-thread-bindings" "clojure.core/binding" "clojure.core/with-bindings"],
 "clojure.xml/emit" ["clojure.core/with-out-str"],
 "clojure.core/ns-resolve" ["clojure.core/resolve"],
 "clojure.core/long" ["clojure.core/int" "clojure.core/longs" "clojure.core/long-array"],
 "clojure.core/subs" ["clojure.string/replace" "clojure.string/split" "clojure.string/replace-first" "clojure.core/re-find" "clojure.core/re-seq" "clojure.core/re-matches"],
 "clojure.core/locking" ["clojure.core/future"],
 "clojure.core/partial" ["clojure.core/comp" "clojure.core/juxt"],
 "clojure.core/char-array" ["clojure.core/into-array" "clojure.core/to-array" "clojure.core/chars"],
 "clojure.core/=" ["clojure.core/==" "clojure.core/not=" "clojure.core/identical?"],
 "clojure.core/sort" ["clojure.core/sort-by"],
 "clojure.core/apply" ["clojure.core/map" "clojure.core/eval" "clojure.template/apply-template" "clojure.core/reduce"],
 "clojure.core/re-pattern" ["clojure.core/re-find" "clojure.string/replace" "clojure.string/replace-first"],
 "clojure.core/new" ["clojure.core/."],
 "clojure.core/future" ["clojure.core/future-cancel" "clojure.core/shutdown-agents" "clojure.core/promise" "clojure.core/realized?" "clojure.core/delay" "clojure.core/future?" "clojure.core/future-call"],
 "clojure.core/send-off" ["clojure.core/send" "clojure.core/agent" "clojure.core/shutdown-agents"],
 "clojure.core/even?" ["clojure.core/odd?"],
 "clojure.test/are" ["clojure.test/is" "clojure.test/deftest"],
 "clojure.core/last" ["clojure.core/first" "clojure.core/next" "clojure.core/rest" "clojure.core/butlast" "clojure.core/take-last"],
 "clojure.java.io/IOFactory" ["clojure.java.io/reader" "clojure.java.io/writer" "clojure.java.io/input-stream" "clojure.java.io/output-stream"],
 "clojure.core/reify" ["clojure.core/proxy"],
 "clojure.core/set!" ["clojure.core/reset!" "clojure.core/binding" "clojure.core/alter-var-root"],
 "clojure.core/symbol" ["clojure.core/var" "clojure.core/var?" "clojure.core/symbol?" "clojure.core/name" "clojure.core/namespace" "clojure.core/keyword"],
 "clojure.core/rseq" ["clojure.core/reverse"],
 "clojure.core/thread-bound?" ["clojure.core/bound-fn" "clojure.core/bound-fn*"],
 "clojure.core/ffirst" ["clojure.core/first" "clojure.core/fnext" "clojure.core/nfirst"],
 "clojure.core/read-string" ["clojure.core/pr-str" "clojure.core/str" "clojure.core/read" "clojure.core/load-string" "clojure.core/*read-eval*"],
 "clojure.core/proxy" ["clojure.core/gen-class" "clojure.core/gen-interface" "clojure.core/reify"],
 "clojure.core/compare" ["clojure.core/sort-by" "clojure.core/sorted-set-by" "clojure.core/sorted-map-by"],
 "clojure.core/replicate" ["clojure.core/repeat"],
 "clojure.core/macroexpand" ["clojure.core/macroexpand-1" "clojure.walk/macroexpand-all"],
 "clojure.core/in-ns" ["clojure.core/ns"],
 "clojure.java.io/output-stream" ["clojure.java.io/writer" "clojure.java.io/input-stream" "clojure.java.io/IOFactory"],
 "clojure.java.io/delete-file" ["clojure.java.io/file" "clojure.java.io/copy"],
 "clojure.core/merge" ["clojure.core/merge-with" "clojure.core/hash-map"],
 "clojure.core/rand" ["clojure.core/rand-int" "clojure.core/rand-nth"],
 "clojure.core/every?" ["clojure.core/some" "clojure.core/not-any?"],
 "clojure.core/sorted-set" ["clojure.core/sorted-set-by" "clojure.core/subseq" "clojure.core/rsubseq" "clojure.core/sorted-map"],
 "clojure.core/defmacro" ["clojure.core/macroexpand" "clojure.core/macroexpand-1" "clojure.walk/macroexpand-all"],
 "clojure.set/subset?" ["clojure.core/set?" "clojure.core/set" "clojure.set/superset?"],
 "clojure.core/sort-by" ["clojure.core/sort" "clojure.core/compare"],
 "clojure.core/distinct?" ["clojure.core/distinct"],
 "clojure.core/resolve" ["clojure.core/ns-resolve"],
 "clojure.walk/prewalk-replace" ["clojure.walk/postwalk-replace" "clojure.core/replace" "clojure.walk/prewalk"],
 "clojure.core/delay" ["clojure.core/force" "clojure.core/realized?" "clojure.core/memoize" "clojure.core/future" "clojure.core/delay?"],
 "clojure.core/lazy-cat" ["clojure.core/lazy-seq" "clojure.core/concat"],
 "clojure.core/file-seq" ["clojure.java.io/file" "clojure.java.io/delete-file"],
 "clojure.core/ns-interns" ["clojure.core/ns-map" "clojure.core/ns-publics" "clojure.core/ns-aliases" "clojure.core/ns-refers"],
 "clojure.core/short-array" ["clojure.core/shorts"],
 "clojure.core/rand-int" ["clojure.core/rand" "clojure.core/int"],
 "clojure.core/future-done?" ["clojure.core/future" "clojure.core/future-cancel" "clojure.core/future?" "clojure.core/future-cancelled?"],
 "clojure.zip/replace" ["clojure.zip/edit"],
 "clojure.core/get-thread-bindings" ["clojure.core/bound-fn" "clojure.core/bound-fn*"],
 "clojure.core/var" ["clojure.core/meta" "clojure.core/symbol" "clojure.core/symbol?" "clojure.core/var?" "clojure.core/binding" "clojure.core/with-redefs" "clojure.core/with-redefs-fn" "clojure.core/set!" "clojure.core/var-set" "clojure.core/var-get" "clojure.core/with-local-vars"],
 "clojure.set/rename" ["clojure.set/rename-keys"],
 "clojure.core/set?" ["clojure.core/set"],
 "clojure.pprint/cl-format" ["clojure.core/printf" "clojure.core/format"],
 "clojure.core/ns-unmap" ["clojure.core/remove-ns" "clojure.core/ns-map"],
 "clojure.core/*print-meta*" ["clojure.core/pr"],
 "clojure.core/struct" ["clojure.core/defstruct"],
 "clojure.core/methods" ["clojure.core/get-method" "clojure.core/remove-method" "clojure.core/prefer-method" "clojure.core/prefers"],
 "clojure.core/areduce" ["clojure.core/amap"],
 "clojure.core/rem" ["clojure.core/quot" "clojure.core/mod"],
 "clojure.core/cons" ["clojure.core/conj"],
 "clojure.core/key" ["clojure.core/keys"],
 "clojure.core/atom" ["clojure.core/reset!" "clojure.core/swap!" "clojure.core/compare-and-set!" "clojure.core/add-watch" "clojure.core/remove-watch" "clojure.core/set-validator!"],
 "clojure.core/intern" ["clojure.core/alter-var-root"],
 "clojure.core/get-in" ["clojure.core/assoc-in" "clojure.core/update-in" "clojure.core/find" "clojure.core/get" "clojure.core/->"],
 "clojure.core/prn" ["clojure.core/println" "clojure.core/pr"],
 "clojure.core/ancestors" ["clojure.core/parents" "clojure.core/derive" "clojure.core/underive" "clojure.core/descendants" "clojure.core/make-hierarchy" "clojure.core/isa?" "clojure.core/supers"],
 "clojure.core/read" ["clojure.core/read-string" "clojure.core/*read-eval*"],
 "clojure.core/subseq" ["clojure.core/rsubseq" "clojure.core/sorted-map" "clojure.core/sorted-set" "clojure.core/sorted-map-by" "clojure.core/sorted-set-by"],
 "clojure.core/hash-map" ["clojure.core/merge" "clojure.core/assoc" "clojure.core/dissoc" "clojure.core/array-map" "clojure.core/sorted-map"],
 "clojure.core/partition-all" ["clojure.core/partition" "clojure.core/partition-by"],
 "clojure.core/seq?" ["clojure.core/seq" "clojure.core/sequential?" "clojure.core/vector?" "clojure.core/coll?" "clojure.core/list?" "clojure.core/map?" "clojure.core/set?"],
 "clojure.walk/macroexpand-all" ["clojure.core/macroexpand-1" "clojure.core/macroexpand"],
 "clojure.core/*1" ["clojure.core/*2" "clojure.core/*3"],
 "clojure.core/swap!" ["clojure.core/atom" "clojure.core/reset!"],
 "clojure.set/index" ["clojure.core/hash-map" "clojure.core/get"],
 "clojure.core/recur" ["clojure.core/loop" "clojure.core/trampoline"],
 "clojure.core/char-escape-string" ["clojure.core/char-name-string"],
 "clojure.core/as->" ["clojure.core/->" "clojure.core/->>" "clojure.core/cond->" "clojure.core/cond->>" "clojure.core/some->" "clojure.core/some->>"],
 "clojure.core/def" ["clojure.core/defn" "clojure.core/fn" "clojure.core/defmacro" "clojure.core/defmulti"],
 "clojure.core/disj!" ["clojure.core/assoc!" "clojure.core/dissoc!"],
 "clojure.core/or" ["clojure.core/and" "clojure.core/if"],
 "clojure.core/constantly" ["clojure.core/repeatedly"],
 "clojure.core/bigdec" ["clojure.core/decimal?"],
 "clojure.core/rest" ["clojure.core/next" "clojure.core/first" "clojure.core/drop" "clojure.core/pop"],
 "clojure.walk/postwalk-replace" ["clojure.walk/prewalk-replace" "clojure.core/replace"],
 "clojure.core/unsigned-bit-shift-right" ["clojure.core/bit-shift-right"],
 "clojure.core/pcalls" ["clojure.core/pvalues" "clojure.core/future"],
 "clojure.core/nthnext" ["clojure.core/nth" "clojure.core/drop" "clojure.core/nthrest"],
 "clojure.core/->>" ["clojure.core/->"],
 "clojure.core/with-out-str" ["clojure.core/with-in-str"],
 "clojure.core/long-array" ["clojure.core/longs"],
 "clojure.core/ns-unalias" ["clojure.core/alias" "clojure.core/ns-aliases"],
 "clojure.core/force" ["clojure.core/delay"],
 "clojure.walk/walk" ["clojure.walk/postwalk" "clojure.walk/prewalk"],
 "clojure.core/take-while" ["clojure.core/drop-while" "clojure.core/split-with"],
 "clojure.set/union" ["clojure.set/intersection" "clojure.set/difference" "clojure.set/superset?"],
 "clojure.core/ref-max-history" ["clojure.core/ref" "clojure.core/ref-min-history" "clojure.core/ref-history-count"],
 "clojure.core/if-not" ["clojure.core/if" "clojure.core/when-not"],
 "clojure.core/not-empty" ["clojure.core/empty"],
 "clojure.core/isa?" ["clojure.core/derive" "clojure.core/instance?" "clojure.core/underive" "clojure.core/ancestors" "clojure.core/parents" "clojure.core/descendants" "clojure.core/make-hierarchy"],
 "clojure.core/zipmap" ["clojure.core/interleave"],
 "clojure.core/ns" ["clojure.core/use" "clojure.core/require" "clojure.core/refer" "clojure.core/import" "clojure.core/ns-publics" "clojure.core/in-ns" "clojure.core/remove-ns" "clojure.core/ns-map" "clojure.core/*ns*"],
 "clojure.core/str" ["clojure.core/pr" "clojure.core/prn"],
 "clojure.core/realized?" ["clojure.core/promise" "clojure.core/delay" "clojure.core/future"],
 "clojure.core/unquote-splicing" ["clojure.core/unquote"],
 "clojure.core/descendants" ["clojure.core/ancestors"],
 "clojure.string/replace" ["clojure.core/subs" "clojure.string/split" "clojure.string/replace-first"],
 "clojure.pprint/pprint" ["clojure.pprint/pp" "clojure.pprint/print-table"],
 "clojure.test/deftest" ["clojure.test/run-all-tests" "clojure.test/run-tests" "clojure.test/is" "clojure.test/are" "clojure.test/testing" "clojure.test/test-var"],
 "clojure.core/println" ["clojure.core/prn" "clojure.core/print" "clojure.core/println-str"],
 "clojure.core/pop-thread-bindings" ["clojure.core/push-thread-bindings" "clojure.core/binding"],
 "clojure.core/<" ["clojure.core/=" "clojure.core/not=" "clojure.core/>" "clojure.core/<=" "clojure.core/>="],
 "clojure.core/nth" ["clojure.core/first" "clojure.core/second" "clojure.core/nthnext" "clojure.core/get"],
 "clojure.core/true?" ["clojure.core/false?"],
 "clojure.core/ns-imports" ["clojure.core/ns-map"],
 "clojure.core/dosync" ["clojure.core/sync" "clojure.core/ref" "clojure.core/locking"],
 "clojure.core/aclone" ["clojure.core/aget"],
 "clojure.core/chars" ["clojure.core/char-array"],
 "clojure.core/empty?" ["clojure.core/seq"],
 "clojure.test/try-expr" ["clojure.test/is"],
 "clojure.core/drop-while" ["clojure.core/take-while" "clojure.core/split-with"],
 "clojure.main/with-bindings" ["clojure.core/binding" "clojure.core/with-local-vars" "clojure.core/with-redefs-fn"],
 "clojure.core/load-reader" ["clojure.core/load-file"],
 "clojure.core/await-for" ["clojure.core/await"],
 "clojure.core/vector" ["clojure.core/vec" "clojure.core/vector?" "clojure.core/vector-of" "clojure.core/pop" "clojure.core/into"],
 "clojure.core/pop" ["clojure.core/peek" "clojure.core/rest" "clojure.core/conj"],
 "clojure.set/rename-keys" ["clojure.set/rename"],
 "clojure.core/aget" ["clojure.core/aclone" "clojure.core/get" "clojure.core/nth"],
 "clojure.core/re-seq" ["clojure.core/re-find" "clojure.core/re-groups" "clojure.core/re-pattern" "clojure.core/re-matcher" "clojure.core/re-matches" "clojure.string/split" "clojure.core/subs"],
 "clojure.core/drop" ["clojure.core/take" "clojure.core/drop-last" "clojure.core/drop-while" "clojure.core/nthnext" "clojure.core/nthrest"],
 "clojure.core/re-matcher" ["clojure.core/re-find"],
 "clojure.core/coll?" ["clojure.core/seq?" "clojure.core/list?" "clojure.core/sequential?"],
 "clojure.core/complement" ["clojure.core/not"],
 "clojure.core/*2" ["clojure.core/*1" "clojure.core/*3"],
 "clojure.core/dissoc" ["clojure.core/assoc" "clojure.core/disj" "clojure.core/select-keys"],
 "clojure.core/concat" ["clojure.core/conj" "clojure.core/into"],
 "clojure.core/extend-protocol" ["clojure.core/extend" "clojure.core/extend-type" "clojure.core/defprotocol"],
 "clojure.core/println-str" ["clojure.core/println" "clojure.core/print-str"],
 "clojure.core/gen-interface" ["clojure.core/proxy" "clojure.core/gen-class"],
 "clojure.core/with-redefs-fn" ["clojure.core/with-redefs"],
 "clojure.core/doseq" ["clojure.core/doall" "clojure.core/dorun" "clojure.core/for" "clojure.core/dotimes"],
 "clojure.core/extends?" ["clojure.core/defprotocol"],
 "clojure.core/drop-last" ["clojure.core/drop" "clojure.core/drop-while"],
 "clojure.core/some" ["clojure.core/every?" "clojure.core/not-any?" "clojure.core/keep" "clojure.core/keep-indexed" "clojure.core/some-fn"],
 "clojure.core/format" ["clojure.core/printf" "clojure.pprint/cl-format" "clojure.pprint/print-table"],
 "clojure.core/int" ["clojure.core/char" "clojure.core/long" "clojure.core/integer?" "clojure.core/ints" "clojure.core/int-array" "clojure.core/short"],
 "clojure.core/*agent*" ["clojure.core/agent"],
 "clojure.core/defrecord" ["clojure.core/deftype" "clojure.core/defstruct" "clojure.core/defprotocol"],
 "clojure.core/alias" ["clojure.core/ns-aliases" "clojure.core/ns-unalias"],
 "clojure.core/ns-publics" ["clojure.core/ns-map" "clojure.core/ns-interns" "clojure.core/resolve"],
 "clojure.core/bound?" ["clojure.core/thread-bound?"],
 "clojure.java.io/writer" ["clojure.java.io/reader" "clojure.java.io/IOFactory" "clojure.java.io/output-stream" "clojure.core/spit"],
 "clojure.core/prn-str" ["clojure.core/prn" "clojure.edn/read-string"],
 "clojure.core/get" ["clojure.core/map-indexed" "clojure.core/get-in" "clojure.core/find"],
 "clojure.core/prefers" ["clojure.core/prefer-method" "clojure.core/methods" "clojure.core/get-method"],
 "clojure.core/max" ["clojure.core/max-key" "clojure.core/min"],
 "clojure.core/butlast" ["clojure.core/first" "clojure.core/rest" "clojure.core/last" "clojure.core/next" "clojure.core/drop-last" "clojure.core/take-last"],
 "clojure.core/get-method" ["clojure.core/remove-method" "clojure.core/methods"],
 "clojure.core/set-error-handler!" ["clojure.core/agent" "clojure.core/agent-error" "clojure.core/restart-agent"],
 "clojure.repl/source" ["clojure.repl/doc" "clojure.repl/dir" "clojure.repl/apropos"],
 "clojure.core/defn-" ["clojure.core/defn"],
 "clojure.core/pr" ["clojure.core/print" "clojure.core/prn" "clojure.core/pr-str"],
 "clojure.java.shell/sh" ["clojure.java.shell/with-sh-dir" "clojure.java.shell/with-sh-env" "clojure.core/future"],
 "clojure.core/identical?" ["clojure.core/=" "clojure.core/=="],
 "clojure.core/lazy-seq" ["clojure.core/lazy-cat" "clojure.core/realized?" "clojure.core/doall" "clojure.core/iterate"],
 "clojure.core/mapcat" ["clojure.core/map" "clojure.core/concat"],
 "clojure.core/max-key" ["clojure.core/max" "clojure.core/min-key"],
 "clojure.core/byte" ["clojure.core/byte-array" "clojure.core/bytes" "clojure.core/short"],
 "clojure.core/unchecked-dec" ["clojure.core/unchecked-add" "clojure.core/unchecked-dec" "clojure.core/unchecked-inc" "clojure.core/unchecked-negate" "clojure.core/unchecked-divide" "clojure.core/unchecked-subtract" "clojure.core/unchecked-multiply" "clojure.core/unchecked-remainder"],
 "clojure.core/map" ["clojure.core/map-indexed" "clojure.core/pmap" "clojure.core/amap" "clojure.core/mapcat" "clojure.core/keep" "clojure.core/juxt"],
 "clojure.core/defn" ["clojure.core/def" "clojure.core/defn-" "clojure.core/defmacro" "clojure.core/fn"],
 "clojure.core/sequence" ["clojure.core/seq"],
 "clojure.zip/zipper" ["clojure.zip/down" "clojure.zip/up" "clojure.zip/right" "clojure.zip/left" "clojure.zip/children"],
 "clojure.core/denominator" ["clojure.core/numerator"],
 "clojure.core/add-watch" ["clojure.core/remove-watch"],
 "clojure.core/refer-clojure" ["clojure.core/refer"],
 "clojure.java.io/reader" ["clojure.java.io/writer" "clojure.java.io/input-stream" "clojure.java.io/IOFactory" "clojure.core/slurp"],
 "clojure.core/pr-str" ["clojure.core/pr" "clojure.core/read-string" "clojure.core/prn-str"],
 "clojure.core/pos?" ["clojure.core/neg?" "clojure.core/zero?"],
 "clojure.core/split-at" ["clojure.core/split-with" "clojure.string/split"],
 "clojure.core/condp" ["clojure.core/cond" "clojure.core/if"],
 "clojure.core/>" ["clojure.core/=" "clojure.core/not=" "clojure.core/<"],
 "clojure.core/doall" ["clojure.core/dorun" "clojure.core/doseq"],
 "clojure.core/rsubseq" ["clojure.core/subseq"]}
